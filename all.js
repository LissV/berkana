ACTUAL_DAY_INFO = function (getDialog, onOpenSubDialog, onCloseSubDialog, onSelectActualDate, onRemoveActualDate, onCancelLesson) {
    var that = this;
    that.openFamily = function (familyLink) {
        onOpenSubDialog();
        DIALOGS.familyDialogs.editFamilyDialog(familyLink.id, null, null, function (event) {
            if (event) {
                onCloseSubDialog();
            }
        });

    };

    that.saveChangedBubbleData = function (container) {
        var params = {};
        params.id = container.attr('id');
        params.type = container.attr('type');
        params.comment = container.find('.actualdaycomment').val();
        params.coursefilter = $('[name="coursefilter"]:checked').val();
        commonHelper.callAjaxMethod('calendar.htm', 'saveObjectInfo', params, function (data) {

        }, true, true);

    };

    that.cancelLesson = function () {
        var params = {};
        params.id = getDialog().find('.subscriptionContainer').attr('id');
        params.scheduleActualDayId = params.id.split('-')[1];
        params.cancel = !eval(getDialog().find('#canceldaylink').attr('canceled'));

        onOpenSubDialog();
        var askMessage = params.cancel ? messages['actualdayinfo.cancelconfirm'] : messages['actualdayinfo.activateconfirm'];
        var askButton = params.cancel ? messages['actualdayinfo.cancel'] : messages['actualdayinfo.activate'];
        DIALOGS.askYesNoDialog(askMessage, askButton, function () {
            commonHelper.callAjaxMethod('calendar.htm', 'cancelLessonInfo', params, function (result) {
                if (onCancelLesson) {
                    onCancelLesson();
                }
                onCloseSubDialog();
                BUBBLE_DIALOG.close(getDialog());
            }, false, true, false);

        }, function (event) {
            onCloseSubDialog();
        });
    };

    that.changeTeacher = function () {
        onOpenSubDialog();
        $('#selectteacher').dialog({
                height:160,
                width:400,
                autoOpen:true,
                modal:true,
                title:messages['actualdayinfo.teacher'],
                create:function (event, ui) {

                    commonHelper.callAjaxMethod('settings.htm', 'loadTeachersReference', {}, function (result) {
                        var references = {};

                        references.teachers = [
                            {name:'', teacherid:''}
                        ].concat(result.rows);


                        var teacherSelect = $('#newteacher');
                        teacherSelect.children(null).remove();
                        $('<option>', {
                            value:''
                        }).appendTo(teacherSelect);
                        teacherSelect.directives({
                            'option':{
                                'teacher <- teachers':{
                                    '.':'teacher.name',
                                    '@value':'teacher.teacherid'
                                }
                            }
                        }).render(references);
                    });

                },
                beforeClose:function (event, ui) {
                    onCloseSubDialog();
                },
                buttons:[
                    {
                        text:messages['common.select'],
                        click:function (event) {
                            var teacherId = $('#newteacher').val();
                            if (teacherId && teacherId.trim() != '') {
                                var sadId = getDialog().find('.subscriptionContainer').attr('id').split('-')[1];
                                var teacherTitle = $('#newteacher').children(null).filter(':selected').html();

                                commonHelper.callAjaxMethod('calendar.htm', 'changeTeacher', {sadid:sadId, newteacher:teacherId}, function (result) {
                                    if (!result) {
                                        getDialog().find('.actualTeacher').html(teacherTitle);
                                        getDialog().find('.actualTeacherDiv').show();
                                    } else {
                                        getDialog().find('.actualTeacher').html('');
                                        getDialog().find('.actualTeacherDiv').hide();
                                    }
                                });
                            }

                            commonHelper.closeDialog('selectteacher');
                        }
                    }
                ]

            }
        );
    };

    that.changeAdditionalTeacher = function () {
        onOpenSubDialog();
        $('#selectteacher').dialog({
                height:160,
                width:400,
                autoOpen:true,
                modal:true,
                title:messages['actualdayinfo.teacher'],
                create:function (event, ui) {

                    commonHelper.callAjaxMethod('settings.htm', 'loadTeachersReference', {}, function (result) {
                        var references = {};

                        references.teachers = [
                            {name:'', teacherid:''}
                        ].concat(result.rows);


                        var teacherSelect = $('#newteacher');
                        teacherSelect.children(null).remove();
                        $('<option>', {
                            value:''
                        }).appendTo(teacherSelect);
                        teacherSelect.directives({
                            'option':{
                                'teacher <- teachers':{
                                    '.':'teacher.name',
                                    '@value':'teacher.teacherid'
                                }
                            }
                        }).render(references);
                    });

                },
                beforeClose:function (event, ui) {
                    onCloseSubDialog();
                },
                buttons:[
                    {
                        text:messages['common.select'],
                        click:function (event) {
                            var teacherId = $('#newteacher').val();
                            if (teacherId && teacherId.trim() != '') {
                                var sadId = getDialog().find('.subscriptionContainer').attr('id').split('-')[1];
                                var teacherTitle = $('#newteacher').children(null).filter(':selected').html();

                                commonHelper.callAjaxMethod('calendar.htm', 'changeAdditionalTeacher', {sadid:sadId, newteacher:teacherId}, function (result) {
                                    if (!result) {
                                        getDialog().find('.actualAdditionalTeacher').html(teacherTitle);
                                        getDialog().find('.actualAdditionalTeacherDiv').show();
                                    } else {
                                        getDialog().find('.actualAdditionalTeacher').html('');
                                        getDialog().find('.actualAdditionalTeacherDiv').hide();
                                    }
                                });
                            }

                            commonHelper.closeDialog('selectteacher');
                        }
                    }
                ]

            }
        );
    };

    that.changeActualDate = function () {
        onOpenSubDialog();
        $('#selectdatetime').dialog({
            height:260,
            width:400,
            autoOpen:true,
            modal:true,
            title:messages['actualdayinfo.selectdatetime'],
            create:function (event, ui) {
                var newdate = $('#selectdatetime').find('#newdate');
                commonHelper.setDatePicker(newdate);
                commonHelper.generateTimepickers('#starttime', '#endtime');
            },
            open:function (event, ui) {
                $('#selectdatetime').find('.errormessage').html('');
                var newdate = $('#selectdatetime').find('#newdate');
                newdate.val('');
                var starttime = $('#starttime').val('');
                var endtime = $('#endtime').val('');
            },
            beforeClose:function (event, ui) {
                onCloseSubDialog();
            },
            buttons:[
                {
                    text:messages['common.select'],
                    click:function (event) {
                        var container = $('#selectdatetime');
                        var newdate = container.find('#newdate').val();
                        var starttime = $('#starttime').val();
                        var endtime = $('#endtime').val();

                        var params = {};
                        params.id = getDialog().find('.subscriptionContainer').attr('id');
                        params.type = getDialog().find('.subscriptionContainer').attr('type');
                        params.coursefilter = $('[name="coursefilter"]:checked').val();
                        params.newdate = newdate;
                        params.starttime = starttime;
                        params.endtime = endtime;

                        if (newdate == '' || starttime == '' || endtime == '') {
                            container.find('.errormessage').html(messages['actualdayinfo.error']);
                        } else {
                            commonHelper.callAjaxMethod('calendar.htm', 'saveObjectInfo', params, function (result) {
                                onSelectActualDate(result);
                                getDialog().find('.actualDate').html(newdate + ' ' + starttime + '-' + endtime);
                                commonHelper.closeDialog('selectdatetime');
                            }, true, true);
                        }
                    }
                }
            ]
        });

    };

    that.removeActualDate = function () {
        var params = {};
        params.id = getDialog().find('.subscriptionContainer').attr('id');
        params.type = getDialog().find('.subscriptionContainer').attr('type');
        params.coursefilter = $('[name="coursefilter"]:checked').val();
        params.removeActualDate = true;

        commonHelper.callAjaxMethod('calendar.htm', 'saveObjectInfo', params, function (result) {
            onRemoveActualDate(result);
            getDialog().find('.actualDate').html(' ' + '-');
        }, true, true);
    };

    return that;
};var DIALOGS = new function () {
    var that = this;


    this.conditionalAskYesNoDialog = function (condition, text, buttonText, callbackFunction, closeFunction) {
        if (condition) {
            this.askYesNoDialog(text, buttonText, callbackFunction, closeFunction);
        } else {
            callbackFunction();
        }
    };

    this.askQuestionDialog = function (text, variants, closeFunction) {
        $('#askyesnodialog-title').html(text);
        var buttons = [];

        $.each(variants, function (index, item) {
            buttons.push({
                text: item.variant,
                click: function () {
                    item.callback();
                    $('#askyesnodialog').overlay().close();
                }
            });
        });

        buttons.push({
            text: messages['common.close'],
            click: function (event) {
                if (closeFunction) {
                    closeFunction(event);
                }
                $('#askyesnodialog').overlay().close();
            }
        });

        var buttonsDiv = $('#askyesnodialog').find('.askyesnobuttons');

        buttonsDiv.children(null).remove();
        $.each(buttons, function (index, item) {
            var buttonDiv = $('<div>', {
                style: 'padding-left: 10px; float: left;'
            });
            var button = $('<button>', {
            }).html(item.text).button();
            button.attr('id', item.id);
            button.appendTo(buttonDiv);
            button.click(item.click);
            buttonDiv.appendTo(buttonsDiv);
        });

        $('#askyesnodialog').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5,
                zIndex: 100
            },
            fixed: true,
            closeOnClick: true
        });

        $('#askyesnodialog').overlay().load();
        $('#askyesnodialog').css('z-index',(commonHelper.getMaxZIndex() + 1));

    };

    this.askYesNoDialog = function (text, buttonText, callbackFunction, closeFunction, closeButtonText) {
        $('#askyesnodialog-title').html(text);

        $('#askyesnodialog').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5,
                zIndex: (commonHelper.getMaxZIndex() + 1)
            },
            fixed: true,
            closeOnClick: true
        });

        var buttonsDiv = $('#askyesnodialog').find('.askyesnobuttons');

        var buttons = [];

        buttons.push({
            text: buttonText,
            click: function (event) {
                if (callbackFunction) {
                    callbackFunction(event);
                }
                $('#askyesnodialog').overlay().close();
            }
        });

        buttons.push({
            text: closeButtonText ? closeButtonText : messages['common.close'],
            click: function (event) {
                if (closeFunction) {
                    closeFunction(event);
                }
                $('#askyesnodialog').overlay().close();
            }
        });

        buttonsDiv.children(null).remove();
        $.each(buttons, function (index, item) {
            var buttonDiv = $('<div>', {
                style: 'padding-left: 10px; float: right;'
            });
            var button = $('<button>', {
            }).html(item.text).button();
            button.attr('id', item.id);
            button.appendTo(buttonDiv);
            button.click(item.click);
            buttonDiv.prependTo(buttonsDiv);
        });

        $('#askyesnodialog').overlay().load();
        $('#askyesnodialog').css('z-index',(commonHelper.getMaxZIndex() + 1));
    };


    this.openDayInfo = function (dayInfoDialog, plannedDate, plannedStartTime, selectedScheduleId, readonly) {
        commonHelper.callAjaxMethod('client.htm', 'loadActualDayInfo', {plannedDate: plannedDate, selectedScheduleId: selectedScheduleId, plannedStartTime: plannedStartTime ? plannedStartTime : ''}, function (data) {
            if (data && data.actualDay) {
                var content = $('#subscriptionsTemplate').clone().show().directives({
                    '.subscriptionContainer@id': 'subscriptions-#{actualDay.id}',
                    '.subscriptionContainer@type': '"subscriptions"',
                    '.plannedDate': '#{actualDay.plannedDate} #{actualDay.plannedStartTime}-#{actualDay.plannedFinishTime}',
                    '.actualDate': '#{actualDay.actualDate} #{actualDay.actualStartTime}-#{actualDay.actualFinishTime}',
                    '.course': 'course.name',
                    '.comment': 'scheduleComment',
                    '.teacher': 'teacher.name',
                    '.room': 'actualDay.plannedRoom.title',
                    '.actualdaycomment': 'actualDay.comment',
                    '.removedateLink@style': readonly ? 'display: none' : activeStatus,
                    '.changedateLink@style': readonly ? 'display: none' : activeStatus,
                    '.changeTeacherLink@style': readonly ? 'display: none' : activeStatus,
                    '.reservationRow@style': activeStatus,
                    '.childRow@style': activeStatus,
                    '.separatorRow@style': activeStatus,
                    '#canceldaylink@style': readonly ? 'display: none' : '',
                    '#canceldaylink': function(context){
                        return context.context.actualDay.canceled ? messages['dialogs.activelesson'] : messages['dialogs.cancellesson']
                    },
                    '#canceldaylink@canceled': 'actualDay.canceled',
                    '.canceledLesson': lessonStatus,
                    '.kidrow': {
                        'element <-children': {
                            '.childinfo': '#{element.child.firstName} #{element.child.lastName}',
                            '.childage': '#{element.child.age}',
                            '.visited': generateVisited,
                            '.phone': '#{element.phone}',
                            '.familylink@id': 'element.familyId'
                        }
                    },
                    '.reservationrow': {
                        'element <-reservation': {
                            '.reservchildinfo': '#{element.child.firstName} #{element.child.lastName}',
                            '.reservchildage': '#{element.child.age}',
                            '.reservphone': '#{element.phone}',
                            '.reservfamilylink@id': 'element.familyId'
                        }
                    }

                }).render(data);
                var dialog = $('<div id="actualdayinfoDialog" style="width: 490px;" class="overlayDialog">');
                dialog.appendTo($('body'));
                content.appendTo(dialog);
                if (data.actualTeacher != null && data.actualTeacher.id != data.teacher.id) {
                    content.find('.actualTeacher').html(data.actualTeacher.name);
                    content.find('.actualTeacherDiv').show();
                }

                dialog.overlay({
                    oneInstance: false,
                    mask: {
                        color: '#fff',
                        loadSpeed: 0,
                        opacity: 0.5
                    },
                    fixed: true,
                    closeOnClick: true
                });
                dialog.overlay().load();
                dialog.css('z-index',(commonHelper.getMaxZIndex() + 1));
            } else {
                commonHelper.showMessage(messages['dialogs.nodata']);
            }
        }, false);
        return dayInfoDialog;
    };

    var activeStatus = function (context) {
        return context.context.actualDay.canceled ? 'display: none' : '';
    };


    that.openChangePasswordDialog = function (dialogName, userid, callback, showCurrent) {
        var dialog = $('#' + dialogName);
        dialog.overlay({
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5,
                zIndex: 100
            },
            closeOnClick: false,
            onClose: function () {
                dialog.find('.dialogChangePassword').unbind('click');
                dialog.find('.dialogChangePasswordClose').unbind('click');
            }
        });

        dialog.find('.oldPassword').val('');
        dialog.find('.newPassword').val('');
        dialog.find('.newPasswordConfirmation').val('');

        if (showCurrent){
            dialog.find('.oldPasswordRow').show();
        } else {
            dialog.find('.oldPasswordRow').hide();
        }

        dialog.find('.dialogChangePassword').bind('click', function () {
            commonHelper.callSecureAjaxMethod('changePassword.htm', 'changePassword',
                {
                    userId: userid,
                    oldPassword: dialog.find('.oldPassword').val(),
                    newPassword: dialog.find('.newPassword').val(),
                    newPasswordConfirmation: dialog.find('.newPasswordConfirmation').val()
                }, function (data) {
                    if (data.result) {
                        dialog.overlay().close();
                        dialog.find('.dialogChangePassword').unbind('click');
                        dialog.find('.dialogChangePasswordClose').unbind('click');

                        callback();
                    } else {
                        commonHelper.showMessage(data.message);
                    }
                });
        });

        dialog.find('.dialogChangePasswordClose').bind('click', function () {
            dialog.overlay().close();
            dialog.find('.dialogChangePassword').unbind('click');
            dialog.find('.dialogChangePasswordClose').unbind('click');
        });

        dialog.overlay().load();

    };

    that.openBarcodeDialog = function (callback) {
        commonHelper.callAjaxMethod('barcode.htm', 'loadReaders', {filteractive: true}, function (data) {
            if(data && data.rows && data.rows.length > 0){
                var readers = {};
                var readersByPrefix = [];
                for(var i=0; i<data.rows.length; i++){
                    readersByPrefix[data.rows[i].prefix] = data.rows[i].id;
                }
                readers.rows = [
                    {title:'', id:'-'}
                ].concat(data.rows);
                var readersSelect = $('#readBarcodeDialog').find('.barcodeReader');
                readersSelect.children(null).remove();
                readersSelect.append($('<option>', {value:''})).directives({
                    'option':{
                        'row <- rows':{
                            '.':'row.title',
                            '@value':'row.id'
                        }
                    }
                }).render(readers);

                var processed = false;
                var onBarcodeRead = function(reader, code){
                    if(processed){return;} //protect from double call
                    processed = true;
                    if(callback){
                        callback(reader, code);
                    }
                    else {
                        commonHelper.callAjaxMethod('barcode.htm', 'processBarcode', {readerId: reader, code: code}, function (data) {
                            if(data.error){
                                commonHelper.showMessage(data.error);
                            }
                            else if(data.childId){
                                if(data.actionClient){
                                    window.open('client.htm?childid=' + data.childId, '_blank');
                                }
                                if(data.actionVisit){
                                    commonHelper.showMessage(messages['dialogs.visits']);
                                }
                                if(data.actionTimezone){
                                    if(data.timezoneType == 'out'){
                                        commonHelper.showMessage(messages['dialogs.timezone1'] + " " + data.childName + " " + messages['dialogs.timezone2']);
                                        var subscriptionParams = {};
                                        if(data.orgid) subscriptionParams['orgid'] = data.orgid;
                                        if(data.childId) subscriptionParams['childId'] = data.childId;
                                        if(data.courseType) subscriptionParams['courseType'] = data.courseType;
                                        if(data.teacher) subscriptionParams['teacher'] = data.teacher;
                                        if(data.additionalTeacher) subscriptionParams['additionalTeacher'] = data.additionalTeacher;
                                        if(data.dateStart) subscriptionParams['dateStart'] = data.dateStart;
                                        if(data.discount) subscriptionParams['discount'] = data.discount;
                                        if(data.price) subscriptionParams['price'] = data.price;
                                        if(data.room) subscriptionParams['room'] = data.room;
                                        if(data.timeStart) subscriptionParams['timeStart'] = data.timeStart;
                                        if(data.timeFinish) subscriptionParams['timeFinish'] = data.timeFinish;
                                        if(data.duration) subscriptionParams['duration'] = data.duration;
                                        if(data.barcode) subscriptionParams['barcode'] = data.barcode;
                                        subscriptionParams['visited'] = true;

                                        window.open('client.htm?action=createOneLesson&actionParameters=' + encodeURIComponent(JSON.stringify(subscriptionParams)), '_blank');
                                    }
                                    else {
                                        commonHelper.showMessage(messages['dialogs.timezone1'] + " " + data.childName + " " + messages['dialogs.timezone3']);
                                    }
                                }
                            }
                        });
                    }
                }

                var readerSelect = $('#readBarcodeDialog').find('.barcodeReader');
                readerSelect.val('-');

                var inputCode = $('#readBarcodeDialog').find('.barcodeText');
                inputCode.val('').off('keyup').on('keyup', function(){
                    var value = inputCode.val().split(' ');
                    if(value.length > 1){
                        readerSelect.val(readersByPrefix[value[0]]);
                        inputCode.val(value[1]);
                    }
                    else if(value[0].length == 13){
                        if(readerSelect.val() == '-' && readersByPrefix['']){
                            readerSelect.val(readersByPrefix['']);
                        }
                        if(readerSelect.val() != '-'){
                            REFERENCE.closeEditReferenceDialog('readBarcodeDialog');
                            onBarcodeRead(readerSelect.val(), value[0]);
                        }
                        else {
                            commonHelper.showMessage(messages['dialogs.undefinedreader']);
                        }
                    }
                });

                var buttons = {
                    'readButton': {
                        title: messages['dialogs.read'],
                        action: function () {
                            if(readerSelect.val() != ''){
                                REFERENCE.closeEditReferenceDialog('readBarcodeDialog');
                                onBarcodeRead(readerSelect.val(), inputCode.val());
                            }
                            else {
                                commonHelper.showMessage(messages['dialogs.undefinedreader']);
                            }
                            return false;
                        }
                    }
                }
                REFERENCE.openEditReferenceDialog('readBarcodeDialog', {
                        buttons: buttons,
                        onClose: function () {}
                    }
                );
                inputCode.focus();
            }
            else {
                commonHelper.showMessage(messages['dialogs.noreaders']);
        	}
        }, false);
    };

    this.openScriptDialog = function (scriptId, type) {
        var params = {};
        var autoclose = false;
        if(scriptId){
            params['scriptId'] = scriptId;
        }
        else if(type){
            params['type'] = type;
            autoclose = true;
        }
        commonHelper.callAjaxMethod('phone.htm', 'loadPhoneScript', params, function (data) {
            if (data && data.name && data.text) {
                if(autoclose){
                    $('#phonescriptdialog').addClass('autoclose');
                }
                else {
                    $('#phonescriptdialog').removeClass('autoclose');
                }
                $('#phonescriptdialog').attr('title', data.name);
                $('#phonescriptdialog-content').html(data.text.replace(/\n/g,"<br>"));

                var w = $(window).width();
                var h = $(window).height();
                $('#phonescriptdialog').dialog({
                    height:h*0.95,
                    width:w*0.35,
                    modal:true
                });
            } else {
                commonHelper.showMessage(messages['dialogs.noscriptdata']);
            }
        }, false);
    };

    var lessonStatus = function (context) {
        return context.context.actualDay.canceled ? messages['dialogs.cancelled'] : '';
    };

    var generateVisited = function (context) {
        return context.item.visited ? '\u2714' : context.item.missed ? 'x' : '';
    };


    return this;
}();
function familyDialog() {
    var that = this;
    var coursesMenuOpened = false;
    var familyPaymentsLoaded = false;
    var familyBonusLoaded = false;
    var selectedFamilyId = null;
    that.editFamilyDialog = function (familyid, childid, saveCallback, closeCallback, deleteCallback, defaultValues) {
        selectedFamilyId = familyid;
        familyPaymentsLoaded = false;
        familyBonusLoaded = false;
        commonHelper.closeDialog('editFamilyDialog');
        $('#tabs-familychidren').tabs({
            show: function (event, ui) {
                $(ui.panel).css('visibility', "visible");
                if (ui.panel.id == 'tabs-payments') {
                    if (!familyPaymentsLoaded) {
                        familyPaymentsLoaded = true;
                        loadFamilyPayments(familyid);
                    }
                }
                if (ui.panel.id == 'tabs-bonus') {
                    if (!familyBonusLoaded) {
                        familyBonusLoaded = true;
                        loadFamilyBonus(familyid);
                    }
                }
            }
        });
        $('#tabs-familychidren').tabs("select", 0);

        $('#editFamilyDialog').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5
            },
            fixed: false,
            closeOnClick: false
        });

        var buttons = [
            {
                text: messages['common.remove'],
                id: "deleteFamilyButton",
                style: 'float: left; margin-right: 640px;',
                position: 'left',
                click: function (event) {
                    DIALOGS.askYesNoDialog(messages['familydialog.confirmfamilyremove'], messages['common.remove'], function () {
                        commonHelper.callAjaxMethod('family.htm', 'deleteFamily', {familyId: familyid ? familyid : '', childId: childid ? childid : ''}, function (result) {
                            if (deleteCallback) {
                                deleteCallback(event);
                            }
                            closeOverlay('editFamilyDialog');
                        });
                    });
                }
            },
            {
                text: messages['common.close'],
                click: function (event) {
                    if (closeCallback) {
                        closeCallback(event);
                    }
                    closeOverlay('editFamilyDialog');
                }
            },
            {
                text: messages['common.save'],
                id: "saveFamilyButton",
                click: function (event) {
                    if (saveFamily()) {
                        closeOverlay('editFamilyDialog');
                    }
                }
            },
            {
                text: messages['common.clear'],
                style: 'float: left; margin-right: 640px;',
                position: 'left',
                click: function (event) {
                    clearForm();
                }
            }

        ];

        var buttonsDivLeft = $('#familyDialogButtonsLeft');
        var buttonsDivRight = $('#familyDialogButtonsRight');
        buttonsDivLeft.children(null).remove();
        buttonsDivRight.children(null).remove();
        $.each(buttons, function (index, item) {
            var buttonDiv = $('<div>', {
                style: 'padding-left: 10px; float: left;'
            });
            var button = $('<button>', {
            }).html(item.text).button();
            button.attr('id', item.id);
            button.appendTo(buttonDiv);
            button.click(item.click);
            if (!item.position || item.position == 'right') {
                buttonDiv.prependTo(buttonsDivRight);
            } else {
                buttonDiv.prependTo(buttonsDivLeft);
            }
        });

        coursesMenuOpened = false;
        $('.dialogMessages').html('');
        var childrenTable = $('#children');
        childrenTable.find('.kid').not('#kid-template').remove();
        var renderParams = {
            ".parentName@value": "parentName",
            ".phone@value": "phone",
            ".email@value": "email",
            ".additionalEmail@value": "additionalEmail",
            ".address@value": "address",
            ".additionalPhone@value": "additionalPhone",
            ".comment": "comment",
            ".familyId@value": "",
            '.familyDepositValue': '',
            '.familyDiscount@value': '0',
            '.familyCreateDate@value' : ''
        };
        if(!studyClubMode){
            renderParams[".familyName@value"] = "familyName";
            renderParams[".agreementsNumbers@value"] = "agreementsNumbers";
        }
        if($('#editFamilyDialog').find('.bonusBlock').length > 0){
            renderParams[".bonusValue"] = '0';
        }
        $('#familyDialogInfo').directives(renderParams).render({});
        $('[name=familyorg]').removeAttr('checked');
        $('.familySendNotifications').attr('checked', 'checked');
        $('.familyCreateDate').val($.datepicker.formatDate(DATE_FORMAT, new Date()));

        if (ORGS_COUNT > 1) {
            $('#childorgsDiv').show();
        } else {
            $('#childorgsDiv').hide();
        }

        if (familyid || childid) {
            var params = {};
            if (familyid) {
                params.familyId = familyid;
            } else {
                params.childId = childid;
            }

            commonHelper.callAjaxMethod('family.htm', 'getFamilyInformation', params, function (result) {

                loadFamilyReferences(result);
                
                var family = result.family;
                var renderParams = {
                    ".parentName@value": "parentName",
                    ".phone@value": "phone",
                    ".email@value": "email",
                    ".additionalEmail@value": "additionalEmail",
                    ".address@value": "address",
                    ".additionalPhone@value": "additionalPhone",
                    ".comment": "comment",
                    '.familyDiscount@value': 'familyDiscount',
                    ".familyId@value": "id",
                    ".familyCreateDate@value" : "createDate"
                };
                if(!studyClubMode){
                    renderParams[".familyName@value"] = "familyName";
                    renderParams[".agreementsNumbers@value"] = "agreementsNumbers";
                }
                $('#familyDialogInfo').directives(renderParams).render(family);
                $('#familyInterest').val(family.interest ? family.interest.value : '');
                $('#familysourceInfo').val(family.infoSource ? family.infoSource.id : '');
                $('#familylocation').val(family.location ? family.location.id : '');
                $('#contactauthor').val(family.contactAuthor ? family.contactAuthor.id : '');
                $('#familyDepositValue').html(family.deposit);
                $('#mobileIntegrationKey').html(family.mobileIntegrationKey);
                if (family.mobileIntegrationKeyExpired){
                    $('#mobileIntegrationKey').hide();
                    $('#mobileIntegrationKeyGenerationButton').show();

                } else {
                    $('#mobileIntegrationKey').show();
                    $('#mobileIntegrationKeyGenerationButton').hide();
                    if (family.email != ''){
                        $('#mobileIntegrationKeyEmailWarning').hide();
                    } else {
                        $('#mobileIntegrationKeyEmailWarning').show();
                    }

                }

                commonHelper.setDatePicker($('#editfamily-dialog-panel').find('.familyCreateDate'));

                //bonus init if available
                if($('#editFamilyDialog').find('.bonusBlock').length > 0){
                    var bonusProgramSelect = $('#bonusProgram');
                    var bonusProgramListRows = [
                        {name: '', programid: ''}
                    ];
                    bonusProgramListRows = bonusProgramListRows.concat(result.bonus.rows);
                    bonusProgramSelect.children(null).remove();
                    $('<option>', {
                        value: ''
                    }).appendTo(bonusProgramSelect);
                    bonusProgramSelect.directives({
                        'option': {
                            'row<-rows': {
                                '.': 'row.title',
                                '@value': 'row.programid'
                            }
                        }
                    }).render({'rows': bonusProgramListRows});

                    if(family.bonusProgram){
                        $('#bonusProgram').val(family.bonusProgram.id);
                    }
                    $('#bonusValue').text(family.bonusMoneyAvailable);
                }
                
                //contracts tab init
                if($('#familyDialogContractInfo').length > 0){
                    var renderParams = {
                        ".contractFIO": "contractFIO",
                        ".contractPassport": "contractPassport",
                        ".contractAddress": "contractAddress"
                    }
                    $('#familyDialogContractInfo').directives(renderParams).render(family);
                    renderParams = {
                        ".legalTitle@value": "legalTitle",
                        ".legalINN@value": "legalINN",
                        ".legalKPP@value": "legalKPP",
                        ".legalORGN@value": "legalORGN",
                        ".legalBank@value": "legalBank",
                        ".legalBankKS@value": "legalBankKS",
                        ".legalBankBik@value": "legalBankBik",
                        ".legalBankRS@value": "legalBankRS",
                        ".legalAddress@value": "legalAddress",
                        ".legalHead@value": "legalHead",
                        ".legalEmail@value": "legalEmail"
                    };
                    $('#familyDialogLegalInfo').directives(renderParams).render(family);
                }

                $.each(family.stoppedNotificationDestinations, function (index, item) {
                    $('#' + item).removeAttr('checked', 'checked');
                });


                for (var index = 0; index < family.kids.length; index++) {
                    var kid = family.kids[index];
                    that.addChildPanel(kid);

                    for (var courseIndex = 0; courseIndex < kid.desiredCourses.length; courseIndex++) {
                        var course = kid.desiredCourses[courseIndex];
                        that.addDesiredCourse(course.name, course.id, kid.id);
                    }
                }

                var orgsId = {};
                $.each(result.family.organizationsIds, function (index, item) {
                    orgsId[item] = true;
                });

                var orgs = $('#editfamily-dialog-panel').find('[name=familyorg]');
                $.each(orgs, function (index, item) {
                    if (orgsId[$(item).attr('orgid')]) {
                        $(item).attr('checked', 'checked');
                    }
                });

                commonHelper.checkFeature('MOBILE', function(){
                    $( "#mobileIntegrationKeyContainer" ).show();
                }, function(){
                    $( "#mobileIntegrationKeyContainer" ).hide();
                });

                commonHelper.prepareViewer([
                    {filter: 'input', action: 'disable'},
                    {filter: 'select', action: 'disable'},
                    {filter: 'textarea', action: 'disable'},
                    {filter: '.removeDesiredCourseLink', action: 'hide'},
                    {filter: '.birthDate', action: 'disabledatepicker'},
                    {filter: '.childCreateDate', action: 'disabledatepicker'},
                    {filter: '.familyCreateDate', action: 'disabledatepicker'}

                ]);

            });
        } else {
            var orgs = $('#editfamily-dialog-panel').find('[name=familyorg]');
            commonHelper.setDatePicker($('#editfamily-dialog-panel').find('.familyCreateDate'));
            $.each(orgs, function (index, element) {
                if ($(element).attr('orgid') == CURRENT_ORG) {
                    $(element).attr('checked', 'checked');
                }
            });

            commonHelper.callAjaxMethod('settings.htm', 'loadSelectedReferences', {'references': 'sourceInfo, location, teacher'}, function (result) {
                loadFamilyReferences(result);
                
                if(defaultValues){
                    var renderParams = {
                        ".parentName@value": "contactName",
                        ".phone@value": "phone",
                        ".email@value": "email",
                        ".comment": "comment",
                        ".sourceType@value": "sourceType",
                        ".sourceId@value": "sourceId",
                        ".callId@value": "callId"
                    }
                    if(!studyClubMode){
                        renderParams[".familyName@value"] = "lastName";
                    }
                    $('#familyDialogInfo').directives(renderParams).render(defaultValues);
                    $('#familysourceInfo').val(defaultValues.infoSourceSelect);
                    $('#familylocation').val(defaultValues.locationSelect);
                    $('#contactauthor').val(defaultValues.inChargeSelect);
                    if(defaultValues.infoSourceId) {
                        $('#familysourceInfo').val(defaultValues.infoSourceId);
                    }
                    if(defaultValues.organizationId) {
                        $.each($('#editfamily-dialog-panel').find('[name=familyorg]'), function (index, item) {
                            if ($(item).attr('orgid') == defaultValues.organizationId) {
                                $(item).attr('checked', 'checked');
                            }
                        });
                    }
                    that.addChildPanel(defaultValues);
                }
                else {
                    if(studyClubMode){
                        //there is only one children in client mode
                        that.addChildPanel(null);
                    }
                }
            });
        }

        commonHelper.prepareViewer([
            {filter: '.addDesiredCourse', action: 'hide'},
            {filter: '#addChildButton', action: 'hide'},
            {filter: '.deleteButton', action: 'hide'},
            {filter: '#saveFamilyButton', action: 'delete'},
            {filter: '#deleteFamilyButton', action: 'delete'}

        ]);
        $('#editFamilyDialog').overlay().load();
        $('#editFamilyDialog').css('z-index', (commonHelper.getMaxZIndex() + 1));

        var loadFamilyReferences = function (result) {
            var sourceInfoSelect = $('#familysourceInfo');
            var sourceListRows = [
                {name: '', infosourceid: ''}
            ];
            sourceListRows = sourceListRows.concat(result.sourceInfo.rows);

            sourceInfoSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(sourceInfoSelect);

            sourceInfoSelect.directives({
                'option': {
                    'row<-rows': {
                        '.': 'row.name',
                        '@value': 'row.infosourceid'
                    }
                }
            }).render({'rows': sourceListRows});

            var locationSelect = $('#familylocation');
            var locationListRows = [
                {name: '', locationid: ''}
            ];
            locationListRows = locationListRows.concat(result.location.rows);

            locationSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(locationSelect);

            locationSelect.directives({
                'option': {
                    'row<-rows': {
                        '.': 'row.name',
                        '@value': 'row.locationid'
                    }
                }
            }).render({'rows': locationListRows});

            var contactAuthorSelect = $('#contactauthor');
            var contactAuthorListRows = [
                {name: '', teacherid: ''}
            ];
            contactAuthorListRows = contactAuthorListRows.concat(result.teacher.rows);

            contactAuthorSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(contactAuthorSelect);

            contactAuthorSelect.directives({
                'option': {
                    'row<-rows': {
                        '.': 'row.name',
                        '@value': 'row.teacherid'
                    }
                }
            }).render({'rows': contactAuthorListRows});
        };

        var saveFamily = function () {
            if (validate()) {
                var structure = {};
                commonHelper.fillWithInputs(structure, $('#editfamily-dialog-panel'), ['parentName', 'id', 'familyName', 'phone', 'email', 'additionalEmail', 'address', 'additionalPhone', "agreementsNumbers", 'comment', 'familysourceInfo', 'familyInterest', 'familylocation', 'contactauthor', 'familyDiscount', 'familyCreateDate', 'sourceType', 'sourceId', 'callId', 'bonusProgram', 'contractFIO', 'contractPassport', 'contractAddress', 'legalTitle', 'legalINN', 'legalKPP', 'legalORGN', 'legalBank', 'legalBankKS', 'legalBankBik', 'legalBankRS', 'legalAddress', 'legalHead', 'legalEmail', 'pushUID']);
                structure.kids = [];
                $.each($('#editfamily-dialog-panel').find('#children').children(null), function (index, element) {
                    element = $(element);
                    var id = element.find('[name=id]').val();
                    if (id != '') {
                        var desiredCourses = element.find('.desiredCourse');
                        var desiredCoursesId = [];
                        $.each(desiredCourses, function (index, element) {
                            desiredCoursesId.push($(element).data('course-id'));
                        });

                        structure.kids[structure.kids.length] = {
                            id: id,
                            lastName: element.find('[name=lastName]').val(),
                            middleName: element.find('[name=middleName]').val(),
                            firstName: element.find('[name=firstName]').val(),
                            birthDate: element.find('[name=birthDate]').val(),
                            approximateAge: element.find('[name=approximateAge]').val(),
                            kindergarten: element.find('[name=kindergarten]').val(),
                            visitkindergarten: element.find('[name=visitkindergarten]:checked').length > 0,
                            visitschool: element.find('[name=visitschool]:checked').length > 0,
                            comment: element.find('[name=comment]').val(),
                            desiredcourses: desiredCoursesId,
                            createDate : element.find('[name=childCreateDate]').val(),
                            agreementNumber : element.find('[name=childAgreementNumber]').val(),
                            agreementStartDate : element.find('[name=childAgreementStartDate]').val(),
                            agreementDate : element.find('[name=childAgreementDate]').val()
                        }
                    }
                });

                structure.orgs = that.collectOrgIds();
                structure.notificationDestinations = $('.familySendNotifications:checked').map(function () {
                    return $(this).val();
                }).get();
                var savedFamily = false;
                commonHelper.callAjaxMethod('family.htm', 'saveFamily', {"objects": JSON.stringify(structure)}, function (response) {
                    savedFamily = true;
                    if (saveCallback) {
                        saveCallback(response);
                    }
                }, false);
                return savedFamily;
            } else {
                return false;
            }
        };


        var validate = function () {
            var messageElement = $('.dialogMessages');
            messageElement.html('');
            /*if ($('[name="familyName"]').val() == '') {
             messageElement.html('Имя семьи не заполнено');
             return false;
             }*/
            if ($('[name="parentName"]').val() == '') {
                messageElement.html(messages['familydialog.errrorparentname']);
                return false;
            }
            if ($('[name="phone"]').val() == '') {
                messageElement.html(messages['familydialog.nophone']);
                return false;
            }

            var kids = $('#editfamily-dialog-panel').find('#children').children(null);
            var res = true;
            $.each(kids, function (index, item) {
                if (item.id != 'kid-template') {
                    //res &= checkEmptyField(item, '[name="birthDate"]', 'Дата рождения не заполнена', messageElement, 'ДД/ММ/ГГГГ');
                    res &= checkEmptyField(item, '[name="firstName"]', messages['familydialog.errorchildname'], messageElement);
                    //res &= checkEmptyField(item, '[name="lastName"]', 'Фамилия одного из детей не заполнено', messageElement);
                }
            });
            return res;
        };

        var checkEmptyField = function (container, elementName, message, messageObject, defaultValue) {
            var name = $(container).find(elementName);
            if (name.val() == '' || (defaultValue && defaultValue == name.val())) {
                messageObject.html(message);
                return false;
            }
            return true;
        };

        if (childid && !studyClubMode) {
            $('#tabs-familychidren').tabs("select", 1);
            window.setTimeout(function () {
                $('#editFamilyDialog').scrollTo($('#editchild-panel-' + childid).find('.firstName'), 400);
            }, 200);
        }
    };

    that.deleteFamilyPayment = function (paymentId) {
        DIALOGS.paymentDialog.deletePayment(paymentId, function (data) {
            $('#familyDepositValue').html(parseFloat($('#familyDepositValue').html()) - parseFloat(data));
            loadFamilyPayments(selectedFamilyId);
        });
    };

    var loadFamilyPayments = function (familyid) {
        REFERENCE.fillReferenceList('familyPayments', 'family.htm', 'loadFamilyPayments', {
            sortOrder: 'desc',
            sortName: 'u.id',
            fillCallback: function (list, template, data) {
                if (data) {
                    var row = template.clone();
                    row.removeClass('familyPaymentsTemplate');
                    row.show();
                    row.appendTo(list);

                    var result = list.directives({
                            '.familyPaymentsRow': {
                                'row <- rows': {
                                    '.author': 'row.author.name',
                                    '.value': function (context) {
                                        return context.item.paymentType.direction == 'INCOME' ? '<span style="color: green">' + context.item.value + ' ' + MONEY_NAME + '</span>' : '<span style="color: red">-' + context.item.value + ' ' + MONEY_NAME + '</span>';
                                    },
                                    '.cash': 'row.cash.name',
                                    '.paymentType': 'row.paymentType.name',
                                    '.modificationDate': 'row.modificationDate',
                                    '.paymentDate' : 'row.paymentDate',
                                    '.organization': 'row.organization.name',
                                    '.paymentInfo': 'row.paymentDescription',
                                    '.paymentComment': 'row.comment',
                                    '.deletePayment@paymentId': 'row.id'
                                }
                            }
                        }
                    ).render(data);

                    commonHelper.checkPermission('finance', function () {
                        $('.deletePayment').show();
                    }, function () {
                        $('.deletePayment').hide();
                    });

                    return result;
                }
            },
            filterParams: {
                familyId: familyid ? familyid : ''
            }
        });
    };

    var loadFamilyBonus = function (familyid) {
        REFERENCE.fillReferenceList('familyBonus', 'bonus.htm', 'loadStatistic', {
            sortOrder: 'desc',
            sortName: 'bonusactionid',
            fillCallback: function (list, template, data) {
                if (data) {
                    var row = template.clone();
                    row.removeClass('familyBonusTemplate');
                    row.show();
                    row.appendTo(list);

                    var result = list.directives({
                            '.familyBonusRow': {
                                'row <- rows': {
                                    '.createddate': 'row.createddate',
                                    '.lesson': 'row.lesson',
                                    '.program': 'row.program',
                                    '.type': function (context) {
                                        return context.item.type == 'INCOME' ? 'начислено' : 'списано';
                                    },
                                    '.bonus': function (context) {
                                        return context.item.type == 'INCOME' ? '<font color="green">' + context.item.bonus + '</font>' : '<font color="red">' + context.item.bonus + '</font>';
                                    },
                                    '.bonusmoney': function (context) {
                                        return context.item.type == 'INCOME' ? '<font color="green">' + context.item.bonusmoney + '</font>' : '<font color="red">' + context.item.bonusmoney + '</font>';
                                    }
                                }
                            }
                        }
                    ).render(data);

                    return result;
                }
            },
            requestCallback: function(data){
                var totalPanel = $('#tabs-bonus');
                var totalValues = data.additionalAggregationList[0];
                totalPanel.find('.totalbonus').text(totalValues.totalbonus ? totalValues.totalbonus : 0);
                totalPanel.find('.totalbonusmoney').text(totalValues.totalbonusmoney ? totalValues.totalbonusmoney : 0);
            },
            filterParams: {
                filterfamily: familyid ? familyid : ''
            }
        });
    };

    that.collectOrgIds = function () {
        var orgs = $('#editfamily-dialog-panel').find('[name=familyorg]');
        var orgsId = [];

        $.each(orgs, function (index, element) {
            if ($(element).attr('checked')) {
                orgsId.push($(element).attr('orgid'));
            }
        });
        return orgsId;
    };

    that.addChildPanel = function (kid) {

        var childrenTable = $('#children');
        var rowTemplate = childrenTable.find('#kid-template');
        if (!kid) {
            kid = {};
            kid.lastName = $('[name="familyName"]').val();
        }
        if(!kid.id) {
            kid.id = 'newchild' + $('[id^="editchild-panel-"]').length;
            kid.createDate = $.datepicker.formatDate(DATE_FORMAT, new Date());
        }

        kid = kid ? kid : {};

        var row = rowTemplate.clone();
        var rowParams = {
            ".firstName@value": "firstName",
            ".middleName@value": "middleName",
            ".lastName@value": "lastName",
            ".birthDate@value": "birthDate",
            ".birthDate@id": "birthDate_#{id}",
            ".approximateAge@value": "#{approximateAge}",
            ".approximateAgeUpdateDate": "approximateAgeUpdateDate",
            ".addDesiredCourse@name": "adddesiredbutton-#{id}",
            ".kidid@value": "id",
            '.childAgreementNumber@value' : 'agreementNumber',
            '.childAgreementStartDate@value' : 'agreementStartDate',
            '.childAgreementDate@value' : 'agreementDate',
            ".@id": "editchild-panel-#{id}"
        };
        if(!studyClubMode){
            rowParams[".childCreateDate@value"] = "createDate";
            rowParams[".childCreateDate@id"] = "childCreateDate_#{id}";
            rowParams[".kindergarten@value"] = "kindergarten";
            rowParams[".comment"] = "comment";
            rowParams[".deleteButton@name"] = "deletebutton-#{id}";
            rowParams[".visitkindergarten@checked"] = renderKindergartenChecked;
            rowParams[".visitschool@checked"] = renderSchoolChecked;
        }
        if($('#familyDialogContractInfo').length > 0){
            rowParams[".printChildContract@name"] = "printcontractbutton-#{id}";
        }
        row = row.attr('id', '').directives(rowParams).render(kid);

        var approximateAge = row.find('.approximateAge');
        var ageDiv = row.find('.approximateAgeUpdateDateDiv');

        if (kid.birthDate != null) {
            approximateAge.attr('disabled', 'disabled');
        } else {
            approximateAge.removeAttr('disabled');
        }

        if (kid.approximateAgeYears != null) {
            ageDiv.show();
        } else {
            ageDiv.hide();
        }

        DEFAULT_INPUT_VALUE.prepare(row.find('.birthDate'), SERVER_DATE_FORMAT);
        row.show().appendTo(childrenTable);
        commonHelper.setDatePicker(row.find('.birthDate'));
        commonHelper.setDatePicker(row.find('.childCreateDate'));
        commonHelper.setDatePicker(row.find('.childAgreementStartDate'));
        commonHelper.setDatePicker(row.find('.childAgreementDate'));
        return row;
    };

    that.changeBirthDate = function (dateInput) {
        var birthDateField = $(dateInput);
        var kid = birthDateField.parents().filter('.kid');
        var approximateField = kid.find('.approximateAge');

        if (birthDateField.val() != null && birthDateField.val() != SERVER_DATE_FORMAT && birthDateField.val() != '') {
            approximateField.attr('disabled', 'disabled');
        } else {
            approximateField.removeAttr('disabled');
        }

    };

    var renderKindergartenChecked = function (arg) {
        var item = arg.context;
        return item.visitKindergarten ? 'checked' : '';
    };

    var renderSchoolChecked = function (arg) {
        var item = arg.context;
        return item.visitSchool ? 'checked' : '';
    };

    that.addChildDialog = function (kid) {
        var row = that.addChildPanel(kid);
        $('#editFamilyDialog').scrollTo(row.find('.firstName'), 400);
    };


    that.addDesiredCourseCallback = function (button, childid) {
        $('#menuCoursesUl').find('.menuCoursesItem').remove();

        var orgIds = that.collectOrgIds();

        commonHelper.callAjaxMethod('family.htm', 'loadFamilyCourseTypeReference', {childId: childid && !childid.startsWith('newchild') ? childid : '', orgIds: orgIds}, function (result) {
            $('#menuCoursesItemTemplate').clone().appendTo($('#menuCoursesUl'));
            $('#menuCoursesDiv ul').directives({
                '.menuCoursesItem': {
                    'row <-rows': {
                        'span.title': 'row.name',
                        '@value': 'row.coursetypeid',
                        '@template': 'false'
                    }
                }
            }).render(result);

            $('#menuCoursesUl').find('.menuCoursesItem').show();

            $('#menuCoursesDiv').css('z-index', commonHelper.getMaxZIndex());
            var menuContainer = $('#menuCoursesDiv ul');

            menuContainer.menu({
                blur: function () {
                    menuContainer.data('selecteditem', null);
                },

                focus: function (event, ui) {
                    menuContainer.data('selecteditem', ui);
                }
            })
        });


        var buttonObject = $(button);
        var buttonOffset = buttonObject.offset();
        $('#menuCoursesDiv').css('left', (buttonOffset.left) + 'px');
        $('#menuCoursesDiv').css('top', (buttonOffset.top + buttonObject.height() + 3) + 'px');

        $('html').one('mousedown', function () {
            var selectedItem = $('#menuCoursesDiv ul').data('selecteditem');
            if (selectedItem) {
                var courseId = selectedItem.item.attr('value');
                that.addDesiredCourse(selectedItem.item.find('.title').html(), courseId, childid);
            }
            $('#menuCoursesDiv').hide();
        });

        $('#menuCoursesDiv').show(10, 'linear');
    };


    that.addDesiredCourse = function (coursetitle, courseid, childid) {
        var desiredCourse = $('#desiredCourseTemplate').clone();
        desiredCourse.attr('id', null);
        desiredCourse.data('course-id', courseid);
        desiredCourse.data('child-id', childid);
        desiredCourse.find('.title').html(coursetitle);
        desiredCourse.show();

        desiredCourse.appendTo($('#editchild-panel-' + childid).find('.desiredCourses'));

    };

    that.createDepositPayment = function () {
        DIALOGS.paymentDialog.addPayment({familyId: $('#editFamilyDialog').find('.familyId').val(), selectedPaymentType: 'depositin'}, function (data) {
            $('#familyDepositValue').html(data.familyDeposit);
            loadFamilyPayments(selectedFamilyId);
        });
    };

    that.moveBonusesToDeposit = function () {
        var familyId = $('#editFamilyDialog').find('.familyId').val();
        var bonusValue = $('#editFamilyDialog').find('.bonusValue').text();
        if(familyId && bonusValue && parseFloat(bonusValue) > 0){
            DIALOGS.askYesNoDialog('Зачислить бонусы на депозит клиента?', 'Да', function () {
                commonHelper.callAjaxMethod('bonus.htm', 'moveToDeposit', {familyId: familyId}, function (data) {
                    $('#editFamilyDialog').find('.bonusValue').text('0');
                    commonHelper.showMessage('Бунусы зачислены на депозит');
                });
            });
        }
        else {
            commonHelper.showMessage('Нет бонусов для зачисления');
        }
    };

    that.removeDesiredCourse = function (button) {
        var course = $(button).parents().filter('.desiredCourse');
        course.remove();
    };

    that.generateMobileIntegrationKey = function(){
        commonHelper.callAjaxMethod('family.htm', 'generateMobileIntegrationKey', {familyId: $('#editFamilyDialog').find('.familyId').val()}, function (response) {
            $('#mobileIntegrationKey').html(response);
            if ($('#editFamilyDialog').find('.email').val() != ''){
                $('#mobileIntegrationKeyEmailWarning').hide();
            } else {
                $('#mobileIntegrationKeyEmailWarning').show();
            }
            $('#mobileIntegrationKey').show();
            $('#mobileIntegrationKeyGenerationButton').hide();
        }, false);
    };

    that.deleteChildDialog = function (id, callbackFunction) {
        DIALOGS.askYesNoDialog(messages['familydialog.confirmchildremove'], messages['common.remove'], function () {
            deleteChild(id);
        });


        var deleteChild = function (id) {
            var params = {"childId": id};
            if (id.indexOf('newchild') == -1) {
                commonHelper.callAjaxMethod('family.htm', 'deleteChild', params, function (result) {
                    if (callbackFunction) {
                        callbackFunction(result.id);
                    }
                    $('[id=editchild-panel-' + id + ']').remove();
                });
            } else {
                $('[id=editchild-panel-' + id + ']').remove();
            }
        };
    };

    that.autofillFamilyName = function() {
        var kids = $('#editfamily-dialog-panel').find('#children').children(null);
        var familyName = "";
        $.each(kids, function (index, item) {
            if (item.id != 'kid-template') {
                familyName = $(item).find('[name=lastName]').val() + " " + $(item).find('[name=firstName]').val()
            }
        });
        $('#editfamily-dialog-panel').find('[name=parentName]').val(familyName);
    };

    var closeOverlay = function (overlayName) {
        $('#' + overlayName).overlay().close();
    };

    var clearForm = function() {
        $('#editfamily-dialog-panel').find('[type=text],select,textarea').each(function(){
           $(this).val('');
        });
    };

    that.printChildContract = function(childid, event){
        $.contextMenu('destroy', $('#printChildContract'));
        commonHelper.callAjaxMethod('settings.htm', 'loadContractTemplates', {}, function (data) {
            if(data.rows.length > 0){
                var menu = {};
                for(var i=0; i<data.rows.length; i++){
                    menu['contract-' + data.rows[i].contracttemplateid] = {name: data.rows[i].title};
                }
                $.contextMenu({
                    trigger: 'left',
                    selector: '#printChildContract',
                    callback: function (key, options, menuElement) {
                        var templatetId = key.split('-')[1];
                        if (!CLIENT_PRINTING) {
                            commonHelper.callAjaxMethod('client.htm', 'printContract', {childId: childid, templateId: templatetId}, function (result) {
                                commonHelper.showMessage(messages['familydialog.printcontract']);
                            });
                        } else {
                            commonHelper.openPdfPrintDialog('client.htm?method=printContractFromClient&childId=' + childid + "&templateId=" + templatetId);
                        }
                    },
                    items: menu

                });
                $('#printChildContract').contextMenu({x:event.clientX, y:event.clientY + $(window).scrollTop()});
            }
            else {
                commonHelper.showMessage(messages['familydialog.nocontracttemplates']);
            }
        });
    };

    return this;
}

DIALOGS.familyDialogs = familyDialog();



function compositeScheduleDialog_helper(compositeScheduleHelper) {
    var that = this;
    var currentSchedules;
    var compositeScheduleId;
    var compositeScheduleType = null;
    var scheduleOrgId = null;
    that.openDialog = function (id, orgid, callbackFunction) {
        commonHelper.closeDialog('editCompositeScheduleDialog');

        scheduleOrgId = orgid;

        compositeScheduleId = id;
        currentSchedules = [];

        $('#editCompositeScheduleDialog').find('[name="active"]:checked').removeAttr('checked');
        $('#editCompositeScheduleDialog').find('organizationSelect').val('');
        $('#editCompositeScheduleDialog').find('courseType').val('');
        $('#editCompositeScheduleDialog').find('.scheduleComment').val('');
        $('#editCompositeScheduleDialog').find('.coursetypeTitle').html();

        $('#simpleScheduleMenuButton').button();
        $('#createSimpleScheduleButton').button();

        $('#editCompositeScheduleDialog').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5,
                zIndex: 100
            },
            fixed: false,
            closeOnClick: false
        });

        if (ORGS_COUNT > 0) {
            $('#compositeScheduleOrganizationSelect').show();
        } else {
            $('#compositeScheduleOrganizationSelect').hide();
        }
        $('#compositeScheduleOrganizationSelect').val(scheduleOrgId);
        var buttons = [
            {
                text: messages['common.remove'],
                id: "deleteCompositeScheduleButton",
                style: 'float: left; margin-right: 640px;',
                position: 'left',
                click: function (event) {
                    DIALOGS.askYesNoDialog(messages['compositescheduledialog.confirmremove'], messages['common.remove'], function () {
                        commonHelper.callAjaxMethod('settings.htm', 'deleteCompositeSchedule', {scheduleId: compositeScheduleId}, function (result) {
                            if (callbackFunction) {
                                callbackFunction();
                            }
                            $('#editCompositeScheduleDialog').overlay().close();
                        });
                    });
                }
            },
            {
                text: messages['common.close'],
                click: function (event) {
                    $('#editCompositeScheduleDialog').overlay().close();
                }
            },
            {
                text: messages['common.save'],
                id: "saveScheduleButton",
                click: function (event) {
                    if (saveCompositeSchedule()) {
                        if (callbackFunction) {
                            callbackFunction();
                        }

                        $('#editCompositeScheduleDialog').overlay().close();
                    }
                }
            }

        ];


        var buttonsDivLeft = $('#compositeScheduleDialogButtonsLeft');
        var buttonsDivRight = $('#compositeScheduleDialogButtonsRight');
        buttonsDivLeft.children(null).remove();
        buttonsDivRight.children(null).remove();

        $.each(buttons, function (index, item) {
            var buttonDiv = $('<div>', {
                style: 'padding-left: 10px; float: left;'
            });
            var button = $('<button>', {
            }).html(item.text).button();
            button.attr('id', item.id);
            button.appendTo(buttonDiv);
            button.click(item.click);
            if (!item.position || item.position == 'right') {
                buttonDiv.prependTo(buttonsDivRight);
            } else {
                buttonDiv.prependTo(buttonsDivLeft);
            }
        });

        that.reloadCompositeSchedule(id);

        var saveCompositeSchedule = function () {
            var params = {compositeScheduleId: compositeScheduleId};
            params.active = $('#editCompositeScheduleDialog').find('[name="active"]:checked').val() ? true : false;
            params.orgid = $('#editCompositeScheduleDialog').find('#compositeScheduleOrganizationSelect').val() ? $('#editCompositeScheduleDialog').find('#compositeScheduleOrganizationSelect').val() : '';
            params.coursetype = $('#editCompositeScheduleDialog').find('.coursetype').val() ? $('#editCompositeScheduleDialog').find('.coursetype').val() : '';
            params.scheduleComment = $('#editCompositeScheduleDialog').find('.scheduleComment').val();
            params.schedules = [];

            var fullPriceParts = 0;
            $.each(currentSchedules, function (index, item) {
                var pricePart = $('.pricePart[scheduleId=' + item.simpleSchedule.id + ']').val();
                params.schedules.push({'scheduleId': item.simpleSchedule.id, 'pricePart': pricePart});
                fullPriceParts += parseFloat(pricePart);
            });

            var result = false;

            if (fullPriceParts != 100) {
                commonHelper.showError(messages['compositescheduledialog.fullpartserror']);
            } else {
                commonHelper.callAjaxMethod('settings.htm', 'saveCompositeSchedule', {"objects": JSON.stringify(params)}, function (data) {
                    result = true;
                }, false);
            }
            return result;
        };

    };

    this.reloadScheduleInfo = function (scheduleId) {
        commonHelper.callAjaxMethod('settings.htm', 'loadScheduleInfo', {'scheduleId': scheduleId, 'compositeScheduleId': compositeScheduleId}, function (result) {
            var foundIndex = null;
            $.each(currentSchedules, function (index, element) {
                if (element.simpleSchedule.id == scheduleId) {
                    foundIndex = index;
                }
            });
            currentSchedules[foundIndex] = result;
        }, false);
    };

    this.reloadCompositeSchedule = function (id) {
        var params = {id: id};
        commonHelper.callAjaxMethod('settings.htm', 'loadCompositeSchedule', params, function (result) {

            var dialogContainer = $('#editCompositeScheduleDialog');

            var coursetypeSelect = dialogContainer.find('.coursetype');
            var coursetypeTitle = dialogContainer.find('.coursetypeTitle');
            var activeCheckbox = dialogContainer.find('.active');
            var scheduleComment = dialogContainer.find('.scheduleComment');
            var orgSelect = dialogContainer.find('#compositeScheduleOrganizationSelect');

            coursetypeSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(coursetypeSelect);

            coursetypeSelect = coursetypeSelect.directives({
                'option': {
                    'coursetype <- coursetypes': {
                        '.': 'coursetype.name',
                        '@value': 'coursetype.coursetypeid'
                    }
                }
            }).render(result);

            if (result.object) {
                currentSchedules = result.object.schedulesInfo;
                coursetypeTitle.html(result.object.courseType ? result.object.courseType.name : '');
                scheduleComment.val(commonHelper.decodeHtmlString(result.object.comment));
                orgSelect.val(result.object.organization ? result.object.organization.id : null);
                if (result.object.active) {
                    activeCheckbox.attr('checked', 'checked');
                } else {
                    activeCheckbox.removeAttr('checked');
                }
                coursetypeTitle.show();
                coursetypeSelect.hide();
                $('#compositeScheduleOrganizationSelect').attr('disabled', 'disabled');
            } else {
                scheduleComment.val('');
                currentSchedules = [];
                activeCheckbox.attr('checked', 'checked');
                coursetypeSelect.show();
                coursetypeTitle.hide();
                $('#compositeScheduleOrganizationSelect').removeAttr('disabled');
            }
            that.rebuildSchedulesList();

            dialogContainer.overlay().load();
        });
    };

    this.createSimpleSchedule = function () {
        DIALOGS.scheduleDialogs.simpleScheduleDialog.openDialog('',  $('#compositeScheduleOrganizationSelect').val(), function (newScheduleId) {
            DIALOGS.scheduleDialogs.updateSimpleSchedulesList();
            that.addSimpleSchedule(newScheduleId);
            that.rebuildSchedulesList();
        });
    };

    this.addSimpleSchedule = function (scheduleId) {
        var scheduleInfo = null;
        $.each(DIALOGS.scheduleDialogs.simpleScheduleCache, function (index, item) {
            if (item.id == scheduleId) {
                if (!compositeScheduleType) {
                    compositeScheduleType = item.scheduleType;
                    scheduleInfo = item;
                } else {
                    if (compositeScheduleType != item.scheduleType) {
                        commonHelper.showError(messages['compositescheduledialog.incorrecttype']);
                    } else {
                        scheduleInfo = item;
                    }
                }
            }
        });

        if (scheduleInfo) {
            var alreadyExists = false;
            $.each(currentSchedules, function (index, element) {
                if (element.simpleSchedule.id == scheduleInfo.id) {
                    alreadyExists |= true;
                    commonHelper.showError(messages['compositescheduledialog.existsschedule']);
                }
            });

            if (!alreadyExists) {
                currentSchedules.push({'simpleSchedule': scheduleInfo});
                that.rebuildSchedulesList();
            }
        }
    };

    this.rebuildSchedulesList = function () {
        var compositeSchedulesList = $('#compositeSchedulesList').find('.listBody');
        compositeSchedulesList.children(null).remove();

        var templateClone = $('.compositeScheduleElementTemplate').clone();
        templateClone.removeClass('compositeScheduleElementTemplate');
        templateClone.show();

        templateClone.appendTo(compositeSchedulesList);
        compositeSchedulesList.directives({
            '.compositeScheduleElement': {
                'schedule <- schedules': {
                    '.teacherName': function (context) {
                        var name = context.item.simpleSchedule.teacher.name;
                        if(context.item.simpleSchedule.additionalTeacher){
                            name += ', ' + context.item.simpleSchedule.additionalTeacher.name;
                        }
                        return name
                    },
                    '.courseName': 'schedule.simpleSchedule.courseType.name',
                    '.pricePart@value': function (context) {
                        return context.item.pricePart * 100
                    },
                    '.pricePart@scheduleId': 'schedule.simpleSchedule.id',
                    '.timeElement': {
                        'element <- schedule.simpleSchedule.elements': {
                            '.day': 'element.day.title',
                            '.startTime': 'element.startTime',
                            '.finishTime': 'element.finishTime',
                            '.room': 'element.room.title'
                        }
                    },
                    '.deleteCompositeScheduleElement@simpleScheduleId': 'schedule.simpleSchedule.id',
                    '.editCompositeScheduleElement@simpleScheduleId': 'schedule.simpleSchedule.id'
                }
            }

        }).render({'schedules': currentSchedules});
    };

    that.openSimpleSchedulesMenu = function () {
        compositeScheduleHelper.openSimpleSchedulesMenu('#simpleScheduleMenuButton', function (key, options) {
            var scheduleId = key.split('-')[1];
            that.addSimpleSchedule(scheduleId);
        });
    };

    this.editSimpleSchedule = function (scheduleId) {
        currentPage.schedules.simpleSchedules.editSimpleScheduleRow(scheduleId, function () {
            that.reloadScheduleInfo(scheduleId);
            that.rebuildSchedulesList();
        });
    };

    this.deleteSimpleSchedule = function (scheduleId) {
        var newCurrentSchedules = [];
        $.each(currentSchedules, function (index, element) {
            if (element.simpleSchedule.id != scheduleId) {
                newCurrentSchedules.push(element);
            }
        });
        currentSchedules = newCurrentSchedules;
        if (newCurrentSchedules.length == 0) {
            compositeScheduleType = null;
        }
        that.rebuildSchedulesList();
    };

    return this;
}function pricePanelHelper(panelName) {
    var that = this;
    var ui = null;

    var extraDiscount = 0;
    var extraDiscountComment = '';
    var newExtraDiscount = 0;
    var price = 0;
    var paidSumUserChanged = false;
    var fullLessonsCount = 0;
    var newPaidSumAutoFilling = false;
    var paidSum = 0;
    var onelesson = true;

    that.initAndClearPanel = function () {
        ui = {
            sourcePrice: $('#sourcePrice' + panelName),
            paymentDate: $('#paymentDate' + panelName),
            paidSum: $('#paidSum' + panelName),
            newPaidSum: $('#newPaidSum' + panelName),
            familyDeposit: $('#familyDeposit' + panelName),
            useDeposit: $('#useDeposit' + panelName),
            extraDiscountLink: $('#extraDiscountLink' + panelName),
            extraDiscount: $('#extraDiscount' + panelName),
            paid: $('#paid' + panelName),
            discount: $('#discount' + panelName),
            realPrice: $('#realPrice' + panelName),
            fullPrice: $('#fullPrice' + panelName),
            menuPaymentsDiv: $('#menuPaymentsDiv' + panelName),
            subscriptionPaymentTypeSelect: $('#subscriptionPaymentType' + panelName),
            cashesSelect: $('#subscriptionCash' + panelName),
            paymentsListMenuLink: $('#paymentsListMenuLink' + panelName),
            copyPaidSum: $('#copyPaidSum' + panelName)
        };

        ui.paymentsListMenuLink.unbind();
        ui.extraDiscountLink.unbind();
        ui.discount.unbind();
        ui.realPrice.unbind();
        ui.newPaidSum.unbind();
        ui.fullPrice.unbind();
        ui.newPaidSum.unbind();
        ui.subscriptionPaymentTypeSelect.unbind();

        ui.paymentsListMenuLink.click(that.openPaymentsList);
        ui.extraDiscountLink.click(that.copyExtraDiscount);
        ui.discount.keyup(that.onChangeDiscount);
        ui.realPrice.keyup(that.onChangeRealPrice);
        ui.fullPrice.keyup(that.onChangeFullPrice);
        ui.newPaidSum.keyup(that.onChangeNewPaidSum);
        ui.subscriptionPaymentTypeSelect.change(that.onSubscriptionPaymentType);
        ui.copyPaidSum.click(that.onCopyNewPaidSum);

        ui.sourcePrice.val('');
        ui.paymentDate.val('');
        ui.paidSum.html('');
        ui.newPaidSum.val('');
        ui.familyDeposit.val('');
        ui.useDeposit.removeAttr('checked');
        ui.extraDiscountLink.attr('title', '');
        ui.extraDiscountLink.attr('alt', '');
        ui.extraDiscount.html('');
        ui.paid.attr('checked', 'checked');
        ui.discount.val('0'); //
        ui.realPrice.val('');
        ui.fullPrice.val('');
        ui.menuPaymentsDiv.find('ul').children().remove();
        ui.cashesSelect.children().remove();
        ui.subscriptionPaymentTypeSelect.children().remove();
        extraDiscount = 0;
        newExtraDiscount = 0;
        extraDiscountComment = '';
        paidSumUserChanged = false;
        newPaidSumAutoFilling = false;
        fullLessonsCount = 0;
        paidSum = 0;
        price = 0;

        commonHelper.setDatePicker(ui.paymentDate);
        ui.paymentDate.datepicker("setDate", new Date());

    };

    that.onSubscriptionPaymentType = function () {
        var subscriptionPaymentType = ui.subscriptionPaymentTypeSelect.val();
        if (subscriptionPaymentType) {
            ui.cashesSelect.val(ui.subscriptionPaymentTypeSelect.find('[value=' + subscriptionPaymentType + ']').attr('defaultcash'));
        }
    };

    that.updatePriceInfo = function (_paidSum, _price, _extraDiscount, _extraDiscountComment, payments) {
        ui.paidSum.html(_paidSum);
        paidSum = _paidSum;
        price = _price ? _price.value : null;
        if (price) {
            ui.sourcePrice.val(price);
        }
        extraDiscount = _extraDiscount;
        extraDiscountComment = commonHelper.decodeHtmlString(_extraDiscountComment);
        ui.extraDiscount.html('0');
        if (extraDiscountComment) {
            ui.extraDiscountLink.attr('title', extraDiscountComment);
            ui.extraDiscountLink.attr('alt', extraDiscountComment);
        }
        generatePaymentMenu(payments);
    };

    that.updateReferences = function (cashes, paymentTypes, defaultPaymentTypeId, defaultCashId) {
        $.each(cashes, function (index, item) {
            var option = $('<option>', {
                'value': item.id
            });
            option.html(item.name);
            option.appendTo(ui.cashesSelect);
        });

        $.each(paymentTypes, function (index, item) {
            var option = $('<option>', {
                'value': item.id
            });
            option.html(item.name);
            option.attr('defaultCash', item.defaultCash.id);
            option.appendTo(ui.subscriptionPaymentTypeSelect);
        });

        if (defaultPaymentTypeId) {
            ui.subscriptionPaymentTypeSelect.val(defaultPaymentTypeId);
        }

        if (defaultCashId) {
            ui.cashesSelect.val(defaultCashId);
        }

    };

    that.onChangeFullPrice = function () {
        if (ui.fullPrice.attr('oldvalue') != ui.fullPrice.val()) {
            if (fullLessonsCount) {
                var sourcePrice = parseFloat(ui.sourcePrice.val());
                if (sourcePrice) {
                    var paidSum = ui.paidSum.html() ? parseFloat(ui.paidSum.html()) : 0;

                    var fullPrice = parseFloat(ui.fullPrice.val());

                    var realPrice;
                    var discount;
                    if (onelesson) {
                        realPrice = (fullPrice / fullLessonsCount);
                        discount = (1 - realPrice / sourcePrice) * 100;
                    } else {
                        realPrice = (fullPrice / fullLessonsCount);
                        discount = (1 - fullPrice / sourcePrice) * 100;
                    }

                    ui.discount.val(discount >= 0 ? discount.toFixed(2) : '0');
                    ui.realPrice.val(realPrice >= 0 ? realPrice.toFixed(2) : '');

                    if (paidSum == 0 && !paidSumUserChanged && newPaidSumAutoFilling) {
                        ui.newPaidSum.val(fullPrice >= 0 ? fullPrice.toFixed(2) : '');
                    }
                }
            }
        }
    };

    that.onChangeRealPrice = function () {
        if (ui.realPrice.attr('oldvalue') != ui.realPrice.val()) {
            if (fullLessonsCount) {
                var sourcePrice = parseFloat(ui.sourcePrice.val());
                if (sourcePrice) {
                    var realPrice = parseFloat(ui.realPrice.val());

                    var discount;
                    var fullPrice;

                    if (onelesson) {
                        discount = (1 - realPrice / sourcePrice) * 100;
                        fullPrice = realPrice * fullLessonsCount;
                    } else {
                        fullPrice = realPrice * fullLessonsCount;
                        discount = (1 - fullPrice / sourcePrice) * 100;
                    }

                    ui.discount.val(discount >= 0 ? discount.toFixed(2) : '0');
                    ui.extraDiscount.html('0');
                    ui.fullPrice.val(fullPrice >= 0 ? fullPrice.toFixed(2) : '');
                }
            }
        }
    };


    that.onChangeDiscount = function () {
        if (fullLessonsCount) {
            var sourcePrice = parseFloat(ui.sourcePrice.val());
            if (sourcePrice) {
                var paidSum = ui.paidSum.html() ? parseFloat(ui.paidSum.html()) : 0;

                var discount = calculateDiscount(sourcePrice, fullLessonsCount);
                var realPrice = 0;
                var fullPrice = 0;
                if (onelesson) {
                    realPrice = (sourcePrice - sourcePrice * (discount / 100));
                    fullPrice = (realPrice * fullLessonsCount);
                } else {
                    fullPrice = (sourcePrice - sourcePrice * (discount / 100));
                    realPrice = (fullPrice / fullLessonsCount);
                }
                ui.realPrice.val(realPrice >= 0 ? realPrice.toFixed(2) : '');
                ui.fullPrice.val(fullPrice >= 0 ? fullPrice.toFixed(2) : '');

                if (paidSum == 0 && !paidSumUserChanged && newPaidSumAutoFilling) {
                    ui.newPaidSum.val(fullPrice >= 0 ? fullPrice.toFixed(2) : '');
                }
            } else {
                ui.realPrice.val('');
                ui.fullPrice.val('');
                if (!paidSumUserChanged && newPaidSumAutoFilling) {
                    ui.newPaidSum.val('');
                }
            }

        } else {
            ui.realPrice.val('');
        }
    };

    that.copyExtraDiscount = function () {
        if (ui.extraDiscount.html() != '' && ui.extraDiscount.html() != '0') {
            ui.extraDiscount.html('0');
            newExtraDiscount = 0;
            that.onChangeDiscount();
        } else {
            ui.extraDiscount.html(extraDiscount);
            newExtraDiscount = extraDiscount;
            if (newExtraDiscount) {
                that.onChangeDiscount();
            }
        }
    };

    that.getNewExtraDiscount = function () {
        return newExtraDiscount ? newExtraDiscount : '';
    };

    that.getNewExtraDiscountComment = function () {
        return newExtraDiscount && newExtraDiscount > 0 && extraDiscountComment ? extraDiscountComment : '';
    };

    that.updateSourcePrice = function (price, _onelesson) {
        if (_onelesson == undefined) {
            _onelesson = true;
        }
        onelesson = _onelesson;
        ui.sourcePrice.val(price);
        that.onChangeDiscount();
    };

    that.updateNewPaidSumAutoFilling = function (value) {
        newPaidSumAutoFilling = value;
    };

    that.updateFullPrice = function (generatedFullPrice) {
        ui.fullPrice.val(generatedFullPrice);
        that.onChangeFullPrice();
    };

    that.updateFullLessonsCount = function (_fullLessonsCount) {
        var valueChanged = fullLessonsCount != _fullLessonsCount;
        fullLessonsCount = _fullLessonsCount;
        if (valueChanged) {
            that.onChangeDiscount();
        }
    };

    that.updateFamilyDeposit = function (value) {
        if (value) {
            ui.familyDeposit.val(value);
        }
    };

    that.updateDiscount = function (value) {
        if (value) {
            ui.discount.val(value);
        }
    };

    that.getPaidSum = function () {
        return ui.paidSum.html();
    };

    that.getPaymentDate = function () {
        return ui.paymentDate.val();
    };

    that.getUseDeposit = function () {
        return ui.useDeposit.is(':checked');
    };

    that.getPaid = function () {
        return ui.paid.is(':checked');
    };

    that.getFullPrice = function () {
        return ui.fullPrice.val() ? ui.fullPrice.val() : 0;
    };

    that.getNewPaidSum = function () {
        return ui.newPaidSum.val() ? ui.newPaidSum.val() : 0;
    };

    that.onCopyNewPaidSum = function () {
        return ui.newPaidSum.val(ui.fullPrice.val() - paidSum);
    };

    that.getCash = function () {
        return ui.cashesSelect.val() ? ui.cashesSelect.val() : ''
    };

    that.getPaymentType = function () {
        return ui.subscriptionPaymentTypeSelect.val() ? ui.subscriptionPaymentTypeSelect.val() : ''
    };

    that.onChangeNewPaidSum = function () {
        paidSumUserChanged = true;
    };

    that.openPaymentsList = function () {
        var buttonOffset = ui.paymentsListMenuLink.offset();
        ui.menuPaymentsDiv.show();
        ui.menuPaymentsDiv.offset({left: buttonOffset.left, top: buttonOffset.top + 16});
        setTimeout(function () {
            $('html').one('click', function () {
                ui.menuPaymentsDiv.hide();
            });
        }, 10)
    };

    that.hideExtraDiscount = function () {
        $('#extraDiscountLink' + panelName).hide();
        $('#extraDiscount' + panelName).hide();
        $('#extraDiscount' + panelName + 'Money').hide();
    };

    that.hide = function () {
        $('#pricePanel' + panelName).hide();
    };

    that.show = function () {
        $('#pricePanel' + panelName).show();
    };

    that.enablePanel = function () {
        $('#realPrice' + panelName).removeAttr('disabled');
        $('#fullPrice' + panelName).removeAttr('disabled');
        $('#newPaidSum' + panelName).removeAttr('disabled');
        $('#subscriptionCash' + panelName).removeAttr('disabled');
        $('#subscriptionPaymentType' + panelName).removeAttr('disabled');
        $('#discount' + panelName).removeAttr('disabled');
        $('#useDeposit' + panelName).removeAttr('disabled');
        $('#paymentDate' + panelName).removeAttr('disabled');
    };

    that.disablePanel = function () {
        $('#realPrice' + panelName).attr('disabled', true);
        $('#fullPrice' + panelName).attr('disabled', true);
        $('#newPaidSum' + panelName).attr('disabled', true);
        $('#subscriptionCash' + panelName).attr('disabled', true);
        $('#subscriptionPaymentType' + panelName).attr('disabled', true);
        $('#discount' + panelName).attr('disabled', true);
        $('#useDeposit' + panelName).attr('disabled', true);
        $('#paymentDate' + panelName).attr('disabled', true);
    };


    var calculateDiscount = function (sourcePrice, fullLessonsCount) {
        var currentDiscount = parseFloat(ui.discount.val());
        var sourceFullPrice;
            if (onelesson) {
                sourceFullPrice = sourcePrice * fullLessonsCount;
            } else {
                sourceFullPrice = sourcePrice * ( 1 - currentDiscount / 100);
            }
         /**
        Can we add  the familyDiscount ? Das not work wten prolong a Subscription
        */
        return currentDiscount + (newExtraDiscount / sourceFullPrice) * 100;
    };

    var generatePaymentMenu = function (payments) {
        var menuScheduleTimeDiv = ui.menuPaymentsDiv;
        var ul = menuScheduleTimeDiv.find('ul');
        ul.children().remove();
        if (payments) {
            $.each(payments, function (index, item) {
                var li = $('<li>');
                li.attr('value', item.id);

                var menuItem = $('<a>', {
                    href: 'javascript:void(0)'
                });
                menuItem.html(item.valueWithDirection + ' ' + MONEY_NAME + ', ' + item.paymentDate + ', ' + item.cashName + (item.author ? ', ' + item.author : ''));
                menuItem.appendTo(li);
                li.appendTo(ul);
            });
        }
        ul.menu('refresh');
        ul.menu();
    };

    return this;
}function simpleScheduleDialog_helper() {
    var that = this;

    var scheduleElements = [];

    var findScheduleElementById = function (id) {
        if (id && scheduleElements.length > 0) {
            for (var elementId in scheduleElements) {
                if (scheduleElements[elementId].id == id) {
                    return scheduleElements[elementId];
                }
            }
        }
        return null;
    };

    that.openDialog = function (id, data, callbackFunction) {
        var orgid = data ? data.orgid : null;
        commonHelper.closeDialog('editSimpleScheduleDialog');
        $('#editSimpleScheduleDialog').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5
            },
            fixed: false,
            closeOnClick: false
        });


        commonHelper.clearBeforeValidation('#editScheduleDialogForm', '#scheduleMessages');
        var teacherSelect = $('#scheduleTeacher');

        teacherSelect.children(null).remove();
        $('<option>', {
            value: ''
        }).appendTo(teacherSelect);

        var additionalTeacherSelect = $('#scheduleAdditionalTeacher');

        additionalTeacherSelect.children(null).remove();
        $('<option>', {
            value: ''
        }).appendTo(additionalTeacherSelect);

        var coursetypeSelect = $('.coursetype');
        var coursetypeTitle = $('#coursetypeTitle');

        coursetypeSelect.children(null).remove();
        $('<option>', {
            value: ''
        }).appendTo(coursetypeSelect);

        $('#scheduleid').val('');
        $('#startDate').val('');
        $('#finishDate').val('');
        $('#scheduleComment').val('');
        $('.scheduleMaxChildrenCount').val('');
        $('#active').attr('checked', 'checked');
        $('.scheduleBonus').val('');

        commonHelper.setDatePicker($('#startDate'));
        $('#startDate').datepicker("disable");
        commonHelper.setDatePicker($('#finishDate'));
        $('#finishDate').datepicker("disable");

        var params = {id: id, orgid: orgid};
        commonHelper.callAjaxMethod('settings.htm', 'loadSimpleSchedule', params, function (result) {
            var newObject = !(result.object && result.object.id >= 0);

            if (newObject && data.elements && data.elements.length > 0) {
                newObject = false;

                var serverResult = result;

                result = {};
                result.object = {};
                result.object.teacher = {};
                result.object.courseType = {};
                result.teachers = serverResult.teachers;
                result.coursetypes = serverResult.coursetypes;

                result.orgid = data.orgid;
                result.object.scheduleType = 'schedule';
                result.object.active = true;
                result.object.comment = '';
                result.object.courseType.id = data.courseType.coursetypeid;
                result.object.courseType.name = data.courseType.name;
                result.object.teacher.id = data.teacher.teacherid;

                if(data.additionalTeacher){
                    result.object.additionalTeacher = {};
                    result.object.additionalTeacher.id = data.additionalTeacher.teacherid;
                }

                result.object.elements = data.elements;

            }
            result.additionalteachers = [{name:'',teacherid:''}].concat(result.teachers);

            if (ORGS_COUNT > 0) {
                $('#simpleScheduleOrganizationSelect').show();
            } else {
                $('#simpleScheduleOrganizationSelect').hide();
            }


            if (!newObject) {
                $('#scheduleid').val(result.object.id);
                $('#startDate').val(result.object.startDate);
                $('#finishDate').val(result.object.finishDate);
                $('#scheduleComment').val(commonHelper.decodeHtmlString(result.object.comment));
                $('#simpleScheduleOrganizationSelect').val(result.object.organization ? result.object.organization.id : orgid);
                $('#active').attr('checked', result.object.active);
                $('.scheduleMaxChildrenCount').val(result.object.maxLessonChildrenCount);
                $('.scheduleBonus').val(result.object.bonus);
                $('[name="schedule_type"]').attr('disabled', 'disabled');

                switch (result.object.scheduleType) {
                    case 'schedule' :
                        $('[id="schedule_type_repeated"]').attr('checked', 'checked');
                        break;
                    case 'event' :
                        $('[id="schedule_type_once"]').attr('checked', 'checked');
                        break;
                }
                that.changeScheduleType();
                $('#simpleScheduleOrganizationSelect').attr('disabled', 'disabled');
            } else {
                $('#scheduleDays').hide();
                $('#scheduleButtons').hide();
                $('#scheduleDates').hide();
                $('[name="schedule_type"]').removeAttr('disabled');
                $('[name="schedule_type"]').removeAttr('checked');
                $('#simpleScheduleOrganizationSelect').val(orgid);
                $('#simpleScheduleOrganizationSelect').removeAttr('disabled');
            }

            teacherSelect = teacherSelect.directives({
                'option': {
                    'teacher <- teachers': {
                        '.': 'teacher.name',
                        '@value': 'teacher.teacherid'
                    }
                }
            }).render(result);

            if (result.object) {
                teacherSelect.val(result.object.teacher.id);
            }

            additionalTeacherSelect = additionalTeacherSelect.directives({
                'option': {
                    'teacher <- additionalteachers': {
                        '.': 'teacher.name',
                        '@value': 'teacher.teacherid'
                    }
                }
            }).render(result);

            if (result.object && result.object.additionalTeacher) {
                additionalTeacherSelect.val(result.object.additionalTeacher.id);
            }

            coursetypeSelect = coursetypeSelect.directives({
                'option': {
                    'coursetype <- coursetypes': {
                        '.': 'coursetype.name',
                        '@value': 'coursetype.coursetypeid'
                    }
                }
            }).render(result);
            if (!newObject) {
                coursetypeSelect.hide();
                coursetypeSelect.val(result.object.courseType.id);
                coursetypeTitle.show();
                coursetypeTitle.html(result.object.courseType.name);
            } else {
                coursetypeSelect.show();
                coursetypeTitle.hide();
            }

            scheduleElements = [];
            if (result.object && result.object.elements) {
                scheduleElements = result.object.elements;
            }
            updateScheduleTable();

        }, false);

        var buttons = [
            {
                text: messages['common.close'],
                click: function () {
                    $('#editSimpleScheduleDialog').overlay().close();
                    $('#scheduleElementDialog').overlay().close();
                }
            },
            {
                text: messages['common.save'],
                id: 'saveSchedule',
                click: function () {
                    if (saveSchedule(callbackFunction)) {
                        $('#editSimpleScheduleDialog').overlay().close();
                        $('#scheduleElementDialog').overlay().close();
                    }
                }
            },
            {
                text: messages['common.remove'],
                id: 'deleteSchedule',
                position: 'left',
                click: function () {
                    DIALOGS.askYesNoDialog(messages['simplescheduledialog.confirm'], messages['common.remove'], function () {
                        $('#editSimpleScheduleDialog').overlay().close();
                        $('#scheduleElementDialog').overlay().close();
                        deleteSchedule(callbackFunction);
                    });


                }
            }

        ];

        $('.addDayButton').button().unbind('click');
        $('.addDayButton').button().click(DIALOGS.scheduleDialogs.simpleScheduleDialog.openScheduleElementDialog);


        $('#startDate').datepicker("enable");
        $('#finishDate').datepicker("enable");

        commonHelper.prepareViewer([
            {filter: '#saveSchedule', action: 'delete'},
            {filter: '#deleteSchedule', action: 'delete'},
            {filter: '[name="editScheduleElement"]', action: 'delete'},
            {filter: '[name="deleteScheduleElement"]', action: 'delete'},
            {filter: 'input', action: 'disable'},
            {filter: 'select', action: 'disable'},
            {filter: '#startDate', action: 'disabledatepicker'},
            {filter: '#finishDate', action: 'disabledatepicker'}
        ]);

        var buttonsDivLeft = $('#simpleScheduleDialogButtonsLeft');
        var buttonsDivRight = $('#simpleScheduleDialogButtonsRight');
        buttonsDivLeft.children(null).remove();
        buttonsDivRight.children(null).remove();

        $.each(buttons, function (index, item) {
            var buttonDiv = $('<div>', {
                style: 'padding-left: 10px; float: left;'
            });
            var button = $('<button>', {
            }).html(item.text).button();
            button.attr('id', item.id);
            button.appendTo(buttonDiv);
            button.click(item.click);
            if (!item.position || item.position == 'right') {
                buttonDiv.prependTo(buttonsDivRight);
            } else {
                buttonDiv.prependTo(buttonsDivLeft);
            }
        });

        $('#editSimpleScheduleDialog').overlay().load();
        $('#editSimpleScheduleDialog').css('z-index', commonHelper.getMaxZIndex() + 1);

        var saveSchedule = function (saveCallback) {
            var result = false;
            if (validate()) {
                var structure = {};
                structure.scheduleElements = scheduleElements;
                structure.scheduleType = $('[name="schedule_type"]:checked').val();
                structure.active = $('#editSimpleScheduleDialog').find('[name="active"]:checked').val() ? true : false;
                structure.orgid = $('#editSimpleScheduleDialog').find('#simpleScheduleOrganizationSelect').val() ? $('#editSimpleScheduleDialog').find('#simpleScheduleOrganizationSelect').val() : '';
                commonHelper.fillWithInputs(structure, $('#editScheduleContent'), ['scheduleid', 'scheduleTeacher', 'scheduleAdditionalTeacher', 'coursetype', 'startDate', 'finishDate', 'scheduleComment', 'scheduleMaxChildrenCount', 'scheduleBonus']);
                commonHelper.callAjaxMethod('settings.htm', 'saveSchedule', {"objects": JSON.stringify(structure)}, function (response) {
                    result = true;
                    if (saveCallback) {
                        saveCallback(response);
                    }
                }, false);
            }
            return result;
        };

        var deleteSchedule = function (saveCallback) {
            commonHelper.callAjaxMethod('settings.htm', 'deleteSchedule', {"scheduleId": $('#scheduleid').val()}, function (response) {
                if (saveCallback) {
                    saveCallback(response);
                }
            });
        };

        var validate = function () {
            return commonHelper.validateForm($('#editScheduleDialogForm'), $('#scheduleMessages'), {
                startDate: {
                    required: true
                },
                finishDate: {
                    required: true
                }
            });
        };
    };

    var updateScheduleTable = function () {
        $('#scheduleElementsTable').empty();
        commonHelper.generateTimepickers('#startTime', '#finishTime');
        $.each(scheduleElements, function (index, element) {
            if (!element.deleted) {
                var tr = $('<tr>');
                var daySelect = $('<select disabled="disabled" style="width: 100%">');

                daySelect.append($('<option value="MONDAY">').html(messages['common.day1']));
                daySelect.append($('<option value="TUESDAY">').html(messages['common.day2']));
                daySelect.append($('<option value="WEDNESDAY">').html(messages['common.day3']));
                daySelect.append($('<option value="THURSDAY">').html(messages['common.day4']));
                daySelect.append($('<option value="FRIDAY">').html(messages['common.day5']));
                daySelect.append($('<option value="SATURDAY">').html(messages['common.day6']));
                daySelect.append($('<option value="SUNDAY">').html(messages['common.day7']));

                daySelect.val(element.day.value);
                tr.append($('<td>').append(daySelect));
                tr.append($('<td>').html(element.room.title));
                tr.append($('<td>').html(commonHelper.timeObjectToString(element.startTime)));
                tr.append($('<td>').html(commonHelper.timeObjectToString(element.finishTime)));
                var actionsTd = $('<td>');
                tr.append(actionsTd);
                actionsTd.append($('<div>').append($('<a href="javascript:void(0);" name="editScheduleElement" onclick="DIALOGS.scheduleDialogs.simpleScheduleDialog.openScheduleElementDialog(null, \'' + element.id + '\'); return false;">' + messages['common.edit'] + '</a>')));
                var deleteLink = $('<div>').append($('<a href="javascript:void(0);" name="deleteScheduleElement">' + messages['common.remove'] + '</a>'));
                deleteLink.click(function () {
                    DIALOGS.askYesNoDialog(messages['simplescheduledialog.confirm'], messages['common.remove'], function () {
                        var deletedElement = findScheduleElementById(element.id);
                        deletedElement.deleted = true;
                        updateScheduleTable();
                    });
                });
                actionsTd.append(deleteLink);
                $('#scheduleElementsTable').append(tr);
            }
        });
    };

    that.changeScheduleType = function () {
        switch ($('[name="schedule_type"]:checked').val()) {
            case 'once' :
                $('#scheduleDays').hide();
                $('#scheduleButtons').hide();
                $('#scheduleDates').hide();

                break;
            case 'repeated' :
                $('#scheduleDates').show();
                $('#scheduleDays').show();
                $('#scheduleButtons').show();
        }

    };

    that.changeScheduleElementDay = function(){
        $('#scheduleElementCreateDate').val(commonHelper.formatDate(new Date()));
    };

    that.openScheduleElementDialog = function (event, scheduleElementId) {
        var scheduleElement;
        commonHelper.closeDialog('scheduleElementDialog');
        $('#scheduleElementDialog').overlay({
            oneInstance: false,
            width: 300,
            height: 150,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5
            },
            fixed: false,
            closeOnClick: false
        });
        var dialog = $('#scheduleElementDialog');
        dialog.show();
        dialog.css('z-index', (commonHelper.getMaxZIndex() + 1));
        var leftButtons = dialog.find('.buttons');

        dialog.find('.dialogMessages').html('');
        leftButtons.children(null).remove();
        var buttons = [
            {
                text: messages['common.save'],
                click: function () {
                    if (validate()) {
                        if (!scheduleElement) {
                            scheduleElement = {id: 'new-' + scheduleElements.length};
                            scheduleElements[scheduleElements.length] = scheduleElement;
                        }
                        scheduleElement.day = {};
                        scheduleElement.room = {};
                        scheduleElement.room.id = $('#roomSelect').val() ? $('#roomSelect').val() : '';
                        scheduleElement.room.title = $('#roomSelect').children().filter(':selected').html();
                        scheduleElement.createDate = $('#scheduleElementCreateDate').val();
                        scheduleElement.startTime = commonHelper.timeObjectToString($('#startTime').val());
                        scheduleElement.finishTime = commonHelper.timeObjectToString($('#finishTime').val());
                        scheduleElement.day.value = $('#schDay').val();

                        updateScheduleTable();
                        $('#scheduleElementDialog').hide();
                    }
                }
            },
            {
                text: messages['common.close'],
                click: function () {
                    $('#scheduleElementDialog').hide();
                }
            }

        ];
        $.each(buttons, function (index, item) {
            var button = $('<button>');
            button.bind('click', item.click);
            button.html(item.text);
            button.button();
            button.appendTo(leftButtons);


        });

        commonHelper.clearBeforeValidation('#scheduleElementDialog', '#scheduleElementMessages');
        scheduleElement = findScheduleElementById(scheduleElementId);

        $('#schDay').val('');
        $('#startTime').val('');
        $('#finishTime').val('');
        $('#roomSelect').val('');
        $('#scheduleElementCreateDate').val(commonHelper.formatDate(new Date()));

        commonHelper.setDatePicker($('#scheduleElementCreateDate'));

        var roomSelect = $('#roomSelect');
        roomSelect.children().remove();
        $('<option>', {
            value: ''
        }).appendTo(roomSelect);
        commonHelper.callAjaxMethod('settings.htm', 'loadRooms', {sidx: 'title', orgid: $('#simpleScheduleOrganizationSelect').val() ? $('#simpleScheduleOrganizationSelect').val() : ''}, function (result) {
            roomSelect.directives({
                'option': {
                    'room <- rows': {
                        '.': 'room.title',
                        '@value': 'room.roomid'
                    }
                }
            }).render(result);

            if (scheduleElement) {
                $('#schDay').val(scheduleElement.day.value);

                $('#startTime').timepicker('setTime', commonHelper.timeObjectToString(scheduleElement.startTime));
                $('#finishTime').timepicker('setTime', commonHelper.timeObjectToString(scheduleElement.finishTime));
                $('#scheduleElementCreateDate').val(scheduleElement.createDate);
                $('#roomSelect').val(scheduleElement.room ? scheduleElement.room.id : '');
            } else {
                $('#schDay').val('');
                $('#startTime').val('');
                $('#finishTime').val('');
                $('#roomSelect').val('');
            }
        });

        $('#scheduleElementDialog').overlay().load();


        var validate = function () {
            if ($('#startTime').val() == '') {
                $('#scheduleElementMessages').html(messages['simplescheduledialog.nostarttime']);
                return false;
            }
            if ($('#finishTime').val() == '') {
                $('#scheduleElementMessages').html(messages['simplescheduledialog.nofinishtime']);
                return false;
            }
            return true;
        };

        return false;
    };


    return this;
}function marketingRequestDialog() {
    var that = this;
    that.TABLE_WIDTH = 0;

    var currentRequestId = '';
    var currentChildId = '';
    var requestTasksDataGrid = null;
    var isChanged = false;

    that.addMarketingRequest = function (params, callback) {
        that.editMarketingRequest(null, params, callback);
    };

    that.editMarketingRequest = function (id, params, marketingRequestCallback) {
        currentRequestId = id ? id : '';
        currentChildId = null;
        commonHelper.callAjaxMethod('marketing.htm', 'loadMarketingRequest', {marketingRequestId: currentRequestId}, function (data) {
            $('#marketingRequestDialog').find('tr').show();

            if(data.marketingRequestInfo && data.marketingRequestInfo.client && data.marketingRequestInfo.kidsCount > 0){
                currentChildId = data.marketingRequestInfo.currentChildId;
            }

            if (!data.marketingRequestInfo) {
                data.marketingRequestInfo = {
                    marketingRequestId: '',
                    firstName: '',
                    lastName: '',
                    contactName: '',
                    phone: '',
                    email: '',
                    status: ''
                };

                $('#marketingRequestDialog').find('.createdDate').closest('tr').hide();
                $('#marketingRequestDialog').find('.modifiedDate').closest('tr').hide();
                $('#marketingRequestDialog').find('.statusSelect').closest('tr').hide();

                if(params){
                    if(params.phone){
                        data.marketingRequestInfo.phone = params.phone.replace(/\D/g,'');
                    }
                    if(params.callId){
                        data.marketingRequestInfo.callId = params.callId;
                    }
                    if(params.infoSourceId){
                        data.marketingRequestInfo.infoSource = {id:params.infoSourceId}
                    }
                    if(params.adCompanyId){
                        data.marketingRequestInfo.adCompany = {id:params.adCompanyId}
                    }
                    if(params.organizationId){
                        data.marketingRequestInfo.organization = {id:params.organizationId}
                    }
                }
            }
            
            if(data.marketingRequestInfo.status != 'REJECTION'){
                $('#marketingRequestDialog').find('.rejectionSelect').closest('tr').hide();
            }

            var userDialog = $('#marketingRequestDialog').directives({
                '.marketingRequestId@value': 'marketingRequestInfo.id',
                '.callId@value': 'marketingRequestInfo.callId',
                '.firstName@value': 'marketingRequestInfo.firstName',
                '.lastName@value': 'marketingRequestInfo.lastName',
                '.contactName@value': 'marketingRequestInfo.contactName',
                '.phone@value': 'marketingRequestInfo.phone',
                '.email@value': 'marketingRequestInfo.email',
                '.birthday@value': 'marketingRequestInfo.birthday',
                '.createdDate': 'marketingRequestInfo.createdDate',
                '.author': 'marketingRequestInfo.author.name',
                '.modifiedDate': 'marketingRequestInfo.modifiedDate',
                '.modifer': 'marketingRequestInfo.modifer.name',
                '.comment': 'marketingRequestInfo.comment',
                '.approximateAge@value': 'marketingRequestInfo.approximateAge',
                '.approximateAgeUpdateDate': 'marketingRequestInfo.approximateAgeUpdateDate'
            }).render(data);

            $('#marketingRequestDialog').find('#firstNameAutofill').click(function(){
                $('#marketingRequestDialog').find('.firstName').val($('#marketingRequestDialog').find('.contactName').val());
                return false;
            });

            commonHelper.setDatePicker($('#marketingRequestDialog').find('.birthday'));

            $('#marketingRequestDialog').find('.infoSourceSelect').children(null).remove();
            $('#marketingRequestDialog').find('.infoSourceSelect').append('<option>');
            $('#marketingRequestDialog').find('.infoSourceSelect').directives({
                'option': {
                    'infoSource <- infoSources.rows': {
                        '.': 'infoSource.name',
                        '@value': 'infoSource.infosourceid'
                    }
                }
            }).render(data);
            $('#marketingRequestDialog').find('.infoSourceSelect').prepend('<option value="" selected="selected">');
            if(data.marketingRequestInfo.infoSource){
                $('#marketingRequestDialog').find('.infoSourceSelect').val(data.marketingRequestInfo.infoSource.id);
            }

            $('#marketingRequestDialog').find('.locationSelect').children(null).remove();
            $('#marketingRequestDialog').find('.locationSelect').append('<option>');
            $('#marketingRequestDialog').find('.locationSelect').directives({
                'option': {
                    'location <- locations.rows': {
                        '.': 'location.name',
                        '@value': 'location.locationid'
                    }
                }
            }).render(data);
            $('#marketingRequestDialog').find('.locationSelect').prepend('<option value="" selected="selected">');
            if(data.marketingRequestInfo.location){
                $('#marketingRequestDialog').find('.locationSelect').val(data.marketingRequestInfo.location.id);
            }

            $('#marketingRequestDialog').find('.adCompanySelect').children(null).remove();
            $('#marketingRequestDialog').find('.adCompanySelect').append('<option>');
            $('#marketingRequestDialog').find('.adCompanySelect').directives({
                'option': {
                    'adCompany <- adCompanies.rows': {
                        '.': 'adCompany.title',
                        '@value': 'adCompany.marketingadcompanyid'
                    }
                }
            }).render(data);
            $('#marketingRequestDialog').find('.adCompanySelect').prepend('<option value="" selected="selected">');
            if(data.marketingRequestInfo.adCompany){
                $('#marketingRequestDialog').find('.adCompanySelect').val(data.marketingRequestInfo.adCompany.id);
            }

            $('#marketingRequestDialog').find('.statusSelect').change(function(){
                var newStatus = $('#marketingRequestDialog').find('.statusSelect').val();
                if(newStatus.indexOf('REJECTION') == 0){
                    $('#marketingRequestDialog').find('.rejectionSelect').closest('tr').show();
                }
                else {
                    $('#marketingRequestDialog').find('.rejectionSelect').closest('tr').hide();
                }
            });

            //init possible status values
            $('#marketingRequestDialog').find('.statusSelect option').each(function(){
                $(this).removeAttr('disabled');
            });
            $('#marketingRequestDialog').find('.statusSelect').val('OPENED');
            if(data.marketingRequestInfo.status){
                $('#marketingRequestDialog').find('.statusSelect').val(data.marketingRequestInfo.status);
                $('#marketingRequestDialog').find('.statusSelect option').each(function(){
                    if(data.marketingRequestInfo.status.indexOf('REJECTION') == 0){
                        if($(this).attr('value') != 'OPENED' && data.marketingRequestInfo.status != $(this).attr('value')){
                            $(this).attr('disabled','disabled');
                        }
                    }
                    else if(data.marketingRequestInfo.status == 'OPENED'){
                        if($(this).attr('value') != 'REJECTION' && $(this).attr('value') != 'OPENED'){
                            $(this).attr('disabled','disabled');
                        }
                    }
                    else {
                        if($(this).attr('value') != ('REJECTION_' + data.marketingRequestInfo.status) && data.marketingRequestInfo.status != $(this).attr('value')){
                            $(this).attr('disabled','disabled');
                        }
                    }
                });
            }

            $('#marketingRequestDialog').find('.rejectionSelect').children(null).remove();
            $('#marketingRequestDialog').find('.rejectionSelect').append('<option>');
            $('#marketingRequestDialog').find('.rejectionSelect').directives({
                'option': {
                    'rejection <- rejections.rows': {
                        '.': 'rejection.name',
                        '@value': 'rejection.marketingrejectionsid'
                    }
                }
            }).render(data);
            $('#marketingRequestDialog').find('.rejectionSelect').prepend('<option value="" selected="selected">');
            if(data.marketingRequestInfo.rejection){
                $('#marketingRequestDialog').find('.rejectionSelect').val(data.marketingRequestInfo.rejection.id);
            }

            $('#marketingRequestDialog').find('.inChargeSelect').children(null).remove();
            $('#marketingRequestDialog').find('.inChargeSelect').append('<option>');
            $('#marketingRequestDialog').find('.inChargeSelect').directives({
                'option': {
                    'inCharge <- inCharges.rows': {
                        '.': 'inCharge.name',
                        '@value': 'inCharge.teacherid'
                    }
                }
            }).render(data);
            $('#marketingRequestDialog').find('.inChargeSelect').prepend('<option value="" selected="selected">');
            if(data.marketingRequestInfo.inCharge){
                $('#marketingRequestDialog').find('.inChargeSelect').val(data.marketingRequestInfo.inCharge.id);
            }

            $('#marketingRequestDialog').find('input,select,textarea').attr('disabled',false);

            isChanged = false;
            $('#marketingRequestDialog').find('input,select,textarea').on('change', function (event) {
                isChanged = true;
            });

            if (ORGS_COUNT > 0) {
                $('#marketingRequestDialog').find('.organizationSelectRow').show();
                if(data.marketingRequestInfo.organization){
                    $('#marketingRequestDialog').find('.organizationSelect').val(data.marketingRequestInfo.organization.id);
                }
            } else {
                $('#marketingRequestDialog').find('.organizationSelectRow').hide();
            }

            var approximateAge = $('#marketingRequestDialog').find('.approximateAge');
            var ageDiv = $('#marketingRequestDialog').find('.approximateAgeUpdateDateDiv');
            if (data.marketingRequestInfo.birthday != null) {
                approximateAge.attr('disabled', 'disabled');
            } else {
                approximateAge.removeAttr('disabled');
            }
            if (data.marketingRequestInfo.approximateAgeYears != null) {
                ageDiv.show();
            } else {
                ageDiv.hide();
            }

            var buttons = {
                'saveButton': {
                    title: messages['common.save'],
                    action: function () {
                        var params = REFERENCE.collectParams('marketingRequestDialog');
                        if (validate(params)) {
                            commonHelper.callAjaxMethod('marketing.htm', 'saveMarketingRequest', params, function (data) {
                                if (!data) {
                                    commonHelper.showMessage(messages['marketingrequestdialog.saveerror']);
                                } else {
                                    REFERENCE.closeEditReferenceDialog('marketingRequestDialog');
                                    if (marketingRequestCallback) {
                                        marketingRequestCallback(data);
                                    }
                                    if(id == null && data.marketingRequest){
                                        //reopen with saved data
                                        that.editMarketingRequest(data.marketingRequest.id, {}, marketingRequestCallback);
                                    }
                                }
                            });
                        }
                        return false;
                    }
                }
            };
            if(id != null){
                if(data.marketingRequestInfo.client == null || data.marketingRequestInfo.client.removed == true){
                    buttons['clientButton'] = {
                        title: messages['marketingrequestdialog.movetoclient'],
                        position: 'left',
                        action: function () {
                            if(isChanged){
                                DIALOGS.askYesNoDialog(messages['marketingrequestdialog.movetoclientconfirm'], messages['common.yes'], function () {
                                    var params = REFERENCE.collectParams('marketingRequestDialog');
                                    if (validate(params)) {
                                        commonHelper.callAjaxMethod('marketing.htm', 'saveMarketingRequest', params, function (data) {
                                            if (!data) {
                                                commonHelper.showMessage(messages['marketingrequestdialog.saveerror']);
                                            } else {
                                                moveToClient();
                                            }
                                        });
                                    }
                                }, function(){}, messages['common.no']);
                            }
                            else {
                                moveToClient();
                            }
                            return false;
                        }
                    }
                } else {
                    $('#marketingRequestDialog').find('input,select,textarea').attr('disabled','disabled');
                    $('#marketingRequestDialog').find('.statusSelect').attr('disabled',false);
                    $('#marketingRequestDialog').find('.rejectionSelect').attr('disabled',false);

                    buttons['clientButton'] = {
                        title: messages['marketingrequestdialog.openclient'],
                        position: 'left',
                        action: function () {
                            if(currentChildId){
                                window.open('client.htm?action=openChild&actionParameters=' + JSON.stringify({
                                        childId: currentChildId
                                    }), '_blank');
                            }
                            return false;
                        }
                    }
                }
            }
            else {
                buttons['saveExitButton'] = {
                    title: messages['common.saveexit'],
                        action: function () {
                        var params = REFERENCE.collectParams('marketingRequestDialog');
                        if (validate(params)) {
                            commonHelper.callAjaxMethod('marketing.htm', 'saveMarketingRequest', params, function (data) {
                                if (!data) {
                                    commonHelper.showMessage(messages['marketingrequestdialog.saveerror']);
                                } else {
                                    if (marketingRequestCallback) {
                                        marketingRequestCallback(data);
                                    }
                                    REFERENCE.closeEditReferenceDialog('marketingRequestDialog');
                                }
                            });
                        }
                        return false;
                    }
                }
            }

            var validate = function (params) {
                var errors = [];
                if (params.firstName == '') {
                    errors.push(messages['marketingrequestdialog.validatename']);
                }
                if (params.contactName == '') {
                    errors.push(messages['marketingrequestdialog.validatecontact']);
                }
                if (params.phone == '') {
                    errors.push(messages['marketingrequestdialog.validatephone']);
                }
                if(errors.length > 0){
                    $('#marketingRequestDialog').find('.dialogMessages').html(errors.join('<br>'));
                    return false;
                }
                return true;
            };

            var moveToClient = function() {
                var params = REFERENCE.collectParams('marketingRequestDialog');
                params.sourceType = 'request';
                params.sourceId = currentRequestId;
                params.birthDate = params.birthday;
                REFERENCE.closeEditReferenceDialog('marketingRequestDialog');
                DIALOGS.familyDialogs.editFamilyDialog(null, null, null, null, null, params);
            }

            REFERENCE.openEditReferenceDialog('marketingRequestDialog', {
                    buttons: buttons,
                    onClose: function () {

                    }
                }
            );

            prepareTabs(id);
            if(id != null){
                that.loadMarketingRequestTasksTable();
            }

        }, false, false);
    };

    this.loadMarketingRequestTasksTable = function () {
        $('#marketingRequestTasks').empty();
        $('#marketingRequestTasks').append('<table id="marketingRequestTasksTable"></table><div id="marketingRequestTasksPager" style="clear: both;"></div>');

        var colNames = [];
        colNames.push(messages['marketingrequestdialog.task.subject']);
        colNames.push(messages['marketingrequestdialog.task.type']);
        colNames.push(messages['marketingrequestdialog.task.date']);
        colNames.push(messages['marketingrequestdialog.task.status']);
        colNames.push('');

        var colModels = [];
        colModels.push({name: 'subject', index: 'subject', formatter: notNullFormatter});
        colModels.push({name: 'type.value', index: 'type', edittype:'select', editable: true, formatter : 'select', editoptions:{value:messages['marketingrequestdialog.typeselect']}});
        colModels.push({name: 'date', index: 'date', formatter: notNullFormatter});
        colModels.push({name: 'status.value', index: 'status', edittype:'select', editable: true, formatter : 'select', editoptions:{value:messages['marketingrequestdialog.statusselect']}});
        colModels.push({name: 'taskid', index: 'taskid', sortable: false, formatter: function (cellvalue, options, rowObject) {
            return '<a href="javascript:void(0)" class="paymentEditLink" onclick="DIALOGS.marketingRequestDialog.editMarketingRequestTask(' + cellvalue + ')">' + messages['common.edit'] + '</a>';
        }});

        requestTasksDataGrid = $('#marketingRequestTasksTable').jqGrid({
            datatype: loadTaskList,
            colNames: colNames,
            colModel: colModels,
            height: "100%",
            jsonReader: { repeatitems: false, id: "id"},
            pager: '#marketingRequestTasksPager',
            sortname: 'date', viewrecords: true, sortorder: "desc"
        });
        requestTasksDataGrid.jqGrid('setGridWidth', that.TABLE_WIDTH);

    };

    var loadTaskList = function (postdata) {
        postdata.filterrequestid = currentRequestId;
        if(currentChildId){
            postdata.additionalfilterchild = currentChildId;
        }
        commonHelper.callAjaxMethod('taskhistory.htm', 'filterTasks',
            postdata, function (result) {
                requestTasksDataGrid.clearGridData(true);
                requestTasksDataGrid[0].addJSONData(result);
            }, true);
    };

    this.addMarketingRequestTask = function(){
        $('#marketingRequestDialog').hide();
        DIALOGS.taskEditDialog(null, null, currentRequestId, null, true, true, null, function(){
            $('#marketingRequestDialog').show();
        }, function (data) {
            var selectedChild = {};
            selectedChild[currentRequestId] = true;
            var createTaskParams = {};
            createTaskParams.taskParams = data;
            createTaskParams.selectedRequests = selectedChild;
            commonHelper.callAjaxMethod('marketing.htm', 'createTasks', {"objects": JSON.stringify(createTaskParams)}, function (data) {
                that.loadMarketingRequestTasksTable();
            });
        });
    }

    this.editMarketingRequestTask = function(taskId){
        $('#marketingRequestDialog').hide();
        DIALOGS.taskEditDialog(taskId, null, currentRequestId, null, true, true, null, function(){
            $('#marketingRequestDialog').show();
            that.loadMarketingRequestTasksTable();
        }, null);
    }

    var prepareTabs = function (requestId) {
        $('#tabs-marketingrequestdialog').tabs();
        that.TABLE_WIDTH = $('#tabs-marketingrequestdialog').parent(null).width() - 40;
        var disabledTabs = [];
        if(requestId == null){
            disabledTabs.push(1);
        }
        $('#tabs-marketingrequestdialog').tabs("option", "disabled", disabledTabs);
        $('#tabs-marketingrequestdialog').tabs("select", 0);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? (rowObject.requestId ? cellvalue : '<font color="#808080">' + cellvalue + '</font>') : '';
    };

    return that;
}

DIALOGS.marketingRequestDialog = marketingRequestDialog();function multiSubscriptionDialogs() {
    var subscriptionChildId;
    var that = this;
    var pricePanel = new pricePanelHelper('MultiSubscription');
    var pricesMap = {};
    var params = null;
    this.openMultiSubscriptionDialogForChild = function (_params) {
        params = _params;
        commonHelper.setDatePicker($('#subscriptionMultiSubscriptionFrom'));
        commonHelper.setDatePicker($('#subscriptionMultiSubscriptionTo'));
        commonHelper.callAjaxMethod('client.htm', 'loadMultiSubscription', {multiSubscriptionId: params.id, childId: params.childId}, function (result) {
            subscriptionChildId = params.childId;
            $('#subscriptionMultiSubscription').children().remove();
            $('#subscriptionMultiSubscriptionFrom').val('');
            $('#subscriptionMultiSubscriptionTo').val('');
            $('#subscriptionMultiSubscriptionDiscount').val('');
            $('#membershipsForMultiSubscriptionCount').val('');

            $('<option>', {value: '', text: ''}).appendTo($('#subscriptionMultiSubscription'));
            $.each(result.subscriptionDescriptions.rows, function (index, element) {
                $('<option>', {value: element.id, text: commonHelper.decodeHtmlString(element.name)}).appendTo($('#subscriptionMultiSubscription'));
                pricesMap[element.id] = element;
            });

            pricePanel.initAndClearPanel();
            pricePanel.hideExtraDiscount();
            pricePanel.updateFullLessonsCount(1);
            pricePanel.updateReferences(result.cashes, result.paymentTypes, result.defaultPaymentTypeId, result.defaultCashId);
            pricePanel.updateFamilyDeposit(result.familyDeposit);
            pricePanel.updateDiscount(result.familyDiscount);

            if (result.subscription) {
                $('#subscriptionMultiSubscription').val(result.subscription.description.id);
                $('#subscriptionMultiSubscriptionFrom').val(result.subscription.periodFrom);
                $('#subscriptionMultiSubscriptionTo').val(result.subscription.periodTo);
                $('#subscriptionMultiSubscriptionTimeSpent').val(result.subscription.timeSpent);
                $('#subscriptionMultiSubscriptionTimeLimit').val(result.subscription.timeLimit);
                $('#membershipsForMultiSubscriptionCount').val(result.membershipsCount);
                pricePanel.updatePriceInfo(result.subscription.paidSum, result.price, 0, '', result.payments);
                pricePanel.updateFullPrice(parseFloat(result.subscription.fullPrice));
            }


            var childautocompleteparams = {
                selectCallback: function (objectId, selectedText, type, data) {
                    if (objectId && objectId != '') {
                        if (type == 'family') {

                        } else {
                            subscriptionChildId = objectId;
                            if (data) {
                                pricePanel.updateFamilyDeposit(data.deposit);
                                pricePanel.updateDiscount(data.discount);
                            }
                        }
                    } else {
                        subscriptionChildId = null;
                    }
                },
                generateId: function (item) {
                    return item.id;
                },
                generateValue: function (item) {
                    return item.value;
                },
                generateLabel: function (item) {
                    return item.title;
                },
                generateType: function (item) {
                    return item.objtype;
                },
                url: 'family.htm',
                method: 'autoCompleteSearchFamilyOrChild',
                defaultValue: messages['common.familyfilternotset'],
                inputDataTitle: messages['common.familyfiltertitle'],
                objectNotFound: messages['common.familyfilternotfound'],
                objectFound: messages['common.familyfilterfound']
            };

            AUTOCOMPLETE_SEARCH_FIELD.prepare('multisubscriptiondialogchild', childautocompleteparams);
            if (subscriptionChildId) {
                AUTOCOMPLETE_SEARCH_FIELD.disable('multisubscriptiondialogchild');
                AUTOCOMPLETE_SEARCH_FIELD.setValue('multisubscriptiondialogchild', subscriptionChildId, result.childFamilyTitle);
            } else {
                AUTOCOMPLETE_SEARCH_FIELD.enable('multisubscriptiondialogchild');
                AUTOCOMPLETE_SEARCH_FIELD.clear('multisubscriptiondialogchild');
            }


            $('#editMultiSubscriptionDialog').overlay({
                mask: {
                    color: '#fff',
                    loadSpeed: 0,
                    opacity: 0.5,
                    zIndex: 100
                },
                fixed: false,
                closeOnClick: false
            });
            $('#editMultiSubscriptionDialog').overlay().load();
        });
    };

    this.saveMultiSubscription = function (receipt) {
        commonHelper.callAjaxMethod('client.htm', 'saveMultiSubscription', {
            multiSubscriptionId: params.id ? params.id : '',
            childId: params.childId,
            periodFrom: $('#subscriptionMultiSubscriptionFrom').val(),
            periodTo: $('#subscriptionMultiSubscriptionTo').val(),
            timeSpent: $('#subscriptionMultiSubscriptionTimeSpent').val(),
            timeLimit: $('#subscriptionMultiSubscriptionTimeLimit').val(),
            multiSubscriptionDescriptionId: $('#subscriptionMultiSubscription').val(),
            subscriptionCash: pricePanel.getCash(),
            subscriptionPaymentType: pricePanel.getPaymentType(),
            paymentDate: pricePanel.getPaymentDate(),
            useDeposit: pricePanel.getUseDeposit(),
            paid: pricePanel.getPaid(),
            fullPrice: pricePanel.getFullPrice(),
            newPaidSum: pricePanel.getNewPaidSum(),
            receipt: receipt

        }, function (result) {
            if (params.callbackFunction) {
                params.callbackFunction();
            }
            that.closeDialog();
        });

    };

    this.onMultiSubscriptionDescriptionChange = function () {
        var description = pricesMap[$('#subscriptionMultiSubscription').val()];
        pricePanel.updateSourcePrice(description.price);

        var spent = parseInt($('#subscriptionMultiSubscriptionTimeSpent').val());
        if(!spent) spent = 0;
        $('#subscriptionMultiSubscriptionTimeSpent').val(spent);
        $('#subscriptionMultiSubscriptionTimeLimit').val(description.duration - spent);
    };

    this.deleteMultiSubscription = function () {
        DIALOGS.askYesNoDialog(messages['multisubscriptiondialog.confirm'], messages['common.remove'], function () {
            if (params.id) {
                commonHelper.callAjaxMethod('client.htm', 'cancelSubscription', {multiSubscriptionId: params.id ? params.id : ''}, function (result) {
                    if (params.callbackFunction) {
                        params.callbackFunction();
                    }
                });
            }
            that.closeDialog();
        });
    };

    this.closeDialog = function () {
        $('#editMultiSubscriptionDialog').overlay().close();
    };

    return this;
}

DIALOGS.multiSubscriptionDialog = multiSubscriptionDialogs();function paymentDialog() {
    var that = this;

    var depositIn = null;
    var depositOut = null;
    var tmcIn = null;
    var tmcOut = null;

    that.addPayment = function (params, callback) {
        that.editPayment(null, params, callback);
    };

    that.deletePayment = function (id, callback) {
        DIALOGS.askYesNoDialog(messages['paymentdialog.confirm'], messages['common.remove'], function () {
            commonHelper.callAjaxMethod('finance.htm', 'deletePayment', {paymentId: id ? id : ''}, function (data) {
                if (callback) {
                    callback(data);
                }
            });
        });
    };

    that.onPaymentTypeChange = function (paymentTypeId) {
        AUTOCOMPLETE_SEARCH_FIELD.hide('paymentdialogfamily');
        $('#paymentDialog').find('.paymentdialogproduct').hide();
        $('#paymentDialog').find('.paymentdialogtmcin').hide();
        $('#paymentDialog').find('.paymentValue').removeAttr('disabled');
        if (paymentTypeId == depositIn.id || paymentTypeId == depositOut.id) {
            AUTOCOMPLETE_SEARCH_FIELD.show('paymentdialogfamily');
        }

        if(tmcOut != null && paymentTypeId == tmcOut.id){
            $('#paymentDialog').find('.paymentdialogproduct').show();
        }
        if(tmcIn != null && paymentTypeId == tmcIn.id){
            AUTOCOMPLETE_SEARCH_FIELD.show('paymentdialogfamily');
            $('#paymentDialog').find('.paymentdialogproduct').show();
            $('#paymentDialog').find('.paymentdialogtmcin').show();
            $('#paymentDialog').find('.paymentValue').attr('disabled','disabled');
        }

        var defaultCash = $('[name=paymentType]').find('[value='+paymentTypeId+']').attr('defaultCash');
        $('[name=paymentCash]').val(defaultCash);

        if(tmcIn != null && paymentTypeId == tmcIn.id)
            $('#paymentDialog').find('.rightbuttons button:nth-child(2)').show();
        else
            $('#paymentDialog').find('.rightbuttons button:nth-child(2)').hide();
    };

    that.editPayment = function (id, params, paymentCallback) {
        commonHelper.callAjaxMethod('finance.htm', 'loadPayment', {paymentId: id ? id : '', familyId: params && params.familyId ? params.familyId : ''}, function (data) {
            if (!data.paymentInfo) {
                data.paymentInfo = {
                    paymentId: '',
                    paymentAuthor: '',
                    paymentEditor: '',
                    paymentComment: '',
                    paymentType: '',
                    paymentDate: $.datepicker.formatDate(DATE_FORMAT, new Date())
                }
            }

            var userDialog = $('#paymentDialog').directives({
                '.paymentId@value': 'paymentInfo.id',
                '.paymentValue@value': 'paymentInfo.value',
                '.paymentComment': 'paymentInfo.comment',
                '.paymentDescription': 'paymentInfo.paymentDescription',
                '.paymentAuthor': 'paymentInfo.author.name',
                '.paymentModifer': 'paymentInfo.modifer.name',
                '.paymentModifyDate': 'paymentInfo.modificationDate',
                '.paymentCreateDate': 'paymentInfo.createDate',
                '.paymentDate@value' : 'paymentInfo.paymentDate'
            }).render(data);

            depositIn = data.depositin;
            depositOut = data.depositout;
            if(data.tmcin){
                tmcIn = data.tmcin;
            }
            if(data.tmcout){
                tmcOut = data.tmcout;
            }

            if (data.paymentInfo && data.paymentInfo.organization) {
                userDialog.find('.paymentOrganizationSelect').val(data.paymentInfo.organization.id);
            } else {
                userDialog.find('.paymentOrganizationSelect').val('');
            }

            commonHelper.setDatePicker($('#paymentDialog').find('.paymentDate'));

            $('#paymentDialog').find('.paymentCash').children(null).remove();
            $('<option>').appendTo($('#paymentDialog').find('.paymentCash'));
            $('#paymentDialog').find('.paymentCash').directives({
                'option': {
                    'cash <- cashes': {
                        '.': 'cash.name',
                        '@value': 'cash.id'
                    }
                }
            }).render(data);

            if (data.paymentInfo && data.paymentInfo.cash) {
                $('#paymentDialog').find('.paymentCash').val(data.paymentInfo.cash.id);
            }

            $('#paymentDialog').find('.paymentdialogproduct').hide();
            $('#paymentDialog').find('.paymentdialogtmcin').hide();
            if(data.products){
                var productautocompleteparams = {
                    url: 'products.htm',
                    method: 'autoCompleteSearchProduct',
                    defaultValue: messages['products.productfilternotset'],
                    inputDataTitle: messages['products.productfilteraction'],
                    objectNotFound: messages['products.productfilternotfound'],
                    objectFound: messages['products.productfilterfound'],
                    generateId: function (item) {
                        return item.id;
                    },
                    generateValue: function (item) {
                        return item.title;
                    },
                    generateLabel: function (item) {
                        return item.title + ' ' + (item.barcode ? item.barcode : '');
                    },
                    selectCallback: function (objectId, selectedText, type, data) {
                        if (objectId && objectId != '') {
                            var orgid = $('#paymentDialog').find('.paymentOrganizationSelect').val();
                            commonHelper.callAjaxMethod('products.htm', 'findProductPrice', {productId: objectId, orgid: orgid}, function (result) {
                                if(result.price){
                                    $('#paymentDialog').find('.paymentPrice').val(result.price);
                                    calculateValue();
                                }
                            });
                        }
                    }
                };
                AUTOCOMPLETE_SEARCH_FIELD.prepare('product', productautocompleteparams);

                if (data.product) {
                    AUTOCOMPLETE_SEARCH_FIELD.setValue('product', data.product.id, data.product.title + ' ' + (data.product.barcode ? data.product.barcode : ''));
                }
                if (data.count) $('#paymentDialog').find('.count').val(data.count);
                if (data.price) $('#paymentDialog').find('.paymentPrice').val(data.price);
                if (data.discount) $('#paymentDialog').find('.paymentDiscount').val(data.discount);
                if (data.cost) $('#paymentDialog').find('.paymentCost').val(data.cost);
            }

            var childautocompleteparams = {
                url: 'family.htm',
                method: 'autoCompleteSearchFamily',
                defaultValue: messages['paymentdialog.familyfilternotset'],
                inputDataTitle: messages['paymentdialog.familyfilteraction'],
                objectNotFound: messages['paymentdialog.familyfilternotfound'],
                objectFound: messages['paymentdialog.familyfilterfound'],

                foundStatusClick: function (event) {
                    var familyid = $(this).parents().filter('#divcontainer_paymentdialogfamily').find('#paymentdialogfamily').val();
                    DIALOGS.familyDialogs.editFamilyDialog(familyid, null);
                },
                generateId: function (item) {
                    return item.id;
                },
                generateValue: function (item) {
                    return item.value;
                },
                generateLabel: function (item) {
                    return item.title;
                },
                selectCallback: function (objectId, selectedText, type, data) {
                    if (objectId && objectId != '' && data) {
                        if(data.discount){
                            $('#paymentDialog').find('.paymentDiscount').val(data.discount);
                        }
                        else {
                            $('#paymentDialog').find('.paymentDiscount').val(0);
                        }
                        calculateValue();
                    }
                }
            };

            AUTOCOMPLETE_SEARCH_FIELD.prepare('paymentdialogfamily', childautocompleteparams);
            AUTOCOMPLETE_SEARCH_FIELD.clear('paymentdialogfamily');
            AUTOCOMPLETE_SEARCH_FIELD.hide('paymentdialogfamily');

            if (id) {
                $('#paymentDialog').find('.paymentType').attr('disabled', 'disabled');
                $('#paymentDialog').find('.paymentOrganizationSelect').attr('disabled', 'disabled');
                if (data.family) {
                    AUTOCOMPLETE_SEARCH_FIELD.disable('paymentdialogfamily');
                    AUTOCOMPLETE_SEARCH_FIELD.setValue('paymentdialogfamily', data.family.id, messages['paymentdialog.family'] + ': ' + data.family.familyName + '; ' + messages['paymentdialog.parent'] + ': ' + data.family.parentName);
                }
            } else {
                if (data.family) {
                    AUTOCOMPLETE_SEARCH_FIELD.setValue('paymentdialogfamily', data.family.id, messages['paymentdialog.family'] + ': ' + data.family.familyName + '; ' + messages['paymentdialog.parent'] + ': ' + data.family.parentName);
                    AUTOCOMPLETE_SEARCH_FIELD.disable('paymentdialogfamily');
                } else {
                    $('#paymentDialog').find('.paymentType').removeAttr('disabled');
                    $('#paymentDialog').find('.paymentOrganizationSelect').removeAttr('disabled');
                    AUTOCOMPLETE_SEARCH_FIELD.enable('paymentdialogfamily');
                }
            }


            $('#paymentDialog').find('.paymentType').children(null).remove();
            $('<option>').appendTo($('#paymentDialog').find('.paymentType'));
            $('#paymentDialog').find('.paymentType').directives({
                'option': {
                    'paymentType <- paymentTypes': {
                        '.': 'paymentType.name',
                        '@value': 'paymentType.id',
                        '@defaultCash' : 'paymentType.defaultCash.id'
                    }
                }
            }).render(data);
            that.onPaymentTypeChange($('#paymentDialog').find('.paymentType').val());

            if (ORGS_COUNT > 0) {
                $('#paymentDialog').find('#paymentorganization').show();
            } else {
                $('#paymentDialog').find('#paymentorganization').hide();
            }

            if (data.paymentInfo && data.paymentInfo.paymentType) {
                $('#paymentDialog').find('.paymentType').val(data.paymentInfo.paymentType.id);
                that.onPaymentTypeChange(data.paymentInfo.paymentType.id);
            } else if (params && params.selectedPaymentType && params.selectedPaymentType == depositIn.code) {
                $('#paymentDialog').find('.paymentType').val(depositIn.id);
                that.onPaymentTypeChange(depositIn.id);
                $('#paymentDialog').find('.paymentType').attr('disabled', 'disabled');
            }


            REFERENCE.openEditReferenceDialog('paymentDialog', {
                    buttons: {
                        'saveButton': {
                            title: messages['common.save'],
                            action: function () {
                                var params = REFERENCE.collectParams('paymentDialog');
                                params.familyid = AUTOCOMPLETE_SEARCH_FIELD.getValue('paymentdialogfamily');
                                params.product = AUTOCOMPLETE_SEARCH_FIELD.getValue('product');

                                var validate = function (params) {
                                    if (params.paymentType == '') {
                                        $('#paymentDialog').find('.dialogMessages').html(messages['paymentdialog.validatetype']);
                                        return false;
                                    }
                                    if (params.paymentCash == '') {
                                        $('#paymentDialog').find('.dialogMessages').html(messages['paymentdialog.validatecash']);
                                        return false;
                                    }
                                    if (params.paymentValue == '') {
                                        $('#paymentDialog').find('.dialogMessages').html(messages['paymentdialog.validatevalue']);
                                        return false;
                                    }
                                    return true;
                                };

                                if (validate(params)) {
                                    commonHelper.callAjaxMethod('finance.htm', 'savePayment', params, function (data) {
                                        if (!data) {
                                            commonHelper.showMessage(messages['paymentdialog.saveerror']);
                                        } else {
                                            if (paymentCallback) {
                                                paymentCallback(data);
                                            }
                                            REFERENCE.closeEditReferenceDialog('paymentDialog');
                                        }
                                    });
                                }
                                return false;
                            }
                        },
                        'saveReceiptButton': {
                            title: messages['paymentdialog.savereceipt'],
                            action: function () {
                                var params = REFERENCE.collectParams('paymentDialog');
                                params.familyid = AUTOCOMPLETE_SEARCH_FIELD.getValue('paymentdialogfamily');
                                params.product = AUTOCOMPLETE_SEARCH_FIELD.getValue('product');
                                params.receipt = true;

                                var validate = function (params) {
                                    if (params.paymentType == '') {
                                        $('#paymentDialog').find('.dialogMessages').html(messages['paymentdialog.validatetype']);
                                        return false;
                                    }
                                    if (params.paymentCash == '') {
                                        $('#paymentDialog').find('.dialogMessages').html(messages['paymentdialog.validatecash']);
                                        return false;
                                    }
                                    if (params.paymentValue == '') {
                                        $('#paymentDialog').find('.dialogMessages').html(messages['paymentdialog.validatevalue']);
                                        return false;
                                    }
                                    return true;
                                };

                                if (validate(params)) {
                                    commonHelper.callAjaxMethod('finance.htm', 'savePayment', params, function (data) {
                                        if (!data) {
                                            commonHelper.showMessage(messages['paymentdialog.saveerror']);
                                        } else {
                                            if (paymentCallback) {
                                                paymentCallback(data);
                                            }
                                            REFERENCE.closeEditReferenceDialog('paymentDialog');
                                        }
                                    });
                                }
                                return false;
                            }
                        },
                        'deleteButton': {
                            title: messages['common.remove'],
                            position: 'left',
                            action: function () {
                                that.deletePayment($('.paymentId').val(), function () {
                                    if (paymentCallback) {
                                        paymentCallback();
                                    }
                                    REFERENCE.closeEditReferenceDialog('paymentDialog');
                                });
                                return false;
                            }
                        }
                    },

                    onClose: function () {

                    }
                }
            );

            $('#paymentDialog').find('.paymentPrice, .paymentDiscount, .count').change(function(){
                calculateValue();
            });

        }, false, false);
        $('#paymentDialog').find('.rightbuttons button:nth-child(2)').hide();
    };

    var calculateValue = function(){
        if($('#paymentDialog').find('.paymentValue').is(':disabled')){
            var summ = $('#paymentDialog').find('.paymentPrice').val() * $('#paymentDialog').find('.count').val();
            summ *= (100.0 - $('#paymentDialog').find('.paymentDiscount').val()) / 100.0;
            $('#paymentDialog').find('.paymentCost').val(summ);
            $('#paymentDialog').find('.paymentValue').val(summ);
        }
    }

    return that;
}

DIALOGS.paymentDialog = paymentDialog();DIALOGS.openPriceDialog = function (id, orgid, callbackFunction) {
    var dialog = $('#editPriceDialog').dialog({
            width: 310,
            modal: true,
            autoOpen: false,
            create: function (event, ui) {
                var params = {id: id, orgid: orgid};
                commonHelper.callAjaxMethod('settings.htm', 'loadPrice', params, function (result) {
                    var coursetypeSelect = $('#price_coursetype');
                    var membershiptypeSelect = $('#price_membershiptype');
                    var priceValue = $('#price_value');
                    var priceOneLesson = $('#price_onelesson');

                    coursetypeSelect.children(null).remove();
                    membershiptypeSelect.children(null).remove();
                    priceValue.val('');
                    priceOneLesson.prop('checked', true);
                    $('#priceid').val('');

                    $('<option>', {
                        value: ''
                    }).appendTo(coursetypeSelect);

                    $('<option>', {
                        value: ''
                    }).appendTo(membershiptypeSelect);

                    coursetypeSelect = coursetypeSelect.directives({
                        'option': {
                            'coursetype <- coursetypes': {
                                '.': 'coursetype.name',
                                '@value': 'coursetype.coursetypeid'
                            }
                        }
                    }).render(result);

                    var membershipTypesRows = [
                        {name: messages['price.default'], membershiptypeid: ' '}
                    ];

                    membershipTypesRows = membershipTypesRows.concat(result.membershiptypes);

                    membershiptypeSelect = membershiptypeSelect.directives({
                        'option': {
                            'row<-rows': {
                                '.': 'row.name',
                                '@value': 'row.membershiptypeid'
                            }
                        }
                    }).render({'rows': membershipTypesRows});

                    var newObject = !(result.object && result.object.id >= 0);
                    if (!newObject) {
                        $('#priceid').val(result.object.id);
                        if (result.object.membershipType) {
                            membershiptypeSelect.val(result.object.membershipType.id);
                        }
                        coursetypeSelect.val(result.object.course.id);
                        priceValue.val(result.object.value);
                        priceOneLesson.prop('checked', result.object.onelesson);
                    }

                    dialog.dialog('open');


                });

            }, open: function (event, ui) {

            },
            close: function (event, ui) {
                commonHelper.closeDialog('editPriceDialog');
            },
            buttons: [
                {
                    text: messages['common.save'],
                    click: function () {
                        if (savePrice()) {

                            if (callbackFunction) {
                                callbackFunction();
                            }
                            commonHelper.closeDialog('editPriceDialog')
                        }
                    }
                },
                {
                    text: messages['common.remove'],
                    click: function () {
                        DIALOGS.askYesNoDialog(messages['price.confirm'], messages['common.remove'], function () {
                            commonHelper.closeDialog('editPriceDialog');

                            deletePrice();

                            if (callbackFunction) {
                                callbackFunction();
                            }
                        });


                    }
                },
                {
                    text: messages['common.close'],
                    click: function () {
                        commonHelper.closeDialog('editPriceDialog')
                    }
                }

            ]
        }
    );

    var savePrice = function () {
        var result = false;
        var structure = {};
        if (validate()) {
            structure.orgid = orgid;
            structure.courseTypeId = $('#price_coursetype').val();
            structure.membershipTypeId = $('#price_membershiptype').val();
            structure.value = $('#price_value').val();
            structure.onelesson = ($('#price_onelesson').length > 0)?$('#price_onelesson').is(':checked'):true;
            commonHelper.callAjaxMethod('settings.htm', 'savePrice', {"objects": JSON.stringify(structure), oper: 'edit', id: $('#priceid').val()}, function (response) {
                result = true;
            }, false);
        }
        return result;
    };

    var validate = function () {
        return commonHelper.validateForm($('#editPriceDialogForm'), $('#scheduleMessages'), {
            price_value: {
                required: true
            }
        });
    };

    var deletePrice = function () {
        commonHelper.callAjaxMethod('settings.htm', 'savePrice', {oper: 'del', id: $('#priceid').val()}, function (response) {
            result = true;
        }, false);
    }
};function recipientsListDialog() {
    var that = this;

    that.show = function (notificationId) {
        that.loadRecipientsList(notificationId);

        commonHelper.closeDialog('recipientsList');
        $('#recipientsList').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5
            },
            fixed: false,
            closeOnClick: false
        });

        $('#recipientsList').overlay().load();
        $('#recipientsList').css('z-index', (commonHelper.getMaxZIndex() + 1));

    };

    that.close = function () {
        $('#recipientsList').overlay().close();
    };

    that.loadRecipientsList = function (notificationId) {
        var listId = 'recipientsList';
        REFERENCE.fillReferenceList(listId, 'notifications.htm', 'loadSentNotificationRecipients', {
            sortOrder: 'asc',
            sortName: 'id',
            fillCallback: function (list, template, data) {
                var row = template.clone();
                row.removeClass(listId + 'Template');
                row.show();
                row.appendTo(list);

                var rowName = '.' + listId + 'Row';
                var rowId = '.' + listId + 'RowId@value';
                var directives = {};
                directives[rowName] = {

                };
                directives[rowName]['row <- rows'] = {};
                directives[rowName]['row <- rows'][rowId] = 'row.id';
                directives[rowName]['row <- rows']['.name'] = 'row.name';
                directives[rowName]['row <- rows']['.name@href'] = 'client.htm?childid=#{row.id}';
                directives[rowName]['row <- rows']['.address'] = 'row.address';
                directives[rowName]['row <- rows']['.phone'] = 'row.phone';
                directives[rowName]['row <- rows']['.status'] = function (context) {
                    switch (context.item.status) {
                        case 'Ok' :
                            return '<span style="color:green">' + messages['recipientsdialog.status.ok'] + '</span>';
                        case 'Failed' :
                            return '<span style="color:red">' + messages['recipientsdialog.status.failed'] + '</span>';
                        case 'Progress' :
                            return '<span style="color:blue">' + messages['recipientsdialog.status.progress'] + '</span>';
                        case 'Sending' :
                            return '<span style="color:blue">' + messages['recipientsdialog.status.sending'] + '</span>';
                        case 'Overdue' :
                            return '<span style="color:orange">' + messages['recipientsdialog.status.overdue'] + '</span>';
                    }
                    return '';
                };
                directives[rowName]['row <- rows']['.message'] = 'row.message';
                directives[rowName]['row <- rows']['.notificationRecipientDelete@recipientId'] = 'row.id';
                directives[rowName]['row <- rows']['.sendNotificationsNames'] = 'row.notificationsNames';
                directives[rowName]['row <- rows']['.sendNotifications'] = function (context) {
                    return context.item.sendNotifications ? '<span style="color: green;">' + messages['recipientsdialog.notifications.on'] + '<span>' : '<span style="color: red;">' + messages['recipientsdialog.notifications.off'] + '</span>';
                };

                var result = list.directives(directives).render(data);
                $('#' + listId).find('.notificationRecipientDelete').click(that.deleteNotificationRecipient);
                if (data.records > 0) {
                    $('.recipientsCountInfo').show();
                } else {
                    $('.recipientsCountInfo').hide();
                }

                return result;

            },
            filterParams: {
                notificationId: notificationId
            }
        });
    }
}

DIALOGS.recipientsListDialog = new recipientsListDialog();function scheduleDialogs() {
    var that = this;

    that.simpleScheduleDialog = new simpleScheduleDialog_helper();
    that.compositeScheduleDialog = new compositeScheduleDialog_helper(this);

    that.simpleScheduleCache = null;

    that.openSimpleSchedulesMenu = function (buttonSelector, callback) {
        if (!that.simpleScheduleCache) {
            var teacherMenu = that.updateSimpleSchedulesList();
            $.contextMenu('destroy', buttonSelector);
            if (teacherMenu) {
                $.contextMenu({
                    trigger: 'left',
                    selector: buttonSelector,
                    callback: function (key, options, menuElement) {
                        callback(key, options, menuElement);
                    },
                    items: teacherMenu

                });
                $(buttonSelector).contextMenu();
            }
        }
    };

    that.reloadCoursesAndTeachers = function (organizationSelect) {
        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {referenceorgid: $(organizationSelect).val()}, function (result) {
            var coursetypeSelect = $('.coursetype');
            var teacherSelect = $('.scheduleTeacher');
            var additionalTeacherSelect = $('.scheduleAdditionalTeacher');

            coursetypeSelect.children().remove();
            teacherSelect.children().remove();
            additionalTeacherSelect.children().remove();

            $('<option>', {
                value: ''
            }).appendTo(coursetypeSelect);

            $('<option>', {
                value: ''
            }).appendTo(teacherSelect);

            $('<option>', {
                value: ''
            }).appendTo(additionalTeacherSelect);

            var references = {};
            references.courses = [].concat(result.courses.rows);
            references.teachers = [].concat(result.teachers.rows);
            references.additionalteachers = [{name:'',teacherid:''}].concat(result.teachers.rows);

            coursetypeSelect.directives({
                'option': {
                    'coursetype <- courses': {
                        '.': 'coursetype.name',
                        '@value': 'coursetype.coursetypeid'
                    }
                }
            }).render(references);


            teacherSelect.directives({
                'option': {
                    'teacher <- teachers': {
                        '.': 'teacher.name',
                        '@value': 'teacher.teacherid'
                    }
                }
            }).render(references);

            additionalTeacherSelect.directives({
                'option': {
                    'teacher <- additionalteachers': {
                        '.': 'teacher.name',
                        '@value': 'teacher.teacherid'
                    }
                }
            }).render(references);
            
            that.simpleScheduleCache = null;
        });
    };

    that.updateSimpleSchedulesList = function () {
        var teacherMenu = {};
        var teacherMenuInited = false;
        commonHelper.callAjaxMethod('settings.htm', 'loadSimpleSchedules', {'sidx': 'courseType.name'}, function (data) {
            that.simpleScheduleCache = data.rows;

            $('#simpleSchedulesMenu').html('');

            var teachersGroup = {};
            var scheduleOrganizationSelect = $('#editCompositeScheduleDialog').find('#compositeScheduleOrganizationSelect').val();
            $.each(data.rows, function (index, item) {
                var teacherKey = item.teacher.id;
                var teacherName = item.teacher.name;
                if(item.additionalTeacher){
                    teacherKey += '_' + item.additionalTeacher.id;
                    teacherName += ', ' + item.additionalTeacher.name;
                }
                var courseType = item.courseType;
                if (!teachersGroup[teacherKey]) {
                    teachersGroup[teacherKey] = {};
                    teachersGroup[teacherKey].name = teacherName;
                    teachersGroup[teacherKey].courses = {};
                }

                if (!teachersGroup[teacherKey].courses[courseType.id]) {
                    teachersGroup[teacherKey].courses[courseType.id] = {};
                    teachersGroup[teacherKey].courses[courseType.id].name = courseType.name;
                    teachersGroup[teacherKey].courses[courseType.id].schedules = [];
                }

                var scheduleTitle = '';
                var scheduleStartTime = null;
                if (item.elements) {
                    $.each(item.elements, function (index, scheduleElement) {
                        scheduleTitle += scheduleElement.day.title + ': ' + scheduleElement.startTime + '-' + scheduleElement.finishTime + '; ' + scheduleElement.room.title + '<br>';
                        if (!scheduleStartTime) {
                            scheduleStartTime = scheduleElement.startTime;
                        }
                    });
                } else {
                    scheduleTitle = messages['scheduledialog.event'];
                }

                teachersGroup[teacherKey].courses[courseType.id].schedules.push(
                    {
                        scheduletitle: scheduleTitle,
                        orgId: item.organization ? item.organization.id : '',
                        scheduleStartTime: scheduleStartTime,
                        scheduleId: item.id
                    }
                );
            });


            $.each(teachersGroup, function (index, item) {
                var courseMenu = {};
                var courseInited = false;
                $.each(item.courses, function (courseIndex, courseItem) {
                    var scheduleMenu = {};
                    var scheduleInited = false;
                    $.each(courseItem.schedules, function (scheduleIndex, scheduleItem) {
                        if (!scheduleItem.orgId || scheduleItem.orgId == scheduleOrganizationSelect) {
                            scheduleMenu['schedule-' + scheduleItem.scheduleId] = {
                                name: scheduleItem.scheduletitle,
                                teacherName: item.name
                            };
                            scheduleInited = true;
                        }
                    });
                    if (scheduleInited) {
                        courseMenu['course-' + courseIndex] = {name: courseItem.name, items: scheduleMenu};
                        courseInited = true;
                    }
                });
                if (courseInited) {
                    teacherMenu['teacher-' + index] = {name: item.name, items: courseMenu};
                    teacherMenuInited = true;
                }

            });

        }, false, true);
        return teacherMenuInited ? teacherMenu : null;
    };

    that.openCompositeScheduleDialog = function (id, data, callbackFunction) {
        that.compositeScheduleDialog.openDialog(id, data, callbackFunction);
    };

    that.openSimpleScheduleDialog = function (id, data, callbackFunction) {
        that.simpleScheduleDialog.openDialog(id, data, callbackFunction);
    };

    return this;
}
DIALOGS.scheduleDialogs = new scheduleDialogs();


function selectedRecipientsListDialog() {
    var that = this;
    var recipientsList = new notificationRecipientsList('toolbarRecipientsList');

    that.show = function(){
        recipientsList.loadRecipientsList();

        commonHelper.closeDialog('selectedRecipientsList');
        $('#selectedRecipientsList').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5
            },
            fixed: false,
            closeOnClick: false
        });

        $('#selectedRecipientsList').overlay().load();
        $('#selectedRecipientsList').css('z-index', (commonHelper.getMaxZIndex() + 1));

    };

    that.clear = function(){
        commonHelper.callAjaxMethod('notifications.htm', 'cleanRecipients', {}, function (result) {
            $('#messageRecipientsCount').html('0');
            $('.recipientsCountInfo').hide();
            that.close();
        });
    };

    that.close = function(){
        $('#selectedRecipientsList').overlay().close();
    }

}

DIALOGS.selectedRecipientsListDialog = new selectedRecipientsListDialog();function sendMessageDialog() {
    var that = this;
    var recipientsList = new notificationRecipientsList('notificationsRecipientsList');

    that.openTestMessageDialog = function (testType) {
        $('#notificationTestMessageDialog').find('#testType').val(testType);
        $('#testAddress').val('');
        $('#notificationTestMessageDialog').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5
            },
            closeOnClick: false
        });

        $('#notificationTestMessageDialog').overlay().load();
        $('#notificationTestMessageDialog').css('z-index', (commonHelper.getMaxZIndex() + 1));

    };

    that.sendTestMessage = function () {
        var testType = $('#notificationTestMessageDialog').find('#testType').val();
        if (testType == 'imap') {
            commonHelper.callAjaxMethod('notifications.htm', 'sendImapTestMessage', {address: $('#testAddress').val()}, function (result) {
                commonHelper.showMessage(messages['sendmessagedialog.imap1'] + ' ' + (result.success ? 'Ok' : 'Failed') + ' ' + messages['sendmessagedialog.imap2'] + (result.failed ? 'Ok' : 'Failed'));
                closeOverlay('notificationTestMessageDialog');
            });
        } else if (testType == 'smtp') {
            commonHelper.callAjaxMethod('notifications.htm', 'sendSmtpTestMessage', {address: $('#testAddress').val()}, function (result) {
                commonHelper.showMessage(messages['sendmessagedialog.smtp']);
                closeOverlay('notificationTestMessageDialog');
            });
        } else if (testType == 'sms') {
            commonHelper.callAjaxMethod('notifications.htm', 'sendSmsTestMessage', {address: $('#testAddress').val()}, function (result) {
                commonHelper.showMessage(messages['sendmessagedialog.sms']);
                closeOverlay('notificationTestMessageDialog');
            });
        } else if(testType == 'voice'){
            commonHelper.callAjaxMethod('notifications.htm', 'sendVoiceTestMessage', {address: $('#testAddress').val()}, function (result) {
                commonHelper.showMessage(messages['sendmessagedialog.voice']);
                closeOverlay('notificationTestMessageDialog');
            })
        } else if (testType == 'push') {
            commonHelper.callAjaxMethod('notifications.htm', 'sendPushTestMessage', {address: $('#testAddress').val()}, function (result) {
                commonHelper.showMessage(messages['sendmessagedialog.push']);
                closeOverlay('notificationTestMessageDialog');
            })
        }

    };


    that.closeTestMessageDialog = function () {
        closeOverlay('notificationTestMessageDialog');
    };

    that.open = function (notificationSettingsId) {
        $('#notificationSendingDialog').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5
            },
            closeOnClick: false
        });

        commonHelper.setDatePicker($('#notificationSendingDialog').find('#notificationSendingDate'));

        recipientsList.loadRecipientsList(notificationSettingsId);
        $('#sendMessagesButton').removeAttr('disabled');
        $('#sendMessagesAndClearListButton').removeAttr('disabled');
        var buttons = [
            {
                text: messages['common.close'],
                click: function (event) {
                    closeOverlay('notificationSendingDialog');
                }
            },
            {
                text: messages['sendmessagedialog.send'],
                id: "sendMessagesButton",
                click: function (event) {
                    $('#sendMessagesButton').attr('disabled', 'disabled');
                    commonHelper.callAjaxMethod('notifications.htm', 'sendMessage', {
                        notificationSettingsId: notificationSettingsId,
                        notificationSendingDate: $('#notificationSendingDialog').find('#notificationSendingDate').val()
                    }, function (result) {
                        $('#sendMessagesButton').removeAttr('disabled');
                        closeOverlay('notificationSendingDialog');
                    });
                }
            },
            {
                text: messages['sendmessagedialog.sendclean'],
                id: "sendMessagesAndClearListButton",
                click: function (event) {
                    $('#sendMessagesAndClearListButton').attr('disabled', 'disabled');
                    commonHelper.callAjaxMethod('notifications.htm', 'sendAndClearMessage', {
                        notificationSettingsId: notificationSettingsId
                    }, function (result) {
                        $('#messageRecipientsCount').html('0');
                        $('.recipientsCountInfo').hide();
                        $('#sendMessagesAndClearListButton').removeAttr('disabled');
                        closeOverlay('notificationSendingDialog');
                    });
                }
            }

        ];

        var buttonsDivLeft = $('#notificationSendingDialogButtonsLeft');
        var buttonsDivRight = $('#notificationSendingDialogButtonsRight');
        buttonsDivLeft.children(null).remove();
        buttonsDivRight.children(null).remove();
        $.each(buttons, function (index, item) {
            var buttonDiv = $('<div>', {
                style: 'padding-left: 10px; float: left;'
            });
            var button = $('<button>', {
            }).html(item.text).button();
            button.attr('id', item.id);
            button.appendTo(buttonDiv);
            button.click(item.click);
            if (!item.position || item.position == 'right') {
                buttonDiv.prependTo(buttonsDivRight);
            } else {
                buttonDiv.prependTo(buttonsDivLeft);
            }
        });

        $('#notificationSendingDialog').overlay().load();
        $('#notificationSendingDialog').css('z-index', (commonHelper.getMaxZIndex() + 1));
    };

    var closeOverlay = function (overlayName) {
        $('#' + overlayName).overlay().close();
    };

    return that;
}

DIALOGS.sendMessageDialog = new sendMessageDialog();function subscriptionDialogs(isPanelMode, suffix) {
    var that = this;
    var panelMode = isPanelMode;
    var panelSuffix = "";
    if(panelMode) panelSuffix = suffix;

    var pricePanel = new pricePanelHelper('Subscription' + panelSuffix);
    var scheduleCache = [];
    var selectedScheduleId = null;
    var canceledDays = {};

    var subscriptionType = null;
    var scheduleType = null;
    var eventSchedule = null;
    var organizationId = null;
    var membershipElementId = null;
    var returnMoneyStrategy = null;
    var multisubscriptionMembershipTypeId = null;

    var prolongReservationId = null;
    var dayInfoDialog = null;
    var subscriptionChildId = null;
    var subscriptionFamilyId = null;
    var action = null;
    var subscriptionId = null;
    var multiSubscriptionId = null;
    var duration = null;
    var fullLessonsCount = null;

    var currentSchedule = null;
    var autoVisited = false;
    var barcode = null;

    that.onTeacherChange = function (autoselectLast) {
        var teacherId = $('#teacher' + panelSuffix + ' option:selected').val();
        var subscriptiontime = $('#subscriptiontime' + panelSuffix);
        var subscriptiondays = $('#subscriptiondays' + panelSuffix);
        var lessonscount = $('#lessonscount' + panelSuffix);

        subscriptiontime.html('');
        subscriptiondays.html('');
        canceledDays = {};

        selectedScheduleId = null;

        clearScheduleSelect();
        var scheduleInfo = loadScheduleSelect(teacherId);

        $('#dialogerrormessage' + panelSuffix).html('');
        $('#eventData' + panelSuffix).hide();

        $('#saveOrCreate' + panelSuffix).removeAttr('disabled');
        $('#saveAndPrint' + panelSuffix).removeAttr('disabled');
        if (scheduleInfo.scheduleCount == 1 || autoselectLast) {
            //select if exists only one
            that.onTimeElementSelect(scheduleInfo.lastSchedule.id);
            var link = scheduleInfo.ul.find('[value=' + scheduleInfo.lastSchedule.id + '] a');
            selectScheduleTime(scheduleInfo.lastSchedule.id, link.data('schedule'));
        }
    };

    var scheduleMenuItemSelected = function (event, ui) {
        var scheduleId = ui.item.attr('value');
        selectScheduleTime(scheduleId, ui.item.find('a').data('schedule'));
    };

    var selectScheduleTime = function (scheduleId, schedule) {
        setScheduleTimeTitle(schedule);
        that.onTimeElementSelect(scheduleId);
    };

    var setScheduleTimeTitle = function (schedule) {
        var selectedScheduleTime = $('#selectedScheduleTime' + panelSuffix);
        selectedScheduleTime.children(null).remove();
        $.each(schedule.schedulesElementsByDayTitle, function (index, item) {
            var scheduleElement = $('<div>');

            var dayInfo = $('<div>', {
                style: 'text-align: left'
            });

            dayInfo.html('<b>' + index + '</b>');
            dayInfo.appendTo(scheduleElement);

            $.each(item, function (dayInfoIndex, dayInfoItem) {
                var lessonInfo = $('<div>', {
                    style: 'text-align: left'
                });
                var teacherInfo = $('<div>', {
                    style: 'text-align: left'
                });
                teacherInfo.html('<span style="color: gray">' + dayInfoItem.teacher.name + '</span>');
                lessonInfo.html('<span style="color: #e78f08">' + dayInfoItem.startTime + '</span> ' + dayInfoItem.courseType.name);
                lessonInfo.appendTo(scheduleElement);
                teacherInfo.appendTo(scheduleElement);
            });


            scheduleElement.appendTo(selectedScheduleTime);
        });
        currentSchedule = schedule;
    };


    var getMatches = function (string, regex, index) {
        index || (index = 1); // default to the first capturing group
        var matches = [];
        var match;
        while ((match = regex.exec(string)) != null) {
            matches.push(match[index]);
        }
        return matches;
    };

    that.onMultiSubscriptionChange = function () {
        multiSubscriptionId = $('#multisubscription' + panelSuffix).val();
        if (multiSubscriptionId) {
            $('#membershiptype' + panelSuffix).val(multisubscriptionMembershipTypeId);
            pricePanel.disablePanel();
        } else {
            $('#membershiptype' + panelSuffix).val('');
            pricePanel.enablePanel();
        }
    };

    that.onMembershipTypeChange = function () {
        var courseId = $('#coursetype' + panelSuffix + ' option:selected').val();
        var membershiptypeId = $('#membershiptype' + panelSuffix).val();
        if (courseId != '') {
            commonHelper.callAjaxMethod('settings.htm', 'loadPriceInfoByCourse', {courseId: courseId, membershipTypeId: membershiptypeId, orgid: $('#subscriptionOrganizationSelect' + panelSuffix).val() ? $('#subscriptionOrganizationSelect' + panelSuffix).val() : ''}, function (result) {
                if (result.price && result.price.value >= 0) {
                    pricePanel.updateSourcePrice(result.price.value, result.price.onelesson);
                } else {
                    pricePanel.updateSourcePrice('');
                }
            }, false);
        }
    };

    that.onSubscriptionOrganizationChange = function (callback) {
        $('#teacher' + panelSuffix).children(null).remove();
        clearScheduleSelect();
        pricePanel.updateSourcePrice('');
        loadCourses($('#subscriptionOrganizationSelect' + panelSuffix).val(), $('#coursetype' + panelSuffix + ' option:selected').val(), callback);
        that.onCourseTypeChange();
    };

    var loadCourses = function (subscriptionOrganizationId, selectedCourseId, callback) {
        var coursetypeSelect = $('#coursetype' + panelSuffix);
        var subscriptionRoomSelect = $('.subscriptionRoom');
        coursetypeSelect.children(null).remove();
        subscriptionRoomSelect.children(null).remove();
        commonHelper.callAjaxMethod('client.htm', 'loadSubscriptionReferences', {orgid: subscriptionOrganizationId ? subscriptionOrganizationId : ''}, function (result) {
            $('<option>', {
                'value': ''
            }).appendTo(coursetypeSelect);

            $.each(result.courses.rows, function (index, item) {
                var option = $('<option>', {
                    'value': item.coursetypeid
                });
                option.html(item.name);
                option.appendTo(coursetypeSelect);
            });

            pricePanel.updateReferences(result.cashes, result.paymentTypes, result.defaultPaymentTypeId, result.defaultCashId);

            $.each(result.rooms, function (index, item) {
                var option = $('<option>', {
                    'value': item.roomid
                });
                option.html(item.title);
                option.appendTo(subscriptionRoomSelect);
            });


            if (selectedCourseId) {
                coursetypeSelect.val(selectedCourseId);
            }

            if(callback){
                callback();
            }

        }, false);
    };

    that.onCourseTypeChange = function (callback) {
        var teacherSelect = $('#teacher' + panelSuffix);
        teacherSelect.children(null).remove();
        var courseId = $('#coursetype' + panelSuffix + ' option:selected').val();
        var subscriptiontime = $('#subscriptiontime' + panelSuffix);
        var subscriptiondays = $('#subscriptiondays' + panelSuffix);
        var membershiptypeId = $('#membershiptype' + panelSuffix).val();
        var organizationId = $('#subscriptionOrganizationSelect' + panelSuffix).val();
        subscriptiontime.html('');
        subscriptiondays.html('');
        canceledDays = {};
        selectedScheduleId = null;
        if (courseId != '') {
            clearScheduleSelect();
            commonHelper.callAjaxMethod('settings.htm', 'loadSchedulesInfoByCourse', {courseId: courseId, membershipTypeId: membershiptypeId, orgid: organizationId ? organizationId : ''}, function (result) {
                scheduleCache = result.schedules;
                loadTeachersSelect(true);
                if (result.price && result.price.value) {
                    pricePanel.updateSourcePrice(result.price.value, result.price.onelesson);
                } else {
                    pricePanel.updateSourcePrice('');
                }
                if(callback){
                    callback();
                }
            }, false);
        }
    };

    var clearScheduleSelect = function () {
        $('#selectedScheduleTime' + panelSuffix).html('');
        var menuScheduleTimeDiv = $('#menuScheduleTimeDiv' + panelSuffix);
        var ul = menuScheduleTimeDiv.find('ul');
        ul.children(null).remove();
    };

    var loadScheduleSelect = function (teacherId) {
        var menuScheduleTimeDiv = $('#menuScheduleTimeDiv' + panelSuffix);
        var ul = menuScheduleTimeDiv.find('ul');

        var lastSchedule = null;
        var scheduleCount = 0;
        $.each(scheduleCache, function (index, element) {
            if (element.teacherKey == teacherId) {
                loadScheduleElements(element);
                lastSchedule = element;
                scheduleCount++;
            }
        });

        ul.menu("refresh");
        ul.menu({
            selected: scheduleMenuItemSelected
        });

        return {lastSchedule: lastSchedule, scheduleCount: scheduleCount, ul: ul};
    };

    var loadTeachersSelect = function (autoLoad) {
        var teacherSelect = $('#teacher' + panelSuffix);
        teacherSelect.children().remove();
        $('<option>', {value: '', text: ''}).appendTo(teacherSelect);
        var createdTeacher = {};
        var teachersCount = 0;
        $.each(scheduleCache, function (index, element) {
            var teachers = element.teachers;
            var teachersKey = '';
            var teacherTitle = '';
            $.each(teachers, function (index, element) {
                teachersKey += element.id + ';';
                teacherTitle += element.name + ';';
            });
            if (!createdTeacher[teachersKey]) {
                createdTeacher[teachersKey] = true;
                teachersCount++;
                var teacherOption = $('<option>', {value: teachersKey});
                teacherOption.html(teacherTitle);
                teacherOption.appendTo(teacherSelect);
            }
        });
        if (autoLoad && teachersCount == 1) {
            teacherSelect.val($(teacherSelect.children(null)[1]).val());
            that.onTeacherChange();
            generateSubscriptionDays();
        }

    };

    var loadScheduleElements = function (schedule) {
        var menuScheduleTimeDiv = $('#menuScheduleTimeDiv' + panelSuffix);
        var ul = menuScheduleTimeDiv.find('ul');
        var li = $('<li>');
        li.attr('value', schedule.id);
        var timeDesc = generateScheduleDesc(schedule);

        var menuItem = $('<a>', {
            href: 'javascript:void(0)'
        });
        menuItem.data('schedule', schedule);
        menuItem.html(timeDesc);
        menuItem.appendTo(li);
        li.appendTo(ul);
    };


    var generateScheduleDesc = function (schedule) {
        var timeDesc = '';
        if (schedule.elements) {
            $.each(schedule.elements, function (index, element) {
                timeDesc += '<span>' + '<b>' + element.day.title + ' </b>' + '</span><span>' + element.startTime + ' - ' + element.finishTime + '; </span>';
            });
            timeDesc += '<span> ' + schedule.comment + ' </span>';
        } else if (schedule.simpleSchedules && !schedule.eventSchedule) {
            $.each(schedule.schedulesElementsByDayTitle, function (index, elements) {
                timeDesc += '<span><b>' + index + ' </b></span><br><span>';
                $.each(elements, function (index, element) {
                    timeDesc += element.teacher.name + ' ' + element.courseType.name + ' ' + element.startTime + ' - ' + element.finishTime + '<br>';
                });
                timeDesc += '</span>';
            });
            timeDesc += '<span>' + schedule.comment + ' </span>';

        } else {
            timeDesc += messages['subscriptiondialog.event'];
        }
        return timeDesc;
    };

    var prepareCallParams = function (subscriptionType) {
        return {
            scheduleId: selectedScheduleId ? selectedScheduleId : '',
            datestart: $('#subscriptiondatestart' + panelSuffix).val(),
            datefinish: $('#subscriptiondatefinish' + panelSuffix).val(),
            subscriptionId: subscriptionId ? subscriptionId : '',
            lessonscount: subscriptionType != 'subscription' && subscriptionType != 'reservation' ? 1 : $('#lessonscount' + panelSuffix).val(),
            canceledays: canceledDays,
            teacher: $('#teacher' + panelSuffix + ' option:selected').val(),
            course: $('#coursetype' + panelSuffix + ' option:selected').val(),
            childId: subscriptionChildId,
            action: action


        };
    };

    var generateSubscriptionDays = function () {
        var shouldLoadScheduleDays =
            selectedScheduleId && (
            (scheduleType == 'event') ||
            ($('#subscriptiondatestart' + panelSuffix).val() != '' && ($('#lessonscount' + panelSuffix).val() || $('#subscriptiondatefinish' + panelSuffix).val() != ''))
            );

        if (shouldLoadScheduleDays) {
            commonHelper.callAjaxMethod('client.htm', 'loadActualScheduleDays', {params: JSON.stringify(prepareCallParams(subscriptionType))}, function (result) {
                if (result.plannedDays) {
                    var subscriptiondays = $('#subscriptiondays' + panelSuffix);
                    subscriptiondays.children(null).remove();
                    fullLessonsCount = 0;
                    for (var i = 0; i < result.plannedDays.length; i++) {
                        var element = result.plannedDays[i];
                        var plannedDate = element.plannedDate;
                        var plannedDateDay = element.plannedDateDay;
                        var canceled = element.canceled;
                        var actualCanceled = element.actualCanceled;
                        generateSubscriptionDay(plannedDate, null, plannedDateDay, subscriptiondays, element, canceled, actualCanceled);
                        if (!canceled && !actualCanceled) {
                            fullLessonsCount++;
                        }
                    }
                    pricePanel.updateFullLessonsCount(fullLessonsCount);
                }

                if (result.onceDays) {
                    var onceDayTime = $('#onceDayTime' + panelSuffix);
                    onceDayTime.children(null).remove();

                    $('<option>', {
                        value: ''
                    }).html(messages['subscriptiondialog.newlesson']).appendTo(onceDayTime);

                    $.each(result.onceDays, function (index, onceDayElement) {
                        var title = '';
                        $.each(onceDayElement, function (index, element) {
                            title += element.plannedRoom.title + ' ';
                            title += element.plannedStartTime + ' - ' + element.plannedFinishTime + '; ';
                        });
                        $('<option>', {
                            value: index
                        }).data('data', onceDayElement).html(title).appendTo(onceDayTime);

                    });
                    $('#actualTimeDaysCount' + panelSuffix).html(result.onceDays.length);
                    that.changeOnceDayTime();

                    fullLessonsCount = 1;
                    pricePanel.updateFullLessonsCount(fullLessonsCount);
                }
            }, false);
        } else {
            if (scheduleType != 'event' && subscriptionType != 'onceLesson' && $('#lessonscount' + panelSuffix).val() == '') {
                fullLessonsCount = undefined;
                pricePanel.updateFullLessonsCount(fullLessonsCount);
            }
        }
    };

    that.changeOnceDayTime = function () {
        var option = $('#onceDayTime' + panelSuffix + ' :selected');
        if (option.val()) {
            var dayTimeElement = option.data('data');
            $.each(dayTimeElement, function (index, element) {
                var row = $('#onceDayList' + panelSuffix).find('[scheduleid=' + element.scheduleId + ']');
                row.find('.subscriptionRoom').attr('disabled', 'disabled');
                row.find('.startTime').attr('disabled', 'disabled');
                row.find('.finishTime').attr('disabled', 'disabled');

                row.find('.subscriptionRoom').val(element.plannedRoom.id);
                row.find('.startTime').val(element.plannedStartTime);
                row.find('.finishTime').val(element.plannedFinishTime);
            });
        } else {
            $('.subscriptionRoom').removeAttr('disabled');
            $('.startTime').removeAttr('disabled');
            $('.finishTime').removeAttr('disabled');

            $('.subscriptionRoom').val('');
            $('.startTime').val('');
            $('.finishTime').val('');
        }
    };

    var generateSubscriptionDay = function (plannedDate, plannedStartTime, plannedDateDay, subscriptionDaysContainer, element, canceled, actualDayCanceled) {
        var cancelDiv = $('#subscriptiondays' + panelSuffix).find('[value="' + plannedDate + '"]');
        if (cancelDiv.length == 0) {
            cancelDiv = $('#scheduleActualDayElementTemplate').clone();
            cancelDiv.removeAttr('id');
            cancelDiv.attr('value', plannedDate);

            cancelDiv.find('.plannedDate').html(plannedDate + ' ' + plannedDateDay.shortTitle);

            var actualDayDiv = cancelDiv.find('.actualDay').clone();
            var cancellink = cancelDiv.find('.cancellink');
            cancellink.click(function () {
                that.cancelDay(plannedDate);
            });

            var daysList = cancelDiv.find('.actualDaysList');
            daysList.children(null).remove();
            //maxScheduleElementsCount
            var createdElementsCount = 0;
            if (element.actualDayInfo) {
                $.each(element.actualDayInfo, function (index, dayInfo) {
                    var currentDiv = actualDayDiv.clone();
                    currentDiv.appendTo(daysList);
                    currentDiv.find('.courseName').html(dayInfo.courseName);
                    currentDiv.find('.actualDate').html(dayInfo.actualDate);
                    currentDiv.find('.scheduledChildrenCount').html(dayInfo.dayChildrenCount);
                    currentDiv.find('.reservationCount').html(dayInfo.dayReservationCount);
                    if (dayInfo.scheduleId) {
                        currentDiv.find('.dayInfo').css('visibility', 'visible');
                        currentDiv.find('.dayInfo').click(function () {
                            DIALOGS.openDayInfo(dayInfoDialog, plannedDate, plannedStartTime, dayInfo.scheduleId, true);
                        });
                    } else {
                        currentDiv.find('.dayInfo').css('visibility', 'hidden');
                    }


                    if (!dayInfo.actualDate || actualDayCanceled || canceled) {
                        currentDiv.find('.actualDateInfo').css('visibility', 'hidden');
                    }

                    if (actualDayCanceled) {
                        currentDiv.find('.countInfo').css('visibility', 'hidden');
                    }
                    createdElementsCount++;
                });
            }
            //create empty info
            for (var i = createdElementsCount; i < element.maxScheduleElementsCount; i++) {
                var currentDiv = actualDayDiv.clone();
                currentDiv.find('.dialogLabel').css('visibility', 'hidden');
                currentDiv.appendTo(daysList);
            }

            cancelDiv.addClass(actualDayCanceled ? 'actualdaycanceledelement' : canceled ? 'canceleddayelement' : 'dayelement');

            if (canceled) {
                cancelDiv.find('.cancellink').html(messages['subscriptiondialog.cancel']);
            }
            cancelDiv.show();

            cancelDiv.appendTo(subscriptionDaysContainer);
        }
    };

    that.openScheduleTimeMenu = function () {
        var buttonOffset = $('#selectScheduleTimeButton' + panelSuffix).offset();
        $('#menuScheduleTimeDiv' + panelSuffix).show();
        $('#menuScheduleTimeDiv' + panelSuffix).offset({left: buttonOffset.left, top: buttonOffset.top + 30});
        setTimeout(function () {
            $('html').one('click', function () {
                $('#menuScheduleTimeDiv' + panelSuffix).hide();
            });
        }, 10)

    };

    that.cancelDay = function (plannedDate) {
        var divElement = $('#subscriptiondays' + panelSuffix).find('[value="' + plannedDate + '"]');
        var link = divElement.find('.cancellink');
        var selectedDate = divElement.attr('value');
        if (!canceledDays[selectedDate]) {
            canceledDays[selectedDate] = true;
            divElement.removeClass('dayelement');
            divElement.addClass('canceleddayelement');
            link.html(messages['subscriptiondialog.cancel']);
            generateSubscriptionDays();
        } else {
            canceledDays[selectedDate] = false;
            divElement.removeClass('canceleddayelement');
            divElement.addClass('dayelement');
            link.html(messages['subscriptiondialog.move']);
            generateSubscriptionDays();
        }
    };

    that.onChangeDateStart = function () {
        if (subscriptionType == 'onceLesson'){
            $('#subscriptiondatefinish').val('');
        }
        generateSubscriptionDays();
    };

    that.onChangeDateFinish = function () {
        if ($('#subscriptiondatefinish' + panelSuffix).val() != '') {
            $('#lessonscount' + panelSuffix).val('');
            generateSubscriptionDays();
        } else {
            var subscriptiondays = $('#subscriptiondays' + panelSuffix);
            subscriptiondays.children(null).remove();
        }
    };

    that.onChangeLessonsCount = function () {
        var lessonscountStr = $('#lessonscount' + panelSuffix).val();
        $('#subscriptiondatefinish' + panelSuffix).val('');
        var lessonsCount = parseFloat(lessonscountStr);
        if (!isNaN(lessonsCount)) {
            generateSubscriptionDays();
            fullLessonsCount = lessonsCount;
        } else {
            var subscriptiondays = $('#subscriptiondays' + panelSuffix);
            subscriptiondays.children(null).remove();
            fullLessonsCount = 0;
        }
        pricePanel.updateFullLessonsCount(fullLessonsCount);

    };

    that.onTimeElementSelect = function (id) {
        $('#eventData' + panelSuffix).hide();

        if (selectedScheduleId) {
            $('#' + selectedScheduleId).removeClass('selectedtimeelement');
        }

        var scheduleRecord;
        $.each(scheduleCache, function (index, element) {
            if (element.id == id) {
                scheduleType = element.scheduleType;
                eventSchedule = element.eventSchedule;
                scheduleRecord = element;
            }
        });

        selectedScheduleId = id;
        canceledDays = {};
        $('#subscriptiondays' + panelSuffix).html('');
        $('#' + id).addClass('selectedtimeelement');

        generateSubscriptionDays();
        if (scheduleType != 'schedule' && (scheduleType != 'composite' || eventSchedule)) {

            var schedulesList;
            if (scheduleRecord.simpleSchedules) {
                schedulesList = scheduleRecord.simpleSchedules;
            } else {
                schedulesList = [];
                schedulesList.push(scheduleRecord);
            }

            var onceDayList = $('#onceDayList' + panelSuffix);
            onceDayList.children(null).remove();

            $.each(schedulesList, function (index, element) {

                var onceDay = $('#onceDayTemplate').clone();
                onceDay.removeAttr('id');
                onceDay.addClass('eventScheduleRecord');
                onceDay.attr('scheduleId', element.id);
                commonHelper.generateTimepickers(onceDay.find('.startTime'), onceDay.find('.finishTime'));

                onceDay.find('.course').html(element.courseType.name);


                onceDay.show();
                onceDay.appendTo(onceDayList);
            });

            $('#eventData' + panelSuffix).show();
        }

        if (scheduleType != 'schedule' && subscriptionType != 'onceLesson' && (scheduleType != 'composite' || eventSchedule)) {
            $('#dialogerrormessage' + panelSuffix).html(messages['subscriptiondialog.notonelessonerror']);
            $('#saveOrCreate' + panelSuffix).attr('disabled', 'disabled');
            $('#saveAndPrint' + panelSuffix).attr('disabled', 'disabled');
        } else {
            $('#dialogerrormessage' + panelSuffix).html('');
            $('#saveOrCreate' + panelSuffix).removeAttr('disabled');
            $('#saveAndPrint' + panelSuffix).removeAttr('disabled');
        }
    };

    that.editCompensation = function (params) {
        params.action = 'edit';
        params.subscriptionType = 'onceLesson';
        params.membershipElementId = '';
        params.selectedOnceType = 'compensation';

        that.openSubscriptionDialogForChild(params);
        $('#membershiptype' + panelSuffix).attr('disabled', 'disabled');
    };

    that.openSubscriptionDialogForCompensation = function (params) {
        var childid = params.childId;
        var familyid = params.familyId;
        var _subscriptionType = 'onceLesson';
        var childFamilyTitle = params.childFamilyTitle;
        var callbackFunction = params.callbackFunction;
        var deleteCallbackFunction = params.deleteCallbackFunction;

        subscriptionChildId = childid;
        subscriptionFamilyId = familyid;
        subscriptionType = _subscriptionType;
        subscriptionId = '';
        membershipElementId = params.membershipElementId;

        action = 'compensate';

        scheduleCache = [];
        canceledDays = {};
        returnMoneyStrategy = null;
        selectedScheduleId = null;
        multiSubscriptionId = null;

        var elementsCache = [];
        elementsCache['coursetype'] = $('#coursetype' + panelSuffix);
        elementsCache['teacher'] = $('#teacher' + panelSuffix);
        elementsCache['subscriptiondatestart'] = $('#subscriptiondatestart' + panelSuffix);
        elementsCache['subscriptiondatefinish'] = $('#subscriptiondatefinish' + panelSuffix);
        elementsCache['subscriptiontime'] = $('#subscriptiontime' + panelSuffix);
        elementsCache['subscriptiondays'] = $('#subscriptiondays' + panelSuffix);
        elementsCache['lessonscount'] = $('#lessonscount' + panelSuffix);
        elementsCache['selectScheduleTimeButton'] = $('#selectScheduleTimeButton' + panelSuffix);
        elementsCache['startTime'] = $('#startTime' + panelSuffix);
        elementsCache['finishTime'] = $('#finishTime' + panelSuffix);
        elementsCache['membershiptype'] = $('#membershiptype' + panelSuffix);
        elementsCache['subscriptionRoom'] = $('.subscriptionRoom');
        elementsCache['subscriptionOrganizationSelect'] = $('#subscriptionOrganizationSelect' + panelSuffix);

        clearUiElements(elementsCache);
        initUiElements(elementsCache, childFamilyTitle, callbackFunction, deleteCallbackFunction, action);

        elementsCache['membershiptype'].attr('disabled', 'disabled');
        elementsCache['subscriptiondatestart'].val(commonHelper.formatDate(new Date()));

        loadSubscriptionDialog(elementsCache, action, subscriptionId, 'compensation');
        prepareSubscriptionViewer();
    };

    that.openSubscriptionDialogForScheduleActualDay = function (params) {
        var _subscriptionType = params.subscriptionType;
        var _plannedDate = params.plannedDate;
        var _scheduleId = params.scheduleId;
        var _sadId = params.sadId;
        var callbackFunction = params.callbackFunction;
        var deleteCallbackFunction = params.deleteCallbackFunction;

        subscriptionType = _subscriptionType;
        subscriptionChildId = null;
        subscriptionFamilyId = null;
        subscriptionId = null;
        multiSubscriptionId = null;
        organizationId = null;
        returnMoneyStrategy = null;

        scheduleCache = [];
        canceledDays = {};
        selectedScheduleId = _scheduleId;
        action = '';

        var elementsCache = [];
        elementsCache['coursetype'] = $('#coursetype' + panelSuffix);
        elementsCache['teacher'] = $('#teacher' + panelSuffix);
        elementsCache['subscriptiondatestart'] = $('#subscriptiondatestart' + panelSuffix);
        elementsCache['subscriptiondatefinish'] = $('#subscriptiondatefinish' + panelSuffix);
        elementsCache['subscriptiontime'] = $('#subscriptiontime' + panelSuffix);
        elementsCache['subscriptiondays'] = $('#subscriptiondays' + panelSuffix);
        elementsCache['lessonscount'] = $('#lessonscount' + panelSuffix);
        elementsCache['selectScheduleTimeButton'] = $('#selectScheduleTimeButton' + panelSuffix);
        elementsCache['startTime'] = $('#startTime' + panelSuffix);
        elementsCache['finishTime'] = $('#finishTime' + panelSuffix);
        elementsCache['membershiptype'] = $('#membershiptype' + panelSuffix);
        elementsCache['subscriptionRoom'] = $('.subscriptionRoom');
        elementsCache['subscriptionOrganizationSelect'] = $('#subscriptionOrganizationSelect' + panelSuffix);
        elementsCache['multisubscription'] =$('#multisubscription' + panelSuffix);

        clearUiElements(elementsCache);
        initUiElements(elementsCache, '', callbackFunction, deleteCallbackFunction, action);
        loadScheduleDialog(elementsCache, _plannedDate, _scheduleId, _sadId);

        prepareSubscriptionViewer();
    };

    that.openSubscriptionDialogForChild = function (params) {

        var childFamilyTitle = params.childFamilyTitle;
        var callbackFunction = params.callbackFunction;
        var deleteCallbackFunction = params.deleteCallbackFunction;
        var selectedOnceType = params.selectedOnceType;

        subscriptionChildId = params.childId;
        subscriptionFamilyId = params.familyId;
        subscriptionType = params.subscriptionType;
        subscriptionId = params.subscriptionId;
        multiSubscriptionId = params.multiSubscriptionId;
        action = params.action;
        membershipElementId = params.membershipElementId ? params.membershipElementId : '';
        returnMoneyStrategy = params.returnMoneyStrategy;

        scheduleCache = [];
        canceledDays = {};
        selectedScheduleId = null;

        var elementsCache = [];
        elementsCache['coursetype'] = $('#coursetype' + panelSuffix);
        elementsCache['teacher'] = $('#teacher' + panelSuffix);
        elementsCache['subscriptiondatestart'] = $('#subscriptiondatestart' + panelSuffix);
        elementsCache['subscriptiondatefinish'] = $('#subscriptiondatefinish' + panelSuffix);
        elementsCache['subscriptiontime'] = $('#subscriptiontime' + panelSuffix);
        elementsCache['subscriptiondays'] = $('#subscriptiondays' + panelSuffix);
        elementsCache['lessonscount'] = $('#lessonscount' + panelSuffix);
        elementsCache['selectScheduleTimeButton'] = $('#selectScheduleTimeButton' + panelSuffix);
        elementsCache['startTime'] = $('#startTime' + panelSuffix);
        elementsCache['finishTime'] = $('#finishTime' + panelSuffix);
        elementsCache['membershiptype'] = $('#membershiptype' + panelSuffix);
        elementsCache['subscriptionRoom'] = $('.subscriptionRoom');
        elementsCache['subscriptionOrganizationSelect'] = $('#subscriptionOrganizationSelect' + panelSuffix);

        clearUiElements(elementsCache);
        initUiElements(elementsCache, childFamilyTitle, callbackFunction, deleteCallbackFunction, action);

        loadSubscriptionDialog(elementsCache, action, subscriptionId, selectedOnceType);
        prepareSubscriptionViewer();

        if(params.defaultValues){
            initWithDefaultValues(params.defaultValues);
        }
    };

    var prepareSubscriptionViewer = function () {
        //TODO fix
        commonHelper.prepareViewer([
            {filter: '#subscriptiondatestart', action: 'disabledatepicker'},
            {filter: '#subscriptiondatefinish', action: 'disabledatepicker'},
            {filter: '#lessonscount', action: 'disable'},
            {filter: '#discount', action: 'disable'},
            {filter: '#realPrice', action: 'disable'},
            {filter: '#fullPrice', action: 'disable'},
            {filter: '#paid', action: 'disable'},
            {filter: '.cancellink', action: 'hide'},
            {filter: '#deleteSubscription', action: 'delete'},
            {filter: '#saveOrCreate', action: 'delete'},
            {filter: '#saveAndPrint', action: 'delete'},
            {filter: '#newPaidSum', action: 'disable'},
            {filter: '#subscriptionCash', action: 'disable'},
            {filter: '#subscriptionPaymentType', action: 'disable'},
            {filter: '#membershiptype', action: 'disable'},
            {filter: '#useDeposit', action: 'disable'}

        ]);
    };

    var clearUiElements = function (elementsCache) {
        var coursetypeSelect = elementsCache['coursetype'];
        var roomSelect = elementsCache['subscriptionRoom'];
        var membershiptypeSelect = elementsCache['membershiptype'];
        var teacherSelect = elementsCache['teacher'];
        var subscriptiondatestart = elementsCache['subscriptiondatestart'];
        var subscriptiondatefinish = elementsCache['subscriptiondatefinish'];
        var subscriptiontime = elementsCache['subscriptiontime'];
        var subscriptiondays = elementsCache['subscriptiondays'];
        var lessonscount = elementsCache['lessonscount'];
        var selectscheduletime = elementsCache['selectScheduleTimeButton'];
        var startTime = elementsCache['startTime'];
        var finishTime = elementsCache['finishTime'];
        var organizationSelect = elementsCache['subscriptionOrganizationSelect'];
        var multisubscriptionSelect = elementsCache['multisubscription'];

        subscriptiontime.html('');
        coursetypeSelect.children(null).remove();
        roomSelect.children(null).remove();
        membershiptypeSelect.children(null).remove();
        teacherSelect.children(null).remove();

        subscriptiondatestart.val('');
        subscriptiondatefinish.val('');
        subscriptiondays.html('');
        lessonscount.val('');
        startTime.val('');
        finishTime.val('');
        organizationSelect.val('');

        coursetypeSelect.removeAttr('disabled');
        membershiptypeSelect.removeAttr('disabled');
        teacherSelect.removeAttr('disabled');
        selectscheduletime.removeAttr('disabled');
        selectscheduletime.css('color', '');
        lessonscount.removeAttr('disabled');
        subscriptiondatefinish.removeAttr('disabled');
        organizationSelect.removeAttr('disabled');

        clearScheduleSelect();

        $('#customNumber' + panelSuffix).val('');
        $('#dialogerrormessage' + panelSuffix).html('');
        $('#selectedScheduleTime' + panelSuffix).html('');
        $('#subscriptionAdditionalInfo' + panelSuffix).html('');
        $('#eventData' + panelSuffix).hide();

        pricePanel.initAndClearPanel();


        $('#onceDayTime' + panelSuffix).children(null).remove();
        if (multisubscriptionSelect){
            multisubscriptionSelect.val('');
            multisubscriptionSelect.children(null).remove();
        }

        $('<option>', {
            value: ''
        }).appendTo(coursetypeSelect);

        $('<option>', {
            value: ''
        }).appendTo(roomSelect);

    };

    var initUiElements = function (elementsCache, childFamilyTitle, callbackFunction, deleteCallbackFunction, action) {
        ACTUAL_DAY_INFO_INSTANCE = ACTUAL_DAY_INFO(function () {
            return dayInfoDialog;
        }, function () {

        }, function () {

        }, function (data) {
            var actualDateDiv = $('#subscriptiondays' + panelSuffix).find('[value="' + data.actualDay.plannedDate + '"]').find('.actualDate');
            actualDateDiv.show();
            actualDateDiv.find('.actualDateTitle').html(data.actualDay.actualDate);

        }, function (data) {
            var actualDateDiv = $('#subscriptiondays' + panelSuffix).find('[value="' + data.actualDay.plannedDate + '"]').find('.actualDate');
            actualDateDiv.find('.actualDateTitle').html('');
            actualDateDiv.hide();
        });

        var childautocompleteparams = {
            selectCallback: function (objectId, selectedText, type, data) {
                if (objectId && objectId != '') {
                    if (type == 'family') {

                    } else {
                        subscriptionChildId = objectId;
                        if (data) {
                            pricePanel.updateFamilyDeposit(data.deposit);
                            pricePanel.updateDiscount(data.discount);

                            var multiSubscriptions = data.multisubscriptions;
                            var multisubscriptionSelect = $('#multisubscription' + panelSuffix);
                            multisubscriptionSelect.children().remove();
                            if (multiSubscriptions && multiSubscriptions.length > 0) {
                                var multisubscriptionList = [];
                                $('<option>', {
                                    value: ''
                                }).appendTo(multisubscriptionSelect);
                                multisubscriptionList.push({name: '', id: ''});
                                multisubscriptionList = multisubscriptionList.concat(multiSubscriptions);
                                multisubscriptionSelect.directives({
                                    'option': {
                                        'multisubscription <- rows': {
                                            '.': 'multisubscription.description.name',
                                            '@value': 'multisubscription.id'
                                        }
                                    }
                                }).render({rows: multisubscriptionList});
                            }

                        }
                    }
                } else {
                    subscriptionChildId = null;
                }
            },
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.value;
            },
            generateLabel: function (item) {
                return item.title;
            },
            generateType: function (item) {
                return item.objtype;
            },
            url: 'family.htm',
            method: 'autoCompleteSearchFamilyOrChild',
            defaultValue: messages['common.familyfilternotset'],
            inputDataTitle: messages['common.familyfiltertitle'],
            objectNotFound: messages['common.familyfilternotfound'],
            objectFound: messages['common.familyfilterfound']
        };

        AUTOCOMPLETE_SEARCH_FIELD.prepare('subscriptiondialogchild', childautocompleteparams);
        if (subscriptionChildId) {
            AUTOCOMPLETE_SEARCH_FIELD.disable('subscriptiondialogchild');
            AUTOCOMPLETE_SEARCH_FIELD.setValue('subscriptiondialogchild', subscriptionChildId, childFamilyTitle);
        } else {
            AUTOCOMPLETE_SEARCH_FIELD.enable('subscriptiondialogchild');
            AUTOCOMPLETE_SEARCH_FIELD.clear('subscriptiondialogchild');
        }

        var buttons = [];
        buttons[buttons.length] = {
            id: 'deleteSubscription',
            text: messages['common.remove'],
            position: 'left',
            click: function () {
                DIALOGS.askYesNoDialog(messages['subscriptiondialog.confirmation'], messages['common.remove'], function () {
                    if (subscriptionId) {
                        commonHelper.callAjaxMethod('client.htm', 'cancelSubscription', {subscriptionId: subscriptionId}, function (result) {
                            if (deleteCallbackFunction) {
                                deleteCallbackFunction();
                            }
                        });
                    }
                    closeOverlay('editSubscriptionDialog');
                });
            }
        };

        buttons[buttons.length] = {
            text: messages['common.close'],
            click: function () {
                closeOverlay('editSubscriptionDialog');
            }
        };

        if (subscriptionType == 'reservation' || subscriptionType == 'subscription' || subscriptionType == 'onceLesson') {
            buttons[buttons.length] = {
                id: 'saveAndPrint',
                text: messages['subscriptiondialog.saveprint'],
                click: function () {
                    saveSubscription(subscriptionId, subscriptionChildId, subscriptionFamilyId, true, false, null, "1", subscriptionType, callbackFunction, action);
                }
            };
        }
        commonHelper.checkFeature('BARCODE', function(){
            if(subscriptionType !== 'reservation'){
                buttons[buttons.length] = {
                    id: 'saveAndReceipt',
                    text: messages['subscriptiondialog.savereceipt'],
                    click: function () {
                        saveSubscription(subscriptionId, subscriptionChildId, subscriptionFamilyId, false, true, "0", "1", subscriptionType, callbackFunction, action);
                    }
                };
            }
        });
        commonHelper.checkFeature('RECEIPT', function(){
            if(subscriptionType !== 'reservation'){
                buttons[buttons.length] = {
                    id: 'saveCashReceipt',
                    text: messages['subscriptiondialog.savecashreceipt'],
                    click: function () {
                        saveSubscription(subscriptionId, subscriptionChildId, subscriptionFamilyId, false, true, "0", "1", subscriptionType, callbackFunction, action);
                    }
                };
            }
        });
        commonHelper.checkFeature('RECEIPT', function(){
            if(subscriptionType !== 'reservation'){
                buttons[buttons.length] = {
                    id: 'saveEleReceipt',
                    text: messages['subscriptiondialog.savereceipt.electronically'],
                    click: function () {
                        saveSubscription(subscriptionId, subscriptionChildId, subscriptionFamilyId, false, true, "1", "1", subscriptionType, callbackFunction, action);
                    }
                };
            }
        });
        buttons[buttons.length] = {
            id: 'saveOrCreate',
            //text: (subscriptionType == 'reservation' || subscriptionType == 'subscription' || subscriptionType == 'onceLesson') && subscriptionChildId != null ? messages['common.save'] : messages['subscriptiondialog.create'],
            text: messages['common.save'],
            click: function () {
                saveSubscription((subscriptionType == 'reservation' || subscriptionType == 'subscription' || subscriptionType == 'onceLesson') && subscriptionId != null ? subscriptionId : null, subscriptionChildId, subscriptionFamilyId, false, false, null, 1, subscriptionType, callbackFunction, action);
            }
        };
        
        

        var buttonsDivLeft = $('#subscriptionDialogButtonsLeft' + panelSuffix);
        var buttonsDivRight = $('#subscriptionDialogButtonsRight' + panelSuffix);
        buttonsDivLeft.children(null).remove();
        buttonsDivRight.children(null).remove();
        $.each(buttons, function (index, item) {
            var buttonDiv = $('<div>', {
                style: 'padding-left: 10px; float: left;'
            });
            var button = $('<button>', {
            }).html(item.text).button();
            button.attr('id', item.id);
            button.appendTo(buttonDiv);
            button.click(item.click);
            if (!item.position || item.position == 'right') {
                buttonDiv.prependTo(buttonsDivRight);
            } else {
                buttonDiv.prependTo(buttonsDivLeft);
            }
        });

        if(!that.panelMode){
            $('#editSubscriptionDialog').overlay({
                oneInstance: false,
                mask: {
                    color: '#fff',
                    loadSpeed: 0,
                    opacity: 0.5,
                    zIndex: 100
                },
                fixed: false,
                closeOnClick: false
            });
        }
        pricePanel.initAndClearPanel();

        $('#subscriptionOrganizationSelect' + panelSuffix).val(CURRENT_ORG);

        if (ORGS_COUNT > 0) {
            $('.organizationSelect').show();
        } else {
            $('.organizationSelect').hide();
        }

        commonHelper.setDatePicker(elementsCache['subscriptiondatestart']);
        commonHelper.setDatePicker(elementsCache['subscriptiondatefinish']);
    };

    var fillUiElements = function (elementsCache, courseInfo, roomsInfo, membershipTypeInfo, multiSubscriptions, selectedOnceType) {
        var roomSelect = elementsCache['subscriptionRoom'];
        var membershiptypeSelect = elementsCache['membershiptype'];
        var lessonscount = elementsCache['lessonscount'];
        var subscriptiondatefinish = elementsCache['subscriptiondatefinish'];
        var multisubscriptionSelect = $('#multisubscription' + panelSuffix);

        var rooms = {rows: [
            {
                name: '',
                roomid: ''
            }
        ]};

        rooms.rows = rooms.rows.concat(roomsInfo.rows);
        roomSelect.directives({
            'option': {
                'room <- rows': {
                    '.': 'room.title',
                    '@value': 'room.roomid'
                }
            }
        }).render(rooms);
        elementsCache['subscriptionRoom'] = $('.subscriptionRoom');

        $('<option>', {
            value: ''
        }).appendTo(membershiptypeSelect);
        var membershipTypes = {rows: []};

        if (subscriptionType == 'onceLesson') {
            lessonscount.attr('disabled', 'disabled');
            subscriptiondatefinish.attr('disabled', 'disabled');
        }

        if (subscriptionType != 'reservation') {
            $('.subscriptionElementsOnly').show();
            $('.multiSubscriptionElementsOnly').show();
            var selectedOnceTypeId = null;

            if (subscriptionType == 'subscription') {
                membershipTypes.rows.push({});
            }

            $.each(membershipTypeInfo.rows, function (index, item) {
                if (selectedOnceType) {
                    if (item.code == selectedOnceType) {
                        selectedOnceTypeId = item.membershiptypeid;
                    }
                }

                if (item.code == 'multisubscription') {
                    multisubscriptionMembershipTypeId = item.membershiptypeid;
                }

                if ((subscriptionType == 'onceLesson' && item.subscription === false) || (subscriptionType != 'onceLesson' && item.subscription === true)) {
                    membershipTypes.rows.push(item);
                }
            });
            if (selectedOnceType) {
                if (selectedOnceType == 'compensation') {
                    $('#membershiptype' + panelSuffix).attr('disabled', 'disabled');
                }
            }

            var multisubscriptionList = [];
            multisubscriptionSelect.children().remove();
            $('<option>', {
                value: ''
            }).appendTo(multisubscriptionSelect);
            if (multiSubscriptions && multiSubscriptions.length > 0) {
                multisubscriptionList.push({name: '', id: ''});
                multisubscriptionList = multisubscriptionList.concat(multiSubscriptions);
                multisubscriptionSelect.directives({
                    'option': {
                        'multisubscription <- rows': {
                            '.': 'multisubscription.description.name',
                            '@value': 'multisubscription.id'
                        }
                    }
                }).render({rows: multisubscriptionList});
            }

            membershiptypeSelect.directives({
                'option': {
                    'membershiptype <- rows': {
                        '.': 'membershiptype.name',
                        '@value': 'membershiptype.membershiptypeid'
                    }
                }
            }).render(membershipTypes);

            $('#membershiptype' + panelSuffix).val(selectedOnceTypeId);
        } else {
            $('.subscriptionElementsOnly').hide();
            $('.multiSubscriptionElementsOnly').hide();
        }

        elementsCache['membershiptype'] = $('#membershiptype' + panelSuffix);

    };

    var fillScheduleElements = function (elementsCache,
                                         scheduleCacheParam,
                                         courseTypeId,
                                         teacherId,
                                         memberElementsCount,
                                         finishDate,
                                         scheduleId,
                                         subscriptionDate,
                                         subscriptionOrganizationId,
                                         useDefaultOrganization) {
        var teacherSelect = elementsCache['teacher'];
        var lessonscount = elementsCache['lessonscount'];
        var subscriptiondatestart = elementsCache['subscriptiondatestart'];
        var subscriptiondatefinish = elementsCache['subscriptiondatefinish'];
        var organizationSelect = elementsCache['subscriptionOrganizationSelect'];

        organizationSelect.val(null);

        if (subscriptionDate) {
            subscriptiondatestart.val(subscriptionDate);
        }

        if (subscriptionOrganizationId || !useDefaultOrganization) {
            organizationSelect.val(subscriptionOrganizationId);
            loadCourses(subscriptionOrganizationId, courseTypeId);
        } else {
            loadCourses(subscriptionOrganizationId, courseTypeId);
        }

        scheduleCache = scheduleCacheParam;
        that.onCourseTypeChange();
        //loadTeachersSelect(false);
        teacherSelect.val(teacherId);
        lessonscount.val(memberElementsCount);



        if (finishDate){
            subscriptiondatefinish.val(finishDate);
        }


        clearScheduleSelect();
        loadScheduleSelect(teacherId);
        if (scheduleId) {
            that.onTimeElementSelect(scheduleId);
        }

    };

    var loadScheduleDialog = function (elementsCache, _plannedDate, _scheduleId, _sadId) {
        var memberElementsCount = null;
        if (subscriptionType == 'onceLesson') {
            memberElementsCount = 1;
        }

        commonHelper.callAjaxMethod('visits.htm', 'loadSubscriptionInfoForSchedule', {plannedDate: _plannedDate, scheduleId: _scheduleId, memberElementsCount: memberElementsCount ? memberElementsCount : ''}, function (result) {
            fillUiElements(elementsCache, result.courseInfo, result.rooms, result.membershiptypeInfo, result.multisubscriptions, null);

            var subscriptiondatestart = elementsCache['subscriptiondatestart'];
            var subscriptiondatefinish = elementsCache['subscriptiondatefinish'];
            var subscriptiontime = elementsCache['subscriptiontime'];
            var subscriptiondays = elementsCache['subscriptiondays'];
            var lessonscount = elementsCache['lessonscount'];

            scheduleCache = result.schedules;
            var schedule = result.schedule;

            if (!schedule.active){
                commonHelper.showMessage(messages['subscriptiondialog.notactiveerror']);
                return;
            }

            var courseTypeId = result.selectedCourse;
            var teacherId = result.selectedTeacher + ';';
            var organizationId = result.schedule.organization ? result.schedule.organization.id : null;

            if (subscriptionType == 'subscription') {
                $('#subscriptionedittitle' + panelSuffix).html(messages['subscriptiondialog.editsubscription']);
            } else if (subscriptionType == 'reservation') {
                $('#subscriptionedittitle' + panelSuffix).html(messages['subscriptiondialog.editreservation']);
            } else if (subscriptionType == 'onceLesson') {
                $('#subscriptionedittitle' + panelSuffix).html(messages['subscriptiondialog.editoncelesson']);
            }

            if (subscriptionType == 'reservation') {
                pricePanel.hide();
            } else {
                pricePanel.show();
            }

            pricePanel.updateNewPaidSumAutoFilling(true);

            fillScheduleElements(elementsCache, scheduleCache, courseTypeId, teacherId, memberElementsCount, null, _scheduleId, _plannedDate, organizationId, true);
            that.onMembershipTypeChange();

            if (_sadId) {
                $('#onceDayTime' + panelSuffix).val(_sadId);
                that.changeOnceDayTime();
            }

            if (schedule) {
                setScheduleTimeTitle(schedule);
            }

            if(!panelMode){
                $('#editSubscriptionDialog').overlay().load();
                $('#editSubscriptionDialog').css('z-index', (commonHelper.getMaxZIndex() + 1));
            }
        }, true);
    };

    var loadSubscriptionUiData = function (data, elementsCache, selectedOnceType) {
        if (data) {
            if (subscriptionType == 'subscription') {
                $('#subscriptionedittitle' + panelSuffix).html(messages['subscriptiondialog.editsubscription']);
            } else if (subscriptionType == 'reservation') {
                $('#subscriptionedittitle' + panelSuffix).html(messages['subscriptiondialog.editreservation']);
            } else if (subscriptionType == 'onceLesson') {
                $('#subscriptionedittitle' + panelSuffix).html(messages['subscriptiondialog.editoncelesson']);
            }

            fillUiElements(
                elementsCache,
                data.courseInfo,
                data.rooms,
                data.membershiptypeInfo,
                data.multisubscriptions,
                selectedOnceType ? selectedOnceType : data.subscription && data.subscription.membershipType ? data.subscription.membershipType.code : null
            );

            //load member params
            {
                var courseTypeId;
                var teacherId;
                var multisubscriptionId;
                var schedule;
                var membershipTypeId;
                var subscriptionDate;
                var membershipElements;
                var scheduleActualDaysKey;
                var useDefaultOrganization;
                var paidSum;
                var fullPrice;
                var prevExtraDiscount = 0;
                var extraDiscount = data.extraDiscount;
                var price = data.price ? data.price.value : null;
                var finishDate = null;

                var disableLessonCount = subscriptionType == 'onceLesson';
                var disableMembershipFields = false;
                var disablePricePanel = false;
                var disableCourse = false;
                var disableTeacher = false;
                var disableMembershipType = false;
                var disableMultiSubscription = subscriptionType != 'onceLesson';

                fullLessonsCount = subscriptionType == 'onceLesson' ? 1 : subscriptionType == 'reservation' ? 1 : 0;

                if (data.subscription) {
                    scheduleCache = data.schedules;
                    useDefaultOrganization = false;
                    courseTypeId = data.subscription.schedule.courseType.id;
                    teacherId = data.subscription.schedule.teacherKey;
                    prolongReservationId = data.prolongReservationId;
                    schedule = data.subscription.schedule;
                    membershipTypeId = data.subscription.membershipTypeId;
                    selectedScheduleId = schedule.id;
                    prevExtraDiscount = data.subscription.extraDiscount;
                    multisubscriptionId = data.subscription.multisubscriptionId;
                    paidSum = data.subscription.paidSum;
                    fullPrice = data.subscription.fullPrice;
                    organizationId = data.subscription.organizationId;
                    if (subscriptionType == 'subscription' || subscriptionType == 'reservation') {
                        fullLessonsCount = data.subscription.membershipElementsCount;
                    }

                    finishDate = data.subscription.finishDate;

                    $('#customNumber' + panelSuffix).val(commonHelper.decodeHtmlString(data.subscription.customNumber));
                    disableMembershipFields = true;
                    if (data.subscription.compensatedInfo) {
                        $('#subscriptionAdditionalInfo' + panelSuffix).html(messages['subscriptiondialog.compensation']+ ' ' + data.subscription.compensatedInfo);
                    }

                    if (!data.subscriptionInfo) {
                        //продливаем разовое занятие
                        subscriptionDate = data.nextdate;
                        finishDate = data.nextdate;
                    } else {
                        //продливаем или редактируем абонемент
                        if (data.subscriptionInfo.type == 'event' || data.subscriptionInfo.type == 'eventComposite') {
                            fullLessonsCount = 1;
                            eventSchedule = true;
                            disableLessonCount = true;
                            subscriptionDate = data.subscriptionInfo.finishDate;
                            scheduleActualDaysKey = data.subscriptionInfo.scheduleActualDaysKey;
                        } else {
                            subscriptionDate = data.subscription.firstPlannedDate;
                            membershipElements = data.subscriptionInfo.elements;
                        }

                    }
                    if (data.subscription.membershipTypeCode == 'multisubscription') {
                        disablePricePanel = true;
                        disableCourse = data.subscription.multiCourseId ? true : false;
                        disableTeacher = data.subscription.multiTeacherId ? true : false;
                        disableMembershipType = true;
                        disableMultiSubscription = multisubscriptionId ? true : false;
                        disableMembershipFields = false;
                    } else if (data.subscription.membershipTypeCode == 'compensation') {
                        disableMultiSubscription = true;
                        disableMembershipType = true;
                    }
                } else if (data.multiSubscription) {
                    if (data.onceSubscriptionByMultisubscription){
                        courseTypeId = data.onceSubscriptionByMultisubscription.schedule.courseType.id;
                        teacherId = data.onceSubscriptionByMultisubscription.schedule.teacherKey;
                    } else {
                        courseTypeId = data.multiSubscription.description.courseType ? data.multiSubscription.description.courseType.id : null;
                        teacherId = data.teacherKey;
                    }
                    fullLessonsCount = 1;
                    disableLessonCount = true;
                    price = 0;
                    fullPrice = 0;
                    paidSum = 0;
                    disablePricePanel = true;
                    disableCourse = courseTypeId ? true : false;
                    disableTeacher = teacherId ? true : false;
                    disableMembershipType = true;
                    multisubscriptionId = data.multiSubscription.id;
                    organizationId = data.multiSubscription.organizationId;

                } else if (selectedOnceType == 'compensation') {
                    organizationId = CURRENT_ORG;
                    disableMembershipType = true;
                    disableMultiSubscription = true;
                } else {
                    organizationId = CURRENT_ORG;
                    subscriptionDate = data.nextdate;
                    finishDate = data.nextdate;
                    subscriptionId = data.subscriptionId;
                    selectedScheduleId = null;
                    schedule = null;
                    price = 0;
                    fullPrice = 0;
                    paidSum = 0;
                }

                {
                    fillScheduleElements(
                        elementsCache,
                        scheduleCache,
                        courseTypeId,
                        teacherId,
                        fullLessonsCount,
                        finishDate,
                        schedule ? schedule.id : null,
                        subscriptionDate,
                        organizationId,
                        useDefaultOrganization
                    );


                    if (membershipTypeId) {
                        elementsCache['membershiptype'].val(membershipTypeId);
                    }
                    that.onMembershipTypeChange();

                    if (multisubscriptionId) {
                        $('#multisubscription' + panelSuffix).val(multisubscriptionId);
                    }

                    if (disableMultiSubscription) {
                        $('#multisubscription' + panelSuffix).attr('disabled', 'disabled');
                    } else {
                        $('#multisubscription' + panelSuffix).removeAttr('disabled');
                    }

                    if (disableMembershipType) {
                        elementsCache['membershiptype'].attr('disabled', 'disabled');
                    } else {
                        elementsCache['membershiptype'].removeAttr('disabled');
                    }

                    if (disableLessonCount) {
                        elementsCache['lessonscount'].attr('disabled', 'disabled');
                    } else {
                        elementsCache['lessonscount'].removeAttr('disabled');
                    }

                    if (disableCourse) {
                        $('#coursetype' + panelSuffix).attr('disabled', 'disabled');
                    } else {
                        $('#coursetype' + panelSuffix).removeAttr('disabled');
                    }

                    if (disableTeacher) {
                        $('#teacher' + panelSuffix).attr('disabled', 'disabled');
                    } else {
                        $('#teacher' + panelSuffix).removeAttr('disabled');
                    }


                    if (disableMembershipFields) {
                        elementsCache['subscriptionOrganizationSelect'].attr('disabled', 'disabled');
                        elementsCache['coursetype'].attr('disabled', 'disabled');
                        elementsCache['teacher'].attr('disabled', 'disabled');
                        elementsCache['selectScheduleTimeButton'].attr('disabled', 'disabled');
                        elementsCache['selectScheduleTimeButton'].css('color', 'lightgray');
                    }
                    $('#onceDayTime' + panelSuffix).val(scheduleActualDaysKey);
                    that.changeOnceDayTime();

                    if (membershipElements) {
                        loadMembershipElements(elementsCache['subscriptiondays'], membershipElements, fullLessonsCount);
                    }

                    if (schedule) {
                        setScheduleTimeTitle(schedule);
                    }
                }

            }

            //load prices
            {
                if (subscriptionType == 'reservation') {
                    pricePanel.hide();
                } else {
                    pricePanel.show();
                }
                pricePanel.updateFamilyDeposit(data.familyDeposit);
                pricePanel.updateDiscount(data.familyDiscount);
                pricePanel.updateNewPaidSumAutoFilling(!subscriptionId || action == 'prolong');
                pricePanel.updateFullLessonsCount(fullLessonsCount);

                pricePanel.updatePriceInfo(paidSum, price, extraDiscount, data.extraDiscountComment, data.payments);
                if (fullPrice) {
                    pricePanel.updateFullPrice(parseFloat(fullPrice) + (action == 'prolong' ? prevExtraDiscount : 0));
                } else {
                    pricePanel.updateFullPrice(0);
                }

                if (disablePricePanel) {
                    pricePanel.disablePanel();
                } else {
                    pricePanel.enablePanel();
                }
            }
            if(!panelMode) {
                $('#editSubscriptionDialog').overlay().load();
                $('#editSubscriptionDialog').css('z-index', (commonHelper.getMaxZIndex() + 1));
            }
        }
    };

    var loadSubscriptionDialog = function (elementsCache, action, _subscriptionId, selectedOnceType) {
        var data;
        switch (action) {
            case 'edit':
            case 'compensate':
                commonHelper.callAjaxMethod(
                    'client.htm', 'loadSubscriptionInfo',
                    {
                        action: action,
                        prolongsubscriptionId: _subscriptionId,
                        multiSubscriptionId: multiSubscriptionId,
                        subscriptionFamilyId: subscriptionFamilyId,
                        subscriptionType: subscriptionType,
                        returnMoneyStrategy: returnMoneyStrategy,
                        membershipElementId: membershipElementId,
                        childId: subscriptionChildId
                    }, function (result) {
                        data = result;
                        loadSubscriptionUiData(data, elementsCache, selectedOnceType);
                    }
                    , false);
                break;
            case 'prolongByMultiSubscription':
                commonHelper.callAjaxMethod(
                    'client.htm', 'loadSubscriptionInfoByMultiSubscription',
                    {
                        action: action,
                        multiSubscriptionId: multiSubscriptionId,
                        subscriptionId: _subscriptionId,
                        subscriptionFamilyId: subscriptionFamilyId,
                        subscriptionType: subscriptionType,
                        returnMoneyStrategy: returnMoneyStrategy,
                        membershipElementId: membershipElementId,
                        childId: subscriptionChildId
                    }, function (result) {
                        data = result;
                        loadSubscriptionUiData(data, elementsCache, selectedOnceType);
                    }
                    , false);
                break;
            case 'prolong':
            case 'change':
                commonHelper.callAjaxMethod(
                    'client.htm', 'prolongSubscriptionInfo',
                    {
                        action: action,
                        prolongsubscriptionId: _subscriptionId,
                        subscriptionFamilyId: subscriptionFamilyId,
                        subscriptionType: subscriptionType,
                        returnMoneyStrategy: returnMoneyStrategy,
                        membershipElementId: membershipElementId,
                        childId: subscriptionChildId
                    }, function (result) {
                        data = result;
                        loadSubscriptionUiData(data, elementsCache, selectedOnceType);
                    }
                    , false);
                break;
        }
    };

    var loadMembershipElements = function (subscriptionDaysContainer, elements, memberElementsCount) {
        var notCanceledFound = false;
        $.each(elements, function (index, item) {
            if (memberElementsCount > 1 || !notCanceledFound) {
                var id = item.id;
                var plannedDate = item.plannedDate;
                var plannedDateDay = item.plannedDateDay;
                var canceled = item.canceled;
                var actualDayCanceled = item.actualDayCanceled;
                if (canceled) {
                    canceledDays['' + plannedDate] = true;
                } else {
                    notCanceledFound = true;
                }
                generateSubscriptionDay(plannedDate, null, plannedDateDay, subscriptionDaysContainer, canceled, actualDayCanceled);
            }
        })
    };

    var closeOverlay = function (overlayName) {
        if(!panelMode){
            $('#' + overlayName).overlay().close();
        }
    };

    that.getSubscriptionInfo = function() {
        return {
            id: subscriptionId,
            panelSuffix: panelSuffix,
            type: subscriptionType,
            courseName: $('#coursetype' + panelSuffix + ' option:selected').text(),
            teacherName: $('#teacher' + panelSuffix + ' option:selected').text(),
            fullPrice: pricePanel.getFullPrice(),
            paidSum: pricePanel.getPaid(),
            schedule: currentSchedule?currentSchedule.scheduleDaysShortInfo:''
        }
    }

    that.saveSubscriptionPanel = function(callbackFunction, justPrepareParameters) {
        saveSubscription(subscriptionId, subscriptionChildId, subscriptionFamilyId, false, false, null, 1, subscriptionType, callbackFunction, action, justPrepareParameters);
    }

    var saveSubscription = function (subscriptionId, childid, familyid, print, receipt, receiptTypeClose, quantity, subscriptionType, callbackFunction, action, justPrepareParameters) {
        var callParams = prepareCallParams(subscriptionType);
        if (validate(callParams)) {
            var membershiptypeSelect = $('#membershiptype' + panelSuffix);

            callParams.childid = childid;
            callParams.familyid = familyid;
            callParams.print = print && !CLIENT_PRINTING;
            callParams.receipt = receipt;
            callParams.receiptTypeClose = receiptTypeClose;
            callParams.quantity = quantity;
            callParams.subscriptionType = subscriptionType;
            callParams.subscriptionId = subscriptionId ? subscriptionId : '';
            callParams.membershipType = membershiptypeSelect.val();
            callParams.prolongReservationId = prolongReservationId ? prolongReservationId : '';
            callParams.membershipElementId = membershipElementId ? membershipElementId : '';
            callParams.multiSubscriptionId = multiSubscriptionId ? multiSubscriptionId : '';
            callParams.action = action;
            callParams.eventRecords = [];
            var eventRecords = $('.eventScheduleRecord');
            if (eventRecords.length > 0) {
                $.each(eventRecords, function (index, element) {
                    var eventRecord = $(element);
                    var scheduleId = eventRecord.attr('scheduleId');
                    var room = eventRecord.find('.subscriptionRoom option:selected').val();
                    var startTime = eventRecord.find('.startTime').val();
                    var finishTime = eventRecord.find('.finishTime').val();
                    var record = {
                        'scheduleId': scheduleId,
                        'room': room,
                        'startTime': startTime,
                        'finishTime': finishTime
                    }
                    if(autoVisited){
                        record['visited'] = true;
                    }
                    callParams.eventRecords.push(record);
                });
            }

            callParams.organizationId = $('#subscriptionOrganizationSelect' + panelSuffix).val() ? $('#subscriptionOrganizationSelect' + panelSuffix).val() : organizationId ? organizationId : '';
            callParams.returnMoneyStrategy = returnMoneyStrategy ? returnMoneyStrategy : '';
            callParams.customNumber = $('#customNumber' + panelSuffix).val();
            callParams.subscriptionCash = pricePanel.getCash();
            callParams.subscriptionPaymentType = pricePanel.getPaymentType();
            callParams.paymentDate = pricePanel.getPaymentDate();
            callParams.extraDiscount = pricePanel.getNewExtraDiscount();
            callParams.extraDiscountComment = pricePanel.getNewExtraDiscountComment();
            callParams.useDeposit = pricePanel.getUseDeposit();
            callParams.paid = pricePanel.getPaid();
            callParams.fullPrice = pricePanel.getFullPrice();
            callParams.newPaidSum = pricePanel.getNewPaidSum();
            if(duration != null){
                callParams.duration = duration;
            }
            if(barcode != null){
                callParams.barcode = barcode;
            }

            if(justPrepareParameters){
                callbackFunction(callParams);
            }
            else {
                DIALOGS.conditionalAskYesNoDialog(
                    pricePanel.getPaidSum() && parseFloat(pricePanel.getPaidSum()) > parseFloat(callParams.fullPrice ? callParams.fullPrice : 0),
                    messages['subscriptiondialog.paiderror'], messages['subscriptiondialog.paidmove'], function () {
                        commonHelper.callAjaxMethod('client.htm', 'saveSubscription', {params: JSON.stringify(callParams)}, function (result) {

                            if (callbackFunction) {
                                callbackFunction(result);
                            }
                            closeOverlay('editSubscriptionDialog');
                            if (print) {
                                if(CLIENT_PRINTING){
                                    commonHelper.openPdfPrintDialog('client.htm?method=printSubscriptionFromClient&subscriptionId=' + result.id);
                                }
                                else {
                                    commonHelper.showMessage(messages['subscriptiondialog.printinfo']);
                                }
                            }

                        });
                    });
            }
        }
    };
    
    that.validateSubscriptionPanel = function(errorPanel){
        var callParams = prepareCallParams(subscriptionType);
        return validate(callParams, errorPanel);
    }

    var validate = function (callParams, errorPanel) {
        var dialogMessage = errorPanel;
        if(!dialogMessage){
            dialogMessage = $('#dialogerrormessage' + panelSuffix);
        }
        if (callParams.scheduleId == null || callParams.scheduleId == '') {
            dialogMessage.html(messages['subscriptiondialog.validateschedule']);
            return false;
        }
        if ((callParams.lessonscount == null || callParams.lessonscount == '') && (callParams.datefinish == null || callParams.datefinish == '')) {
            dialogMessage.html(messages['subscriptiondialog.validatelessonscount']);
            return false;
        }
        if (callParams.datestart == null || callParams.datestart == '') {
            dialogMessage.html(messages['subscriptiondialog.validatedate']);
            return false;
        }

        if (callParams.childId == null || callParams.childId == '') {
            dialogMessage.html(messages['subscriptiondialog.validatechild']);
            return false;
        }

        return true;
    };

    var initWithDefaultValues = function(values){
        var errors = [];
        AUTOCOMPLETE_SEARCH_FIELD.enable('subscriptiondialogchild');
        if(values.duration){
            duration = values.duration;
        }
        if(values.barcode){
            barcode = values.barcode;
        }
        var initDefaultPrices = function(){
            if(values.discount){
                $('#discountSubscription' + panelSuffix).val(values.discount);
            }
            if(values.price){
                $('#fullPriceSubscription' + panelSuffix).val(values.price);
                $('#newPaidSumSubscription' + panelSuffix).val(values.price);
            }
        }
        var initDefaultDate = function(){
            if(values.dateStart){
                $('#subscriptiondatestart' + panelSuffix).val(values.dateStart);
                that.onChangeDateStart();

                var row = $('#onceDayList' + panelSuffix).find('.eventScheduleRecord');
                if(values.room){
                    row.find('.subscriptionRoom').val(values.room);
                }
                if(values.timeStart){
                    row.find('.startTime').val(values.timeStart);
                }
                if(values.timeFinish){
                    row.find('.finishTime').val(values.timeFinish);
                }
            }
            initDefaultPrices();
            $('#dialogerrormessage' + panelSuffix).html(errors.join('<br>'));
        }
        var initDefaultTeacher = function(){
            if(values.teacher){
                var optionValue = values.teacher + ';';
                if(values.additionalTeacher){
                    optionValue += values.additionalTeacher + ';'
                }
                if($('#teacher' + panelSuffix).find('option[value="' + optionValue + '"]').length > 0){
                    $('#teacher' + panelSuffix).val(optionValue);
                    that.onTeacherChange(true);
                }
                else {
                    errors.push(messages['subscriptiondialog.noteacher']);
                }
            }
            initDefaultDate();
        };
        var initDefaultCourseType = function(){
            if(values.courseType){
                if($('#coursetype' + panelSuffix).find('option[value="' + values.courseType + '"]').length > 0){
                    $('#coursetype' + panelSuffix).val(values.courseType);
                    that.onCourseTypeChange(function(){
                        initDefaultTeacher();
                    });
                }
                else {
                    errors.push(messages['subscriptiondialog.nocourse']);
                    initDefaultTeacher();
                }
            }
            else {
                initDefaultTeacher();
            }
        };
        if(values.orgid){
            organizationId = values.orgid;
            if($('#subscriptionOrganizationSelect' + panelSuffix).find('option[value="' + values.orgid + '"]').length > 0){
                $('#subscriptionOrganizationSelect' + panelSuffix).val(values.orgid);
                that.onSubscriptionOrganizationChange(function(){
                    initDefaultCourseType();
                });
            }
            else {
                errors.push(messages['subscriptiondialog.noorganization']);
                initDefaultCourseType();
            }
        }
        else {
            initDefaultCourseType();
        }
        if(values.visited){
            autoVisited = values.visited;
        }
    }

    return that;
}

DIALOGS.subscriptionDialogs = subscriptionDialogs();
function subscriptionsPackDialog() {
    var that = this;
    var subscriptionsPackAction = null;
    var subscriptionsPackChildId = null;
    var subscriptionsPackChildTitle = null;
    var subscriptionsPackId = null;
    var selectedPackOrganizationId = null;
    var totalPaidSum = 0;
    var totalPrice = 0;

    var subscriptionPanelIndex = 0;

    var listToAdd = [];
    var listToEdit = [];
    var listToRemove = [];

    that.openSubscriptionsPackDialog = function (_params) {

        subscriptionsPackAction = _params.action;
        subscriptionsPackChildId = _params.childId;
        subscriptionsPackChildTitle = _params.childFamilyTitle;
        subscriptionsPackId = null;
        selectedPackOrganizationId = $('#subscriptionOrganizationPackSelect option:selected').val().trim();

        init(_params);
        openDialog();

        if(subscriptionsPackAction == 'prolong'){
            var baseSubscriptionPackId = _params.subscriptionsPackId;

            $('#subscriptionOrganizationPackSelect').val(selectedPackOrganizationId);

            commonHelper.callAjaxMethod('client.htm', 'loadSubscriptionsPackById', {subscriptionsPackId: baseSubscriptionPackId}, function (result) {
                selectedPackOrganizationId = result.organizationId;
                $.each(result.membershipsInfo, function (index, item) {
                    var subscriptionId = item.id;
                    var subscriptionDialog = DIALOGS.subscriptionDialogsPack;
                    listToAdd.push(subscriptionDialog);
                    subscriptionDialog.openSubscriptionDialogForChild({
                        childId: subscriptionsPackChildId,
                        subscriptionId: subscriptionId,
                        subscriptionType: item.type,
                        childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('childnamefilter'),
                        action: 'prolong',
                        defaultValues: {
                            orgid: selectedPackOrganizationId
                        }
                    });
                    var data = subscriptionDialog.getSubscriptionInfo();
                    addSubscriptionToPackList(
                        data.id,
                        data.type,
                        data.courseName,
                        data.teacherName,
                        data.schedule,
                        data.fullPrice,
                        data.panelSuffix);
                    addSubscriptionPanel();
                });

            });
        }
    };

    that.openSubscriptionsPackDialogForChild = function (_params) {
        subscriptionsPackAction = 'edit';
        subscriptionsPackId = _params.id;
        commonHelper.callAjaxMethod('client.htm', 'loadSubscriptionsPackById', {subscriptionsPackId: _params.id}, function (result) {
            subscriptionsPackChildId = result.childId;
            subscriptionsPackChildTitle = result.childTitle;

            selectedPackOrganizationId = result.organizationId;
            $('#subscriptionOrganizationPackSelect').val(selectedPackOrganizationId);

            init(_params);
            $.each(result.membershipsInfo, function (index, item) {
                addSubscriptionToPackList(
                    item.id,
                    item.type,
                    item.courseName,
                    item.schedule.teacherInfo,
                    item.scheduleDaysInfo,
                    item.fullPrice,
                    '');
            });


            openDialog();
        });
    };

    that.editPackSubscription = function (subscriptionId, membershipType, panelSuffix) {
        var subscriptionDialog = null;
        for(var i=0; i<listToEdit.length; i++){
            if(listToEdit[i].getSubscriptionInfo().id == subscriptionId){
                subscriptionDialog = listToEdit[i];
                $('.subscriptionPanels').children('div').hide();
                $('.subscriptionPanels').find('#outerDiv' + subscriptionDialog.getSubscriptionInfo().panelSuffix).show();
                DIALOGS.subscriptionDialogsPack = subscriptionDialog;
                break;
            }
        }
        if(subscriptionDialog == null) {
            for (var i = 0; i < listToAdd.length; i++) {
                if (listToAdd[i].getSubscriptionInfo().id == subscriptionId) {
                    subscriptionDialog = listToAdd[i];
                    $('.subscriptionPanels').children('div').hide();
                    $('.subscriptionPanels').find('#outerDiv' + subscriptionDialog.getSubscriptionInfo().panelSuffix).show();
                    DIALOGS.subscriptionDialogsPack = subscriptionDialog;
                    break;
                }
            }
        }
        if(subscriptionDialog == null){
            subscriptionDialog = addSubscriptionPanel();
            if(subscriptionId){
                listToEdit.push(subscriptionDialog);
            }
            subscriptionDialog.openSubscriptionDialogForChild({
                childId: subscriptionsPackChildId,
                subscriptionId: subscriptionId,
                subscriptionType: membershipType,
                childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('childnamefilter'),
                action: 'edit',
                defaultValues: {
                    orgid: selectedPackOrganizationId
                }
            });
        }
    };

    that.createPackSubscription = function () {
        var subscriptionDialog = addSubscriptionPanel();
        subscriptionDialog.openSubscriptionDialogForChild({
            childId: subscriptionsPackChildId,
            familyId: undefined,
            subscriptionId: undefined,
            subscriptionType: 'subscription',
            childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('subscriptionspackdialogchild'),
            action: 'edit',
            defaultValues: {
                orgid: selectedPackOrganizationId
            }
        });
    };

    that.savePackSubscription = function () {
        var subscriptionDialog = DIALOGS.subscriptionDialogsPack;
        var addToAddList = true;
        for(var i=0; i<listToAdd.length; i++){
            if(listToAdd[i] == subscriptionDialog){
                addToAddList = false;
            }
        }
        for(var i=0; i<listToEdit.length; i++){
            if(listToEdit[i] == subscriptionDialog){
                addToAddList = false;
            }
        }
        if(addToAddList && subscriptionDialog.validateSubscriptionPanel($('#dialogerrormessagePack'))){
            listToAdd.push(subscriptionDialog);
            var data = subscriptionDialog.getSubscriptionInfo();
            addSubscriptionToPackList(
                data.id,
                data.type,
                data.courseName,
                data.teacherName,
                data.schedule,
                data.fullPrice,
                data.panelSuffix);
        }
    }

    that.save = function (callbackFunction, print) {
        //validate all changed subscriptions
        var isSubscriptionsCorrect = true;
        for(var i=0; i<listToEdit.length; i++){
            if(!listToEdit[i].validateSubscriptionPanel($('#dialogerrormessagePack'))){
                isSubscriptionsCorrect = false;
                break;
            }
        }
        for(var i=0; i<listToAdd.length; i++){
            if(!listToAdd[i].validateSubscriptionPanel($('#dialogerrormessagePack'))){
                isSubscriptionsCorrect = false;
                break;
            }
        }

        if(isSubscriptionsCorrect){
            var saveOperationCount = listToEdit.length + listToAdd.length;
            var removeOperationCount = listToRemove.length;
            var subscriptionsIds = [];
            if(subscriptionsPackAction != 'prolong'){
                $.each($('#subscriptionsPackList tbody tr'), function (index, item) {
                    if($(item).attr('subscriptionId')){
                        subscriptionsIds.push($(item).attr('subscriptionId'));
                    }
                });
            }

            var callParams = {};
            callParams.id = subscriptionsPackId;
            callParams.childId = subscriptionsPackChildId;
            callParams.selectedPackOrganizationId = selectedPackOrganizationId ? selectedPackOrganizationId : '';
            callParams.print = print;
            callParams.subscriptionsIds = subscriptionsIds;
            callParams.listToRemove = listToRemove;
            callParams.listToEdit = [];
            for(var i=0; i<listToEdit.length; i++){
                listToEdit[i].saveSubscriptionPanel(function(data){
                    callParams.listToEdit.push(data);
                }, true);
            }
            callParams.listToAdd = [];
            for(var i=0; i<listToAdd.length; i++){
                listToAdd[i].saveSubscriptionPanel(function(data){
                    callParams.listToAdd.push(data);
                }, true);
            }
            commonHelper.callAjaxMethod('client.htm', 'saveSubscriptionsPack', {params: JSON.stringify(callParams)}, function (result) {
                if (callbackFunction) {
                    callbackFunction();
                }
                closeOverlay('editSubscriptionsPackDialog');
                if(print){
                    commonHelper.showMessage(messages['subscriptionpackdialog.printinfo']);
                }
            });
        }
    };

    that.removeCurrentSubscription = function() {
        var subscriptionDialog = DIALOGS.subscriptionDialogsPack;

        var removeAdded = false;
        for(var i = listToAdd.length - 1; i >= 0; i--) {
            if(listToAdd[i] == subscriptionDialog) {
                listToAdd.splice(i, 1);
                removeAdded = true;
            }
        }
        if(removeAdded){
            $('#subscriptionsPackList tbody tr[panelSuffix=' + subscriptionDialog.getSubscriptionInfo().panelSuffix + ']').remove();
            updateTotalPrice();
        }
        else {
            var currentSubscriptionId = subscriptionDialog.getSubscriptionInfo().id;
            if(currentSubscriptionId != null){
                DIALOGS.askYesNoDialog(messages['subscriptionpackdialog.confirm'], messages['common.remove'], function () {
                    listToRemove.push(currentSubscriptionId);
                    for(var i = listToEdit.length - 1; i >= 0; i--) {
                        if(listToEdit[i] == subscriptionDialog) {
                            listToEdit.splice(i, 1);
                        }
                    }
                    $('#subscriptionsPackList tbody tr[subscriptionid=' + currentSubscriptionId + ']').remove();
                    updateTotalPrice();
                });
            }
        }
        that.createPackSubscription();
    }
    
    var openDialog = function () {
        $('#editSubscriptionsPackDialog').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5,
                zIndex: 10
            },
            fixed: false,
            closeOnClick: false
        });


        $('#editSubscriptionsPackDialog').overlay().load();
        $('#editSubscriptionsPackDialog').css('z-index', (commonHelper.getMaxZIndex() + 1));
    };

    var init = function (_params) {
        initChildTextEditor();
        $('#subscriptionsPackList tbody tr').remove();

        var saveButton = $('#editSubscriptionsPackDialog').find('.subscriptionsPackSave');
        saveButton.unbind('click');

        var savePrintButton = $('#editSubscriptionsPackDialog').find('.subscriptionsPackSavePrint');
        savePrintButton.unbind('click');

        var closeButton = $('#editSubscriptionsPackDialog').find('.subscriptionsPackClose');
        closeButton.unbind('click');

        saveButton.click(function () {
            that.save(_params.callbackFunction, false);
        });

        savePrintButton.click(function () {
            that.save(_params.callbackFunction, true);
        });

        closeButton.click(function () {
            closeOverlay('editSubscriptionsPackDialog');
        });

        listToAdd = [];
        listToEdit = [];
        listToRemove = [];
        initSubscriptionPanels();
        that.createPackSubscription();
    };

    var initChildTextEditor = function () {
        var childautocompleteparams = {
            selectCallback: function (objectId, selectedText, type, data) {

                if (objectId && objectId != '') {
                    if (type == 'family') {

                    } else {
                        subscriptionsPackChildId = objectId;
                    }
                } else {
                    subscriptionsPackChildId = null;
                }
            },
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.value;
            },
            generateLabel: function (item) {
                return item.title;
            },
            generateType: function (item) {
                return item.objtype;
            },
            url: 'family.htm',
            method: 'autoCompleteSearchFamilyOrChild',
            defaultValue: messages['common.familyfilternotset'],
            inputDataTitle: messages['common.familyfiltertitle'],
            objectNotFound: messages['common.familyfilternotfound'],
            objectFound: messages['common.familyfilterfound']
        };

        AUTOCOMPLETE_SEARCH_FIELD.prepare('subscriptionspackdialogchild', childautocompleteparams);
        if (subscriptionsPackChildId) {
            AUTOCOMPLETE_SEARCH_FIELD.disable('subscriptionspackdialogchild');
            AUTOCOMPLETE_SEARCH_FIELD.setValue('subscriptionspackdialogchild', subscriptionsPackChildId, subscriptionsPackChildTitle);
        } else {
            AUTOCOMPLETE_SEARCH_FIELD.enable('subscriptionspackdialogchild');
            AUTOCOMPLETE_SEARCH_FIELD.clear('subscriptionspackdialogchild');
        }
    };

    var addSubscriptionToPackList = function (subscriptionId,
                                              membershipType,
                                              courseName,
                                              teacherName,
                                              weekDays,
                                              fullPrice,
                                              panelSuffix) {
        var subscriptionRow = $('#subscriptionsPackList thead tr').clone().show().directives({
            '.courseName': 'courseName',
            '.teacherName': 'teacherName',
            '.weekDays': 'weekDays',
            '@subscriptionId': 'subscriptionId',
            '@membershipType': 'membershipType',
            '@panelSuffix': 'panelSuffix',
            '@fullPrice': 'fullPrice'
        }).render({
            subscriptionId: subscriptionId,
            courseName: courseName,
            teacherName: teacherName,
            weekDays: weekDays,
            membershipType: membershipType,
            panelSuffix: panelSuffix,
            fullPrice: fullPrice
        });

        subscriptionRow.appendTo($('#subscriptionsPackList tbody'));
        updateTotalPrice();
    };

    var updateTotalPrice = function() {
        var fullPrice = 0;
        $.each($('#subscriptionsPackList tbody tr'), function() {
            fullPrice += parseInt($(this).attr('fullprice'));
        });
        $('#editSubscriptionsPackDialog').find('.totalPrice').text(fullPrice);
    };

    that.onSubscriptionPackOrganizationChange = function () {
        selectedPackOrganizationId = $('#subscriptionOrganizationPackSelect option:selected').val().trim();
        removeCurrentSubscription();
        createPackSubscription();
    };

    var closeOverlay = function (overlayName) {
        $('#' + overlayName).overlay().close();
    };

    var initSubscriptionPanels = function() {
        $('.subscriptionPanels').find('#outerDivPack').hide();
        $('.subscriptionPanels').children('div').each(function(){
            if(this.id != 'outerDivPack'){
                $(this).remove();
            }
        });
        subscriptionPanelIndex = 0;
    }

    var addSubscriptionPanel = function() {
        var subscriptionPanel = $('.subscriptionPanels').find('#outerDivPack').clone();
        subscriptionPanelIndex ++;
        var panelId = 'Pack' + subscriptionPanelIndex;
        subscriptionPanel.attr('id', 'outerDiv' + panelId).find("*").each(function() {
            var id = this.id || "";
            if (id.endsWith('Pack')) {
                this.id = id.replace('Pack', panelId);
            }
        });
        $('.subscriptionPanels').append(subscriptionPanel);
        $('.subscriptionPanels').children('div').hide();
        subscriptionPanel.show();

        var subscriptionPanelDialog = new subscriptionDialogs(true, panelId);
        DIALOGS.subscriptionDialogsPack = subscriptionPanelDialog;
        return subscriptionPanelDialog;
    }

    return this;
}

DIALOGS.subscriptionsPackDialog = subscriptionsPackDialog();DIALOGS.taskEditDialog = function (taskid, childid, requestid, _taskType, hideChild, enableType, saveCallback, closeCallback, saveFunction, defaultParams) {
    var enableDisable = function (element, disable) {
        if (disable) {
            element.attr('disabled', 'disabled');
        } else {
            element.removeAttr('disabled');
        }
    };

    var dialogButtons = [];
    var taskObject = {};
    var child = null;
    var marketingRequest = null;
    if (taskid) {
        commonHelper.callAjaxMethod('index.htm', 'getTask', {taskId: taskid}, function (result) {
            taskObject = result;

        }, false);
    } else if (childid) {
        commonHelper.callAjaxMethod('family.htm', 'getChildInfo', {childid: childid}, function (result) {
            child = result;
        }, false);
    }
    if(requestid) {
        if(requestid < 0){
            marketingRequest = {};
        }
        else {
            commonHelper.callAjaxMethod('marketing.htm', 'loadMarketingRequest', {marketingRequestId: requestid}, function (result) {
                marketingRequest = result.marketingRequestInfo;
            }, false);
        }
    }

    if (!child && taskObject && taskObject.task && taskObject.task.child) {
        child = taskObject.task.child;
    }
    if(!marketingRequest && taskObject && taskObject.task && taskObject.task.request){
        marketingRequest = taskObject.task.request;
    }
    if(defaultParams && !taskObject.task){
        taskObject.task = defaultParams;
    }

    var closedTask = taskObject && taskObject.task && taskObject.task.status && (taskObject.task.status.value == 'CLOSED' || taskObject.task.status.value == 'CANCELED');
    if (taskObject && taskObject.task && taskObject.task.id && taskObject.task.id != '' && !closedTask) {
        dialogButtons[dialogButtons.length] = {
            text: messages['taskdialog.taskdone'],
            id: "markTaskAsDone",
            click: function (event) {
                if (saveTask('CLOSED')) {
                    commonHelper.hideDialog('editTaskDialog', event);
                }
            }
        };

        dialogButtons[dialogButtons.length] = {
            text: messages['taskdialog.taskcancelled'],
            id: "markTaskAsCanceled",
            style: 'margin-right: 290px;',
            click: function (event) {
                if (saveTask('CANCELED')) {
                    commonHelper.hideDialog('editTaskDialog', event);
                }
            }
        };
    }

    $('#editTaskDialog').find('.custom-block').hide();
    if(marketingRequest){
        $('#editTaskDialog').find('.request-block').show();
    }
    else {
        $('#editTaskDialog').find('.parent-block').show();
        $('#editTaskDialog').find('.children-block').show();
    }

    if (hideChild) {
        $('#childtext_label').hide();
        AUTOCOMPLETE_SEARCH_FIELD.hide('taskdialogchild');
    } else {
        $('#childtext_label').show();
        AUTOCOMPLETE_SEARCH_FIELD.show('taskdialogchild');
    }

    if (enableType) {
        $('#taskdialogtypespan').hide();
        $('[name="taskdialogtype"]').removeAttr('disabled');
    } else {
        $('[name="taskdialogtype"]').attr('disabled', 'disabled');
        $('[name="taskdialogtype"]').hide();
        $('#taskdialogtypespan').show();
    }

    if (!closedTask) {
        dialogButtons[dialogButtons.length] = {
            text: messages['common.save'],
            id: "saveTask",
            click: function (event) {
                if (saveTask(null)) {
                    commonHelper.hideDialog('editTaskDialog', event);
                }
            }
        };
    }

    dialogButtons[dialogButtons.length] =
    {
        text: messages['common.close'],
        click: function (event) {
            commonHelper.hideDialog('editTaskDialog', event);
        }
    };
    $('#editTaskDialog').dialog({
        height: 510,
        width: 680,
        autoOpen: true,
        modal: true,
        create: function (event, ui) {
            commonHelper.clearBeforeValidation('#editTaskDialog', '#messages');
            var typeSelect = $('select.taskdialogtype');
            typeSelect.children(null).remove();

            var taskType = _taskType ? _taskType : (taskObject.task && taskObject.task.type) ? taskObject.task.type.value : '';
            var selectedTaskTitle = '';
            taskObject.tasktypes = [
                {
                    "title": messages['taskdialog.type.call'],
                    "value": "CALL",
                    "selected": "CALL" == taskType
                },
                {
                    "title": messages['taskdialog.type.task'],
                    "value": "TASK",
                    "selected": "TASK" == taskType
                },
                {
                    "title": messages['taskdialog.type.email'],
                    "value": "EMAIL",
                    "selected": "EMAIL" == taskType
                }
            ];

            for (var taskIndex in taskObject.tasktypes) {
                if (taskObject.tasktypes[taskIndex].selected) {
                    selectedTaskTitle = taskObject.tasktypes[taskIndex].title;
                }
            }

            $('<option>', {
                value: ''
            }).appendTo(typeSelect);

            var renderResult = $('#editTaskContent').directives({
                ".taskdialogid@value": "task.id",
                ".taskdialogsubject@value": "task.subject",
                ".taskdialogdate@value": "task.date",
                ".taskdialogchildid@value": "task.child.id",
                ".taskdialogrequestid@value": "task.request.id",
                ".taskdialogcomment": "task.comment",
                ".taskdialogparent" : '#{family.parentName}',
                ".taskdialogphone" : '#{family.phone}',
                ".taskdialogtypespan": "task.type.title"
            }).render(taskObject);

            $('.taskdialogtype').directives({
                    'option': {
                        'tasktype<-tasktypes': {
                            ".": "tasktype.title",
                            "@value": "tasktype.value",
                            "@selected": "tasktype.selected"
                        }
                    }
                }
            ).render(taskObject);

            if ($('#taskdialogtypespan').html() == '') {
                $('#taskdialogtypespan').html(selectedTaskTitle);
            }

            AUTOCOMPLETE_SEARCH_FIELD.clear('taskdialogchild');
            var childautocompleteparams = {
                url: 'index.htm',
                method: 'autoCompleteSearchChild',
                defaultValue: messages['taskdialog.childfilternotset'],
                inputDataTitle: messages['taskdialog.childfilteraction'],
                objectNotFound: messages['taskdialog.childfilternotfound'],
                objectFound: messages['taskdialog.childfilterfound'],
                foundStatusClick: function (event) {
                    var childid = $(this).parents().filter('#divcontainer_taskdialogchild').find('#taskdialogchild').val();
                    DIALOGS.familyDialogs.editFamilyDialog(null, childid);
                },
                generateId: function (item) {
                    return item.id;
                },
                generateValue: function (item) {
                    return item.firstName + ' ' + item.lastName;
                },
                generateLabel: function (item) {
                    return item.firstName + ' ' + item.lastName + ';' + item.phone;
                }
            };
            AUTOCOMPLETE_SEARCH_FIELD.prepare('taskdialogchild', childautocompleteparams);

            if (closedTask) {
                AUTOCOMPLETE_SEARCH_FIELD.disable('taskdialogchild');
            } else {
                AUTOCOMPLETE_SEARCH_FIELD.enable('taskdialogchild');
                commonHelper.setDatePicker($('#editTaskDialog').find('.taskdialogdate')).datepicker('hide');

            }

            commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
                var references = {};
                references.teachers = [
                    {name: '', teacherid: ''}
                ].concat(result.teachers.rows);

                commonHelper.initReferenceSelect($('#editTaskDialog').find('.taskdialoguser'), references, 'teacher', 'teacherid', 'name');
                if(taskObject && taskObject.task && taskObject.task.user){
                    $('#editTaskDialog').find('.taskdialoguser').val(taskObject.task.user.id);
                }
            });

            enableDisable($('.taskdialogsubject'), closedTask);
            enableDisable($('.taskdialogdate'), closedTask);
            enableDisable($('.taskdialogcomment'), closedTask);
            enableDisable($('.taskdialoguser'), closedTask);

            if (child && child.id) {
                AUTOCOMPLETE_SEARCH_FIELD.setValue('taskdialogchild', child.id, child.firstName + ' ' + child.lastName);
            }

            if (taskObject && taskObject.task){
                $('#taskorganization').val(taskObject.task.organizationId ? taskObject.task.organizationId : '');
            } else {
                $('#taskorganization').val(CURRENT_ORG);
            }

            if (ORGS_COUNT > 0) {
                $('.organizationSelect').show();
            } else {
                $('.organizationSelect').hide();
            }

            commonHelper.prepareViewer([
                {filter: '#saveTask', action: 'delete'},
                {filter: '#markTaskAsDone', action: 'delete'},
                {filter: '#markTaskAsCanceled', action: 'delete'},
                {filter: 'taskdialogchild', action: 'disableautocomplete'},
                {filter: '#taskdialogdate', action: 'disabledatepicker'},
                {filter: '#taskorganization', action: 'disable'},
                {filter: '[name=taskdialogsubject]', action: 'disable'},
                {filter: '[name=taskdialogcomment]', action: 'disable'}
            ]);

            if(marketingRequest){
                AUTOCOMPLETE_SEARCH_FIELD.clear('taskdialogrequest');
                var requestautocompleteparams = {
                    url: 'marketing.htm',
                    method: 'autoCompleteSearchRequest',
                    defaultValue: messages['taskdialog.requestfilternotset'],
                    inputDataTitle: messages['taskdialog.requestfilteraction'],
                    objectNotFound: messages['taskdialog.requestfilternotfound'],
                    objectFound: messages['taskdialog.requestfilterfound'],
                    foundStatusClick: function (event) {
                        //nothing to do
                    },
                    generateId: function (item) {
                        return item.id;
                    },
                    generateValue: function (item) {
                        return item.firstName + ' ' + item.lastName;
                    },
                    generateLabel: function (item) {
                        return item.firstName + ' ' + item.lastName + ';' + item.phone;
                    }
                };
                AUTOCOMPLETE_SEARCH_FIELD.prepare('taskdialogrequest', requestautocompleteparams);
                if(marketingRequest.id){
                    AUTOCOMPLETE_SEARCH_FIELD.setValue('taskdialogrequest', marketingRequest.id, marketingRequest.firstName + ' ' + marketingRequest.lastName);
                    $('.taskdialogcontact').html(marketingRequest.contactName);
                }
            }

            if($('#editTaskContent').find('.taskdialogparent').html().length == 0 && $('#editTaskContent').find('.taskdialogphone').html().length == 0){
                $('#editTaskContent').find('.parentInfo').hide();
            }
        },

        beforeClose: function (event, ui) {
            commonHelper.clearBeforeValidation('#editTaskDialog', '#messages');
            if (closeCallback) {
                closeCallback(event);
            }
        },
        close: function (event, ui) {
            commonHelper.closeDialog('editTaskDialog', event);
        },
        buttons: dialogButtons
    });


    var saveTask = function (newTaskStatus) {
        var structure = {};

        structure.newTaskStatus = newTaskStatus ? newTaskStatus : '';
        commonHelper.fillWithInputs(structure, $('#editTaskDialog'), ['taskdialogid', 'taskdialogsubject', 'taskdialogdate', 'taskdialogtype', 'taskdialogcomment', 'taskdialogchild', 'taskdialogrequest', 'taskdialoguser']);
        structure.taskorganization = $('#taskorganization').val() ? $('#taskorganization').val() : '';
        if (validate(structure)) {
            if (saveFunction) {
                saveFunction(structure);
            } else {
                commonHelper.callAjaxMethod('index.htm', 'saveTask', {"objects": JSON.stringify(structure)}, function (response) {
                    if (saveCallback) {
                        saveCallback(response);
                    }
                });
            }
            return true;
        } else {
            return false;
        }
    };

    var validate = function (data) {
        return commonHelper.validateForm($('#editTaskDialogForm'), $('#messages'), {
            taskdialogsubject: {
                required: true
            },
            taskdialogdate: {
                required: true,
                date: true
            },
            taskdialogchildid: {
                required: true
            }
        });
    };

};function barcode_helper() {
    var that = this;

    var openedTab = {};

    that.readers = new barcodeReaders_helper(that);
    that.timezone = new timezone_helper(that);
    that.timezonestat = new timezonestat_helper(that);

    that.TABLE_WIDTH = 0;

    this.pageReady = function () {
        $('#tabs-barcode').tabs();
        that.TABLE_WIDTH = $('#tabs-barcode').parent(null).width() - 70;

        $('#tabs-barcode').tabs({
            show: function (event, ui) {
                $(ui.panel).show();
                onTabSelected(ui.index);
            }
        });

        prepareTabs();
    };

    var prepareTabs = function () {
        onTabSelected(0);
        $('#tab-barcode-readers').show();
        $('button').button();
    };

    var onTabSelected = function (index) {
        switch (index) {
            case 0:
                that.readers.display();
                break;
            case 1:
                that.timezone.display();
                break;
            case 2:
                that.timezonestat.display();
                break;
        }
    };

    return this;
}function bonus_helper() {
    var that = this;

    var openedTab = {};

    that.programs = new bonusPrograms_helper(that);
    that.statistic = new bonusStatistic_helper(that);

    that.TABLE_WIDTH = 0;

    this.pageReady = function () {
        $('#tabs-bonus').tabs();
        that.TABLE_WIDTH = $('#tabs-bonus').parent(null).width() - 70;

        $('#tabs-bonus').tabs({
            show: function (event, ui) {
                $(ui.panel).show();
                onTabSelected(ui.index);
            }
        });

        prepareTabs();
    };

    var prepareTabs = function () {
        onTabSelected(0);
        $('#tab-bonus-settings').show();
        $('button').button();
    };

    var onTabSelected = function (index) {
        switch (index) {
            case 0:
                that.programs.display();
                break;
            case 1:
                that.statistic.display();
                break;
        }
    };

    return this;
}function calendar_helper() {
    var that = this;
    var selectedEvent = null;
    var removedEvents = [];
    var eventManager = {};
    var shouldClearBubbles = true;
    var currentBubbleDialog = null;

    var calculateCalendarHeight = function () {
        return $(window).height() - 130;
    };

    this.selectDate = function () {
        var date = commonHelper.parseDate($('#filterdate').val());
        $('#calendar').fullCalendar('gotoDate', date);
    };

    this.showBirthDate = function () {
        $('#calendar').fullCalendar('refetchEvents');
    };

    this.pageReady = function () {
        commonHelper.registerChangeOrganizationListener(function(selectedOrganizationId){
            $('#calendar').fullCalendar('refetchEvents');
        });
        ACTUAL_DAY_INFO_INSTANCE = ACTUAL_DAY_INFO(
            function () {
                return currentBubbleDialog;
            },
            function () {
                shouldClearBubbles = false;
            },
            function () {
                shouldClearBubbles = false;
            },
            function (result) {
                var plannedEventObjects = $('#calendar').fullCalendar('clientEvents', 'planned-' + result.actualDay.id);
                var actualEventObjects = $('#calendar').fullCalendar('clientEvents', 'actual-' + result.actualDay.id);
                if (plannedEventObjects.length > 0) {
                    plannedEventObjects[0].className = 'baseelement movedplannedlesson';
                    eventManager.fillDayEvent(plannedEventObjects[0], result.actualDay, result.actualDay.plannedDate, result.actualDay.plannedStartTime, result.actualDay.plannedFinishTime, result.lessonTitle);
                    $('#calendar').fullCalendar('updateEvent', plannedEventObjects[0]);
                }
                if (actualEventObjects.length > 0) {
                    eventManager.fillDayEvent(actualEventObjects[0], result.actualDay, result.actualDay.actualDate, result.actualDay.actualStartTime, result.actualDay.actualFinishTime, result.lessonTitle);
                    $('#calendar').fullCalendar('updateEvent', actualEventObjects[0]);
                } else {
                    var newActualEvent = {};
                    newActualEvent.className = 'baseelement actuallesson';
                    newActualEvent.type = 'subscriptions';
                    newActualEvent.id = 'actual-' + result.actualDay.id;
                    newActualEvent.allDay = false;
                    eventManager.fillDayEvent(newActualEvent, result.actualDay, result.actualDay.actualDate, result.actualDay.actualStartTime, result.actualDay.actualFinishTime, result.lessonTitle);
                    $('#calendar').fullCalendar('renderEvent', newActualEvent);
                }
            },
            function (result) {
                var plannedEventObjects = $('#calendar').fullCalendar('clientEvents', 'planned-' + result.actualDay.id);
                var actualEventObjects = $('#calendar').fullCalendar('clientEvents', 'actual-' + result.actualDay.id);
                if (plannedEventObjects.length > 0) {
                    eventManager.fillDayEvent(plannedEventObjects[0], result.actualDay, result.actualDay.plannedDate, result.actualDay.plannedStartTime, result.actualDay.plannedFinishTime, result.lessonTitle);
                    plannedEventObjects[0].className = 'baseelement plannedlesson';
                    $('#calendar').fullCalendar('updateEvent', plannedEventObjects[0]);
                }
                if (actualEventObjects.length > 0) {
                    $('#calendar').fullCalendar('removeEvents', actualEventObjects[0].id);
                }
            },
            function (result) {
                $('#calendar').fullCalendar('refetchEvents');
            }
        );

        var height = calculateCalendarHeight();
        $('#filterdate').val(commonHelper.formatDate(new Date()));
        commonHelper.setDatePicker($('#filterdate'), function (date) {
            that.selectDate();
        });

        $('body').find('button').button();
        $('#calendar').fullCalendar({
            header: {left: 'today prev,next',
                center: 'title',
                right: 'month agendaWeek agendaDay'
            },
            monthNames: [messages['common.month1'], messages['common.month2'], messages['common.month3'], messages['common.month4'], messages['common.month5'], messages['common.month6'], messages['common.month7'], messages['common.month8'], messages['common.month9'], messages['common.month10'], messages['common.month11'], messages['common.month12']],
            monthNamesShort: [messages['common.smonth1'], messages['common.smonth2'], messages['common.smonth3'], messages['common.smonth4'], messages['common.smonth5'], messages['common.smonth6'], messages['common.smonth7'], messages['common.smonth8'], messages['common.smonth9'], messages['common.smonth10'], messages['common.smonth11'], messages['common.smonth12']],
            dayNames: [messages['common.day7'], messages['common.day1'], messages['common.day2'], messages['common.day3'], messages['common.day4'], messages['common.day5'], messages['common.day6']],
            dayNamesShort: [messages['common.sday7'], messages['common.sday1'], messages['common.sday2'], messages['common.sday3'], messages['common.sday4'], messages['common.sday5'], messages['common.sday6']],
            buttonText: {
                today: messages['calendar.today'],
                month: messages['calendar.month'],
                week: messages['calendar.week'],
                day: messages['calendar.day']
            },
            theme: false,
            firstDay: 1,
            selectable: false,
            allDayText: messages['calendar.allday'],
            axisFormat: 'HH:mm',
            timeFormat: 'HH:mm',
            displayEventEnd: true,
            slotMinutes: 10,
            weekMode: 'liquid',
            height: height,
            windowResize: function () {
                $('#calendar').fullCalendar('option', 'height', calculateCalendarHeight());
            },
            events: function (start, end, timezone, callback) {
                var params = {};
                params.start = commonHelper.formatDate(start.toDate());
                params.end = commonHelper.formatDate(end.toDate());
                params.coursefilter = $('[name="coursefilter"]:checked').val();
                params.showBirthDates = $('[name="showbirthdate"]:checked').val();
                commonHelper.callAjaxMethod('calendar.htm', 'loadEvents', params, function (data) {
                    callback(data);
                }, false);
            },
            viewDisplay: function () {
                $('#filterdate').val(commonHelper.formatDate($('#calendar').fullCalendar('getDate')));
                $('.fc-agenda-slots').parent().parent().scroll(function () {
//                    clearBubbles();
                });
            },
            dayDblClick: function (date, allDay, jsEvent, view) {
                var calendar = $('#calendar');
                calendar.fullCalendar('gotoDate',
                    date.getFullYear(), date.getMonth(), date.getDate());
                calendar.fullCalendar('changeView', 'agendaDay');
            },
            beforeClearEvents: function () {

            },

            eventClick: function (calEvent, jsEvent, view) {
                var eventObject = $(jsEvent.currentTarget);
                //clearBubbles();
                selectedEvent = eventObject;
                removedEvents.push(selectedEvent);
                var params = {};
                params.type = calEvent.type;
                params.id = calEvent.id;
                commonHelper.callAjaxMethod('calendar.htm', 'loadObjectInfo', params, function (data) {
                    var content;
                    if (calEvent.type == 'task') {
                        content = $('#eventTemplate').clone().directives({
                            '.eventContainer@id': 'task.id',
                            '.eventContainer@type': '"task.task"',
                            '.eventContainer@status': 'task.status',
                            '.taskchild': '#{task.child.firstName}  #{task.child.lastName}',
                            '.tasksubject': 'task.subject',
                            '.tasktype': 'task.type.title',
                            '.taskdate': 'task.date',
                            '.taskphone' : 'family.phone',
                            '.taskparent' : 'family.parentName'
                        }).render(data);
                    } else if (calEvent.type == 'subscriptions') {
                        content = $('#subscriptionsTemplate').clone().directives({
                            '.subscriptionContainer@id': 'subscriptions-#{actualDay.id}',
                            '.subscriptionContainer@type': '"subscriptions"',
                            '.plannedDate': '#{actualDay.plannedDate} #{actualDay.plannedStartTime}-#{actualDay.plannedFinishTime}',
                            '.actualDate': '#{actualDay.actualDate} #{actualDay.actualStartTime}-#{actualDay.actualFinishTime}',
                            '.course': 'course.name',
                            '.comment': 'scheduleComment',
                            '.teacher': 'teacher.name',
                            '.room': 'actualDay.plannedRoom.title',
                            '.actualdaycomment': 'actualDay.comment',
                            '.removedateLink@style': activeStatus,
                            '.changedateLink@style': activeStatus,
                            '.changeTeacherLink@style': activeStatus,
                            '.reservationRow@style': activeStatus,
                            '.childRow@style': activeStatus,
                            '.separatorRow@style': activeStatus,
                            '.canceledLesson': lessonStatus,
                            '.kidrow': {
                                'element <-children': {
                                    '.childinfo': '<a href="client.htm?childid=#{element.child.id}">#{element.child.firstName} #{element.child.lastName}</a>',
                                    '.childage': '#{element.child.age}',
                                    '.visited': generateVisited,
                                    '.phone': '#{element.phone}',
                                    '.familylink@id': 'element.familyId'
                                }
                            },
                            '.reservationrow': {
                                'element <-reservation': {
                                    '.reservchildinfo': '<a href="client.htm?childid=#{element.child.id}">#{element.child.firstName} #{element.child.lastName}</a>',
                                    '.reservchildage': '#{element.child.age}',
                                    '.reservphone': '#{element.phone}',
                                    '.reservfamilylink@id': 'element.familyId'
                                }
                            }

                        }).render(data);
                        if (data.actualTeacher.id != data.teacher.id) {
                            content.find('.actualTeacher').html(data.actualTeacher.name);
                            content.find('.actualTeacherDiv').show();
                        }
                        if(data.additionalTeacher){
                            content.find('.additionalTeacher').html(data.additionalTeacher.name);
                        }
                        if(data.actualAdditionalTeacher && (!data.additionalTeacher || data.actualAdditionalTeacher.id != data.additionalTeacher.id)){
                            content.find('.actualAdditionalTeacher').html(data.actualAdditionalTeacher.name);
                            content.find('.actualAdditionalTeacherDiv').show();
                        }

                        var cancelDayLink = content.find('#canceldaylink');
                        cancelDayLink.attr('canceled', data.actualDay.canceled);

                        if (data.actualDay.canceled) {
                            cancelDayLink.html(messages['calendar.activate']);
                        } else {
                            cancelDayLink.html(messages['calendar.cancel']);
                        }

                        commonHelper.prepareViewer([
                            {filter: '#canceldaylink', action: 'hide'},
                            {filter: '.changedateLink', action: 'hide'},
                            {filter: '.removedateLink', action: 'hide'},
                            {filter: '.changeTeacherLink', action: 'hide'}
                        ], content);
                    }

                    if (selectedEvent) {
                        currentBubbleDialog = BUBBLE_DIALOG.show(selectedEvent, content);
                    }

                }, true, true);
            },
            eventMouseover: function (event, jsEvent, view) {
                $(jsEvent.currentTarget).addClass('hovered');
            },
            eventMouseout: function (event, jsEvent, view) {
                $(jsEvent.currentTarget).removeClass('hovered');
            },
            eventRender: function( event, element, view ) {
                var $title = element.find( '.fc-title' );
                $title.html( $title.text() );
            }
        });
    };

    var lessonStatus = function (context) {
        return context.context.actualDay.canceled ? messages['calendar.canceled'] : '';
    };

    var activeStatus = function (context) {
        return context.context.actualDay.canceled ? 'display: none' : '';
    };

    var generateVisited = function (context) {
        return context.item.visited ? '\u2714' : context.item.missed ? 'x' : '';
    };


    that.changeCourseFilter = function () {
        $('#calendar').fullCalendar('refetchEvents');
    };

    that.openTask = function (buttonObject) {
        var taskId = $(buttonObject).parents().filter('.eventContainer').attr('id');
        shouldClearBubbles = false;
        DIALOGS.taskEditDialog(taskId, null, null, null, false, false, function (task) {
            var eventObject = $('#calendar').fullCalendar('clientEvents', 'task-' + taskId)[0];
            eventManager.fillTaskEvent(eventObject, task);
            $('#calendar').fullCalendar('updateEvent', eventObject);
        }, function (event) {
            shouldClearBubbles = true;
        });
    };

    eventManager.fillTaskEvent = function (eventObject, task) {
        var taskdate = commonHelper.parseDate(task.date);
        eventObject.title = task.subject + '; ' + (task.child ? task.child.firstName + ' ' + task.child.lastName : '');
        eventObject.start = taskdate;
        switch (task.status.value) {
            case 'CLOSED' :
                eventObject.className = 'baseelement closedtask';
                return;
            default :
                eventObject.className = 'baseelement task';
                return;
        }
    };

    eventManager.fillDayEvent = function (eventObject, actualDay, date, starttime, endtime, lessontitle) {
        eventObject.title = lessontitle;
        eventObject.start = commonHelper.parseDateTime(date, starttime);
        eventObject.end = commonHelper.parseDateTime(date, endtime);
    };

    return that;
}function client_helper() {
    var that = this;
    var subscriptionFilter = 'active';
    var selectedChildId = null;
    var selectedFamilyId = null;
    var subscriptionSelectedPage = 1;
    var taskSelectedPage = 1;
    var phoneCallSelectedPage = 1;
    var clientPrinting = false;

    that.gradebook = null;
    
    this.pageReady = function () {
        $("input:submit, button").button();
        that.selectSubscriptionFilter($('#subscriptionfilter_active'), subscriptionFilter);
        clearChildInfo();
        $('#clientinfotabs').tabs({
            selected: 0,
            select: function (event, ui) {
                switch (ui.panel.id) {
                    case 'tabs-subscriptions':
                        reloadSubscriptionList();
                        break;
                    case 'tabs-tasks':
                        reloadTasksList();
                        break;
                    case 'tabs-phonecalls':
                        reloadPhoneCallsList();
                        break;
                    case 'tabs-gradebook':
                        reloadGradebookTab();
                        break;
                }
            }
        });

        commonHelper.registerChangeOrganizationListener(function (organizationId) {
            reloadSubscriptionList();
            reloadTasksList();
        });

        var childautocompleteparams = {
            selectCallback: function (objectId, selectedText, type) {
                if (objectId && objectId != '') {
                    if (type == 'family') {
                        selectFamily(objectId);
                    } else {
                        selectChild(objectId);
                    }
                } else {
                    selectedChildId = '';
                    selectedFamilyId = '';
                    clearChildInfo();
                }
            },
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.value;
            },
            generateLabel: function (item) {
                return item.title;
            },
            generateType: function (item) {
                return item.objtype;
            },
            url: 'family.htm',
            method: 'autoCompleteSearchFamilyOrChild',
            defaultValue: messages['common.familyfilternotset'],
            inputDataTitle: messages['common.familyfiltertitle'],
            objectNotFound: messages['common.familyfilternotfound'],
            objectFound: messages['common.familyfilterfound']
        };

        AUTOCOMPLETE_SEARCH_FIELD.prepare('childnamefilter', childautocompleteparams);
        var childIdFromParameter = $('#selectedchildid').val();
        if (childIdFromParameter != '') {
            AUTOCOMPLETE_SEARCH_FIELD.setValue('childnamefilter', childIdFromParameter, $('#childnamefilter_field').val());
        }

        var action = $('#action').val();
        if(action != ''){
            var params = {};
            var actionParameters = $('#actionParameters').val();
            if(actionParameters != ''){
                params = JSON.parse(actionParameters);
            }
            if(action == 'openDialog'){
                that.createClient(params);
                if(params.scriptType) DIALOGS.openScriptDialog(null, params.scriptType);
            }
            else if(action == 'openChild'){
                AUTOCOMPLETE_SEARCH_FIELD.setValue('childnamefilter', params.childId, $('#childnamefilter_field').val());
                if(params.scriptType) DIALOGS.openScriptDialog(null, params.scriptType);
            }
            else if(action == 'createOneLesson'){
                AUTOCOMPLETE_SEARCH_FIELD.setValue('childnamefilter', params.childId, $('#childnamefilter_field').val());
                var timerId = setInterval(function(){
                    if(selectedFamilyId){
                        clearInterval(timerId);
                        currentPage.createOnceLesson(undefined, undefined, params);
                    }
                }, 100);
            }
        }

        $('#uploadChildPhoto').html5_upload({
            url: function (number) {
                return 'family.htm?method=uploadChildPhoto&childid=' + selectedChildId;
            },
            sendBoundary: window.FormData || $.browser.mozilla,
            onStart: function (event, total) {
                if (document.getElementById("uploadChildPhoto").files[0].size > 10000000) {
                    commonHelper.showError(messages['client.filelimit']);
                    return false;
                } else {
                    return true;
                }
            },

            onFinishOne: function (event, response, name, number, total) {
                if (selectedChildId) {
                    $('#childPhoto').attr('src', 'family.htm?method=childPhoto&childid=' + selectedChildId + '&q=' + new Date().getTime());
                    $('#childPhoto').show();
                    $('#deleteChildPhotoLink').show();
                }

                $('#uploadChildPhoto').hide();
                $('#deleteChildPhotoLinkDiv').show();
                $('#uploadChildPhotoLinkDiv').show();
            },

            onError: function (event, name, error) {

            },
            autostart: true,
            autoclear: true

        });

        commonHelper.prepareViewer([
            {filter: '#createtaskButton', action: 'delete'},
            {filter: '#editclientButton', action: 'delete'},
            {filter: '#createfamilyButton', action: 'delete'},
            {filter: '#createsubscriptionButton', action: 'delete'},
            {filter: '#createonelessonButton', action: 'delete'},
            {filter: '#createreservationButton', action: 'delete'},
            {filter: '#uploadChildPhotoLinkDiv', action: 'delete'},
            {filter: '#createMultiSubscriptionButton', action: 'delete'},
            {filter: '#addToRecipientsButton', action: 'delete'},
            {filter: '#createSubscriptionsPackButton', action: 'delete'},
        ]);
    };

    that.editTask = function (buttonObject) {
        var taskid = buttonObject.parents().filter('.taskRow').attr('id');
        DIALOGS.taskEditDialog(taskid, null, null, null, false, false, function () {
            reloadTasksList();
        });
    };

    that.deleteChildPhoto = function () {
        commonHelper.callAjaxMethod('family.htm', 'deleteChildPhoto', {childid: selectedChildId}, function (result) {
            $('#childPhoto').attr('src', '');
            $('#childPhoto').hide();
            $('#deleteChildPhotoLink').hide();
        });
    };

    var reloadSubscriptionList = function (onlysubscription) {
        if ((selectedChildId && selectedChildId != '') || (selectedFamilyId && selectedFamilyId != '')) {
            commonHelper.callAjaxMethod('client.htm', 'loadClientInfo', {
                childId: selectedChildId,
                familyId: selectedFamilyId,
                subscriptionFilter: subscriptionFilter,
                page: subscriptionSelectedPage
            }, function (result) {
                if (!onlysubscription) {
                    clearChildInfo();
                    selectedFamilyId = result.family.id;
                    fillFamilyInfo(result);
                }
                if (selectedChildId && selectedChildId != '') {
                    if (!onlysubscription) {
                        fillChildInfo(result);
                    }
                    fillSubscriptionInfo(result);
                    enableSubscriptionButtons();
                }
                enableClientButtons();
            });
        }
    };

    var reloadTasksList = function () {
        if (selectedChildId && selectedChildId != '') {
            var params = {
                filterchild: selectedChildId,
                page: taskSelectedPage,
                sord: 'desc',
                sidx: 'date'
            }
            var requestId = $('#requestLinks').find('a').attr('data-request');
            if(requestId){
                params['additionalfilterrequest'] = requestId;
            }

            commonHelper.callAjaxMethod('taskhistory.htm', 'filterTasks', params,
                function (result) {
                    fillTasksInfo(result);
                });
        }
    };

    var reloadPhoneCallsList = function () {
        if (selectedChildId && selectedChildId != '') {
            commonHelper.callAjaxMethod('phone.htm', 'filterPhoneCalls',
                {
                    filterchild: selectedChildId,
                    page: phoneCallSelectedPage,
                    sord: 'desc',
                    sidx: 'date'
                },
                function (result) {
                    fillPhoneCallsInfo(result);
                });
        }
    };

    var selectChild = function (childid) {
        selectedChildId = childid;
        reloadSubscriptionList();
        reloadTasksList();

        commonHelper.prepareViewer([
            {filter: '.convertLink', action: 'hide'},
            {filter: '.prolongAsSubscription', action: 'hide'},
            {filter: '.prolongAsOnce', action: 'hide'},
            {filter: '.cancelSubscriptionLink', action: 'hide'},
            {filter: '.removePartMembershipLink', action: 'hide'},
            {filter: '.changebutton', action: 'hide'}
        ]);
    };

    var selectFamily = function (familyid) {
        selectedChildId = '';
        selectedFamilyId = familyid;
        reloadSubscriptionList();
        reloadTasksList();

        commonHelper.prepareViewer([
            {filter: '.convertLink', action: 'hide'},
            {filter: '.prolongAsSubscription', action: 'hide'},
            {filter: '.prolongAsOnce', action: 'hide'},
            {filter: '.cancelSubscriptionLink', action: 'hide'},
            {filter: '.removePartMembershipLink', action: 'hide'},
            {filter: '.changebutton', action: 'hide'}
        ]);
    };


    var enableClientButtons = function () {
        $('#createtaskButton').attr('disabled', false).removeClass('ui-state-disabled');
        $('#editclientButton').attr('disabled', false).removeClass('ui-state-disabled');
        $('#addToRecipientsButton').attr('disabled', false).removeClass('ui-state-disabled');
    };

    var enableSubscriptionButtons = function () {
        $('#createonelessonButton').attr('disabled', false).removeClass('ui-state-disabled');
        $('#createsubscriptionButton').attr('disabled', false).removeClass('ui-state-disabled');
        $('#createtestlessionButton').attr('disabled', false).removeClass('ui-state-disabled');
        $('#createreservationButton').attr('disabled', false).removeClass('ui-state-disabled');
        $('#createMultiSubscriptionButton').attr('disabled', false).removeClass('ui-state-disabled');
        $('#createSubscriptionsPackButton').attr('disabled', false).removeClass('ui-state-disabled');

    };

    var disableButtons = function () {
        $('#createonelessonButton').attr('disabled', true).addClass('ui-state-disabled');
        $('#createsubscriptionButton').attr('disabled', true).addClass('ui-state-disabled');
        $('#createSubscriptionsPackButton').attr('disabled', true).addClass('ui-state-disabled');
        $('#createtestlessionButton').attr('disabled', true).addClass('ui-state-disabled');
        $('#createtaskButton').attr('disabled', true).addClass('ui-state-disabled');
        $('#editclientButton').attr('disabled', true).addClass('ui-state-disabled');
        $('#createreservationButton').attr('disabled', true).addClass('ui-state-disabled');
        $('#createMultiSubscriptionButton').attr('disabled', true).addClass('ui-state-disabled');
        $('#addToRecipientsButton').attr('disabled', true).addClass('ui-state-disabled');
    };

    var clearChildInfo = function () {
        disableButtons();

        $('#visitKindergarten').html('');
        $('#visitSchool').html('');
        $('#visitedCourses').children(null).remove();
        $('#desiredCourses').children(null).remove();
        $('#visitedCourses').html('');
        $('#desiredCourses').html('');
        $('#firstname').html('');
        $('#lastname').html('');
        $('#parentname').html('');
        $('#infosource').html('');
        $('#familydept').html('');
        $('#familyDeptContainer').css('color', 'black');
        $('#interest').html('');
        $('#location').html('');
        $('#contactAuthor').html('');
        $('#familyname').html('');
        $('[id=phone]').html('');
        $('#email').html('');
        $('#additionalEmail').html('');
        $('#address').html('');
        $('#additionalPhone').html('');
        $('#agreementsNumbers').html('');
        $('#depositTitle').html('');
        $('#deposit').html('');
        $('#familyDiscount').html('');
        $('#age').html('');
        $('#childcomment').html('');
        $('#familycomment').html('');
        $('#childrenfamilylist').html('');
        $('#filterControls').hide();
        $('#organizations').html('');
        $('#childPhoto').attr('src', '');
        $('#childPhoto').hide();
        $('#deleteChildPhotoLink').hide();
        $('#uploadChildPhotoLinkDiv').hide();
        $('#deleteChildPhotoLinkDiv').hide();
        $('#sendNotifications').html('');
        $('#childCreateDate').html('');
        $('#familyCreateDate').html('');
        $('#childAgreementNumber').html('');
        $('#childAgreementDate').html('');
        $('#barcodeImage').html('');
        $('#barcodeLinks').hide();
        $('#barcodeTimezoneImage').html('');
        $('#barcodeTimezoneLinks').hide();
        $('#barcodeTimezoneLinks2').hide();
        $('#requestLinks').hide();

        $('#subscriptionsList').children(null).remove();
        $('#tasksList').children(null).remove();

        commonHelper.hidePaginator('membershiplist');
        commonHelper.showEmptyList('membershiplist');

        commonHelper.hidePaginator('tasklist');
        commonHelper.showEmptyList('tasklist');

        $('#clientinfotabs').tabs('select', 0);

    };

    var fillTasksInfo = function (data) {
        $('#tasksList').children(null).remove();
        if (data.rows.length > 0) {
            $('#taskRowTemplate').clone().appendTo($('#tasksList'));
            $('#tasksList').directives({
                    '.taskRow': {
                        'row <- rows': {
                            '@id': 'row.taskid',
                            '@data-request': 'row.requestId',
                            '.subject': 'row.subject',
                            '.type': 'row.type.title',
                            '.status': 'row.status.title',
                            '.date': 'row.date',
                            '.comment': 'row.fullcomment',
                            '.organization': 'row.organizationName'
                        }
                    }
                }
            ).render(data);

            $('#tasksList').children(null).filter(':even').addClass('evenRow');
            $('#tasksList').children(null).filter(':odd').addClass('oddRow');
            $('#tasksList').children(null).each(function(){if($(this).attr('data-request')){$(this).addClass('greyRow');}});

            if (ORGS_COUNT > 0) {
                $('#tasksList').find('.organizationCell').show();
            } else {
                $('#tasksList').find('.organizationCell').hide();
            }


            commonHelper.hideEmptyList('tasklist');

            taskSelectedPage = data.page;
            commonHelper.generatePaginator('tasklist', taskSelectedPage, data.total, function (page) {
                taskSelectedPage = page;
                reloadTasksList();
            });
            $('#tasksList').children(null).show();

        } else {
            commonHelper.hidePaginator('tasklist');
            commonHelper.showEmptyList('tasklist');
        }
    };

    var fillPhoneCallsInfo = function (data) {
        $('#phoneCallList').children(null).remove();
        if (data.rows.length > 0) {
            $('#phoneCallRowTemplate').clone().appendTo($('#phoneCallList'));
            var callRow = $('#phoneCallList').directives({
                '.phoneCallRow': {
                    'row <- rows': {
                        '@id': 'row.phonecallid',
                        '.date': function (context) {
                            return context.item.date + ' ' + context.item.time;
                        },
                        '.phoneNumber': 'row.phoneNumber',
                        '.infoSource': 'row.infoSource',
                        '.family': 'row.family',
                        '.duration': 'row.duration',
                        '.internalPhone': 'row.internalPhone',
                        '.adCompany': 'row.adCompany',
                        '.marketingRequest': 'row.marketingRequest',
                        '.status': function (context) {
                            switch (context.item.status) {
                                case 'ADOPTED':
                                    return messages['client.call.status.adopted'];
                                case 'REJECTED':
                                    return messages['client.call.status.rejected'];
                                case 'PHONED':
                                    return messages['client.call.status.phoned'];
                                case 'NOT_PHONED':
                                    return messages['client.call.status.notphoned'];
                            }
                            return "";
                        },
                        '.externalPhone': 'row.externalPhone',
                        '.organization': 'row.organization',
                        '.user': 'row.user',
                        '.type': function (context) {
                            switch (context.item.type) {
                                case 'INCOME':
                                    return messages['client.call.type.income'];
                                case 'OUTCOME':
                                    return messages['client.call.type.outcome'];
                            }
                            return "";
                        },
                        '.record': function (context) {
                            switch (context.item.record) {
                                case 'LINK':
                                    return '<a href="javascript:void(0)" onclick="currentPage.statistics.loadRecordByLink(' + context.item.phonecallid + ')">' + messages['client.call.record.download'] + '</a>';
                                case 'DOWNLOADED':
                                    return '<a target="_blank" href="phone.htm?method=downloadFile&callid=' + context.item.phonecallid + '">' + messages['client.call.record.open'] + '</a>';
                            }
                            return messages['client.call.record.none'];
                        }
                    }
                }}
            ).render(data);

            commonHelper.hideEmptyList('phoneCallList');

            phoneCallSelectedPage = data.page;
            commonHelper.generatePaginator('phoneCallList', phoneCallSelectedPage, data.total, function (page) {
                phoneCallSelectedPage = page;
                reloadPhoneCallsList();
            });
            $('#phoneCallList').children(null).show();

        } else {
            commonHelper.hidePaginator('phoneCallList');
            commonHelper.showEmptyList('phoneCallList');
        }
    };

    var fillFamilyInfo = function (data) {
        $('#familyname').html(data.family.familyName);
        $('#parentname').html(data.family.parentName);
        $('[id=phone]').html(data.family.phone);
        $('#additionalPhone').html(data.family.additionalPhone);
        $('#agreementsNumbers').html(data.family.agreementsNumbers);
        $('#email').html(data.family.email);
        $('#additionalEmail').html(data.family.additionalEmail);
        $('#address').html(data.family.address);
        $('#depositTitle').html(' ' + MONEY_NAME);
        $('#deposit').html(data.family.deposit);
        $('#familyDiscount').html(data.family.familyDiscount);
        $('#infosource').html(data.family.infoSource != null ? data.family.infoSource.name : '');
        $('#familydept').html(data.dept);
        if (data.dept > 0) {
            $('#familyDeptContainer').css('color', 'red');
        } else {
            $('#familyDeptContainer').css('color', 'green');
        }

        $('#interest').html(data.family.interest != null ? data.family.interest.title : '');
        $('#location').html(data.family.location != null ? data.family.location.name : '');
        $('#contactAuthor').html(data.family.contactAuthor != null ? data.family.contactAuthor.name : '');
        $('#familycomment').html(data.family.comment);
        $('#sendNotifications').html(data.family.notificationDestinationsString);
        $('#familyCreateDate').html(data.family.createDate);

        var childrenlistContainer = $('#childrenfamilylist');
        childrenlistContainer.children(null).remove();
        $.each(data.family.kids, function (index, item) {
            var kidLink = $('<a>', {
                href: 'client.htm?childid=' + item.id,
                style: 'margin-right: 5px;'
            }).html(item.firstName);
            kidLink.appendTo(childrenlistContainer);
        });

        var organizations = $('#organizations');
        var organizationsList = '';
        $.each(data.familyOrganizations, function (index, item) {
            organizationsList += item.name;
            if (index < data.familyOrganizations.length - 1) {
                organizationsList += ', ';
            }
        });
        organizations.html(organizationsList);

    };

    var fillSubscriptionInfo = function (data) {
        if (data.subscriptions.oldcount > 0 || data.subscriptions.allcount > 0 || data.subscriptions.activecount > 0) {
            $('#subscriptionfilter_active_count').html(data.subscriptions.activecount);
            $('#subscriptionfilter_old_count').html(data.subscriptions.oldcount);
            $('#subscriptionfilter_all_count').html(data.subscriptions.allcount);
            $('#filterControls').show();
            $('#subscriptionsList').children(null).remove();

            var subscriptionRowTemplate = $('#subscriptionRowTemplate');
            var subscriptionsPackRowTemplate = $('#subscriptionsPackRowTemplate');

            $.each(data.subscriptions.list, function (index, item) {
                switch (item.type) {
                    case 'subscriptionsPack':
                        $('#subscriptionsList').append(
                            subscriptionsPackRowTemplate.clone().removeAttr('id').
                                directives({
                                    '@id': 'id',
                                    '@membershiptype': 'type',
                                    '.membershipType': membershipType,
                                    '.subscriptionNumber': function (context) {
                                        return context.context.customNumber && context.context.customNumber != '' ? context.context.customNumber : context.context.number
                                    },
                                    '.startDate': 'startDate',
                                    '.finishDate': 'finishDate',
                                    '.membershipElement': {
                                        'element <- membershipsInfo': {
                                            '@id' : 'element.id',
                                            '@membershiptype' : 'element.type',
                                            '.courseName': 'element.courseName',
                                            '.teacherName': 'element.schedule.teacherInfo',
                                            '.weekDays': 'element.scheduleDaysInfo',
                                            '.elementDays': function (context) {
                                                var result = '';
                                                $.each(this.membershipElements, function (index, element) {
                                                    result += (result != '' ? ', ' : '') + element.plannedDate + ' ' + element.plannedStartTime
                                                });
                                                return result;
                                            }
                                        }
                                    },
                                    '.organization': 'organizationName'
                                }).render(item));
                        break;
                    default:
                        var row = subscriptionRowTemplate.clone().removeAttr('id').
                                directives({
                                    '@id': 'id',
                                    '@multisubscriptionId': 'multiSubscriptionId',
                                    '.course': 'courseName',
                                    '.teacher': 'schedule.teacherInfo',
                                    '.deletedstatus': generateSubscriptionStatus,
                                    '.membershipType': membershipType,
                                    '.subscriptionComment': 'subscriptionComment',
                                    '@membershiptype': 'type',
                                    '.subscriptionNumber': function (context) {
                                        return context.context.customNumber && context.context.customNumber != '' ? context.context.customNumber : context.context.number
                                    },
                                    '.fullPrice': fullPrice,
                                    '.printbutton@style+': printButtonType,
                                    '.changebutton@style+': changeButtonType,
                                    '.sendbutton@style+' : sendButtonType,
                                    '.cancelSubscriptionLink@subscriptionType': cancelSubscriptionLinkType,
                                    '.prolongAsSubscription@style+': prolongAsSubscriptionButtonType,
                                    '.prolongAsOnce@style+': prolongAsOnceButtonType,
                                    '.prolongAsOnceByMultiSubscription@style+': prolongAsOnceBySubscriptionButtonType,
                                    '.editbutton@style+': editButtonType,
                                    '.convertLink@style+': convertLinkType,
                                    '.convertLink': convertLink,
                                    '.removePartMembershipLink@style+': removePartMembershipLink,
                                    '.scheduleelement': {
                                        'element <- membershipElements': {
                                            '.room': 'element.plannedRoomTitle',
                                            '.courseName': 'element.courseName',
                                            '.startTime': 'element.plannedStartTime',
                                            '.finishTime': 'element.plannedFinishTime',
                                            '.actualStartTime': 'element.actualStartTime',
                                            '.actualFinishTime': 'element.actualFinishTime',
                                            '.plannedDate': 'element.plannedDate',
                                            '.actualWeekDay': actualWeekDay,
                                            '.actualDate': 'element.actualDate',
                                            '.plannedWeekDay': plannedWeekDay,
                                            '.visited': generateVisited,
                                            '.visited@title': generateVisitedTitle,
                                            '.visited@alt': generateVisitedTitle,
                                            '.visited@membershipelementid': 'element.id',
                                            '.visited@state': generatestate,
                                            '.compensation@membershipelementid': 'element.id',
                                            '.compensation@compensationid': 'element.compensationId',
                                            '.compensation@compensatedtype': 'membershipTypeCode',
                                            '.compensation': compensationtext,
                                            '.compensation@style': compensationstyle,
                                            '.lastCompensationDate': function (context) {
                                                return context.item.lastCompensationDate ? 'до ' + context.item.lastCompensationDate : ''
                                            },
                                            '.compensationContainer@style': compensationContainerstyle
                                        }
                                    },
                                    '.organization': 'organizationName',
                                    '.scheduledays': 'scheduleDaysInfo',
                                    '.barcode': function (context) {
                                        var result = '';
                                        if(context.context.barcode){
                                            commonHelper.checkFeature('BARCODE', function(){
                                                result = '<img src="barcode.htm?method=showBarcode&amp;code=' + context.context.barcode + '" alt="' + context.context.barcode + '"><br/>' + context.context.barcode;
                                            });
                                        }
                                        return result;
                                    }
                                }).render(item);
                        $('#subscriptionsList').append(row);
                        if(item.packId){
                            row.find('.inpack').attr('subscriptionPackId', item.packId).show();
                        }
                }
            });

            $('#subscriptionsList').children(null).filter(':even').addClass('evenRow');
            $('#subscriptionsList').children(null).filter(':odd').addClass('oddRow');

            if (data.subscriptions.pagecount > 0) {
                subscriptionSelectedPage = data.subscriptions.page;
                commonHelper.generatePaginator('membershiplist', subscriptionSelectedPage, data.subscriptions.pagecount, function (page) {
                    subscriptionSelectedPage = page;
                    reloadSubscriptionList(true);
                });
                commonHelper.hideEmptyList('membershiplist');
            } else {
                commonHelper.hidePaginator('membershiplist');
                commonHelper.showEmptyList('membershiplist');
            }

            $('#subscriptionsList').children(null).show();
        }
    };

    var compensationtext = function (context) {
        return context.item.compensationId ? messages['client.compensation.complete'] : messages['client.compensation.inprogress'];
    };

    var compensationstyle = function (context) {
        return context.item.compensationId ? 'font-weight: bold;' : '';
    };

    var compensationContainerstyle = function (context) {
        var lessonDateStr = context.item.actualDate ? context.item.actualDate : context.item.plannedDate;
        var lessonDate = commonHelper.parseDate(lessonDateStr);
        return context.item.visited || (lessonDate >= new Date()) || context.item.notVisitedGoodReason === false ? 'visibility : hidden;' : '';
    };

    var fillChildInfo = function (data) {
        $('#firstname').html(data.child.firstName);
        $('#lastname').html(data.child.lastName);
        $('#age').html(data.child.age);
        $('#childcomment').html(data.child.comment);
        $('#visitKindergarten').html(data.child.visitKindergarten ? messages['client.visit.yes'] : messages['client.visit.no']);
        $('#visitSchool').html(data.child.visitSchool ? messages['client.visit.yes'] : messages['client.visit.no']);
        $('#childCreateDate').html(data.child.createDate);
        $('#childAgreementDate').html(data.child.agreementDate);
        $('#childAgreementNumber').html(data.fullAgreementNumber);

        if (data.child.photoBinaryDataId) {
            $('#childPhoto').attr('src', 'family.htm?method=childPhoto&childid=' + data.child.id);
            $('#childPhoto').show();
            $('#deleteChildPhotoLink').show();
        } else {
            $('#childPhoto').attr('src', '');
            $('#childPhoto').hide();
            $('#deleteChildPhotoLink').hide();
        }

        $('#uploadChildPhotoLinkDiv').show();
        $('#deleteChildPhotoLinkDiv').show();

        var divVisitedCourses = $('#visitedCourses');
        $.each(data.visitedCourses, function (index, item) {
            $('<div>').html('<span>[' + item.courseName + '-' + item.teacherName + ']' + '</span>').appendTo(divVisitedCourses);
        });

        var divDesiredCourses = $('#desiredCourses');
        $.each(data.child.desiredCourses, function (index, item) {
            $('<span>').html('' + item.name + '' + (index < data.child.desiredCourses.length - 1 ? ', ' : '')).appendTo(divDesiredCourses);
        });

        commonHelper.checkFeature('BARCODE', function () {
            if(data.child.barcode){
                $('#barcodeImage').html('<img src="barcode.htm?method=showBarcode&childCode=' + data.child.barcode + '" alt="' + data.child.barcode + '" />');
            }
            $('#barcodeLinks').show();
            if(data.child.timezoneBarcode){
                $('#barcodeTimezoneImage').html('<img src="barcode.htm?method=showBarcode&code=' + data.child.timezoneBarcode + '" alt="' + data.child.timezoneBarcode + '" />');
                $('#barcodeTimezoneLinks2').show();
            }
            else {
                $('#barcodeTimezoneLinks').show();
            }
        }, function () {});

        commonHelper.checkFeature('MARKETING', function () {
            $('#requestLinks').find('a').attr('data-request', '');
            if(data.requestId){
                $('#requestLinks').find('a').attr('data-request', data.requestId);
                $('#requestLinks').show();
            }
        }, function () {});
    };

    var actualWeekDay = function (context) {
        return getDayTitle(context.item.actualDate);
    };
    var plannedWeekDay = function (context) {
        return getDayTitle(context.item.plannedDate);
    };

    var getDayTitle = function (dateStr) {
        if (dateStr) {
            var dayNumber = commonHelper.parseDate(dateStr).getDay();
            switch (dayNumber) {
                case 0:
                    return 'вс';
                case 1:
                    return 'пн';
                case 2:
                    return 'вт';
                case 3:
                    return 'ср';
                case 4:
                    return 'чт';
                case 5:
                    return 'пт';
                case 6:
                    return 'сб';
            }
        }
        return '';
    };


    var editButtonType = function (context) {
        var object = context.context;
        var showButton = false;
        showButton |= object.type == 'onceLesson';
        showButton |= object.type == 'reservation';
        showButton |= object.type == 'subscription';
        showButton |= object.type == 'subscriptionsPack';
        showButton |= object.schedule && object.schedule.scheduleType == 'event';
        showButton |= checkSchedule(context) || object.type == 'multisubscription';
        if (!showButton) {
            return 'display : none';
        } else {
            return '';
        }
    };

    var sendButtonType = function(context) {
        if (!checkSchedule(context) || context.context.membershipTypeCode == 'multisubscription') {
            return 'display : none';
        }
        return '';
    };

    var printButtonType = function (context) {
        var object = context.context;
        if (object.type == 'reservation' || !checkSchedule(context)) {
            return 'display : none';
        } else {
            return '';
        }
    };

    var cancelSubscriptionLinkType = function (context) {
        return context.context.type;
    };

    var changeButtonType = function (context) {
        var object = context.context;
        if (object.type == 'reservation' || !checkSchedule(context)) {
            return 'display : none';
        } else {
            return '';
        }
    };

    var prolongAsSubscriptionButtonType = function (context) {
        if (!checkSchedule(context) || context.context.membershipTypeCode == 'multisubscription') {
            return 'display : none';
        }
        return '';
    };

    var prolongAsOnceBySubscriptionButtonType = function (context) {
        var object = context.context;
        return object.type == 'multisubscription' ? '' : 'display : none';
    };

    var prolongAsOnceButtonType = function (context) {
        var object = context.context;
        if (!checkSchedule(context)) {
            return 'display : none';
        }
        return '';
    };

    var checkSchedule = function (context) {
        return context.context.schedule ? context.context.schedule.active : false;
    };

    var convertLinkType = function (context) {
        var object = context.context;
        if (!checkSchedule(context) && object.type != 'multisubscription') {
            return 'display : none';
        }
        return '';
    };

    var removePartMembershipLink = function (context) {
        if (!checkSchedule(context)) {
            return 'display : none';
        }
        return '';
    };

    var convertLink = function (context) {
        var object = context.context;
        if (object.type == 'multisubscription') {
            return messages['client.create']
        } else if (object.type == 'reservation') {
            return messages['common.save'];
        } else {
            return messages['client.prolong'];
        }
    };

    var fullPrice = function (context) {
        var object = context.context;
        if (object.fullPrice) {
            if (object.paid) {
                return '<span style="color: green;font-size: 12px;">' + messages['client.payed'] + ' ' + object.fullPrice + ' ' + MONEY_NAME + '</span>';
            } else {
                return '<span style="color: red;font-size: 12px;">' + messages['client.payed'] + ' ' + object.paidSum + ' ' + MONEY_NAME + ' ' + messages['client.payed2'] + ' ' + object.fullPrice + ' ' + MONEY_NAME + '</span>';
            }
        }
        return '';
    };

    var membershipType = function (context) {
        var object = context.context;
        if (object.type == 'subscriptionsPack') {
            return messages['client.type.pack']
        } else if (object.type == 'subscription') {
            return messages['client.type.subscription'] + (object.membershipTypeName ? ': ' + object.membershipTypeName : '');
        } else if (object.type == 'onceLesson') {
            return messages['client.type.oncelesson'] + ' ' + (object.membershipTypeName ? object.membershipTypeName : '');
        } else if (object.type == 'reservation') {
            return messages['client.type.reservation'];
        } else if (object.type == 'multisubscription') {
            return messages['client.type.multisubscription'];
        }
        return '';
    };

    var generatestate = function (context) {
        if (context.context.visited) {
            return 'visited';
        } else if (context.context.notVisitedGoodReason === true) {
            return 'not-visited-with-reason';
        } else {
            return 'not-visited-without-reason';
        }
    };

    var generateVisitedTitle = function (context) {
        if (!context.context.visited) {
            if (context.context.notVisitedGoodReason === true) {
                return messages['client.notvisited.goodreason'];
            } else if (context.context.missed) {
                return messages['client.notvisited.notgoodreason'];
            }
        }
        return '';
    };

    var generateVisited = function (context) {
        //if (context.row.item.type != 'reservation') {
        if (context.item.visited) {
            return '\u2714';
        } else {
            if (context.item.missed) {
                if (context.item.notVisitedGoodReason === true) {
                    return '~';
                } else {
                    return 'x';
                }
            }
        }
        //}
        return '';
    };

    var generateSubscriptionStatus = function (context) {
        return context.context.removed ? 'УДАЛЕН' : '';
    };

    that.changeVisited = function (membershipElementId, currentState, visitedLink, compensationLink) {
        switch (currentState) {
            case 'visited' :
                commonHelper.callAjaxMethod('visits.htm', 'cancelAsVisited', {subscriptionElementId: membershipElementId}, function (data) {
                    if (data) {
                        compensationLink.parent().css('visibility', 'hidden');
                        visitedLink.html('x');
                        visitedLink.attr('state', 'not-visited-without-reason');
                        visitedLink.attr('title', messages['client.notvisited.notgoodreason']);
                        visitedLink.attr('alt', messages['client.notvisited.notgoodreason']);
                    }
                });
                break;
            case 'not-visited-without-reason':
                commonHelper.callAjaxMethod('visits.htm', 'markAsNotVisitedWithReason', {subscriptionElementId: membershipElementId}, function (data) {
                    if (data) {
                        compensationLink.parent().css('visibility', 'visible');
                        visitedLink.html('~');
                        visitedLink.attr('state', 'not-visited-with-reason');
                        visitedLink.attr('title', messages['client.notvisited.goodreason']);
                        visitedLink.attr('alt', messages['client.notvisited.goodreason']);
                    }
                });
                break;
            case 'not-visited-with-reason':
                commonHelper.callAjaxMethod('visits.htm', 'markAsVisited', {subscriptionElementId: membershipElementId}, function (data) {
                    if (data) {
                        compensationLink.parent().css('visibility', 'hidden');
                        visitedLink.html('\u2714');
                        visitedLink.attr('state', 'visited');
                        visitedLink.attr('title', messages['client.visited']);
                        visitedLink.attr('alt', messages['client.visited']);
                    }
                });
                break;
        }
    };

    this.editClient = function () {
        if ((selectedChildId && selectedChildId != '') || (selectedFamilyId && selectedFamilyId != '')) {
            DIALOGS.familyDialogs.editFamilyDialog(selectedFamilyId && selectedFamilyId != '' ? selectedFamilyId : '', selectedChildId && selectedChildId != '' ? selectedChildId : '', function (family) {
                if (selectedChildId && selectedChildId != '') {
                    if (family.kids.length > 0) {
                        var kid = findKid(family.kids, selectedChildId);
                        if (kid != null) {
                            AUTOCOMPLETE_SEARCH_FIELD.setTitle('childnamefilter', kid.firstName + ' ' + kid.lastName);
                            selectChild(kid.id);
                        }
                    }
                } else if (selectedFamilyId && selectedFamilyId != '') {
                    AUTOCOMPLETE_SEARCH_FIELD.setTitle('childnamefilter', family.parentName + ' ' + family.familyName);
                    selectFamily(selectedFamilyId);
                }

            }, null, function () {
                clearChildInfo();
                selectedChildId = '';
                selectedFamilyId = '';
                AUTOCOMPLETE_SEARCH_FIELD.setValue('childnamefilter', '', '');
            });
        }
    };

    this.createOnceLesson = function (subscriptionId, action, defaultValues) {
        DIALOGS.subscriptionDialogs.openSubscriptionDialogForChild({
                childId: selectedChildId,
                familyId: selectedFamilyId,
                subscriptionId: subscriptionId,
                subscriptionType: 'onceLesson',
                childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('childnamefilter'),
                callbackFunction: function () {
                    reloadSubscriptionList(false);
                },
                deleteCallbackFunction: function () {
                    reloadSubscriptionList(false);
                },
                action: action ? action : 'edit',
                defaultValues: defaultValues
            }
        );
    };

    this.createOnceLessonByMultiSubscription = function (action, multiSubscriptionId, subscriptionId) {
        DIALOGS.subscriptionDialogs.openSubscriptionDialogForChild({
                childId: selectedChildId,
                familyId: selectedFamilyId,
                multiSubscriptionId: multiSubscriptionId,
                subscriptionId: subscriptionId,
                selectedOnceType: 'multisubscription',
                subscriptionType: 'onceLesson',
                childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('childnamefilter'),
                callbackFunction: function () {
                    reloadSubscriptionList(false);
                },
                deleteCallbackFunction: function () {
                    reloadSubscriptionList(false);
                },
                action: action ? action : 'edit'
            }
        );
    };

    this.createReservation = function (subscriptionId) {
        DIALOGS.subscriptionDialogs.openSubscriptionDialogForChild({
            childId: selectedChildId,
            familyId: selectedFamilyId,
            subscriptionId: subscriptionId,
            subscriptionType: 'reservation',
            childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('childnamefilter'),
            callbackFunction: function () {
                reloadSubscriptionList(false);
            },
            deleteCallbackFunction: function () {
                reloadSubscriptionList(false);
            },
            action: 'edit'
        });
    };

    this.createSubscriptionsPack = function (subscriptionsPackId, action) {
        DIALOGS.subscriptionsPackDialog.openSubscriptionsPackDialog({
            childId: selectedChildId,
            familyId: selectedFamilyId,
            subscriptionsPackId: subscriptionsPackId,
            childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('childnamefilter'),
            action: action ? action : 'edit',
            callbackFunction: function () {
                reloadSubscriptionList(false);
            }
        });
    };

    this.createMultiSubscription = function () {
        DIALOGS.multiSubscriptionDialog.openMultiSubscriptionDialogForChild({
            childId: selectedChildId,
            familyId: selectedFamilyId,
            callbackFunction: function () {
                reloadSubscriptionList(false);
            }
        });
    };

    this.addRecipient = function () {
        commonHelper.callAjaxMethod('statistic.htm', 'addRecipient', {"objects": JSON.stringify({childId: selectedChildId})}, function (data) {
            $('#messageRecipientsCount').html(data.currentRecipientsCount);
        });
    };

    this.createTask = function () {
        if (selectedChildId != null) {
            DIALOGS.taskEditDialog(null, selectedChildId, null, null, false, true, function () {
                reloadTasksList();
            });
        }
    };

    this.createSubscription = function (subscriptionId, action, returnMoneyStrategy) {
        DIALOGS.subscriptionDialogs.openSubscriptionDialogForChild({
            childId: selectedChildId,
            familyId: selectedFamilyId,
            subscriptionId: subscriptionId,
            subscriptionType: 'subscription',
            childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('childnamefilter'),
            callbackFunction: function () {
                reloadSubscriptionList(false);
            },
            deleteCallbackFunction: function () {
                reloadSubscriptionList(false);
            },
            action: action ? action : 'edit',
            returnMoneyStrategy: returnMoneyStrategy
        });
    };

    this.prolongSubscription = function (buttonObject, type) {
        var subscriptionId = buttonObject.parents().filter('.subscriptionRow').attr('id');
        if (type == 'subscriptionsPack') {
            that.createSubscriptionsPack(subscriptionId, 'prolong');
        }
        else {
            that.createSubscription(subscriptionId, 'prolong');
        }
    };

    this.changeSubscriptionSchedule = function (buttonObject, type) {
        var subscriptionId = buttonObject.parents().filter('.subscriptionRow').attr('id');
        DIALOGS.askQuestionDialog(messages['client.deposit.confirm'], [
            {
                variant: messages['client.deposit.future'],
                callback: function () {
                    that.createSubscription(subscriptionId, 'change', 'FUTURE');
                }
            },
            {
                variant: messages['client.deposit.notvisited'],
                callback: function () {
                    that.createSubscription(subscriptionId, 'change', 'NOT_VISITED');
                }
            }
        ]);
    };

    this.prolongOnceLesson = function (buttonObject) {
        var subscriptionId = buttonObject.parents().filter('.subscriptionRow').attr('id');
        var multiSubscriptionId = buttonObject.parents().filter('.subscriptionRow').attr('multisubscriptionid');
        if (multiSubscriptionId) {
            that.createOnceLessonByMultiSubscription('prolongByMultiSubscription', multiSubscriptionId, subscriptionId);
        } else {
            that.createOnceLesson(subscriptionId, 'prolong');

        }
    };

    this.prolongOnceLessonByMultiSubscription = function (buttonObject) {
        var multiSubscriptionId = buttonObject.parents().filter('.subscriptionRow').attr('id');
        that.createOnceLessonByMultiSubscription('prolongByMultiSubscription', multiSubscriptionId);
    };


    this.removePartMembership = function (buttonObject) {
        var subscriptionId = buttonObject.parents().filter('.subscriptionRow').attr('id');
        if (buttonObject.attr('subscriptionType') == 'reservation') {
            DIALOGS.askYesNoDialog(messages['client.removepart.reservationconfirm'], messages['common.yes'], function () {
                commonHelper.callAjaxMethod('client.htm', 'cancelSubscription', {subscriptionId: subscriptionId}, function (result) {
                    reloadSubscriptionList(false);
                });
            });
        } else {
            DIALOGS.askQuestionDialog(messages['client.removepart.confirm'], [
                {
                    variant: messages['client.removepart.future'],
                    callback: function () {
                        commonHelper.callAjaxMethod('client.htm', 'removePartMembership', {
                            subscriptionId: subscriptionId,
                            returnMoneyStrategy: 'FUTURE'
                        }, function (result) {
                            reloadSubscriptionList(false);
                        });
                    }
                },
                {
                    variant: messages['client.removepart.notvisited'],
                    callback: function () {
                        commonHelper.callAjaxMethod('client.htm', 'removePartMembership', {
                            subscriptionId: subscriptionId,
                            returnMoneyStrategy: 'NOT_VISITED'
                        }, function (result) {
                            reloadSubscriptionList(false);
                        });
                    }
                }
            ]);
        }
    };

    this.cancelSubscription = function (buttonObject) {
        var subscriptionId = buttonObject.parents().filter('.subscriptionRow').attr('id');
        var subscriptionType = buttonObject.parents().filter('.subscriptionRow').attr('membershiptype');
        if (subscriptionType == 'multisubscription') {
            DIALOGS.askYesNoDialog(messages['client.cancel.multisubscription'], messages['common.yes'], function () {
                commonHelper.callAjaxMethod('client.htm', 'cancelSubscription', {multiSubscriptionId: subscriptionId}, function (result) {
                    reloadSubscriptionList(false);
                });
            });
        } else if (subscriptionType == 'reservation') {
            DIALOGS.askYesNoDialog(messages['client.cancel.reservation'], messages['common.yes'], function () {
                commonHelper.callAjaxMethod('client.htm', 'cancelSubscription', {subscriptionId: subscriptionId}, function (result) {
                    reloadSubscriptionList(false);
                });
            });
        } else if (subscriptionType == 'subscriptionsPack') {
            DIALOGS.askYesNoDialog(messages['client.cancel.pack'], messages['common.yes'], function () {
                commonHelper.callAjaxMethod('client.htm', 'cancelSubscriptionsPack', {subscriptionId: subscriptionId}, function (result) {
                    reloadSubscriptionList(false);
                });
            });
        } else {
            DIALOGS.askYesNoDialog(messages['client.cancel.subscription'], messages['common.yes'], function () {
                commonHelper.callAjaxMethod('client.htm', 'cancelSubscription', {subscriptionId: subscriptionId}, function (result) {
                    reloadSubscriptionList(false);
                });
            });
        }
    };
    
    this.editSubscription = function (buttonObject) {
        var subscriptionId = buttonObject.parents().filter('.subscriptionRow').attr('id');
        var subscriptionType = buttonObject.parents().filter('.subscriptionRow').attr('membershiptype');
        if (subscriptionType == 'subscriptionsPack') {
            DIALOGS.subscriptionsPackDialog.openSubscriptionsPackDialogForChild({
                id: subscriptionId,
                childId: selectedChildId,
                familyId: selectedFamilyId,
                callbackFunction: function () {
                    reloadSubscriptionList(false);
                }
            });
        } else if (subscriptionType == 'multisubscription') {
            DIALOGS.multiSubscriptionDialog.openMultiSubscriptionDialogForChild({
                id: subscriptionId,
                childId: selectedChildId,
                familyId: selectedFamilyId,
                callbackFunction: function () {
                    reloadSubscriptionList(false);
                }
            });
        } else {
            DIALOGS.subscriptionDialogs.openSubscriptionDialogForChild({
                childId: selectedChildId,
                familyId: selectedFamilyId,
                subscriptionId: subscriptionId,
                subscriptionType: subscriptionType,
                childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('childnamefilter'),
                callbackFunction: function () {
                    reloadSubscriptionList(false);
                },
                deleteCallbackFunction: function () {
                    reloadSubscriptionList(false);
                },
                action: 'edit'
            });
        }
    };

    this.editSubscriptionParentPack = function(buttonObject){
        var subscriptionPackId = buttonObject.parent().attr('subscriptionPackId');
        DIALOGS.subscriptionsPackDialog.openSubscriptionsPackDialogForChild({
            id: subscriptionPackId,
            childId: selectedChildId,
            familyId: selectedFamilyId,
            callbackFunction: function () {
                reloadSubscriptionList(false);
            }
        });
    };

    this.sendSubscription = function(buttonObject) {
        var subscriptionId = buttonObject.parents().filter('.subscriptionRow').attr('id');

        commonHelper.callAjaxMethod('client.htm', 'sendSubscription', {subscriptionId: subscriptionId}, function (result) {
            if (result.length > 0) {
                commonHelper.showMessage(messages['client.send'] + result);
            } else {
                commonHelper.showMessage(messages['client.not_sent']);
            }
        });
    };

    this.printSubscription = function (buttonObject) {
        var subscriptionId = buttonObject.parents().filter('.subscriptionRow').attr('id');
        var subscriptionType = buttonObject.parents().filter('.subscriptionRow').attr('membershiptype');
        if (subscriptionType == 'subscriptionsPack') {
            if (!CLIENT_PRINTING) {
                commonHelper.callAjaxMethod('client.htm', 'printSubscriptionPack', {subscriptionPackId: subscriptionId}, function (result) {
                    commonHelper.showMessage(messages['client.print']);
                });
            } else {
                commonHelper.openPdfPrintDialog('client.htm?method=printSubscriptionPackFromClient&subscriptionPackId=' + subscriptionId);
            }
        }
        else {
            if (!CLIENT_PRINTING) {
                commonHelper.callAjaxMethod('client.htm', 'printSubscription', {subscriptionId: subscriptionId}, function (result) {
                    commonHelper.showMessage(messages['client.print']);
                });
            } else {
                commonHelper.openPdfPrintDialog('client.htm?method=printSubscriptionFromClient&subscriptionId=' + subscriptionId);
            }
        }
    };


    this.selectSubscriptionFilter = function (button, filterType) {
        $('.subscriptionfilter').removeClass('switcherOn');
        $('.subscriptionfilter').addClass('switcherOff');
        button.addClass('switcherOn');
        subscriptionFilter = filterType;
        subscriptionSelectedPage = 1;
        reloadSubscriptionList(true);

    };

    this.createClient = function (defaultValues) {
        DIALOGS.familyDialogs.editFamilyDialog(null, null, function (family) {
            if (family.kids.length > 0) {
                var kid = family.kids[family.kids.length - 1];
                AUTOCOMPLETE_SEARCH_FIELD.setValue('childnamefilter', kid.id, kid.firstName + ' ' + kid.lastName);
                selectChild(kid.id);
            } else {
                AUTOCOMPLETE_SEARCH_FIELD.setTitle('childnamefilter', family.parentName + ' ' + family.familyName);
                selectFamily(family.id);
            }
        }, null, null, defaultValues);
    };

    this.createOrEditCompensation = function (subscriptionId, membershipelementid, compensationid, compensatedtype, container) {
        if (compensationid) {
            DIALOGS.subscriptionDialogs.editCompensation({
                childId: selectedChildId,
                familyId: selectedFamilyId,
                childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('childnamefilter'),
                subscriptionId: compensationid,
                callbackFunction: function () {
                    reloadSubscriptionList(false);
                },
                deleteCallbackFunction: function () {
                    reloadSubscriptionList(false);
                }
            });
        } else {
            if (compensatedtype == 'compensation') {
                commonHelper.showMessage(messages['client.compensation.error']);
            } else {
                DIALOGS.subscriptionDialogs.openSubscriptionDialogForCompensation(
                    {
                        childId: selectedChildId,
                        familyId: selectedFamilyId,
                        membershipElementId: membershipelementid,
                        childFamilyTitle: AUTOCOMPLETE_SEARCH_FIELD.getTitle('childnamefilter'),
                        callbackFunction: function () {
                            reloadSubscriptionList(false);
                        },
                        deleteCallbackFunction: function () {
                            reloadSubscriptionList(false);
                        }
                    }
                );
            }
        }
    };

    var findKid = function (kids, childid) {
        for (var kidIndex in kids) {
            if (kids[kidIndex].id == childid) {
                return kids[kidIndex];
            }
        }
        return null;
    };

    that.barcodeCreate = function () {
        if(selectedChildId){
            commonHelper.callAjaxMethod('client.htm', 'barcodeCreate', {childId: selectedChildId}, function (result) {
                if(result.barcode){
                    $('#barcodeImage').html('<img src="barcode.htm?method=showBarcode&childCode=' + result.barcode + '" alt="' + result.barcode + '" />');
                    commonHelper.showMessage(messages['client.barcode.created']);
                }
                else {
                    commonHelper.showMessage(messages['client.barcode.doubleerror']);
                }
            });
        }
    };
    
    that.barcodeRead = function () {
        if(selectedChildId){
            DIALOGS.openBarcodeDialog(function(reader, barcode){
                commonHelper.callAjaxMethod('client.htm', 'barcodeCreate', {childId: selectedChildId, barcode: barcode}, function (result) {
                    if(result.barcode){
                        $('#barcodeImage').html('<img src="barcode.htm?method=showBarcode&childCode=' + result.barcode + '" alt="' + result.barcode + '" />');
                        commonHelper.showMessage(messages['client.barcode.assigned']);
                    }
                    else if(result.status && result.status == 'exists') {
                        commonHelper.showMessage(messages['client.barcode.disabled']);
                    }
                    else if(result.status && result.status == 'incorrect') {
                        commonHelper.showMessage(messages['client.barcode.formaterror']);
                    }
                    else {
                        commonHelper.showMessage(messages['client.barcode.repeaterror']);
                    }
                });
            });
        }
    };
    
    that.barcodePrint = function () {
        commonHelper.openPdfPrintDialog('barcode.htm?method=printBarcode&childId=' + selectedChildId);
    };

    that.barcodeTimezoneRead = function () {
        if(selectedChildId){
            DIALOGS.openBarcodeDialog(function(reader, barcode){
                commonHelper.callAjaxMethod('client.htm', 'assignTimezoneBarcode', {childId: selectedChildId, timezoneBarcode: barcode}, function (result) {
                    if(result.timezoneBarcode){
                        $('#barcodeTimezoneImage').html('<img src="barcode.htm?method=showBarcode&code=' + result.timezoneBarcode + '" alt="' + result.timezoneBarcode + '" />');
                        $('#barcodeTimezoneLinks').hide();
                        $('#barcodeTimezoneLinks2').show();
                        commonHelper.showMessage(messages['client.timezone.assigned']);
                    }
                    else {
                        commonHelper.showMessage(messages['client.timezone.assignerror']);
                    }
                });
            });
        }
    };

    that.barcodeTimezoneRemove = function () {
        DIALOGS.askYesNoDialog(messages['client.timezone.removeconfirm'], messages['common.yes'], function () {
            commonHelper.callAjaxMethod('client.htm', 'unassignTimezoneBarcode', {childId: selectedChildId}, function (result) {
                if(result.status && result.status == 'unassigned'){
                    $('#barcodeTimezoneImage').html('');
                    $('#barcodeTimezoneLinks').show();
                    $('#barcodeTimezoneLinks2').hide();
                }
                else {
                    commonHelper.showMessage(messages['client.timezone.removeerror']);
                }
            });
        }, function(){}, messages['common.no']);
    };

    var reloadGradebookTab = function () {
        if(that.gradebook == null){
            that.gradebook = new schedulerGradebook_helper(that, false);
            that.gradebook.initFilterPane();
        }
        that.gradebook.setFixedChild(selectedChildId);
	};

    that.openRequest = function () {
        window.open('marketing.htm?action=openDialog&actionParameters=' + JSON.stringify({
                requestid: $('#requestLinks').find('a').attr('data-request'),
            }), '_blank');
    };

    return that;
}function family_helper() {
    var that = this;
    var selectedPage = 1;
    this.pageReady = function () {
        loadFamilies();
        $("input:submit, button").not('[id="editchild-deletebutton-templateDiv"]').button();

    };

    this.openSaveDialog = function (id) {
        DIALOGS.familyDialogs.editFamilyDialog(id, null, function () {
            that.filterList();
            if (id) {
                updateSelectedFamily(id);
            }
        });
    };

    var deleteFamily = function (id) {
        commonHelper.callNAjaxMethod('family.htm', 'deleteFamily', {familyId:id}, function (result) {
            clearFamilyInfo();
            that.filterList();
        })
    };

    var updateSelectedFamily = function (id) {
        commonHelper.callAjaxMethod('family.htm', 'getFamilyInformation', {familyId:id}, function (result) {
            if ($('#familyInfoPanel-' + id).length > 0) {
                clearFamilyInfo();
                selectFamily(id);
            }
        });
    };

    var selectFamily = function (id) {
        try {
            var familyId = parseInt(id, 10);
            if (!isNaN(familyId)) {
                clearFamilyInfo();
                commonHelper.callAjaxMethod('family.htm', 'getFamilyInformation', {familyId:familyId}, function (result) {
                    result.panelId = 'familyInfoPanel-' + familyId;
                    var familyInfoPanel = $('#familyInfoPanel');
                    var familyPanel = $('#familyInfoPanel').clone().directives(
                        {
                            '.@id':'panelId',
                            '.parentName':'parentName',
                            '.familyName':'familyName',
                            '.infoSource':'infoSource.name',
                            '.interest':'interest.title',
                            '.phone':'phone',
                            '.email':'email',
                            '.address' : 'address',
                            '.comment':'comment',
                            '.kids':{
                                "kid <- kids":{
                                    ".firstName":"kid.firstName",
                                    ".lastName":"kid.lastName",
                                    ".birthDate":"kid.birthDate",
                                    ".kindergarten":"kid.kindergarten",
                                    ".age":"kid.age",
                                    ".comment":"kid.comment"
                                }
                            }
                        }).render(result).show().appendTo('#familyInfo');

                    var familyInfoList = $('#familyInfo').find('.kidTable');
                    familyInfoList.filter(':even').addClass('evenRow');
                    familyInfoList.filter(':odd').addClass('oddRow');


                    familyPanel.find('[name="deleteFamily"]').attr('name', 'deletebutton-' + familyId);
                    familyPanel.find('[name="editFamily"]').attr('name', 'deletebutton-' + familyId);
                });
            }
        } catch (e) {
        }
    };


    this.deleteFamilyDialogById = function (id) {
        var dialog = $('#deleteFamilyDialog').dialog({
            height:210,
            width:350,
            modal:true,
            buttons:[
                {
                    text:messages['common.remove'],
                    click:function () {
                        deleteFamily(id);
                        $(this).dialog('close');
                    }
                },
                {
                    text:messages['common.close'],
                    click:function () {
                        $(this).dialog('close');
                    }
                }
            ]

        });
    };

    this.deleteFamilyDialog = function (element) {
        var id = $(element).parents().filter('.familyRow').attr('id');
        that.deleteFamilyDialogById(id);
    };

    var clearFamilyInfo = function () {
        $('#familyInfo').empty();
    };

    var loadFamilies = function () {
        var filter = $('#searchfield').val();
        var params = {filter:filter};

        commonHelper.callAjaxMethod('family.htm', 'loadFamilies',
            {
                filter:filter,
                page:selectedPage
            },
            function (result) {
                fillFamilyListInfo(result);
            });

    };

    var fillFamilyListInfo = function (data) {
        var familyList = $('#familylist');
        familyList.children(null).remove();
        if (data.rows.length > 0) {
            $('#familyListTemplate').clone().appendTo(familyList);
            familyList.directives({
                    '.familyRow':{
                        'row <- rows':{
                            '@id':'row.id',
                            '.familyName':'row.familyname',
                            '.parentName':'row.parentname',
                            '.phone':'row.phone',
                            '.familylistchild':{
                                'kid <- row.kids':{
                                    '.childname':'#{kid}'
                                }
                            }
                        }
                    }}
            ).render(data);


            commonHelper.hideEmptyList('familylist');

            commonHelper.generatePaginator('familylist', selectedPage, data.total, function (page) {
                selectedPage = page;
                loadFamilies();
            });

            $('#familylist').children(null).filter(':even').addClass('evenRow');
            $('#familylist').children(null).filter(':odd').addClass('oddRow');

            $('#familylist').children(null).show();

        } else {
            commonHelper.hidePaginator('familylist');
            commonHelper.showEmptyList('familylist');
        }
    };

    this.clickFamily = function (element) {
        selectFamily($(element).attr('id'));
        $('#familylist').children(null).removeClass('selectedFamilyRow');

        $('#familylist').children(null).filter(':even').addClass('evenRow');
        $('#familylist').children(null).filter(':odd').addClass('oddRow');

        $(element).addClass('selectedFamilyRow');
    };

    this.openFamilyDialog = function (element) {
        that.editFamilyDialog($(element).parents().filter('.familyRow').attr('id'), null)
    };

    this.editFamilyDialog = function (id) {
        this.openSaveDialog(id);
    };

    this.filterList = function () {
        selectedPage = 1;
        loadFamilies();
    };

}

function finance_helper() {
    var that = this;

    var openedTab = {};

    that.realisationReport = new realisationreport_helper(that);
    that.settings = new financesettings_helper(that);
    that.incomeOutcomeReport = new incomeoutcomereport_helper(that);
    that.cashJournalReport = new cashjournalreport_helper(that);
    that.moneyFlowReport = new moneyflowreport_helper(that);
    that.incomeReport = new incomereport_helper(that);
    that.plots = new financeplots_helper(that);
    that.salary = new salary_helper(that);

    that.TABLE_WIDTH = 0;

    this.pageReady = function () {
        $('#tabs-finance').tabs();
        that.TABLE_WIDTH = $('#tabs-finance').parent(null).width() - 70;

        $('#tabs-finance').tabs({
            show: function (event, ui) {
                $(ui.panel).show();
                onTabSelected(ui.index);
            }
        });

        prepareTabs();

    };

    var prepareTabs = function () {
        var disabledTabs = [];
        var firstTabSelected = false;
        commonHelper.checkPermission('finance', function () {
            firstTabSelected = true;
            onTabSelected(0);
            $('#tab-income-outcome-report').show();
        }, function () {
            $('#tab-income-outcome-report').hide();
            disabledTabs.push(0);
            disabledTabs.push(1);
        });

        commonHelper.checkPermission('financereports', function () {
            if (!firstTabSelected) {
                $("#tabs-finance").tabs({selected: 2});

                onTabSelected(2);
                $('#tab-main-money-flow').show();
            }
            firstTabSelected = true;
        }, function () {

            disabledTabs.push(2);
            disabledTabs.push(3);
            disabledTabs.push(4);
        });

        commonHelper.checkPermission('financesettings', function () {
            if (!firstTabSelected) {
                $("#tabs-finance").tabs({selected: 6});
                onTabSelected(6);
                $('#tab-settings').show();
            }
            firstTabSelected = true;
        }, function () {
            disabledTabs.push(6);
        });

        commonHelper.checkPermission('excelpdfexport', function () {
            $('#tab-plots').show();
            $('#realisationReportExcelLink').show();
            $('#incomeReportExcelLink').show();
            $('#moneyFlowReportExcelLink').show();
            $('#cashJournalReportExcelLink').show();
            $('#incomeOutcomeReportExcelLink').show();
        }, function () {
            $('#tab-plots').hide();
            $('#realisationReportExcelLink').hide();
            $('#incomeReportExcelLink').hide();
            $('#moneyFlowReportExcelLink').hide();
            $('#cashJournalReportExcelLink').hide();
            $('#incomeOutcomeReportExcelLink').hide();
        });


        commonHelper.checkPermission('financesalary', function () {
            if (!firstTabSelected) {
                $("#tabs-finance").tabs({selected: 5});
                onTabSelected(5);
                $('#tab-settings').show();
            }
            firstTabSelected = true;
        }, function () {
            disabledTabs.push(5);
        });

        commonHelper.checkFeature('RESERVE_COPY', function(){
            disabledTabs.push(1);
            disabledTabs.push(2);
            disabledTabs.push(3);
            disabledTabs.push(4);
        }, function(){

        });

        $('#tabs-finance').tabs("option", "disabled", disabledTabs);

        commonHelper.prepareViewer([
            {filter: '#createPaymentButton', action: 'delete'},
            {filter: '#cashesAddCash', action: 'delete'},
            {filter: '#paymentTypesAddType', action: 'delete'},
            {filter: '.editCash', action: 'hide'},
            {filter: '.deleteCash', action: 'hide'},
            {filter: '.editPaymentType', action: 'hide'},
            {filter: '.deletePaymentType', action: 'hide'}
        ]);

        $('button').button();

    };

    var onTabSelected = function (index) {
        switch (index) {
            case 0:
                that.incomeOutcomeReport.display();
                break;
            case 1:
                that.cashJournalReport.display();
                break;
            case 2:
                that.moneyFlowReport.display();
                break;
            case 3:
                that.realisationReport.display();
                break;
            case 4:
                that.incomeReport.display();
                break;
            case 5:
                that.salary.display();
                break;
            case 6:
                that.plots.display();
                break;
            case 7:
                that.settings.display();
                break;
        }
    };


    return this;
}function gradebook_helper() {
    var that = this;

    that.gradebook = new schedulerGradebook_helper(that, true);
    that.references = new schedulerReferences_helper(that);

    this.pageReady = function () {
        $('#tabs-gradebook').tabs();
        $('#tabs-gradebook').tabs({
            show: function (event, ui) {
                $(ui.panel).show();
                onTabSelected(ui.index);
            }
        });

        prepareTabs();

        commonHelper.registerChangeOrganizationListener(function (orgid) {
            that.gradebook.initFilterPane();
            that.references.initFilterPane();
            that.references.loadPreferencesWorkinghours();
        });
    };

    var prepareTabs = function () {
        var disabledTabs = [];
        commonHelper.checkPermission('scheduler', function () {
            //nothing to do
        }, function () {
            disabledTabs.push(1);
        });
        $('#tabs-gradebook').tabs("option", "disabled", disabledTabs);

        onTabSelected(0);
        $('#tab-gradebook-main').show();
        $('button').button();
    };

    var onTabSelected = function (index) {
        switch (index) {
            case 0:
                that.gradebook.display();
                break;
            case 1:
                that.references.display();
                break;
        }
    };

    return this;
}function barcodeReaders_helper() {
    var that = this;

    that.display = function () {
        that.loadReaders();
        that.loadPrintSettings();
    };

    that.loadReaders = function () {
        REFERENCE.fillReferenceList('barcodeReaders', 'barcode.htm', 'loadReaders', {
                sortOrder: 'asc',
                sortName: 'title',
                fillCallback: function (list, template, data) {
                    var row = template.clone();
                    row.removeClass('barcodeReadersTemplate');
                    row.show();
                    row.appendTo(list);

                    return list.directives({
                            '.barcodeReadersRow': {
                                'row <- rows': {
                                    '.title': 'row.title',
                                    '.active': function (context) {
                                        return context.item.active ? '<span style="color: green;">' + messages['barcode.readers.active'] + '</span>' : '<span style="color: red;">' + messages['barcode.readers.notactive'] + '</span>';
                                    },
                                    '.barcodeReadersActions': function (context) {
                                        var actions = '';
                                        if(context.item.visit) actions += messages['barcode.readers.visit'] + '<br/>';
                                        if(context.item.client) actions += messages['barcode.readers.client'] + '<br/>';
                                        if(context.item.timezone) actions += messages['barcode.readers.timezone'] + '<br/>';
                                        return actions;
                                    },
                                    '.organizationsList': {
                                        'organization <- row.organizations': {
                                            '.': 'organization.name'
                                        }
                                    },
                                    '.editReader@readerid': 'row.id',
                                    '.deleteReader@readerid': 'row.id'
                                }
                            }
                        }
                    ).render(data);
                }
            }
        );

    };

    this.addReader = function () {
        that.editReader(null);
    };

    this.editReader = function (readerid) {
        commonHelper.callAjaxMethod('barcode.htm', 'loadReader', {readerId: readerid}, function (data) {

            if (!data) {
                data = {
                    barcodeReader : {
                        title: '',
                        prefix: '',
                        visit: false,
                        client: false,
                        timezone: false,
                        active: false
                    }
                }
            }

            var barcodeReadersDialog = $('#barcodeReadersDialog').directives({
                '.readerId@value': 'barcodeReader.id',
                '.title@value': 'barcodeReader.title',
                '.prefix@value': 'barcodeReader.prefix',
                '.visit@checked': function (context) {return context.context.barcodeReader.visit ? 'checked' : '';},
                '.client@checked': function (context) {return context.context.barcodeReader.client ? 'checked' : '';},
                '.timezone@checked': function (context) {return context.context.barcodeReader.timezone ? 'checked' : '';},
                '.active@checked': function (context) {return context.context.barcodeReader.active ? 'checked' : '';}

            }).render(data);

            barcodeReadersDialog.find('.barcodeReaderOrganizations').removeAttr('checked');
            if (data.barcodeReader.organizations) {
                for (var k = 0; k < data.barcodeReader.organizations.length; k++) {
                    barcodeReadersDialog.find('[id="organization.' + data.barcodeReader.organizations[k].id + '"]').attr('checked', 'checked');
                }
            }

            REFERENCE.openEditReferenceDialog('barcodeReadersDialog', {
                    buttons: {
                        'saveButton': {
                            title: messages['common.save'],
                            action: function () {

                                var params = REFERENCE.collectParams('barcodeReadersDialog');
                                params.organizations = {};
                                var usersOrganizations = $('#barcodeReadersDialog').find('.barcodeReaderOrganizations');
                                $.each(usersOrganizations, function (index, item) {
                                    var orgItem = $(item);
                                    if (orgItem.attr('checked') == 'checked') {
                                        params.organizations[orgItem.attr('orgid')] = orgItem.attr('orgid');
                                    }
                                });
                                var validate = function (params) {
                                    if (params.title == '') {
                                        $('#barcodeReadersDialog').find('.dialogMessages').html(messages['barcode.readers.nameempty']);
                                        return false;
                                    }
                                    return true;
                                };

                                if (validate(params)) {
                                    commonHelper.callAjaxMethod('barcode.htm', 'saveReader', params, function (data) {
                                        if (!data) {
                                            commonHelper.showMessage(messages['barcode.readers.saveerror']);
                                        } else {
                                            that.loadReaders();
                                            REFERENCE.closeEditReferenceDialog('barcodeReadersDialog');
                                        }
                                    });
                                }
                            }
                        }
                    },
                    onClose: function () {

                    }
                }
            );

        }, false, false, !readerid);
    };

    this.deleteReader = function (readerid) {
        DIALOGS.askYesNoDialog(messages['barcode.readers.confirm'], messages['common.remove'], function () {
            commonHelper.callAjaxMethod('barcode.htm', 'deleteReader', {readerId: readerid}, function (data) {
                that.loadReaders();
            });
        });
    };

    this.loadPrintSettings = function () {
        commonHelper.callAjaxMethod('barcode.htm', 'loadBarcodePrintParams', {}, function (data) {
            var barcodePrintParams = $('#barcodePrintParams').directives({
                '.barcodePrintSubscription@checked': function (context) {
                    return context.context.barcodePrintSubscription ? 'checked' : '';
                },
                '.barcodePrintContract@checked': function (context) {
                    return context.context.barcodePrintContract ? 'checked' : '';
                }
            }).render(data);
            barcodePrintParams.find('.barcodeFont').val(data.barcodeFont);
        });
    }

    this.savePrintSettings = function () {
        commonHelper.callAjaxMethod('barcode.htm', 'saveBarcodePrintParams', {
            barcodePrintSubscription: $('[name=barcodePrintSubscription]:checked').val() ? true : false,
            barcodePrintContract: $('[name=barcodePrintContract]:checked').val() ? true : false,
            barcodeFont: $('[name=barcodeFont]').val()
        }, function (data) {
            that.loadPrintSettings();
        });
    }

    return this;
}function timezone_helper(timezoneHelper) {
    var that = this;

    var requestsDataGrid = null;

    that.display = function () {
        that.loadTimezoneSettings();
        this.loadTimezoneTable();
    };

    this.loadTimezoneSettings = function () {
        commonHelper.callAjaxMethod('barcode.htm', 'loadTimezoneParams', {}, function (data) {
            var timezoneParams = $('#timezoneParams');
            timezoneParams.find('.timezoneUnit').val(data.timezoneUnit);
            timezoneParams.find('.timezoneRounding').val(data.timezoneRounding);
            if(data.timezoneChildRequired){
                timezoneParams.find('.timezoneChildRequired').attr('checked','checked');
            }
            if(data.timezoneByMinuteMode){
                timezoneParams.find('.timezoneByMinuteMode').attr('checked','checked');
            }
            if(data.timezoneLastId){
                timezoneParams.find('.timezoneLastId').html(data.timezoneLastId);
            }
        });
    }

    this.saveTimezoneSettings = function () {
        commonHelper.callAjaxMethod('barcode.htm', 'saveTimezoneParams', {
            timezoneUnit: $('[name=timezoneUnit]').val(),
            timezoneRounding: $('[name=timezoneRounding]').val(),
            timezoneChildRequired: $('[name=timezoneChildRequired]').is(":checked"),
            timezoneByMinuteMode: $('[name=timezoneByMinuteMode]').is(":checked")
        }, function (data) {
            that.loadTimezoneTable();
        });
    }

    this.loadTimezoneTable = function () {
        if (!requestsDataGrid) {
            var colNames = [];
            colNames.push(messages['barcode.timezone.interval']);
            colNames.push(messages['barcode.timezone.title']);
            colNames.push(messages['barcode.timezone.price']);
            if (ORGS_COUNT > 0) {
                colNames.push(messages['barcode.timezone.organization']);
            }
            colNames.push(messages['barcode.timezone.code']);
            colNames.push('');

            var colModels = [];
            colModels.push({name: 'interval', index: 'interval', formatter: notNullFormatter});
            colModels.push({name: 'title', index: 'title', formatter: notNullFormatter});
            colModels.push({name: 'price', index: 'price', formatter: notNullFormatter});
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'orgid', index: 'orgid', edittype:'select', editable: true, formatter : 'select', editoptions:{value:':;'+ORGS_SELECT}});
            }
            colModels.push({name: 'code', index: 'code', formatter: notNullFormatter});
            colModels.push({name: 'timezoneid', index: 'timezoneid', sortable: false, formatter: function (cellvalue, options, rowObject) {
                return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.timezone.editTimezone(' + cellvalue + ')">' + messages['barcode.timezone.edit'] + '</a>,&nbsp;' +
                    '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.timezone.printTimezoneBarcode(' + cellvalue + ')">' + messages['barcode.timezone.print'] + '</a>';
            }});

            requestsDataGrid = $('#timezonesTable').jqGrid({
                datatype:loadTimezones,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#timezonesPager',
                sortname: 'timezoneid', viewrecords: true, sortorder: "desc"
            });
            requestsDataGrid.jqGrid('setGridWidth', timezoneHelper.TABLE_WIDTH);
        } else {
            requestsDataGrid.setGridParam({
                page: 1
            });
            requestsDataGrid.trigger("reloadGrid");
        }
    };

    var loadTimezones = function (postdata) {
        commonHelper.callAjaxMethod('barcode.htm', 'loadTimezones',
            postdata, function (result) {
                requestsDataGrid.clearGridData(true);
                requestsDataGrid[0].addJSONData(result);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    this.addTimezone = function () {
        that.editTimezone(null);
    };

    this.editTimezone = function (timezoneId) {
        var params = {};
        if(timezoneId){
            params['timezoneId'] = timezoneId;
        }
        commonHelper.callAjaxMethod('barcode.htm', 'loadTimezone', params, function (data) {

            if (!data.timezone) {
                data.timezone = {
                    
                }
            }
            data.additionalTeacherList = {
                rows: [{name:'',teacherid:''}].concat(data.teacherList.rows)
            }

            var timezoneEditDialog = $('#timezoneEditDialog');
            if(data.timezoneByMinuteMode){
                timezoneEditDialog.find('.byminutemode').show();
                timezoneEditDialog.find('.standardmode').hide();
            }
            else {
                timezoneEditDialog.find('.byminutemode').hide();
                timezoneEditDialog.find('.standardmode').show();
            }

            var fillSelect = function(selector, listName, nameField, valueField){
                selector.children(null).remove();
                selector.append('<option>');
                var option = {};
                option['teacher <- ' + listName + '.rows'] = {
                    '.': 'teacher.' + nameField,
                    '@value': 'teacher.' + valueField
                }
                selector.directives({
                    'option': option
                }).render(data);
            }

            fillSelect(timezoneEditDialog.find('.courseType'), 'courseTypeList', 'name', 'coursetypeid');
            fillSelect(timezoneEditDialog.find('.teacher'), 'teacherList', 'name', 'teacherid');
            fillSelect(timezoneEditDialog.find('.additionalTeacher'), 'additionalTeacherList', 'name', 'teacherid');
            fillSelect(timezoneEditDialog.find('.room'), 'roomList', 'title', 'roomid');
            fillSelect(timezoneEditDialog.find('.barcodeReader'), 'barcodeReaderList', 'title', 'id');

            timezoneEditDialog.directives({
                '.timezoneId@value': 'timezone.id',
                '.code@value': 'timezone.code'
            }).render(data);
            if(data.timezone.courseType){
                $('#timezoneEditDialog').find('.courseType').val(data.timezone.courseType.id);
            }
            if(data.timezone.teacher){
                $('#timezoneEditDialog').find('.teacher').val(data.timezone.teacher.id);
            }
            if(data.timezone.additionalTeacher){
                $('#timezoneEditDialog').find('.additionalTeacher').val(data.timezone.additionalTeacher.id);
            }
            if(data.timezone.room){
                $('#timezoneEditDialog').find('.room').val(data.timezone.room.id);
            }
            if (ORGS_COUNT > 0) {
                $('#timezoneEditDialog').find('.organizationSelect').show();
                if(data.timezone.organization){
                    $('#timezoneEditDialog').find('.organizationSelect').val(data.timezone.organization.id);
                }
            } else {
                $('#timezoneEditDialog').find('.organizationSelect').hide();
            }
            $('#timezoneIntervalTable').find('.intervalRow').remove();
            if(data.timezone.intervals){
                for(var i=0; i<data.timezone.intervals.length; i++){
                    that.addTimezoneInterval(data.timezone.intervals[i].interval, data.timezone.intervals[i].price);
                }
            }
            if(data.timezone.priceForMinute){
                $('#timezoneEditDialog').find('.priceForMinute').val(data.timezone.priceForMinute);
            }

            var buttons = {}
            if(timezoneId){
                buttons['removeButton'] = {
                    title: messages['common.remove'],
                    action: function () {
                        DIALOGS.askYesNoDialog(messages['barcode.timezone.confirm'], messages['common.yes'], function () {
                            var timezoneId = $('#timezoneEditDialog').find('.timezoneId').val();
                            if (timezoneId) {
                                commonHelper.callAjaxMethod('barcode.htm', 'removeTimezone', {timezoneId: timezoneId}, function (data) {
                                    that.loadTimezoneTable();
                                    REFERENCE.closeEditReferenceDialog('timezoneEditDialog');
                                });
                            }
                        }, function(){}, messages['common.no']);
                    }
                }
            }
            buttons['saveButton'] = {
                title: messages['common.save'],
                action: function () {
                    var params = REFERENCE.collectParams('timezoneEditDialog');
                    params.intervals = [];
                    $('#timezoneIntervalTable .intervalRow').each(function(){
                        var interval = $(this).find('.interval').val();
                        var price = $(this).find('.price').val();
                        if(interval && price){
                            params.intervals.push({interval:interval, price:price});
                        }
                    });
                    var validate = function (params) {
                        if(data.timezoneByMinuteMode){
                            if(params.priceForMinute.length == 0){
                                $('#timezoneEditDialog').find('.dialogMessages').html(messages['barcode.timezone.validate.priceminute']);
                                return false;
                            }
                        }
                        else {
                            if(params.intervals.length < 1){
                                $('#timezoneEditDialog').find('.dialogMessages').html(messages['barcode.timezone.validate.pricecount']);
                                return false;
                            }
                            for(var i=0; i<params.intervals.length; i++){
                                if((params.intervals[i].interval % data.timezoneUnit) != 0){
                                    $('#timezoneEditDialog').find('.dialogMessages').html(messages['barcode.timezone.validate.interval1'] + ' ' + data.timezoneUnit + ' ' + messages['barcode.timezone.validate.interval2']);
                                    return false;
                                }
                            }
                        }
                        return true;
                    };
                    $('#timezoneEditDialog').find('.dialogMessages').html('');
                    if (validate(params)) {
                        commonHelper.callAjaxMethod('barcode.htm', 'saveTimezone', {"objects": JSON.stringify(params)}, function (data) {
                            if (!data) {
                                commonHelper.showMessage(messages['barcode.timezone.saveerror']);
                            } else {
                                that.loadTimezoneTable();
                                REFERENCE.closeEditReferenceDialog('timezoneEditDialog');
                            }
                        });
                    }
                }
            }
            REFERENCE.openEditReferenceDialog('timezoneEditDialog', {
                    buttons: buttons,
                    onClose: function () {}
                }
            );

        }, false, false, false);
    };

    this.addTimezoneInterval = function(interval, price) {
        $('#timezoneIntervalTable').append('<tr class="intervalRow"><td><input type="text" class="interval" name="interval[]" value="' + interval + '"/></td><td><input type="text" class="price" name="price[]" value="' + price + '"/></td></tr>')
    }

    this.printTimezoneBarcode = function (timezoneId) {
        DIALOGS.askYesNoDialog(messages['barcode.timezone.printconfirm'], messages['common.yes'], function () {
            commonHelper.openPdfPrintDialog('barcode.htm?method=printTimezoneCodes&timezoneId=' + timezoneId);
            setTimeout(function () {
                that.loadTimezoneSettings();
            }, 1000)
        }, function(){}, messages['common.no']);
    };

    return this;
}function timezonestat_helper(timezoneHelper) {
    var that = this;

    var statDataGrid = null;

    that.display = function () {
        this.initFilterPane();
        this.loadTimezoneStatTable();
    };

    this.initFilterPane = function () {
        var searchPanel = $('#searchTimezoneStatParamForm');
        
        commonHelper.setDatePicker(searchPanel.find('#filterdatefrom'));
        commonHelper.setDatePicker(searchPanel.find('#filterdateto'));

        var childautocompleteparams = {
            url: 'index.htm',
            method: 'autoCompleteSearchChild',
            defaultValue: messages['statistic.childfilternotset'],
            inputDataTitle: messages['statistic.childfilteraction'],
            objectNotFound: messages['statistic.childfilternotfound'],
            objectFound: messages['statistic.childfilterfound'],
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.firstName + ' ' + item.lastName;
            },
            generateLabel: function (item) {
                return item.firstName + ' ' + item.lastName + ';' + item.phone;
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('filterchild', childautocompleteparams);

        commonHelper.callAjaxMethod('barcode.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.courseTypes = [
                {name: '', coursetypeid: ''}
            ].concat(result.courseTypeList.rows);
            references.rooms = [
                {title: '', roomid: ''}
            ].concat(result.roomList.rows);
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.teacherList.rows);
            initReferenceSelect(searchPanel.find('#filtercourseType'), references, 'courseType', 'coursetypeid', 'name');
            initReferenceSelect(searchPanel.find('#filterroom'), references, 'room', 'roomid', 'title');
            initReferenceSelect(searchPanel.find('#filterteacher'), references, 'teacher', 'teacherid', 'name');
            initReferenceSelect(searchPanel.find('#filteradditionalTeacher'), references, 'teacher', 'teacherid', 'name');
        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        if (ORGS_COUNT > 0) {
            searchPanel.find('#filterOrganizationBlock').show();
        }
        else {
            searchPanel.find('#filterOrganizationBlock').hide();
        }
    }

    this.loadTimezoneStatTable = function () {
        if (!statDataGrid) {
            var colNames = [];
            colNames.push(messages['barcode.timezonestat.date']);
            colNames.push(messages['barcode.timezonestat.child']);
            colNames.push(messages['barcode.timezonestat.type']);
            colNames.push(messages['barcode.timezonestat.course']);
            colNames.push(messages['barcode.timezonestat.teacher']);
            colNames.push(messages['barcode.timezonestat.room']);
            if (ORGS_COUNT > 0) {
                colNames.push(messages['barcode.timezonestat.organization']);
            }
            commonHelper.checkFeature('BARCODE', function(){
                colNames.push(messages['barcode.timezonestat.barcode']);
            });

            var colModels = [];
            colModels.push({name: 'dateCreated', index: 'dateCreated', formatter: function (cellvalue, options, rowObject) {
                return cellvalue + ' ' + rowObject.time;
            }});
            colModels.push({name: 'childName', index: 'childName', formatter: notNullFormatter});
            colModels.push({name: 'type', index: 'type', edittype:'select', formatter : 'select', editoptions:{value:messages['barcode.timezonestat.typeselect']}});
            colModels.push({name: 'courseName', index: 'courseName', formatter: notNullFormatter});
            colModels.push({name: 'teacherName', index: 'teacherName', formatter: notNullFormatter});
            colModels.push({name: 'roomTitle', index: 'roomTitle', formatter: notNullFormatter});
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'orgid', index: 'orgid', edittype:'select', editable: true, formatter : 'select', editoptions:{value:':;'+ORGS_SELECT}});
            }
            commonHelper.checkFeature('BARCODE', function(){
              colModels.push({name: 'timezonestatid', index: 'timezonestatid', sortable: false, formatter: function (cellvalue, options, rowObject) {
                    var code = null;
                    if(rowObject.type == "OUT"){
                        code = rowObject.lessonBarcode;
                    }
                    else {
                        code = rowObject.childBarcode;
                    }
                    if(code){
                        return '<div style="text-align:center;"><img src="barcode.htm?method=showBarcode&amp;code=' + code + '" alt="' + code + '"><br/>' + code + '</div>';
                    }
                    return '&nbsp;';
                }});
            });

            statDataGrid = $('#timezoneStatsTable').jqGrid({
                datatype:loadTimezoneStats,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#timezoneStatsPager',
                sortname: 'timezonestatid', viewrecords: true, sortorder: "desc"
            });
            statDataGrid.jqGrid('setGridWidth', timezoneHelper.TABLE_WIDTH);
        } else {
            statDataGrid.setGridParam({
                page: 1
            });
            statDataGrid.trigger("reloadGrid");
        }
    };

    that.clearFilter = function () {
        var searchPanel = $('#searchTimezoneStatParamForm');
        searchPanel.find('#filterdatefrom').val('');
        searchPanel.find('#filterdateto').val('');
        AUTOCOMPLETE_SEARCH_FIELD.setValue('filterchild', null, '');
        searchPanel.find('#filtertype').val('');
        searchPanel.find('#filterorganization').val('');
        searchPanel.find('#filtercourseType').val('');
        searchPanel.find('#filterroom').val('');
        searchPanel.find('#filterteacher').val('');
        searchPanel.find('#filteradditionalTeacher').val('');

        that.loadTimezoneStatTable();
    };

    var loadTimezoneStats = function (postdata) {
        $('#searchTimezoneStatParamForm').find('input, select').each(function(){
            postdata[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        commonHelper.callAjaxMethod('barcode.htm', 'loadTimezoneStats',
            postdata, function (result) {
                statDataGrid.clearGridData(true);
                statDataGrid[0].addJSONData(result);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    return this;
}function bonusPrograms_helper(helper) {
    var that = this;

    var dataGrid = null;

    that.display = function () {
        this.loadProgramsTable();
    };

    this.loadProgramsTable = function () {
        if (!dataGrid) {
            var colNames = [];
            colNames.push(messages['bonus.programs.title']);
            colNames.push(messages['bonus.programs.active']);
            colNames.push(messages['bonus.programs.date'] + ' ' + messages['common.from2']);
            colNames.push(messages['bonus.programs.date'] + ' ' + messages['common.to2']);
            colNames.push('');

            var colModels = [];
            colModels.push({name: 'title', index: 'title', formatter: notNullFormatter});
            colModels.push({name: 'active', index: 'active', formatter: function (cellvalue, options, rowObject) {
                return cellvalue == true ? messages['bonus.programs.active.yes'] : messages['bonus.programs.active.no'];
            }});
            colModels.push({name: 'startdate', index: 'startdate', formatter: notNullFormatter});
            colModels.push({name: 'enddate', index: 'enddate', formatter: notNullFormatter});
            colModels.push({name: 'programid', index: 'programid', sortable: false, formatter: function (cellvalue, options, rowObject) {
                return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.programs.editProgram(' + cellvalue + ')">' + messages['common.edit'] + '</a>,&nbsp;<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.programs.applyAllFamily(' + cellvalue + ')">' + messages['bonus.programs.attachclients'] + '</a>';
            }});

            dataGrid = $('#programTable').jqGrid({
                datatype:loadPrograms,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#programPager',
                sortname: 'programid', viewrecords: true, sortorder: "desc"
            });
            dataGrid.jqGrid('setGridWidth', helper.TABLE_WIDTH);
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    };

    var loadPrograms = function (postdata) {
        commonHelper.callAjaxMethod('bonus.htm', 'loadPrograms',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    this.addProgram = function () {
        that.editProgram(null);
    };

    this.editProgram = function (programId) {
        var params = {};
        if(programId){
            params['programId'] = programId;
        }
        commonHelper.callAjaxMethod('bonus.htm', 'loadProgram', params, function (data) {

            if (!data.program) {
                data.program = {
                    
                }
            }
            data.marketingAdCompanyList.rows = [
                {title: '', marketingadcompanyid: ''}
            ].concat(data.marketingAdCompanyList.rows);

            var programEditDialog = $('#programEditDialog');

            var fillSelect = function(selector, listName, nameField, valueField){
                selector.children(null).remove();
                selector.append('<option>');
                var option = {};
                option['obj <- ' + listName + '.rows'] = {
                    '.': 'obj.' + nameField,
                    '@value': 'obj.' + valueField
                }
                selector.directives({
                    'option': option
                }).render(data);
            }
            fillSelect(programEditDialog.find('.marketingAdCompany'), 'marketingAdCompanyList', 'title', 'marketingadcompanyid');

            programEditDialog.directives({
                '.programId@value': 'program.id',
                '.title@value': 'program.title',
                '.startDate@value': 'program.startDate',
                '.endDate@value': 'program.endDate',
                '.active@checked': function (context) {
                    return context.context.program ? context.context.program.active ? 'checked' : '' : '';
                },
                '.price@value': 'program.price',
                '.onlyVisits@checked': function (context) {
                    return context.context.program ? context.context.program.onlyVisits ? 'checked' : '' : '';
                },
            }).render(data);

            $('#programEditDialog').find('.desiredCourse').remove();
            if(data.program.courses){
                for (var i = 0; i < data.program.courses.length; i++) {
                    var course = data.program.courses[i];
                    that.addDesiredCourse(course.name, course.id);
                }
            }

            if (ORGS_COUNT > 0) {
                $('#programEditDialog').find('.organizationBlock').show();
                if(data.program.organization){
                    $('#programEditDialog').find('.organizationSelect').val(data.program.organization.id);
                }
            } else {
                $('#programEditDialog').find('.organizationBlock').hide();
            }
            commonHelper.checkFeature('MARKETING', function(){
                $('#programEditDialog').find('.marketingBlock').show();
                if(data.program.adCompany){
                    $('#programEditDialog').find('.marketingAdCompany').val(data.program.adCompany.id);
                }
            });

            var buttons = {}
            if(programId){
                buttons['removeButton'] = {
                    title: messages['common.remove'],
                    action: function () {
                        DIALOGS.askYesNoDialog(messages['bonus.programs.confirm'], messages['common.yes'], function () {
                            var programId = $('#programEditDialog').find('.programId').val();
                            if (programId) {
                                commonHelper.callAjaxMethod('bonus.htm', 'deleteProgram', {programId: programId}, function (data) {
                                    that.loadProgramsTable();
                                    REFERENCE.closeEditReferenceDialog('programEditDialog');
                                });
                            }
                        }, function(){}, messages['common.no']);
                    }
                }
            }
            buttons['saveButton'] = {
                title: messages['common.save'],
                action: function () {
                    var params = REFERENCE.collectParams('programEditDialog');
                    var courses = $('#programEditDialog').find('.desiredCourse');
                    var coursesId = [];
                    $.each(courses, function (index, element) {
                        coursesId.push($(element).data('course-id'));
                    });
                    params['courses'] = coursesId.join(';');
                     validate = function (params) {
                        var errors = [];
                        if (params.title == '') {
                            errors.push(messages['bonus.programs.validate.title']);
                        }
                        if(errors.length > 0){
                            $('#programEditDialog').find('.dialogMessages').html(errors.join('<br>'));
                            return false;
                        }
                        return true;
                    };
                    $('#programEditDialog').find('.dialogMessages').html('');
                    if (validate(params)) {
                        commonHelper.callAjaxMethod('bonus.htm', 'saveProgram', params, function (data) {
                            if (!data) {
                                commonHelper.showMessage(messages['bonus.programs.validate.title']);
                            } else {
                                that.loadProgramsTable();
                                REFERENCE.closeEditReferenceDialog('programEditDialog');
                            }
                        });
                    }
                }
            }
            REFERENCE.openEditReferenceDialog('programEditDialog', {
                    buttons: buttons,
                    onClose: function () {}
                }
            );

            commonHelper.setDatePicker($('#programEditDialog').find('.startDate'));
            commonHelper.setDatePicker($('#programEditDialog').find('.endDate'));

        }, false, false, false);
    };

    that.addDesiredCourseCallback = function (button) {
        $('#menuCoursesUl').find('.menuCoursesItem').remove();


        commonHelper.callAjaxMethod('settings.htm', 'loadCourseTypeReference', {}, function (result) {
            $('#menuCoursesItemTemplate').clone().appendTo($('#menuCoursesUl'));
            $('#menuCoursesDiv ul').directives({
                '.menuCoursesItem': {
                    'row <-rows': {
                        'span.title': 'row.name',
                        '@value': 'row.coursetypeid',
                        '@template': 'false'
                    }
                }
            }).render(result);

            $('#menuCoursesUl').find('.menuCoursesItem').show();

            $('#menuCoursesDiv').css('z-index', commonHelper.getMaxZIndex());
            var menuContainer = $('#menuCoursesDiv ul');

            menuContainer.menu({
                blur: function () {
                    menuContainer.data('selecteditem', null);
                },

                focus: function (event, ui) {
                    menuContainer.data('selecteditem', ui);
                }
            })
        });


        var buttonObject = $(button);
        var buttonOffset = buttonObject.offset();
        $('#menuCoursesDiv').css('left', (buttonOffset.left) + 'px');
        $('#menuCoursesDiv').css('top', (buttonOffset.top + buttonObject.height() + 3) + 'px');

        $('html').one('mousedown', function () {
            var selectedItem = $('#menuCoursesDiv ul').data('selecteditem');
            if (selectedItem) {
                var courseId = selectedItem.item.attr('value');
                that.addDesiredCourse(selectedItem.item.find('.title').html(), courseId);
            }
            $('#menuCoursesDiv').hide();
        });

        $('#menuCoursesDiv').show(10, 'linear');
    };


    that.addDesiredCourse = function (coursetitle, courseid) {
        var desiredCourse = $('#desiredCourseTemplate').clone();
        desiredCourse.attr('id', null);
        desiredCourse.data('course-id', courseid);
        desiredCourse.find('.title').html(coursetitle);
        desiredCourse.show();

        desiredCourse.appendTo($('#programEditDialog').find('.desiredCourses'));

    };

    that.removeDesiredCourse = function (button) {
        var course = $(button).parents().filter('.desiredCourse');
        course.remove();
    };

    that.applyAllFamily = function(programId) {
        DIALOGS.askYesNoDialog(messages['bonus.programs.applyconfirm'], messages['common.yes'], function () {
            commonHelper.callAjaxMethod('bonus.htm', 'applyAllFamily', {programId: programId}, function (data) {
                commonHelper.showMessage(messages['bonus.programs.applymessage']);
            });
        }, function(){}, messages['common.no']);
    };

    that.calculateBonuses = function(programId) {
        DIALOGS.askYesNoDialog(messages['bonus.programs.calculateconfirm'], messages['common.yes'], function () {
            commonHelper.callAjaxMethod('bonus.htm', 'calculateBonuses', {}, function (data) {
                commonHelper.showMessage(messages['bonus.programs.calculatemessage']);
            });
        }, function(){}, messages['common.no']);
    };

    return this;
}function bonusStatistic_helper(helper) {
    var that = this;

    var dataGrid = null;

    that.display = function () {
        this.initFilterPane();
        this.loadStatisticTable();
    };

    this.initFilterPane = function () {
        var searchPanel = $('#searchStatisticParamForm');

        commonHelper.setDatePicker(searchPanel.find('#filterdatefrom'));
        commonHelper.setDatePicker(searchPanel.find('#filterdateto'));

        var familyautocompleteparams = {
            url: 'family.htm',
            method: 'autoCompleteSearchFamily',
            defaultValue: messages['paymentdialog.familyfilternotset'],
            inputDataTitle: messages['paymentdialog.familyfilteraction'],
            objectNotFound: messages['paymentdialog.familyfilternotfound'],
            objectFound: messages['paymentdialog.familyfilterfound'],

            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.value;
            },
            generateLabel: function (item) {
                return item.title;
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('filterfamily', familyautocompleteparams);

        commonHelper.callAjaxMethod('bonus.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.courseTypes = [
                {name: '', coursetypeid: ''}
            ].concat(result.courseTypeList.rows);
            references.programs = [
                {title: '', programid: ''}
            ].concat(result.programList.rows);
            references.adCompanys = [
                {title: '', adcompanyid: ''}
            ].concat(result.marketingAdCompanyList.rows);
            initReferenceSelect(searchPanel.find('#filtercourseType'), references, 'courseType', 'coursetypeid', 'name');
            initReferenceSelect(searchPanel.find('#filterprogram'), references, 'program', 'programid', 'title');
            initReferenceSelect(searchPanel.find('#filteradCompany'), references, 'adCompany', 'marketingadcompanyid', 'title');
        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        if (ORGS_COUNT > 0) {
            searchPanel.find('#filterOrganizationBlock').show();
        }

        commonHelper.checkFeature('MARKETING', function(){
            searchPanel.find('#filteradCompanyBlock').show();
        });
    }

    this.loadStatisticTable = function () {
        if (!dataGrid) {
            var colNames = [];
            colNames.push(messages['bonus.statistic.date']);
            colNames.push(messages['bonus.statistic.lesson']);
            colNames.push(messages['bonus.statistic.client']);
            colNames.push(messages['bonus.statistic.type']);
            colNames.push(messages['bonus.statistic.bonus']);
            colNames.push(messages['bonus.statistic.money'] + ' ' + MONEY_NAME);

            var colModels = [];
            colModels.push({name: 'createddate', index: 'createddate', formatter: notNullFormatter});
            colModels.push({name: 'lesson', index: 'lesson', formatter: notNullFormatter});
            colModels.push({name: 'client', index: 'client', formatter: notNullFormatter});
            colModels.push({name: 'type', index: 'type', formatter: function (cellvalue, options, rowObject) {
                return cellvalue == 'INCOME' ? messages['bonus.statistic.type.income'] : messages['bonus.statistic.type.outcome'];
            }});
            colModels.push({name: 'bonus', index: 'bonus', formatter: bonusFormatter});
            colModels.push({name: 'bonusmoney', index: 'bonusmoney', formatter: bonusFormatter});

            dataGrid = $('#statisticTable').jqGrid({
                datatype:loadStatistic,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#statisticPager',
                sortname: 'bonusactionid', viewrecords: true, sortorder: "desc"
            });
            dataGrid.jqGrid('setGridWidth', helper.TABLE_WIDTH);
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    };

    var loadStatistic = function (postdata) {
        $('#searchStatisticParamForm').find('input, select').each(function(){
            postdata[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        commonHelper.callAjaxMethod('bonus.htm', 'loadStatistic',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);

                var totalPanel = $('#statisticTotalInfo');
                var totalValues = result.additionalAggregationList[0];
                totalPanel.find('.totalbonus').text(totalValues.totalbonus ? totalValues.totalbonus : 0);
                totalPanel.find('.totalbonusmoney').text(totalValues.totalbonusmoney ? totalValues.totalbonusmoney : 0);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    var bonusFormatter = function (cellvalue, options, rowObject) {
        return rowObject.type == 'INCOME' ? '<font color="green">' + cellvalue + '</font>' : '<font color="red">' + cellvalue + '</font>';
    };

    that.clearFilter = function () {
        var searchPanel = $('#searchStatisticParamForm');
        AUTOCOMPLETE_SEARCH_FIELD.setValue('filterfamily', null, '');
        searchPanel.find('#filterprogram').val('');
        searchPanel.find('#filterdatefrom').val('');
        searchPanel.find('#filterdateto').val('');
        searchPanel.find('#filtercourseType').val('');
        searchPanel.find('#filtertype').val('');
        searchPanel.find('#filterorganization').val('');
        searchPanel.find('#filteradCompany').val('');
        that.loadStatisticTable();
    };

    that.downloadExcel = function () {
        if (dataGrid.jqGrid('getGridParam', 'reccount') > 0) {
            var sortColumnName = dataGrid.jqGrid('getGridParam', 'sortname');
            var sortOrder = dataGrid.jqGrid('getGridParam', 'sortorder');

            var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&';
            var existNotEmptyParam = false;

            $('#searchStatisticParamForm').find('input, select').each(function(){
                if($(this).val()){
                    existNotEmptyParam = true;
                    paramsString += $(this).attr('name') + '=' + $(this).val() + '&';
                }
            });

            var excelFunction = function () {
                window.location.assign("bonus.htm?method=downloadStatisticAsExcel" + (paramsString ? '&' + paramsString : ''));
            };
            if (!existNotEmptyParam) {
                DIALOGS.askYesNoDialog(messages['common.filternoparam'], messages['common.yes'], excelFunction);
            } else {
                excelFunction();
            }
        } else {
            commonHelper.showMessage(messages['common.filternodata']);
        }
    };
    
    return this;
}function contracts_helper() {
    var that = this;

    var dataGrid = null;

    that.init = function () {
        that.loadContractTemplatesTable();

        commonHelper.registerChangeOrganizationListener(function (organizationId) {
            that.loadContractTemplatesTable();
        });
    };

    this.loadContractTemplatesTable = function () {
        if (!dataGrid) {
            var colNames = [];
            colNames.push(messages['contracts.templates.title']);
            colNames.push('');

            var colModels = [];
            colModels.push({name: 'title', index: 'title', formatter: 'string'});
            colModels.push({name: 'contracttemplateid', index: 'contracttemplateid', sortable: false, formatter: function (cellvalue, options, rowObject) {
                return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.contracts.editContractTemplate(' + cellvalue + ')">' + messages['common.edit'] + '</a>,&nbsp;<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.contracts.removeContractTemplate(' + cellvalue + ')">' + messages['common.remove'] + '</a>';
            }});

            dataGrid = $('#contractTemplateTable').jqGrid({
                caption: messages['contracts.templates'],
                datatype:loadContractTemplates,
                colNames: colNames,
                colModel: colModels,
                autowidth: true,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#contractTemplatePager',
                sortname: 'contracttemplateid', viewrecords: true, sortorder: "desc"
            });
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    };

    var loadContractTemplates = function (postdata) {
        commonHelper.callAjaxMethod('settings.htm', 'loadContractTemplates',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);
            }, true);
    };

    this.addContractTemplate = function() {
        this.editContractTemplate(null);
    };

    this.editContractTemplate = function(contractTemplateId) {
        var params = {};
        if(contractTemplateId){
            params['contractTemplateId'] = contractTemplateId;
        }
        commonHelper.callAjaxMethod('settings.htm', 'loadContractTemplate', params, function (data) {
            if (!data.contractTemplate) {
                data.contractTemplate = {

                }
            }

            $('#contractTemplateDialog').directives({
                '.contractTemplateId@value': 'contractTemplate.id',
                '.title@value': 'contractTemplate.title',
                '.template': 'contractTemplate.template'
            }).render(data);

            if (ORGS_COUNT > 0) {
                $('#contractTemplateDialog').find('.organizationBlock').show();
                if(data.contractTemplate.organization){
                    $('#contractTemplateDialog').find('.organizationSelect').val(data.contractTemplate.organization.id);
                }
            } else {
                $('#contractTemplateDialog').find('.organizationBlock').hide();
            }

            var buttons = {}
            buttons['saveButton'] = {
                title: messages['common.save'],
                action: function () {
                    var params = REFERENCE.collectParams('contractTemplateDialog');
                    params['template'] = CKEDITOR.instances['template'].getData();
                    validate = function (params) {
                        var errors = [];
                        if (params.title == '') {
                            errors.push(messages['contracts.edit.validate.title']);
                        }
                        if(errors.length > 0){
                            $('#contractTemplateDialog').find('.dialogMessages').html(errors.join('<br>'));
                            return false;
                        }
                        return true;
                    };
                    $('#contractTemplateDialog').find('.dialogMessages').html('');
                    if (validate(params)) {
                        commonHelper.callAjaxMethod('settings.htm', 'saveContractTemplate', params, function (data) {
                            that.loadContractTemplatesTable();
                            REFERENCE.closeEditReferenceDialog('contractTemplateDialog');
                        });
                    }
                }
            }
            REFERENCE.openEditReferenceDialog('contractTemplateDialog', {
                    buttons: buttons,
                    onClose: function () {}
                }
            );

            $('#contractTemplateDialog').find('#cke_template').remove();
            CKEDITOR.replace('template', {
                language: 'ru'
            });

        }, false, false, false);
    };

    this.removeContractTemplate = function(contractTemplateId) {
        DIALOGS.askYesNoDialog(messages['contracts.remove.confirm'], messages['common.yes'], function () {
            if (contractTemplateId) {
                commonHelper.callAjaxMethod('settings.htm', 'deleteContractTemplate', {contractTemplateId: contractTemplateId}, function (data) {
                    that.loadContractTemplatesTable();
                    REFERENCE.closeEditReferenceDialog('contractTemplateDialog');
                });
            }
        }, function(){}, messages['common.no']);
    };

    return this;
}function cashjournalreport_helper(financeHelper) {
    var that = this;

    var inited = false;
    var referenceInited = false;
    var journalDataGrid = null;

    that.display = function () {
        if (!inited) {
            commonHelper.setDatePicker($('#filtercashjournaldatefrom'));
            commonHelper.setDatePicker($('#filtercashjournaldateto'));

            $('#filtercashjournaldatefrom').datepicker('setDate', new Date());
            $('#filtercashjournaldateto').datepicker('setDate', new Date());

            commonHelper.registerChangeOrganizationListener(function (organizationId) {
                that.refreshCashJournalList();
            });

            that.refreshCashJournalList();
            inited = true;
        }
    };

    that.downloadExcel = function () {
        if (journalDataGrid.jqGrid('getGridParam', 'reccount') > 0) {
            var params = collectSearchParams();

            var sortColumnName = journalDataGrid.jqGrid('getGridParam', 'sortname');
            var sortOrder = journalDataGrid.jqGrid('getGridParam', 'sortorder');

            var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&';
            var existNotEmptyParam = false;
            for (var param in params) {
                var paramValue = params[param];
                existNotEmptyParam |= paramValue ? true : false;
                paramsString += param + '=' + paramValue + '&';
            }

            var excelFunction = function () {
                window.location.assign("finance.htm?method=downloadCashJournalReportAsExcel" + (paramsString ? '&' + paramsString : ''));
            };
            if (!existNotEmptyParam) {
                DIALOGS.askYesNoDialog(messages['common.filternoparam'], messages['common.yes'], excelFunction);
            } else {
                excelFunction();
            }
        } else {
            commonHelper.showMessage(messages['common.filternodata']);
        }
    };

    var collectSearchParams = function () {
        return {
            filtercashjournaldatefrom: $('#filtercashjournaldatefrom').val() ? $('#filtercashjournaldatefrom').val() : '',
            filtercashjournaldateto: $('#filtercashjournaldateto').val() ? $('#filtercashjournaldateto').val() : '',
            cashjournalcash: $('#cashjournalcash').val() ? $('#cashjournalcash').val() : ''
        }
    };

    that.clearFilter = function () {
        $('#filtercashjournaldatefrom').val('');
        $('#filtercashjournaldateto').val('');
        $('#cashjournalcash').val('');
    };

    that.refreshCashJournalList = function () {
        if (!journalDataGrid) {
            var colNames = [
                messages['finance.cashjournalreport.date'],
                messages['finance.cashjournalreport.startsum'],
                messages['finance.cashjournalreport.income'],
                messages['finance.cashjournalreport.outcome'],
                messages['finance.cashjournalreport.finishsum']
            ];

            var colModels = [
                {name: 'date', index: 'date', formatter: 'string'},
                {name: 'startsum', index: 'startsum', formatter: commonHelper.currencyFormatter},
                {name: 'income', index: 'income', formatter: commonHelper.currencyFormatter},
                {name: 'outcome', index: 'outcome', formatter: commonHelper.currencyFormatter},
                {name: 'finishsum', index: 'finishsum', formatter: commonHelper.currencyFormatter}
            ];

            journalDataGrid = $('#filterResultCashJournal').jqGrid({
                datatype: loadCashJournal,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "date"},
                sortname: 'date', viewrecords: true, sortorder: "asc",
                rowNum: 25, pager: '#filterResultCashJournalPager'
            });
            journalDataGrid.jqGrid('setGridWidth', financeHelper.TABLE_WIDTH);
        } else {
            journalDataGrid.setGridParam({
                page: 1
            });
            journalDataGrid.trigger("reloadGrid");
        }
    };

    var loadCashJournal = function (postdata) {
        postdata = $.extend(postdata,collectSearchParams());

        commonHelper.callAjaxMethod('finance.htm', 'loadCashJournal',
            postdata, function (result) {
                journalDataGrid.clearGridData(true);
                journalDataGrid[0].addJSONData(result.data);

                if (!referenceInited) {
                    referenceInited = true;
                    $('#cashjournalcash').children(null).remove();
                    $('<option>').appendTo($('#cashjournalcash'));

                    var cashes = [
                        {id: '', name: ''}
                    ].concat(result.cashes);

                    $('#cashjournalcash').directives({
                        'option': {
                            'cash <- cashes': {
                                '.': 'cash.name',
                                '@value': 'cash.id'
                            }
                        }
                    }).render({cashes: cashes});

                }
            }, true);
    };

}function financeplots_helper(financeHelper) {
    var that = this;

    var inited = false;

    that.display = function () {
        if (!inited) {
            inited = true;
            initReferences();
        }
    };

    this.selectPlot = function (menuitem, plotdivid) {
        $('#plots-menu').children(null).removeClass('plotmenuitemselected');
        $(menuitem).addClass('plotmenuitemselected');
        $('#plots-list').children(null).hide();
        $('#' + plotdivid).show();
    };

    this.generateIncomeOutcomeByMonthsPlot = function(){
        if ($('#incomeoutcomebymonthsto').val() == '' || $('#incomeoutcomebymonthsfrom').val() == '') {
            commonHelper.showMessage(messages['finance.financeplots.nodate']);
        } else {
            $('#incomeoutcomebymonthscontainer').children(null).remove();
            $('<img>', {
                width: '740px',
                height: '500px',
                src: 'plot.htm?method=incomeOutcomeByMonths&from=' +
                ($('#incomeoutcomebymonthsfrom').val()) + '&' + 'to=' +
                ($('#incomeoutcomebymonthsto').val()) + '&key=' +
                (new Date().getTime()) +
                '&paymenttype=' + ($('#incomeoutcomebymonthssource option:selected').val() ? $('#incomeoutcomebymonthssource option:selected').val() : '')
            }).appendTo($('#incomeoutcomebymonthscontainer'));
        }
    };

    var initReferences = function () {
        commonHelper.setDatePicker($('#incomeoutcomebymonthsfrom'));
        commonHelper.setDatePicker($('#incomeoutcomebymonthsto'));
        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.paymenttypes = [
                {name: '', paymenttypeid: ''}
            ].concat(result.paymenttypes.rows);

            var incomePaymentTypeSelect = $('#incomepaymenttype');
            initReferenceSelect(incomePaymentTypeSelect, references, 'paymenttype', 'id');

            var incomePaymentTypeByMonthPlotSelect = $('#incomeoutcomebymonthssource');
            initReferenceSelect(incomePaymentTypeByMonthPlotSelect, references, 'paymenttype', 'id');

        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.name',
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

    };

    return this;

}function financesettings_helper(financeHelper) {
    var that = this;
    var inited = false;

    that.display = function () {
        if (!inited) {
            inited = true;
            that.loadCashes();
            that.loadPaymentTypes();

            commonHelper.registerChangeOrganizationListener(function (organizationId) {
                that.loadCashes();
            });
        }
    };

    that.loadCashes = function () {
        REFERENCE.fillReferenceList('cashes', 'finance.htm', 'loadCashes', {
                sortOrder: 'asc',
                sortName: 'id',
                fillCallback: function (list, template, data) {
                    var row = template.clone();
                    row.removeClass('cashesTemplate');
                    row.show();
                    row.appendTo(list);

                    return list.directives({
                            '.cashesRow': {
                                'row <- rows': {
                                    '.name': 'row.name',
                                    '.editCash@cashid': 'row.id',
                                    '.deleteCash@cashid': 'row.id',
                                    '.grantedUsers': {
                                        'user <- row.grantedUsers': {
                                            '.': 'user.name'
                                        }
                                    }
                                }
                            }
                        }
                    ).render(data);
                }
            }
        );
    };

    that.addCash = function () {
        that.editCash(null);
    };

    that.deleteCash = function (id, callback) {
        DIALOGS.askYesNoDialog(messages['finance.financesettings.cash.confirm'], messages['common.remove'], function () {
            commonHelper.callAjaxMethod('finance.htm', 'deleteCash', {cashId: id}, function (data) {
                that.loadCashes();
                if (callback) {
                    callback();
                }
            });
        });
    };

    that.editCash = function (id) {
        commonHelper.callAjaxMethod('finance.htm', 'loadCash', {cashId: id ? id : ''}, function (data) {

            if (!data) {
                data = {
                    name: '',
                    initValue: '',
                    startDate: '',
                    orgId: ''
                }
            }

            var userDialog = $('#cashDialog').directives({
                '.cashId@value': 'cashInfo.id',
                '.cashName@value': 'cashInfo.name'
            }).render(data.data);

            if (data.cashInfo && data.cashInfo.organization) {
                userDialog.find('.cashOrganizationSelect').val(data.cashInfo.organization.id);
            } else {
                userDialog.find('.cashOrganizationSelect').val('');
            }

            $('#cashUsers').children(null).remove();

            var cashUserTemplate = $('.cashUserTemplate').clone();
            cashUserTemplate.show();
            cashUserTemplate.appendTo($('#cashUsers'));

            $('#cashUsers').directives({
                '.cashUser': {
                    'user <- rows': {
                        '.userName': 'user.name',
                        '.grantUser@userid': 'user.id'
                    }
                }

            }).render(data.users);

            if (data.data && data.data.cashInfo) {
                var cashCurrentUsers = data.data.cashInfo.grantedUsers;
                $.each(cashCurrentUsers, function (index, item) {
                    $('.grantUser[userid=' + item.id + ']').attr('checked', 'checked');
                });
            }

            if (ORGS_COUNT > 0) {
                $('#cashDialog').find('#cashOrganization').show();
            } else {
                $('#cashDialog').find('#cashOrganization').hide();
            }


            commonHelper.setDatePicker($('#cashDialog').find('.startDate'));

            REFERENCE.openEditReferenceDialog('cashDialog', {
                    buttons: {
                        'saveButton': {
                            title: messages['common.save'],
                            action: function () {

                                var params = REFERENCE.collectParams('cashDialog');
                                params.users = {};
                                var users = $('#cashDialog').find('.grantUser:checked');

                                var grantedUsers = $('#cashDialog').find('.grantUser');
                                $.each(grantedUsers, function (index, item) {
                                    var userItem = $(item);
                                    if (userItem.attr('checked') == 'checked') {
                                        params.users[userItem.attr('userid')] = userItem.attr('userid');
                                    }
                                });

                                var validate = function (params) {
                                    if (params.cashName == '') {
                                        $('#cashDialog').find('.dialogMessages').html(messages['finance.financesettings.cash.validate.name']);
                                        return false;
                                    }
                                    if (params.initValue == '') {
                                        $('#cashDialog').find('.dialogMessages').html(messages['finance.financesettings.cash.validate.value']);
                                        return false;
                                    }
                                    if (params.startDate == '') {
                                        $('#cashDialog').find('.dialogMessages').html(messages['finance.financesettings.cash.validate.date']);
                                        return false;
                                    }
                                    return true;
                                };

                                if (validate(params)) {
                                    commonHelper.callAjaxMethod('finance.htm', 'saveCash', params, function (data) {
                                        if (!data) {
                                            commonHelper.showMessage(messages['finance.financesettings.cash.error']);
                                        } else {
                                            that.loadCashes();
                                            REFERENCE.closeEditReferenceDialog('cashDialog');
                                        }
                                    });
                                }
                            }
                        }
                    },
                    onClose: function () {

                    }
                }
            );

        }, false, false);
    };

    that.loadPaymentTypes = function () {
        REFERENCE.fillReferenceList('paymentTypes', 'finance.htm', 'loadPaymentTypes', {
                sortOrder: 'asc',
                sortName: 'id',
                fillCallback: function (list, template, data) {
                    var row = template.clone();
                    row.removeClass('paymentTypesTemplate');
                    row.show();
                    row.appendTo(list);

                    return list.directives({
                            '.paymentTypesRow': {
                                'row <- rows': {
                                    '.name': 'row.name',
                                    '.editPaymentType@paymentTypeId': 'row.id',
                                    '.deletePaymentType@paymentTypeId': 'row.id',
                                    '.defaultCash': 'row.defaultCash.name',
                                    '.paymentTypeDirection': function (context) {
                                        return context.item.direction == 'INCOME' ? messages['finance.financesettings.type.direction.income'] : messages['finance.financesettings.type.direction.outcome'];
                                    }
                                }
                            }
                        }
                    ).render(data);
                }
            }
        );
    };


    that.addPaymentType = function () {
        that.editPaymentType(null);
    };

    that.deletePaymentType = function (id, callback) {
        DIALOGS.askYesNoDialog(messages['finance.financesettings.type.confirm'], messages['common.remove'], function () {
            commonHelper.callAjaxMethod('finance.htm', 'deletePaymentType', {paymentTypeId: id}, function (data) {
                that.loadPaymentTypes();
                if (callback) {
                    callback();
                }
            });
        });
    };

    that.editPaymentType = function (id) {
        commonHelper.callAjaxMethod('finance.htm', 'loadPaymentType', {paymentTypeId: id ? id : ''}, function (data) {

            if (!data) {
                data = {
                    paymentTypeInfo: {
                        defaultCash: {

                        }
                    }
                }
            }

            var userDialog = $('#paymentTypeDialog').directives({
                '.paymentTypeId@value': 'paymentTypeInfo.id',
                '.paymentTypeName@value': 'paymentTypeInfo.name'
            }).render(data);

            if (data.paymentTypeInfo) {
                $('#paymentTypeDialog').find('.paymentTypeDirection').val(data.paymentTypeInfo.direction);

                if (data.paymentTypeInfo.code) {
                    $('#paymentTypeDialog').find('.paymentTypeDirection').attr('disabled', 'disabled');
                } else {
                    $('#paymentTypeDialog').find('.paymentTypeDirection').removeAttr('disabled');
                }
            } else {
                $('#paymentTypeDialog').find('.paymentTypeDirection').removeAttr('disabled');
            }



            $('#paymentTypeDialog').find('.defaultCash').children(null).remove();
            $('<option>').appendTo($('#paymentTypeDialog').find('.defaultCash'));

            $('#paymentTypeDialog').find('.defaultCash').directives({
                'option': {
                    'cash <- cashes': {
                        '.': 'cash.name',
                        '@value': 'cash.id'
                    }
                }
            }).render(data);

            if (data.paymentTypeInfo && data.paymentTypeInfo.defaultCash) {
                $('#paymentTypeDialog').find('.defaultCash').val(data.paymentTypeInfo.defaultCash.id);
            } else {
                $('#paymentTypeDialog').find('.defaultCash').val('');
            }


            REFERENCE.openEditReferenceDialog('paymentTypeDialog', {
                    buttons: {
                        'saveButton': {
                            title: messages['common.save'],
                            action: function () {

                                var params = REFERENCE.collectParams('paymentTypeDialog');

                                var validate = function (params) {
                                    if (params.paymentTypeName == '') {
                                        $('#paymentTypeDialog').find('.dialogMessages').html(messages['finance.financesettings.type.validate.name']);
                                        return false;
                                    }
                                    if (params.paymentTypeDirection == '') {
                                        $('#paymentTypeDialog').find('.dialogMessages').html(messages['finance.financesettings.type.validate.type']);
                                        return false;
                                    }
                                    return true;
                                };

                                if (validate(params)) {
                                    commonHelper.callAjaxMethod('finance.htm', 'savePaymentType', params, function (data) {
                                        if (!data) {
                                            commonHelper.showMessage(messages['finance.financesettings.type.error']);
                                        } else {
                                            that.loadPaymentTypes();
                                            REFERENCE.closeEditReferenceDialog('paymentTypeDialog');
                                        }
                                    });
                                }
                            }
                        }
                    },
                    onClose: function () {

                    }
                }
            );

        }, false, false);
    };

    return this;
}function incomeoutcomereport_helper(financeHelper) {
    var that = this;

    var inited = false;
    var referenceInited = false;
    var paymentsDataGrid = null;

    that.display = function () {
        if (!inited) {
            commonHelper.setDatePicker($('#filterpaymentdatefrom'));
            commonHelper.setDatePicker($('#filterpaymentdateto'));

            $('#filterpaymentdatefrom').datepicker('setDate', new Date());
            $('#filterpaymentdateto').datepicker('setDate', new Date());

            commonHelper.registerChangeOrganizationListener(function (organizationId) {
                that.loadPayments();
            });

            that.loadPayments();
            inited = true;
        }
    };

    that.addPayment = function () {
        DIALOGS.paymentDialog.addPayment({}, function () {
            currentPage.incomeOutcomeReport.loadPayments();
        })
    };

    that.editPayment = function (id) {
        DIALOGS.paymentDialog.editPayment(id, {}, function () {
            currentPage.incomeOutcomeReport.loadPayments();
        });
    };

    that.clearFilter = function () {
        $('#filterpaymentdatefrom').val('');
        $('#filterpaymentdateto').val('');
        $('#paymentCashFilter').val('');
        $('#paymentTypeFilter').val('');
    };

    that.downloadExcel = function () {
        if (paymentsDataGrid.jqGrid('getGridParam', 'reccount') > 0) {
            var params = collectSearchParams();

            var sortColumnName = paymentsDataGrid.jqGrid('getGridParam', 'sortname');
            var sortOrder = paymentsDataGrid.jqGrid('getGridParam', 'sortorder');

            var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&';
            var existNotEmptyParam = false;
            for (var param in params) {
                var paramValue = params[param];
                existNotEmptyParam |= paramValue ? true : false;
                paramsString += param + '=' + paramValue + '&';
            }

            var excelFunction = function () {
                window.location.assign("finance.htm?method=downloadIncomeOutcomeReportAsExcel" + (paramsString ? '&' + paramsString : ''));
            };
            if (!existNotEmptyParam) {
                DIALOGS.askYesNoDialog(messages['common.filternoparam'], messages['common.yes'], excelFunction);
            } else {
                excelFunction();
            }
        } else {
            commonHelper.showMessage(messages['common.filternodata']);
        }
    };

    that.loadPayments = function () {
        if (!paymentsDataGrid) {
            var colNames = [];
            if (ORGS_COUNT > 0) {
                colNames.push(messages['finance.incomeoutcomereport.organization']);
            }
            colNames.push(messages['finance.incomeoutcomereport.cash']);
            colNames.push(messages['finance.incomeoutcomereport.type']);
            colNames.push(messages['finance.incomeoutcomereport.description']);
            colNames.push(messages['finance.incomeoutcomereport.value']);
            colNames.push(messages['finance.incomeoutcomereport.date']);
            colNames.push(messages['finance.incomeoutcomereport.author']);
            colNames.push(messages['finance.incomeoutcomereport.createdate']);
            colNames.push(messages['finance.incomeoutcomereport.modifier']);
            colNames.push(messages['finance.incomeoutcomereport.modificationdate']);
            colNames.push(messages['finance.incomeoutcomereport.comment']);
            colNames.push(messages['finance.incomeoutcomereport.receipt']);
            colNames.push('');

            var colModels = [];
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'organization', index: 'organization', formatter: notNullFormatter});
            }
            colModels.push({name: 'cash', index: 'cash', formatter: notNullFormatter});
            colModels.push({name: 'paymenttype', index: 'paymenttype', formatter: notNullFormatter});
            colModels.push({name: 'paymentDescription', index: 'paymentDescription', formatter: notNullFormatter, sortable: false});
            colModels.push({name: 'value', index: 'value', formatter: function (value, options, rowObject) {
                var color = rowObject.direction == 'INCOME' ? 'green' : 'red';
                return '<span style="color: ' + color + '">' + (rowObject.direction == 'INCOME' ? value : -value) + ' ' + MONEY_NAME + '<span>';
            }});
            colModels.push({name: 'paymentdate', index: 'paymentdate', formatter: notNullFormatter});
            colModels.push({name: 'author', index: 'author', formatter: notNullFormatter});
            colModels.push({name: 'createdate', index: 'createdate', formatter: notNullFormatter});
            colModels.push({name: 'modifer', index: 'modifer', formatter: notNullFormatter});
            colModels.push({name: 'modificationdate', index: 'modificationdate', formatter: notNullFormatter});
            colModels.push({name: 'comment', index: 'comment', formatter: notNullFormatter, sortable: false});
            colModels.push({name: 'receipt', index: 'receipt', sortable: false, formatter: function (cellvalue, options, rowObject) {
                return cellvalue ? messages['common.yes'] : messages['common.no'] ;
            }});
            colModels.push({name: 'id', index: 'id', sortable: false, formatter: function (cellvalue, options, rowObject) {
                return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.incomeOutcomeReport.editPayment(' + cellvalue + ')">' + messages['common.edit'] + '</a>';
            }});

            paymentsDataGrid = $('#payments').jqGrid({
                datatype: loadPaymentsLists,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#paymentsPager',
                sortname: 'createdate', viewrecords: true, sortorder: "desc",
                ondblClickRow: function (rowid, iRow, iCol, e) {
                    if (!DEMO && !VIEWER) {
                        DIALOGS.paymentDialog.editPayment(rowid, {}, function () {
                            that.loadPayments()
                        });
                    }
                }
            });
            paymentsDataGrid.jqGrid('setGridWidth', financeHelper.TABLE_WIDTH);
        } else {
            paymentsDataGrid.setGridParam({
                page: 1
            });
            paymentsDataGrid.trigger("reloadGrid");
        }
    };


    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    var collectSearchParams = function () {
        return {
            filterpaymentdatefrom: $('#filterpaymentdatefrom').val() ? $('#filterpaymentdatefrom').val() : '',
            filterpaymentdateto: $('#filterpaymentdateto').val() ? $('#filterpaymentdateto').val() : '',
            paymentCashFilter: $('#paymentCashFilter').val() ? $('#paymentCashFilter').val() : '',
            paymentTypeFilter: $('#paymentTypeFilter').val() ? $('#paymentTypeFilter').val() : '',
            receiptFilter: $('#receiptFilter').val() ? $('#receiptFilter').val() : ''
        }
    };

    var loadPaymentsLists = function (postdata) {
        postdata = $.extend(postdata, collectSearchParams());

        commonHelper.callAjaxMethod('finance.htm', 'loadPayments',
            postdata, function (result) {
                paymentsDataGrid.clearGridData(true);
                paymentsDataGrid[0].addJSONData(result.data);

                if (!referenceInited) {
                    referenceInited = true;
                    $('#paymentCashFilter').children(null).remove();
                    $('<option>').appendTo($('#paymentCashFilter'));

                    $('#paymentTypeFilter').children(null).remove();
                    $('<option>').appendTo($('#paymentTypeFilter'));

                    var cashes = [
                        {id: '', name: ''}
                    ].concat(result.cashes);
                    var paymentTypes = [
                        {id: '', name: ''}
                    ].concat(result.paymentTypes);

                    $('#paymentCashFilter').directives({
                        'option': {
                            'cash <- cashes': {
                                '.': 'cash.name',
                                '@value': 'cash.id'
                            }
                        }
                    }).render({cashes: cashes});

                    $('#paymentTypeFilter').directives({
                        'option': {
                            'paymentType <- paymentTypes': {
                                '.': 'paymentType.name',
                                '@value': 'paymentType.id'
                            }
                        }
                    }).render({paymentTypes: paymentTypes});
                }
                if (result.data && result.data.additionalAggregationList) {
                    $('#sumValue').html(result.data.additionalAggregationList[0].totalValue);
                }
            }, true);
    };


    return this;
}
function incomereport_helper(financeHelper) {
    var that = this;
    var financeDataGrid = null;

    var inited = false;

    that.display = function () {
        if (!inited) {
            inited = true;
            initReferences();
            initFinanceTab();
            that.refreshIncomeFinanceLists();
        }
    };

    var initFinanceTab = function () {
        commonHelper.setDatePicker($('#filterincomefinancedatefrom'));
        commonHelper.setDatePicker($('#filterincomefinancedateto'));

        var initDateTo = new Date();
        var initDateFrom = new Date();

        initDateFrom.setDate(1);
        initDateFrom.setMonth(8);

        if (initDateTo.getMonth() >= 8) {
            initDateFrom.setYear(initDateTo.getFullYear());
        } else {
            initDateFrom.setYear(initDateTo.getFullYear() - 1);
        }

        $('#filterincomefinancedatefrom').datepicker('setDate', initDateFrom);
        $('#filterincomefinancedateto').datepicker('setDate', initDateTo);
    };


    commonHelper.registerChangeOrganizationListener(function (organizationId) {
        initReferences();
        that.clearIncomeFinanceFilterParams();
        that.refreshIncomeFinanceLists();
    });

    this.clearIncomeFinanceFilterParams = function () {
        $('#incomefinancecourse').val('');
        $('#incomefinanceteacher').val('');
        $('#incomefinanceadditionalteacher').val('');
        $('#incomepaymenttype').val('');
        $('#filterincomefinancedatefrom').val('');
        $('#filterincomefinancedateto').val('');
        $('#incomefinancegroup').val('NONE');

        var initDateTo = new Date();
        var initDateFrom = new Date();


        initDateFrom.setDate(1);
        initDateFrom.setMonth(8);

        if (initDateTo.getMonth() >= 8) {
            initDateFrom.setYear(initDateTo.getFullYear());
        } else {
            initDateFrom.setYear(initDateTo.getFullYear() - 1);
        }

        $('#filterincomefinancedatefrom').datepicker('setDate', initDateFrom);
        $('#filterincomefinancedateto').datepicker('setDate', initDateTo);

    };

    this.refreshIncomeFinanceLists = function () {
        if (!financeDataGrid) {
            var colNames = [
                messages['finance.incomereport.group'],
                messages['finance.incomereport.incomesubscription'],
                messages['finance.incomereport.incomeonce'],
                messages['finance.incomereport.total']
            ];

            var colModels = [
                {name: 'groupname', index: 'groupname', formatter: 'string'},
                {name: 'incomesubscription', index: 'incomesubscription', formatter: commonHelper.currencyFormatter},
                {name: 'incomeonce', index: 'incomeonce', formatter: commonHelper.currencyFormatter},
                {name: 'total', index: 'total', formatter: commonHelper.currencyFormatter}
            ];

            financeDataGrid = $('#filterResultIncomeFinances').jqGrid({
                datatype: loadFinanceLists,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                footerrow: true,
                jsonReader: { repeatitems: false, id: "groupname"},
                sortname: 'groupname', viewrecords: true, sortorder: "desc"
            });
            financeDataGrid.jqGrid('setGridWidth', financeHelper.TABLE_WIDTH);
        } else {
            financeDataGrid.setGridParam({
                page: 1
            });
            financeDataGrid.trigger("reloadGrid");
        }
    };

    that.downloadExcel = function () {
        if (financeDataGrid.jqGrid('getGridParam', 'reccount') > 0) {
            var params = collectSearchParams();

            var sortColumnName = financeDataGrid.jqGrid('getGridParam', 'sortname');
            var sortOrder = financeDataGrid.jqGrid('getGridParam', 'sortorder');

            var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&';
            var existNotEmptyParam = false;
            for (var param in params) {
                var paramValue = params[param];
                existNotEmptyParam |= paramValue ? true : false;
                paramsString += param + '=' + paramValue + '&';
            }

            var excelFunction = function () {
                window.location.assign("finance.htm?method=downloadIncomeReportAsExcel" + (paramsString ? '&' + paramsString : ''));
            };
            if (!existNotEmptyParam) {
                DIALOGS.askYesNoDialog(messages['common.filternoparam'], messages['common.yes'], excelFunction);
            } else {
                excelFunction();
            }
        } else {
            commonHelper.showMessage(messages['common.filternodata']);
        }
    };

    var collectSearchParams = function () {
        return {
            teacherid: $('#incomefinanceteacher').val() ? $('#incomefinanceteacher').val() : '',
            additionalteacherid: $('#incomefinanceadditionalteacher').val() ? $('#incomefinanceadditionalteacher').val() : '',
            filterfinancedateto: $('#filterincomefinancedateto').val() ? $('#filterincomefinancedateto').val() : '',
            filterfinancedatefrom: $('#filterincomefinancedatefrom').val() ? $('#filterincomefinancedatefrom').val() : '',
            filtergroup: $('#incomefinancegroup').val() ? $('#incomefinancegroup').val() : '',
            filtercourseid: $('#incomefinancecourse').val() ? $('#incomefinancecourse').val() : '',
            filterpaymenttype: $('#incomepaymenttype').val() ? $('#incomepaymenttype').val() : ''
        }
    };

    var loadFinanceLists = function (postdata) {
        postdata = $.extend(postdata, collectSearchParams());

        commonHelper.callAjaxMethod('finance.htm', 'filterIncomeFinances',
            postdata, function (result) {
                financeDataGrid.clearGridData(true);
                financeDataGrid[0].addJSONData(result.data);

                if (result.data.total > 0) {
                    result.total.rows[0].groupname = messages['common.total'];
                    financeDataGrid.jqGrid('footerData', 'set', result.total.rows[0]);
                }
            }, true);
    };

    var initReferences = function () {
        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.courses = [
                {name: '', courseid: ''}
            ].concat(result.courses.rows);
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.teachers.rows);
            references.paymenttypes = [
                {name: '', paymenttypeid: ''}
            ].concat(result.paymenttypes.rows);

            var financecourseSelect = $('#incomefinancecourse');
            initReferenceSelect(financecourseSelect, references, 'course', 'coursetypeid');

            var financeteacherSelect = $('#incomefinanceteacher');
            initReferenceSelect(financeteacherSelect, references, 'teacher', 'teacherid');

            var financeadditionalteacherSelect = $('#incomefinanceadditionalteacher');
            initReferenceSelect(financeadditionalteacherSelect, references, 'teacher', 'teacherid');

            var incomePaymentTypeSelect = $('#incomepaymenttype');
            initReferenceSelect(incomePaymentTypeSelect, references, 'paymenttype', 'id');

        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.name',
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

    };

    return this;
}function moneyflowreport_helper(financeHelper) {
    var that = this;

    var inited = false;
    var referenceInited = false;
    var flowDataGrid = null;


    that.display = function () {
        if (!inited) {
            commonHelper.setDatePicker($('#filtermoneyflowldatefrom'));
            commonHelper.setDatePicker($('#filtermoneyflowldateto'));

            $('#filtermoneyflowldatefrom').datepicker('setDate', new Date());
            $('#filtermoneyflowldateto').datepicker('setDate', new Date());

            commonHelper.registerChangeOrganizationListener(function (organizationId) {
                that.refreshMoneyFlowList();
            });

            that.refreshMoneyFlowList();
            inited = true;
        }
    };

    var collectSearchParams = function () {
        return {
            filtermoneyflowldatefrom: $('#filtermoneyflowldatefrom').val() ? $('#filtermoneyflowldatefrom').val() : '',
            filtermoneyflowldateto: $('#filtermoneyflowldateto').val() ? $('#filtermoneyflowldateto').val() : '',
            moneyflowuser: $('#moneyflowuser').val() ? $('#moneyflowuser').val() : '',
            moneyflowcash: $('#moneyflowcash').val() ? $('#moneyflowcash').val() : ''
        }
    };

    that.downloadExcel = function () {
        if (flowDataGrid.jqGrid('getGridParam', 'reccount') > 0) {
            var params = collectSearchParams();

            var sortColumnName = flowDataGrid.jqGrid('getGridParam', 'sortname');
            var sortOrder = flowDataGrid.jqGrid('getGridParam', 'sortorder');

            var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&';
            var existNotEmptyParam = false;
            for (var param in params) {
                var paramValue = params[param];
                existNotEmptyParam |= paramValue ? true : false;
                paramsString += param + '=' + paramValue + '&';
            }

            var excelFunction = function () {
                window.location.assign("finance.htm?method=downloadMoneyFlowReportAsExcel" + (paramsString ? '&' + paramsString : ''));
            };
            if (!existNotEmptyParam) {
                DIALOGS.askYesNoDialog(messages['common.filternoparam'], messages['common.yes'], excelFunction);
            } else {
                excelFunction();
            }
        } else {
            commonHelper.showMessage(messages['common.filternodata']);
        }
    };

    that.refreshMoneyFlowList = function () {
        if (!flowDataGrid) {
            var colNames = [
                messages['finance.moneyflowreport.type'],
                messages['finance.moneyflowreport.income'],
                messages['finance.moneyflowreport.outcome']
            ];

            var colModels = [
                {name: 'paymenttype', index: 'paymenttype', formatter: 'string'},
                {name: 'income', index: 'income', formatter: commonHelper.currencyFormatter},
                {name: 'outcome', index: 'outcome', formatter: commonHelper.currencyFormatter}
            ];

            flowDataGrid = $('#filterResultMoneyFlow').jqGrid({
                datatype: loadMoneyFlow,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                footerrow: true,
                userDataOnFooter: true,
                jsonReader: { repeatitems: false, id: "paymenttype"},
                sortname: 'paymenttype', viewrecords: true, sortorder: "asc",
                rowNum: 25, pager: '#filterResultMoneyFlowPager'
            });
            flowDataGrid.jqGrid('setGridWidth', financeHelper.TABLE_WIDTH);
        } else {
            flowDataGrid.setGridParam({
                page: 1
            });
            flowDataGrid.trigger("reloadGrid");
        }
    };

    var loadMoneyFlow = function (postdata) {
        postdata = $.extend(postdata, collectSearchParams());

        commonHelper.callAjaxMethod('finance.htm', 'loadMoneyFlow',
            postdata, function (result) {
                flowDataGrid.clearGridData(true);

                if (result.data && result.data.additionalAggregationList) {
                    flowDataGrid[0].addJSONData(result.data);
                    flowDataGrid.jqGrid('addRowData', -1, {'paymenttype': '<b style="font-size: 12px">' + messages['finance.moneyflowreport.saldo'] + '</b>', 'income': '<b style="font-size: 12px">' + commonHelper.currencyFormatter(result.data.additionalAggregationList[0].prevsaldo) + '</b>'}, 'first');
                    flowDataGrid.jqGrid('addRowData', -1, {'paymenttype': '<b style="font-size: 12px">' + messages['finance.moneyflowreport.oborot'] + '</b>',
                        'income': '<b style="font-size: 12px">' + commonHelper.currencyFormatter(result.data.additionalAggregationList[0].incomesum) + '</b>',
                        'outcome': '<b style="font-size: 12px">' + commonHelper.currencyFormatter(result.data.additionalAggregationList[0].outcomesum) + '</b>'
                    }, 'last');
                    flowDataGrid.jqGrid('footerData', 'set', {'paymenttype': messages['finance.moneyflowreport.saldoend'], 'income': result.data.additionalAggregationList[0].postsaldo});

                    if (!referenceInited) {
                        referenceInited = true;
                        $('#moneyflowcash').children(null).remove();
                        $('<option>').appendTo($('#moneyflowcash'));

                        var cashes = [
                            {id: '', name: ''}
                        ].concat(result.cashes);

                        $('#moneyflowcash').directives({
                            'option': {
                                'cash <- cashes': {
                                    '.': 'cash.name',
                                    '@value': 'cash.id'
                                }
                            }
                        }).render({cashes: cashes});

                        $('#moneyflowuser').children(null).remove();
                        $('<option>').appendTo($('#moneyflowuser'));

                        var users = [
                            {id: '', name: ''}
                        ].concat(result.users);

                        $('#moneyflowuser').directives({
                            'option': {
                                'user <- users': {
                                    '.': 'user.name',
                                    '@value': 'user.id'
                                }
                            }
                        }).render({users: users});

                    }
                }
            }, true);
    };

    that.clearFilter = function () {
        $('#filtermoneyflowldatefrom').val('');
        $('#filtermoneyflowldateto').val('');
        $('#moneyflowuser').val('');
        $('#moneyflowcash').val('');
    };

    return that;
}function realisationreport_helper(financeHelper) {
    var that = this;
    var financeDataGrid = null;

    var inited = false;

    that.display = function () {
        if (!inited) {
            inited = true;
            initReferences();
            initFinanceTab();
            that.refreshFinanceLists();
        }
    };

    var initFinanceTab = function () {
        commonHelper.setDatePicker($('#filterfinancedatefrom'));
        commonHelper.setDatePicker($('#filterfinancedateto'));

        var initDateTo = new Date();
        var initDateFrom = new Date();

        initDateFrom.setDate(1);
        initDateFrom.setMonth(8);

        if (initDateTo.getMonth() >= 8) {
            initDateFrom.setYear(initDateTo.getFullYear());
        } else {
            initDateFrom.setYear(initDateTo.getFullYear() - 1);
        }

        $('#filterfinancedatefrom').datepicker('setDate', initDateFrom);
        $('#filterfinancedateto').datepicker('setDate', initDateTo);
    };


    commonHelper.registerChangeOrganizationListener(function (organizationId) {
        initReferences();
        that.clearFinanceFilterParams();
        that.refreshFinanceLists();
    });

    that.downloadExcel = function () {
        if (financeDataGrid.jqGrid('getGridParam', 'reccount') > 0) {
            var params = collectSearchParams();

            var sortColumnName = financeDataGrid.jqGrid('getGridParam', 'sortname');
            var sortOrder = financeDataGrid.jqGrid('getGridParam', 'sortorder');

            var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&';
            var existNotEmptyParam = false;
            for (var param in params) {
                var paramValue = params[param];
                existNotEmptyParam |= paramValue ? true : false;
                paramsString += param + '=' + paramValue + '&';
            }

            var excelFunction = function () {
                window.location.assign("finance.htm?method=downloadRealisationReportAsExcel" + (paramsString ? '&' + paramsString : ''));
            };
            if (!existNotEmptyParam) {
                DIALOGS.askYesNoDialog(messages['common.filternoparam'], messages['common.yes'], excelFunction);
            } else {
                excelFunction();
            }
        } else {
            commonHelper.showMessage(messages['common.filternodata']);
        }
    };

    this.clearFinanceFilterParams = function () {
        $('#financecourse').val('');
        $('#financeteacher').val('');
        $('#financeadditionalteacher').val('');
        $('#filterfinancedatefrom').val('');
        $('#filterfinancedateto').val('');
        $('#financegroup').val('NONE');

        var initDateTo = new Date();
        var initDateFrom = new Date();


        initDateFrom.setDate(1);
        initDateFrom.setMonth(8);

        if (initDateTo.getMonth() >= 8) {
            initDateFrom.setYear(initDateTo.getFullYear());
        } else {
            initDateFrom.setYear(initDateTo.getFullYear() - 1);
        }

        $('#filterfinancedatefrom').datepicker('setDate', initDateFrom);
        $('#filterfinancedateto').datepicker('setDate', initDateTo);

    };

    this.refreshFinanceLists = function () {
        if (!financeDataGrid) {
            var colNames = [
                messages['finance.realisationreport.group'],
                messages['finance.realisationreport.subscriptioncount'],
                messages['finance.realisationreport.subscriptionavgprice'],
                messages['finance.realisationreport.subscriptionincome'],
                messages['finance.realisationreport.oncecount'],
                messages['finance.realisationreport.onceavgprice'],
                messages['finance.realisationreport.onceincome'],
                messages['finance.realisationreport.total']
            ];

            var colModels = [
                {name: 'groupname', index: 'groupname', formatter: 'string'},
                {name: 'subscriptionlessonscount', index: 'subscriptionlessonscount', formatter: notNullFormatter},
                {name: 'avgsubscriptionsprice', index: 'avgsubscriptionsprice', formatter: commonHelper.currencyFormatter},
                {name: 'incomesubscription', index: 'incomesubscription', formatter: commonHelper.currencyFormatter},
                {name: 'oncelessonscount', index: 'oncelessonscount', formatter: notNullFormatter},
                {name: 'avgonceprice', index: 'avgonceprice', formatter: commonHelper.currencyFormatter},
                {name: 'incomeonce', index: 'incomeonce', formatter: commonHelper.currencyFormatter},
                {name: 'total', index: 'total', formatter: commonHelper.currencyFormatter}
            ];

            financeDataGrid = $('#filterResultFinances').jqGrid({
                datatype: loadFinanceLists,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                footerrow: true,
                jsonReader: { repeatitems: false, id: "groupname"},
                sortname: 'groupname', viewrecords: true, sortorder: "desc"
            });
            financeDataGrid.jqGrid('setGridWidth', financeHelper.TABLE_WIDTH);
        } else {
            financeDataGrid.setGridParam({
                page: 1
            });
            financeDataGrid.trigger("reloadGrid");
        }
    };

    var collectSearchParams = function () {
        return {
            teacherid: $('#financeteacher').val() ? $('#financeteacher').val() : '',
            additionalteacherid: $('#financeadditionalteacher').val() ? $('#financeadditionalteacher').val() : '',
            filterfinancedateto: $('#filterfinancedateto').val() ? $('#filterfinancedateto').val() : '',
            filterfinancedatefrom: $('#filterfinancedatefrom').val() ? $('#filterfinancedatefrom').val() : '',
            filtergroup: $('#financegroup').val() ? $('#financegroup').val() : '',
            filtercourseid: $('#financecourse').val() ? $('#financecourse').val() : ''
        }
    };

    var loadFinanceLists = function (postdata) {
        postdata = $.extend(postdata, collectSearchParams());

        commonHelper.callAjaxMethod('finance.htm', 'filterFinances',
            postdata, function (result) {
                financeDataGrid.clearGridData(true);
                financeDataGrid[0].addJSONData(result.data);

                if (result.data.total > 0) {
                    result.total.rows[0].groupname = messages['common.total'];
                    financeDataGrid.jqGrid('footerData', 'set', result.total.rows[0]);
                }
            }, true);
    };

    var initReferences = function () {
        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.teachers.rows);
            references.schedules = [
                {id: '-1'}
            ].concat(result.schedules.rows);
            references.sourceInfos = [
                {name: '', infosourceid: ''}
            ].concat(result.sourceInfos.rows);
            references.locations = [
                {name: '', locationid: ''}
            ].concat(result.locations.rows);

            references.courses = [
                {name: '', coursetypeid: ''}
            ].concat(result.courses.rows);

            $.each(result.multisubscriptionDescriptions.rows, function(index, item){
                references.courses.push({name: messages['finance.realisationreport.multi'] + ' ' + item.name, coursetypeid: 'multi_' + item.id});
            });

            membershiptype = result.membershiptype;


            var financecourseSelect = $('#financecourse');
            initReferenceSelect(financecourseSelect, references, 'course', 'coursetypeid');

            var financeteacherSelect = $('#financeteacher');
            initReferenceSelect(financeteacherSelect, references, 'teacher', 'teacherid');

            var financeadditionalteacherSelect = $('#financeadditionalteacher');
            initReferenceSelect(financeadditionalteacherSelect, references, 'teacher', 'teacherid');

        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.name',
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    return this;
}function salary_helper(financeHelper) {
    var that = this;

    var inited = false;
    var currentSalaryId = null;
    var salaryPaymentsGrid = null;
    var maxSalaryLessonPriceCount = 10;

    that.display = function () {
        if (!inited) {
            inited = true;
            $('#tab-salary').tabs();
            initReferences();
            that.loadSalaryPayments();
            commonHelper.registerChangeOrganizationListener(function (organizationId) {
                initReferences();
                that.refreshTeacherSalarySettingsList();
                that.loadSalaryPayments();
            });

            that.refreshTeacherSalarySettingsList();
        }
    };

    var initReferences = function () {
        commonHelper.callAjaxMethod('salary.htm', 'loadReferences', {}, function (result) {
            that.refreshTeacherSalarySettingsList();

            $('#salaryPaymentCashFilter').children(null).remove();
            $('<option>').appendTo($('#salaryPaymentCashFilter'));

            var cashes = [
                {id: '', name: ''}
            ].concat(result.cashes);

            $('#salaryPaymentCashFilter').directives({
                'option': {
                    'cash <- cashes': {
                        '.': 'cash.name',
                        '@value': 'cash.id'
                    }
                }
            }).render({cashes: cashes});

            $('#salaryuser').children(null).remove();
            $('<option>').appendTo($('#salaryuser'));

            var users = [
                {id: '', name: ''}
            ].concat(result.users.rows);

            $('#salaryuser').directives({
                'option': {
                    'user <- users': {
                        '.': 'user.name',
                        '@value': 'user.teacherid'
                    }
                }
            }).render({users: users});

            maxSalaryLessonPriceCount = result.maxSalaryLessonPriceCount;

            commonHelper.setDatePicker($('#filtersalarypaymentdatefrom'));
            commonHelper.setDatePicker($('#filtersalarypaymentdateto'));
        });

    };

    that.clearSalaryPaymentsFilter = function () {
        $('#filtersalarypaymentdatefrom').val('');
        $('#filtersalarypaymentdateto').val('');
        $('#salaryuser').val('');
        $('#salaryPaymentCashFilter').val('');
    };

    that.loadSalaryPayments = function () {
        if (!salaryPaymentsGrid) {
            var colNames = [];
            if (ORGS_COUNT > 0) {
                colNames.push(messages['finance.salary.organization']);
            }
            colNames.push(messages['finance.salary.teacher']);
            colNames.push(messages['finance.salary.cash']);
            colNames.push(messages['finance.salary.description']);
            colNames.push(messages['finance.salary.value']);
            colNames.push(messages['finance.salary.date']);
            colNames.push(messages['finance.salary.author']);
            colNames.push(messages['finance.salary.createdate']);
            colNames.push(messages['finance.salary.modifier']);
            colNames.push(messages['finance.salary.modificationdate']);
            colNames.push(messages['finance.salary.comment']);

            var colModels = [];
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'organization', index: 'organization', formatter: commonHelper.notNullFormatter});
            }
            colModels.push({name: 'teacher', index: 'teacher', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'cash', index: 'cash', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'paymentDescription', index: 'paymentDescription', formatter: commonHelper.notNullFormatter, sortable: false});
            colModels.push({name: 'value', index: 'value', formatter: function (value, options, rowObject) {
                var color = rowObject.direction == 'INCOME' ? 'green' : 'red';
                return '<span style="color: ' + color + '">' + (rowObject.direction == 'INCOME' ? value : -value) + ' ' + MONEY_NAME + '<span>';
            }});
            colModels.push({name: 'paymentdate', index: 'paymentdate', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'author', index: 'author', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'createdate', index: 'createdate', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'modifer', index: 'modifer', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'modificationdate', index: 'modificationdate', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'comment', index: 'comment', formatter: commonHelper.notNullFormatter, sortable: false});


            salaryPaymentsGrid = $('#salaryPayments').jqGrid({
                datatype: that.loadSalaryPaymentsList,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#salaryPaymentsPager',
                sortname: 'createdate', viewrecords: true, sortorder: "desc",
                ondblClickRow: function (rowid, iRow, iCol, e) {
                    if (!DEMO && !VIEWER) {
                        DIALOGS.paymentDialog.editPayment(rowid, {}, function () {
                            that.loadSalaryPayments();
                        });
                    }
                }
            });
            salaryPaymentsGrid.jqGrid('setGridWidth', financeHelper.TABLE_WIDTH);
        } else {
            salaryPaymentsGrid.setGridParam({
                page: 1
            });
            salaryPaymentsGrid.trigger("reloadGrid");
        }
    };

    that.loadSalaryPaymentsList = function (postdata) {
        postdata.filtersalarypaymentdatefrom = $('#filtersalarypaymentdatefrom').val() ? $('#filtersalarypaymentdatefrom').val() : '';
        postdata.filtersalarypaymentdateto = $('#filtersalarypaymentdateto').val() ? $('#filtersalarypaymentdateto').val() : '';
        postdata.salaryPaymentCashFilter = $('#salaryPaymentCashFilter').val() ? $('#salaryPaymentCashFilter').val() : '';
        postdata.salaryTeacherFilter = $('#salaryuser').val() ? $('#salaryuser').val() : '';

        commonHelper.callAjaxMethod('salary.htm', 'loadSalaryPayments',
            postdata, function (result) {
                salaryPaymentsGrid.clearGridData(true);
                salaryPaymentsGrid[0].addJSONData(result.data);
                if (result.data && result.data.additionalAggregationList) {
                    $('#salarySumValue').html(result.data.additionalAggregationList[0].totalValue);
                }
            }, true);
    };

    that.deleteSalarySettings = function (salaryId, callBack) {
        DIALOGS.askYesNoDialog(messages['finance.salary.settingconfirm'], messages['common.yes'], function () {
            commonHelper.callAjaxMethod('salary.htm', 'deleteSalary', {salaryId: salaryId}, function () {
                that.refreshTeacherSalarySettingsList();
                if (callBack) {
                    callBack();
                }
            });
        });
    };

    that.selectSalaryElement = function (element) {
        updateTotal();
    };

    that.selectAllSalaries = function () {
        var dialog = $('#generateSalaryDialog');
        var generatesalaries = dialog.find('.generatesalary');
        $.each(generatesalaries, function (index, item) {
            if ($('[name=generatesalarySelectAll]:checked').val() ? true : false) {
                $(item).attr('checked', 'checked')
            } else {
                $(item).removeAttr('checked');
            }
        });
        updateTotal();
    };

    that.generateSalary = function (salaryId) {
        var dialog = $('#generateSalaryDialog');

        var data = loadSalariesElements(salaryId, null);

        dialog.find('.generateCourseFrom').val(data.defaultFrom);
        dialog.find('.generateCourseTo').val(data.defaultTo);

        dialog.find('.generateCourseFromAll').val(data.defaultFrom);
        dialog.find('.generateCourseToAll').val(data.defaultTo);

        var generateFixedYear = dialog.find('.generateFixedYear');
        generateFixedYear.children().remove();
        var currentYear = new Date().getFullYear();
        var currentMonth = new Date().getMonth() + 1;
        for (var yearIndex = currentYear - 2; yearIndex < currentYear + 5; yearIndex++) {
            var option = $('<option>', {value: yearIndex, text: yearIndex});
            option.appendTo(generateFixedYear);
        }

        dialog.find('.generateFixedMonth').val(currentMonth);
        dialog.find('.generateFixedYear').val(currentYear);

        commonHelper.setDatePicker(dialog.find('.generateCourseFromAll'), function (value) {
            var generateCourseFrom = dialog.find('.generateCourseFrom');
            var generateCourseTo = dialog.find('.generateCourseTo');
            var elementsDates = {};

            $.each(generateCourseFrom, function (index, _item) {
                var item = $(_item);
                var elementId = item.attr('salaryelementid');
                if (elementId) {
                    var element = elementsDates[elementId];
                    if (element == null) {
                        element = elementsDates[elementId] = {};
                    }
                    element.from = value;
                }
            });

            $.each(generateCourseTo, function (index, _item) {
                var item = $(_item);
                var elementId = item.attr('salaryelementid');
                if (elementId) {
                    var element = elementsDates[elementId];
                    if (element == null) {
                        element = elementsDates[elementId] = {};
                    }
                    element.to = item.val();
                }
            });

            loadSalariesElements(salaryId, elementsDates);
            dialog.find('.generateCourseTo').val(dialog.find('.generateCourseToAll').val());
            dialog.find('.generateCourseFrom').val(value);

        });
        commonHelper.setDatePicker(dialog.find('.generateCourseToAll'), function (value) {
            var generateCourseFrom = dialog.find('.generateCourseFrom');
            var generateCourseTo = dialog.find('.generateCourseTo');
            var elementsDates = {};

            $.each(generateCourseFrom, function (index, _item) {
                var item = $(_item);
                var elementId = item.attr('salaryelementid');
                if (elementId) {
                    var element = elementsDates[elementId];
                    if (element == null) {
                        element = elementsDates[elementId] = {};
                    }
                    element.from = item.val();
                }
            });

            $.each(generateCourseTo, function (index, _item) {
                var item = $(_item);
                var elementId = item.attr('salaryelementid');
                if (elementId) {
                    var element = elementsDates[elementId];
                    if (element == null) {
                        element = elementsDates[elementId] = {};
                    }
                    element.to = value;
                }
            });

            loadSalariesElements(salaryId, elementsDates);

            dialog.find('.generateCourseFrom').val(dialog.find('.generateCourseFromAll').val());
            dialog.find('.generateCourseTo').val(value);

        });

        REFERENCE.openEditReferenceDialog('generateSalaryDialog', {
            buttons: {
                'saveButton': {
                    title: messages['finance.salary.pay'],
                    action: function () {

                        var salaryElements = dialog.find('.salaryelement');
                        var paramElements = [];
                        $.each(salaryElements, function (index, _item) {
                            var item = $(_item);
                            if (item.find('.generatesalary:checked').length > 0) {
                                var paramElement = {};

                                paramElement.id = item.attr('id');
                                paramElement.from = item.find('.generateCourseFrom').val();
                                paramElement.to = item.find('.generateCourseTo').val();
                                paramElement.fixedMonth = item.find('.generateFixedMonth').val();
                                paramElement.fixedYear = item.find('.generateFixedYear').val();
                                paramElement.correction = item.find('.correction').val() ? item.find('.correction').val() : 0;
                                paramElements.push(paramElement);
                            }
                        });
                        dialog.find('.message').html('');
                        commonHelper.callAjaxMethod('salary.htm', 'paySalary', {params: JSON.stringify(
                            {
                                salaryId: salaryId ? salaryId : '',
                                total: dialog.find('.total').html(),
                                cashId: dialog.find('#salarycash').val(),
                                elements: paramElements
                            }
                        )}, function (data) {
                            if (!data && paramElements.length > 0) {
                                dialog.find('.salaryCommonMessage').html('');
                                REFERENCE.closeEditReferenceDialog('generateSalaryDialog');
                            } else {
                                if (data) {
                                    $.each(data, function (index, element) {
                                        var salaryElement = dialog.find('#salaryelement-' + index);
                                        var message = salaryElement.find('.message');
                                        message.html(messages['finance.salary.payexist'] + ' ' + element.paidFrom + ' - ' + element.paidTo);
                                        dialog.find('.salaryCommonMessage').html(messages['finance.salary.payerror']);
                                    });
                                }
                            }
                        });

                        return false;
                    }
                }
            },

            onClose: function () {

            }
        });

    };

    that.onCorrectionChange = function (correctionInput) {
        var salaryElement = correctionInput.parents().filter('.salaryelement');
        var defaultVal = salaryElement.find('.elementSum').attr('defaultVal');
        var correctionValue = parseFloat(correctionInput.val());
        if (correctionValue) {
            salaryElement.find('.elementSum').html((parseFloat(defaultVal) + correctionValue).toFixed(2));
        } else {
            salaryElement.find('.elementSum').html(defaultVal);
        }
        updateTotal();
    };

    var updateTotal = function () {
        var dialog = $('#generateSalaryDialog');
        var elementsSum = dialog.find('.elementSum');
        var totalSum = 0;
        $.each(elementsSum, function (index, element) {
            var salaryElement = $(element).parents().filter('.salaryelement');
            var generatesalary = salaryElement.find('.generatesalary');
            if (generatesalary.filter(':checked').length > 0 && $(element).html()) {
                totalSum += parseFloat($(element).html());
            }
        });

        dialog.find('.salaryCommonMessage').html('');
        dialog.find('.total').html(totalSum.toFixed(2));

    };

    that.updateSalaryElement = function (salaryElementId, from, to) {
        commonHelper.callAjaxMethod('salary.htm', 'loadSalaryElement',
            {
                salaryElementId: salaryElementId ? salaryElementId : '',
                from: from,
                to: to
            },
            function (data) {
                var dialog = $('#generateSalaryDialog');
                var filledTemplate = dialog.find('.salaryelementTemplate').clone().show();
                filledTemplate.removeClass('salaryelementTemplate');

                dialog.find('#salaryelement-' + salaryElementId).replaceWith(filledTemplate);
                filledTemplate.attr('id', 'salaryelement-' + salaryElementId);

                fillSalaryElement(dialog, filledTemplate, data, from, to);
                updateTotal();
            });
    };

    var loadSalariesElements = function (salaryId, elementsDates) {
        var result;
        commonHelper.callAjaxMethod('salary.htm', 'generateSalary', {params: JSON.stringify({salaryId: salaryId, elementsDates: elementsDates})}, function (data) {
            result = data;
            var dialog = $('#generateSalaryDialog');
            var generateElementsList = dialog.find('.generatesalaryelements');
            dialog.find('.generatesalary').removeAttr('checked');
            dialog.find('[name=generatesalarySelectAll]').removeAttr('checked');
            generateElementsList.children().remove();

            dialog.find('.generateSalaryInfo').find('.teacher').html(data.salary.teacher.name);

            $('#salarycash').children(null).remove();
            $('<option>').appendTo($('#salarycash'));

            var cashes = [
                {id: '', name: ''}
            ].concat(result.cashes);

            $('#salarycash').directives({
                'option': {
                    'cash <- cashes': {
                        '.': 'cash.name',
                        '@value': 'cash.id'
                    }
                }
            }).render({cashes: cashes});

            $('#salarycash').val(data.defaultCash);

            var template = dialog.find('.salaryelementTemplate');
            $.each(data.salary.elements, function (index, element) {
                var object = template.clone();
                object.removeClass('salaryelementTemplate');
                object.attr('id', 'salaryelement-' + element.id);
                object.show().appendTo(dialog.find('.generatesalaryelements'));
                fillSalaryElement(dialog, object, element, elementsDates ? elementsDates[element.id].from : null, elementsDates ? elementsDates[element.id].to : null);
            });
            updateTotal();
        }, false);
        return result;
    };

    var fillSalaryElement = function (dialog, template, data, from, to) {
        var filledTemplate = template.directives({
            '.comment': 'comment',
            '@salaryElementType': 'salaryElementType',
            '.value': function (context) {
                return context.context.value ? context.context.value + ' ' + MONEY_NAME : ''
            },
            '.courseType': 'courseType.name',
            '.onlyVisited': function (context) {
                if (context.context.salaryElementType == 'course') {
                    return context.context.onlyVisited ? messages['finance.salary.onlyvisited'] : messages['finance.salary.notonlyvisited']
                } else {
                    return '';
                }
            },
            '.elementSum': 'finalSum',
            '.elementSum@defaultVal': 'finalSum',
            '.generateCourseFrom@salaryElementId': 'id',
            '.generateCourseTo@salaryElementId': 'id',
            '.generateFixedMonth@salaryElementId': 'id',
            '.generateFixedYear@salaryElementId': 'id',
            '.realizationPercentValue': 'realizationPercent',
            '.compensationPriceValue': 'compensationPrice',
            '.compensationsCount': 'compensationsCount',
            '.realizationCalculatedValue': 'realisationMoneyAmountWithPercent',
            '.realisationMoneyAmount': 'realisationMoneyAmount',
            '.fullStudentsGroupsSum': 'elementsSum',
            '.fullStudentsGroupsSumDiv@style+': function (context) {
                return context.context.studentsCountToMoneyEntries && context.context.studentsCountToMoneyEntries.length > 0 ? '' : 'display: none;'
            },
            '.fullStudentsGroupsSumTitle@style+': function (context) {
                return context.context.studentsCountToMoneyEntries && context.context.studentsCountToMoneyEntries.length > 0 ? '' : 'display: none;'
            },
            '.realizationInfo@style+': function (context) {
                return context.context.realizationPercent ? '' : 'display: none;'
            },
            '.realizationPercentTitle@style+': function (context) {
                return context.context.studentsCountToMoneyEntries && context.context.studentsCountToMoneyEntries.length > 0 ? '' : 'display: none;'
            },
            '.realizationPercent': function (context) {
                return context.context.realizationPercent ? '<label>' + messages['finance.salary.realizationpercent'] + '</label> <span style="margin: 0; padding: 0;font-weight: bold;">' + context.context.realizationPercent + '%</span>' : ''
            },
            '.salaryType': function (context) {
                switch (context.context.salaryElementType) {
                    case 'fixed':
                        return messages['finance.salary.type.fixed'];
                    case 'course':
                        return messages['finance.salary.type.course'];
                    case 'schedule':
                        return messages['finance.salary.type.schedule'];
                }
                return '';
            },
            '.coursePeriod@style+': function (context) {
                switch (context.context.salaryElementType) {
                    case 'fixed':
                        return 'display: none';
                    case 'schedule':
                        return 'display: none';
                    case 'course':
                        return '';
                }
                return '';
            },
            '.fixedPeriod@style+': function (context) {
                switch (context.context.salaryElementType) {
                    case 'fixed':
                        return '';
                    case 'schedule':
                        return '';
                    case 'course':
                        return 'display: none';
                }
                return '';
            },
            '.studentcounttomoney': {
                'sc2money <- studentsCountToMoneyEntries': {
                    '.studentCount': 'sc2money.childrenCount',
                    '.money': 'sc2money.groupSalary',
                    '.studentsGroupsCount': 'sc2money.groupsCount',
                    '.studentsGroupsSum': 'sc2money.studentsGroupsSum'

                }
            }
        }).render(data);

        var message = filledTemplate.find('.message');
        if (data.paidSalary) {
            message.html(messages['finance.salary.payexist'] + ' ' + data.paidSalary.paidFrom + ' - ' + data.paidSalary.paidTo);
        } else {
            message.html('');
        }


        if (from) {
            var date = commonHelper.parseDate(from);
            filledTemplate.find('.generateFixedMonth').val(date.getMonth() + 1);
            filledTemplate.find('.generateFixedYear').val(date.getFullYear());

            filledTemplate.find('.generateCourseFrom').val(from);
            filledTemplate.find('.generateCourseTo').val(to);
        }

        commonHelper.setDatePicker(filledTemplate.find('.generateCourseFrom'), function (value, inst) {
            var pickerElement = $('#' + $(inst).attr('id'));
            that.updateSalaryElement(pickerElement.attr('salaryelementid'), value, pickerElement.parent().find('.generateCourseTo').val());
        });
        commonHelper.setDatePicker(filledTemplate.find('.generateCourseTo'), function (value, inst) {
            var pickerElement = $('#' + $(inst).attr('id'));
            that.updateSalaryElement(pickerElement.attr('salaryelementid'), pickerElement.parent().find('.generateCourseFrom').val(), value);
        });

        filledTemplate.find('.generateFixedMonth').bind('change', function (e) {
            var dateStr = '01/' + filledTemplate.find('.generateFixedMonth').val() + '/' + filledTemplate.find('.generateFixedYear').val();
            var date = commonHelper.parseDateWithFormat(dateStr, 'dd/mm/yy');
            that.updateSalaryElement($(e.target).attr('salaryelementid'), commonHelper.formatDate(date), commonHelper.formatDate(date));
        });
        filledTemplate.find('.generateFixedYear').bind('change', function (e) {
            var dateStr = '01/' + filledTemplate.find('.generateFixedMonth').val() + '/' + filledTemplate.find('.generateFixedYear').val();
            var date = commonHelper.parseDateWithFormat(dateStr, 'dd/mm/yy');
            that.updateSalaryElement($(e.target).attr('salaryelementid'), commonHelper.formatDate(date), commonHelper.formatDate(date));
        });

        return filledTemplate;
    };

    that.addSalarySettings = function () {
        that.editSalarySettings(null);
    };

    that.editSalarySettings = function (salaryId) {
        currentSalaryId = salaryId;
        commonHelper.callAjaxMethod('salary.htm', 'loadSalary', {salaryId: salaryId ? salaryId : ''}, function (data) {
            if (!data) {
                data = {
                    name: ''
                }
            }

            var elementsList = $('.salaryElementList');
            elementsList.children(null).remove();

            $('#salaryTeacher').children(null).remove();
            $('<option>').appendTo($('#salaryTeacher'));

            $('.salaryElementCourse').children(null).remove();
            $('<option>').appendTo($('.salaryElementCourse'));

            $('#salaryTeacher').directives({
                'option': {
                    'teacher <- rows': {
                        '.': 'teacher.name',
                        '.@value': 'teacher.teacherid'
                    }
                }

            }).render(data.teachers);

            $('.salaryElementCourse').directives({
                'option': {
                    'course <- rows': {
                        '.': 'course.name',
                        '.@value': 'course.coursetypeid'
                    }
                }

            }).render(data.courses);

            if (data.selectedOrgName) {
                $('#salaryOrganization').html(data.selectedOrgName);
            } else {
                $('#salaryOrganization').html('');
            }

            if (salaryId) {
                $('#salaryTeacher').val(data.data.salaryInfo.teacher.id);
                $('#salaryTeacher').attr('disabled', 'disabled');
                if (data.data.salaryInfo.organization) {
                    $('#salaryOrganization').html(data.data.salaryInfo.organization.name);
                }

                var elements = data.data.salaryInfo.elements;
                $.each(elements, function (index, item) {
                    var element;
                    if (item.salaryElementType == 'fixed') {
                        element = that.addFixedSalaryElement(messages['finance.salary.type.fixed']);

                        element.find('[name=fixedValue]').val(item.value);
                        element.find('[name=salaryElementId]').val(item.id);

                    } else if (item.salaryElementType == 'course') {
                        element = that.addCourseSalaryElement(messages['finance.salary.coursepayment'] + ' ' + commonHelper.decodeHtmlString(item.courseType.name), false);

                        element.find('.salaryElementCourse').val(item.courseType.id);
                        element.find('[name=realizationPercent]').val(item.realizationPercent);
                        element.find('[name=compensationPrice]').val(item.compensationPrice);
                        element.find('.courseSalaryElementTitle').html(': ' + item.courseType.name);
                        if (item.onlyVisited) {
                            element.find('[name=onlyVisited]').attr('checked', 'checked');
                        } else {
                            element.find('[name=onlyVisited]').removeAttr('checked');
                        }

                        var lessonCountPrices = element.find('[name=lessonCountPrice]');
                        $.each(item.studentsCountToMoney, function (index, value) {
                            $(lessonCountPrices[index - 1]).val(value);
                        });
                    }
                    else if(item.salaryElementType == 'schedule') {
                        element = that.addScheduleSalaryElement(messages['finance.salary.type.schedule']);

                        element.find('[name=rateValue]').val(item.rate);
                        element.find('[name=salaryElementId]').val(item.id);
                    }
                    
                    element.find('.deleteSalaryElement').attr('salaryElementId', item.id);
                    element.attr('salaryElementId', item.id);
                    element.find('[name=salaryElementComment]').val(commonHelper.decodeHtmlString(item.comment));
                });
            } else {
                $('#salaryTeacher').removeAttr('disabled');
            }

            REFERENCE.openEditReferenceDialog('salaryDialog', {
                    buttons: {
                        'saveButton': {
                            title: messages['common.save'],
                            action: function () {

                                var params = collectSalaryElements();
                                var validate = function (params) {

                                    return true;
                                };

                                if (validate(params)) {
                                    commonHelper.callAjaxMethod('salary.htm', 'saveSalary', {data: JSON.stringify(params)}, function (data) {
                                        if (!data) {
                                            commonHelper.showMessage(messages['finance.salary.saveerror']);
                                        } else {
                                            that.refreshTeacherSalarySettingsList();
                                            REFERENCE.closeEditReferenceDialog('salaryDialog');
                                        }
                                    });
                                }
                            }
                        },
                        'deleteButton': {
                            title: messages['common.remove'],
                            position: 'left',
                            action: function () {
                                that.deleteSalarySettings(currentSalaryId, function () {
                                    REFERENCE.closeEditReferenceDialog('salaryDialog');
                                });
                            }
                        }
                    },
                    onClose: function () {

                    }
                }
            );

            var collectSalaryElements = function () {
                var dialog = $('#salaryDialog');
                var elements = dialog.find('.salaryElementList').children('.salaryElement');
                var result = {};
                result.salaryId = currentSalaryId;
                result.teacherId = dialog.find('.salaryTeacher').val() ? dialog.find('.salaryTeacher').val() : '';

                result.elements = [];
                $.each(elements, function (index, _item) {
                    var item = $(_item);
                    var type = item.find('[name=salaryType]').val();
                    var salaryElementId = item.find('[name=salaryElementId]').val();
                    var comment = item.find('[name=salaryElementComment]').val();

                    var salaryElement = {};
                    salaryElement.comment = comment;
                    salaryElement.salaryElementId = salaryElementId;
                    salaryElement.salaryType = type;

                    if (type == 'fixed') {
                        salaryElement.fixedValue = item.find('[name=fixedValue]').val();
                    } else if(type == 'course') {
                        salaryElement.salaryElementCourseId = item.find('[name=salaryElementCourse]').val();
                        salaryElement.realizationPercent = item.find('[name=realizationPercent]').val();
                        salaryElement.compensationPrice = item.find('[name=compensationPrice]').val();
                        salaryElement.onlyVisited = item.find('[name=onlyVisited]:checked').val() ? true : false;

                        var lessonCountPrices = item.find('[name=lessonCountPrice]');
                        salaryElement.lessonCountPrices = [];
                        $.each(lessonCountPrices, function (index, item) {
                            salaryElement.lessonCountPrices.push($(item).val());
                        });
                    }
                    else if(type == 'schedule') {
                        salaryElement.rate = item.find('[name=rateValue]').val();
                    }

                    result.elements.push(salaryElement);
                });

                return result;
            };
        });
    };

    that.refreshTeacherSalarySettingsList = function () {
        REFERENCE.fillReferenceList('salaries', 'salary.htm', 'loadSalariesSettings', {
                sortOrder: 'asc',
                sortName: 'id',
                fillCallback: function (list, template, data) {
                    var row = template.clone();
                    row.removeClass('salariesTemplate');
                    row.show();
                    row.appendTo(list);

                    var result = list.directives({
                            '.salariesRow': {
                                'row <- rows': {
                                    '.teacher': 'row.salary.teacher.name',
                                    '.organization': 'row.salary.organization.name',
                                    '.deleteSalary@salaryId': 'row.salary.id',
                                    '.editSalary@salaryId': 'row.salary.id',
                                    '.generateSalary@salaryId': 'row.salary.id',
                                    '.salaryelements': {
                                        'element <- row.salary.elements': {
                                            '.comment': 'element.comment',
                                            '.value': function (context) {
                                                return context.item.value ? context.item.value + ' ' + MONEY_NAME : context.item.rate ? context.item.rate + ' ' + MONEY_NAME : ''
                                            },
                                            '.courseType': 'element.courseType.name',
                                            '.onlyVisited': function (context) {
                                                if (context.item.salaryElementType == 'course') {
                                                    return context.item.onlyVisited ? messages['finance.salary.onlyvisited'] : messages['finance.salary.notonlyvisited']
                                                } else {
                                                    return '';
                                                }
                                            },
                                            '.realizationPercent': function (context) {
                                                return context.item.realizationPercent ? '<label>' + messages['finance.salary.realizationpercent'] + '</label> <span style="margin: 0; padding: 0;font-weight: bold;">' + context.item.realizationPercent + '%</span>' : ''
                                            },
                                            '.compensationPrice': function (context) {
                                                return context.item.compensationPrice ? '<label>' + messages['finance.salary.compensationprice'] + '</label> <span style="margin: 0; padding: 0;font-weight: bold;">' + context.item.compensationPrice + ' ' + MONEY_NAME + '</span>' : ''
                                            },
                                            '.salaryType': function (context) {
                                                switch (context.item.salaryElementType) {
                                                    case 'fixed':
                                                        return messages['finance.salary.type.fixed'];
                                                    case 'course':
                                                        return messages['finance.salary.type.course'];
                                                    case 'schedule':
                                                        return messages['finance.salary.type.schedule'];
                                                }
                                                return '';
                                            },
                                            '.studentcounttomoney': {
                                                'sc2money <- element.studentsCountToMoneyEntries': {
                                                    '.studentCount': 'sc2money.key',
                                                    '.money': 'sc2money.value'
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    ).render(data);

                    if (ORGS_COUNT > 0) {
                        $('.organizationRow').show();

                    } else {
                        $('.organizationRow').hide();
                    }

                    return result;
                }
            }
        );
    };

    that.addFixedSalaryElement = function (title, show) {
        var elementsList = $('.salaryElementList');
        var fixedSalaryElement = $('.fixedSalaryElementTemplate').clone();
        fixedSalaryElement.removeClass('fixedSalaryElementTemplate');

        var titleElement = $('<h3>', {
            text: title,
            style: 'cursor: pointer; padding-top: 1px;margin: 0;'
        });
        titleElement.show().appendTo(elementsList);
        fixedSalaryElement.show().appendTo(elementsList);
        fixedSalaryElement.data('titleObject', titleElement);
        if (show) {
            fixedSalaryElement.show();
        }
        return fixedSalaryElement;
    };

    that.addCourseSalaryElement = function (title, show) {
        var elementsList = $('.salaryElementList');
        var courseSalaryElement = $('.courseSalarySettingsTemplate').clone();
        courseSalaryElement.removeClass('courseSalarySettingsTemplate');
        var titleElement = $('<h3>', {
            text: title,
            style: 'cursor: pointer; padding-top: 1px;margin: 0;'
        });
        titleElement.show().appendTo(elementsList);
        courseSalaryElement.show().appendTo(elementsList);
        courseSalaryElement.data('titleObject', titleElement);
        if (show) {
            courseSalaryElement.show();
        }

        var lessonCountPriceContainer = courseSalaryElement.find('.lessonCountPriceContainer');
        lessonCountPriceContainer.children().remove();
        var lessonCountPriceContainerRow;
        for (var priceIndex = 0; priceIndex < maxSalaryLessonPriceCount; priceIndex++) {

            if (priceIndex % 4 == 0) {
                $('<div>', {'style': 'clear: both'}).appendTo(lessonCountPriceContainer);
                lessonCountPriceContainerRow = $('<div>');
                lessonCountPriceContainerRow.appendTo(lessonCountPriceContainer);
            }

            var lessonPrice = $('.lessonCountPriceTemplate').clone();
            lessonPrice.find('.lessonCountPriceTitle').html((priceIndex == maxSalaryLessonPriceCount - 1 ? '≥' : '') + (priceIndex + 1));
            lessonPrice.removeClass('lessonCountPriceTemplate');
            lessonPrice.addClass('lessonCountPrice');
            lessonPrice.show();
            lessonPrice.appendTo(lessonCountPriceContainerRow);

        }

        return courseSalaryElement;
    };

    
    that.addScheduleSalaryElement = function (title, show) {
        var elementsList = $('.salaryElementList');
        var scheduleSalaryElement = $('.scheduleSalarySettingsTemplate').clone();
        scheduleSalaryElement.removeClass('scheduleSalarySettingsTemplate');
        var titleElement = $('<h3>', {
            text: title,
            style: 'cursor: pointer; padding-top: 1px;margin: 0;'
        });
        titleElement.show().appendTo(elementsList);
        scheduleSalaryElement.show().appendTo(elementsList);
        scheduleSalaryElement.data('titleObject', titleElement);
        if (show) {
            scheduleSalaryElement.show();
        }

        return scheduleSalaryElement;
    };

    that.deleteSalaryElement = function (salaryElement) {
        salaryElement.data('titleObject').remove();
        salaryElement.remove();
    };

    return that;
}function marketingReferences_helper() {
    var that = this;

    that.display = function () {
        that.createMarketingRejectionsTable();
        that.createMarketingAdCompaniesTable();
    };

    this.createMarketingRejectionsTable = function () {
        $('#marketingRejectionsTable').jqGrid({
            caption: messages['marketing.references.rejections'],
            url: "marketing.htm?method=loadMarketingRejections",
            datatype: "json",
            colNames: [messages['marketing.references.rejections.name'], messages['marketing.references.rejections.comment']],
            colModel: [
                {name: 'name', index: 'name', formatter: 'string', editable: true, required: true, editoptions: {size: 47}},
                {name: 'comment', index: 'comment', formatter: 'string', editable: true, required: true, sortable: false, edittype: "textarea", editoptions: {rows: "20", cols: "45"}}
            ],
            autowidth: true,
            height: "100%",
            jsonReader: { repeatitems: false, id: "marketingrejectionsid"},
            rowNum: 10,
            pager: '#marketingRejectionsPager',
            sortname: 'marketingrejectionsid',
            viewrecords: true,
            sortorder: "desc",
            editurl: "marketing.htm?method=saveMarketingRejections"

        });

        $("#marketingRejectionsTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);

        if (!DEMO && !VIEWER) {
            $('#marketingRejectionsTable').jqGrid('navGrid', '#marketingRejectionsPager', {search: false}, //options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                {reloadAfterSubmit: true}, // del options
                {} // search options
            );
        }
    };

    this.createMarketingAdCompaniesTable = function () {
        commonHelper.callAjaxMethod('settings.htm', 'loadTeachersReference', {}, function (result) {
            var references = {};
            references.teachers = [
                {name:'', teacherid:0}
            ].concat(result.rows);

            var teachers = [];
            var div = document.createElement('div');
            for(var i=0; i<references.teachers.length; i++){
                div.innerHTML = references.teachers[i].name;
                teachers[i] = references.teachers[i].teacherid + ':' + div.textContent;
            }

            var colNames = [];
            colNames.push(messages['marketing.references.adcompany.title']);
            colNames.push(messages['marketing.references.adcompany.start']);
            colNames.push(messages['marketing.references.adcompany.end']);
            colNames.push(messages['marketing.references.adcompany.status']);
            colNames.push(messages['marketing.references.adcompany.comment']);
            colNames.push(messages['marketing.references.adcompany.plandohod'] + '(' + MONEY_NAME + ')');
            colNames.push(messages['marketing.references.adcompany.factdohod'] + '(' + MONEY_NAME + ')');
            colNames.push(messages['marketing.references.adcompany.planrashod'] + '(' + MONEY_NAME + ')');
            colNames.push(messages['marketing.references.adcompany.factrashod'] + '(' + MONEY_NAME + ')');
            colNames.push(messages['marketing.references.adcompany.incharge']);
            if (ORGS_COUNT > 0) {
                colNames.push(messages['marketing.references.adcompany.organization']);
            }

            var colModels = [];
            colModels.push({name: 'title', index: 'title', formatter: 'string', editable: true, required: true, editoptions: {size: 45}});
            colModels.push({name: 'startDate', index : 'startDate', sorttype:"datetime", formatter :"date", editable:true, formatoptions:{srcformat:"d\/m\/Y",newformat:"d\/m\/Y"}, editoptions:{
                dataInit:function(el){
                    commonHelper.setDatePicker(jQuery(el));
                }
            }});
            colModels.push({name: 'endDate', index : 'endDate', sorttype:"datetime", formatter :"date", editable:true, formatoptions:{srcformat:"d\/m\/Y",newformat:"d\/m\/Y"}, editoptions:{
                dataInit:function(el){
                    commonHelper.setDatePicker(jQuery(el));
                }
            }});
            colModels.push({name: 'status', index: 'status', edittype:'select', editable: true, formatter : 'select', editoptions:{value:messages['marketing.references.adcompany.statusselect']}});
            colModels.push({name: 'comment', index: 'comment', formatter: 'string', editable: true, required: true, sortable: false, edittype: "textarea", editoptions: {rows: "5", cols: "44"}});
            colModels.push({name: 'planDohod', index: 'planDohod', formatter: 'string', editable: true, editoptions: {size: 45}, hidden: true, editrules: { edithidden: true }});
            colModels.push({name: 'factDohod', index: 'factDohod', formatter: 'string', editable: true, editoptions: {size: 45}, hidden: true, editrules: { edithidden: true }});
            colModels.push({name: 'planRashod', index: 'planRashod', formatter: 'string', editable: true, editoptions: {size: 45}, hidden: true, editrules: { edithidden: true }});
            colModels.push({name: 'factRashod', index: 'factRashod', formatter: 'string', editable: true, editoptions: {size: 45}, hidden: true, editrules: { edithidden: true }});
            colModels.push({name: 'inCharge', index: 'inCharge', edittype:'select', editable: true, formatter : 'select', editoptions:{value:teachers.join(';')}});
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'orgid', index: 'orgid', edittype:'select', editable: true, formatter : 'select', editoptions:{value:':;'+ORGS_SELECT}});
            }

            $('#marketingAdCompaniesTable').jqGrid({
                caption: messages['marketing.references.adcompany'],
                url: "marketing.htm?method=loadMarketingAdCompanies",
                datatype: "json",
                colNames: colNames,
                colModel: colModels,
                autowidth: true,
                height: "100%",
                jsonReader: { repeatitems: false, id: "marketingadcompanyid"},
                rowNum: 10,
                pager: '#marketingAdCompaniesPager',
                sortname: 'marketingadcompanyid',
                viewrecords: true,
                sortorder: "desc",
                editurl: "marketing.htm?method=saveMarketingAdCompanies"
            });

            $("#marketingAdCompaniesTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);

            if (!DEMO && !VIEWER) {
                $('#marketingAdCompaniesTable').jqGrid('navGrid', '#marketingAdCompaniesPager', {search: false}, //options
                    {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                    {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                    {reloadAfterSubmit: true}, // del options
                    {} // search options
                );
            }
        });
    };

    return this;
}function marketingRejections_helper(marketingHelper) {
    var that = this;

    var requestsDataGrid = null;

    that.display = function () {
        that.loadMarketingRejectionsTable();
        that.initFilterPane();
    };

    this.initFilterPane = function () {
        commonHelper.setDatePicker($('#searchMarketingRejectionsParamForm').find('#rejectionfiltercreateddatefrom'));
        commonHelper.setDatePicker($('#searchMarketingRejectionsParamForm').find('#rejectionfiltercreateddateto'));

        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.sourceInfos = [
                {name: '', infosourceid: ''}
            ].concat(result.sourceInfos.rows);
            references.locations = [
                {name: '', locationid: ''}
            ].concat(result.locations.rows);

            initReferenceSelect($('#searchMarketingRejectionsParamForm').find('#rejectionfilterinfoSource'), references, 'sourceInfo', 'infosourceid', 'name');
            initReferenceSelect($('#searchMarketingRejectionsParamForm').find('#rejectionfilterlocation'), references, 'location', 'locationid', 'name');
        });

        commonHelper.callAjaxMethod('settings.htm', 'loadTeachersReference', {}, function (result) {
            var references = {};
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchMarketingRejectionsParamForm').find('#rejectionfilterinCharge'), references, 'teacher', 'teacherid', 'name');
        });

        commonHelper.callAjaxMethod('marketing.htm', 'loadMarketingAdCompanies', {}, function (result) {
            var references = {};
            references.adCompanys = [
                {title: '', marketingadcompanyid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchMarketingRejectionsParamForm').find('#rejectionfilteradCompany'), references, 'adCompany', 'marketingadcompanyid', 'title');
        });

        commonHelper.callAjaxMethod('marketing.htm', 'loadMarketingRejections', {}, function (result) {
            var references = {};
            references.rejections = [
                {title: '', marketingrejectionid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchMarketingRejectionsParamForm').find('#rejectionfilterrejection'), references, 'rejection', 'marketingrejectionsid', 'name');
        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        if (ORGS_COUNT > 0) {
            $('#searchMarketingRejectionsParamForm').find('#filterOrganizationBlock').show();
        }
        else {
            $('#searchMarketingRejectionsParamForm').find('#filterOrganizationBlock').hide();
        }
    };

    this.loadMarketingRejectionsTable = function () {
        //update rejection plot
        $('#rejectionPlot').find('img').remove();
        var src = 'marketing.htm?method=plotRejections&onlyrejections=1&' + $('#searchMarketingRejectionsParamForm').find('input, select').serialize();
        $('#rejectionPlot').append('<img src="' + src + '" />');

        if (!requestsDataGrid) {
            var colNames = [];
            colNames.push(messages['marketing.rejections.createddate']);
            colNames.push(messages['marketing.rejections.firstname']);
            colNames.push(messages['marketing.rejections.lastname']);
            colNames.push(messages['marketing.rejections.incharge']);
            colNames.push(messages['marketing.rejections.source']);
            colNames.push(messages['marketing.rejections.rejection']);
            colNames.push(messages['marketing.rejections.taskcount']);
            colNames.push(messages['marketing.rejections.modifieddate']);
            colNames.push('');

            var colModels = [];
            colModels.push({name: 'createdDate', index: 'createdDate', formatter: notNullFormatter});
            colModels.push({name: 'firstName', index: 'firstName', formatter: notNullFormatter});
            colModels.push({name: 'lastName', index: 'lastName', formatter: notNullFormatter});
            colModels.push({name: 'inCharge', index: 'inCharge', formatter: notNullFormatter});
            colModels.push({name: 'infoSource', index: 'infoSource', formatter: notNullFormatter});
            colModels.push({name: 'rejection', index: 'rejection', formatter: notNullFormatter});
            colModels.push({name: 'taskCount', index: 'taskCount', sortable: false, formatter: notNullFormatter});
            colModels.push({name: 'modifiedDate', index: 'modifiedDate', formatter: notNullFormatter});
            colModels.push({name: 'marketingrequestid', index: 'marketingrequestid', sortable: false, formatter: function (cellvalue, options, rowObject) {
                return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.rejections.editMarketingRejection(' + cellvalue + ')">' + messages['common.edit'] + '</a>';
            }});

            requestsDataGrid = $('#marketingRejectionsTabTable').jqGrid({
                url: "marketing.htm?method=loadMarketingRequests&onlyrejections=1",
                datatype: "json",
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#marketingRejectionsTabPager',
                sortname: 'createdDate', viewrecords: true, sortorder: "desc"
            });
            requestsDataGrid.jqGrid('setGridWidth', marketingHelper.TABLE_WIDTH);
        } else {
            requestsDataGrid.setGridParam({
                page: 1,
                "url": "marketing.htm?method=loadMarketingRequests&onlyrejections=1&" + $('#searchMarketingRejectionsParamForm').find('input, select').serialize(),
                "datatype": "json"
            });
            requestsDataGrid.trigger("reloadGrid");
        }
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    that.clearFilter = function () {
        $('#rejectionfiltercreateddatefrom').val('');
        $('#rejectionfiltercreateddateto').val('');
        $('#rejectionfilterrejection').val('');
        $('#rejectionfilterinfoSource').val('');
        $('#rejectionfilterlocation').val('');
        $('#rejectionfilterinCharge').val('');
        $('#rejectionfilteradCompany').val('');
        $('#searchMarketingRejectionsParamForm').find('#filterorganization').val('');

        that.loadMarketingRejectionsTable();
    };

    that.editMarketingRejection = function (id) {
        DIALOGS.marketingRequestDialog.editMarketingRequest(id, {}, function () {
            currentPage.rejections.loadMarketingRejectionsTable();
        })
    };

    return this;
}function marketingRequests_helper(marketingHelper) {
    var that = this;

    var requestsDataGrid = null;
    var selectedChild = {};

    that.display = function () {
        that.loadMarketingRequestsTable();
        that.initFilterPane();
    };

    this.initFilterPane = function () {
        commonHelper.setDatePicker($('#searchMarketingRequestParamForm').find('#filtercreateddatefrom'));
        commonHelper.setDatePicker($('#searchMarketingRequestParamForm').find('#filtercreateddateto'));

        var requestautocompleteparams = {
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.firstName + ' ' + item.lastName;
            },
            generateLabel: function (item) {
                return item.firstName + ' ' + item.lastName + '; ' + item.phone;
            },
            url: 'marketing.htm',
            method: 'autoCompleteSearchRequest',
            defaultValue: messages['marketing.requests.filter.requestfilternotset'],
            inputDataTitle: messages['marketing.requests.filter.requestfiltertitle'],
            objectNotFound: messages['marketing.requests.filter.requestfilternotfound'],
            objectFound: messages['marketing.requests.filter.requestfilterfound']
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('requestnamefilter', requestautocompleteparams);

        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.sourceInfos = [
                {name: '', infosourceid: ''}
            ].concat(result.sourceInfos.rows);
            references.locations = [
                {name: '', locationid: ''}
            ].concat(result.locations.rows);

            initReferenceSelect($('#searchMarketingRequestParamForm').find('#filterinfoSource'), references, 'sourceInfo', 'infosourceid', 'name');
            initReferenceSelect($('#searchMarketingRequestParamForm').find('#filterlocation'), references, 'location', 'locationid', 'name');
        });

        commonHelper.callAjaxMethod('settings.htm', 'loadTeachersReference', {}, function (result) {
            var references = {};
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchMarketingRequestParamForm').find('#filterinCharge'), references, 'teacher', 'teacherid', 'name');
        });

        commonHelper.callAjaxMethod('marketing.htm', 'loadMarketingAdCompanies', {}, function (result) {
            var references = {};
            references.adCompanys = [
                {title: '', marketingadcompanyid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchMarketingRequestParamForm').find('#filteradCompany'), references, 'adCompany', 'marketingadcompanyid', 'title');
        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        if (ORGS_COUNT > 0) {
            $('#searchMarketingRequestParamForm').find('#filterOrganizationBlock').show();
        }
        else {
            $('#searchMarketingRequestParamForm').find('#filterOrganizationBlock').hide();
        }
    };

    this.loadMarketingRequestsTable = function () {
        if (!requestsDataGrid) {
            var colNames = [];
            colNames.push('');
            colNames.push(messages['marketing.requests.firstname']);
            colNames.push(messages['marketing.requests.lastname']);
            colNames.push(messages['marketing.requests.contactname']);
            colNames.push(messages['marketing.requests.phone']);
            colNames.push(messages['marketing.requests.email']);
            colNames.push(messages['marketing.requests.birthday']);
            colNames.push(messages['marketing.requests.approximateage']);
            colNames.push(messages['marketing.requests.createddate']);
            colNames.push(messages['marketing.requests.author']);
            colNames.push(messages['marketing.requests.modifieddate']);
            colNames.push(messages['marketing.requests.modifier']);
            colNames.push(messages['marketing.requests.source']);
            colNames.push(messages['marketing.requests.location']);
            colNames.push(messages['marketing.requests.status']);
            colNames.push(messages['marketing.requests.comment']);
            colNames.push(messages['marketing.requests.incharge']);
            colNames.push(messages['marketing.requests.adcompamy']);
            colNames.push(messages['marketing.requests.rejection']);
            if (ORGS_COUNT > 0) {
                colNames.push(messages['marketing.requests.organization']);
            }
            colNames.push('');

            var colModels = [];
            colModels.push({name: 'marketingrequestid', index: 'marketingrequestid', sortable: false, formatter: function (cellvalue, options, rowObject) {
                return '<input type="checkbox" onclick="currentPage.requests.selectChild(this.checked, ' + cellvalue + ')"/>';
            }});
            colModels.push({name: 'firstName', index: 'firstName', formatter: notNullFormatter});
            colModels.push({name: 'lastName', index: 'lastName', formatter: notNullFormatter});
            colModels.push({name: 'contactName', index: 'contactName', formatter: notNullFormatter});
            colModels.push({name: 'phone', index: 'phone', formatter: notNullFormatter});
            colModels.push({name: 'email', index: 'email', formatter: notNullFormatter});
            colModels.push({name: 'birthday', index: 'birthday', formatter: notNullFormatter});
            colModels.push({name: 'approximateAge', index: 'approximateAge', formatter: notNullFormatter});
            colModels.push({name: 'createdDate', index: 'createdDate', formatter: notNullFormatter});
            colModels.push({name: 'author', index: 'author', formatter: notNullFormatter});
            colModels.push({name: 'modifiedDate', index: 'modifiedDate', formatter: notNullFormatter});
            colModels.push({name: 'modifer', index: 'modifer', formatter: notNullFormatter});
            colModels.push({name: 'infoSource', index: 'infoSource', formatter: notNullFormatter});
            colModels.push({name: 'location', index: 'location', formatter: notNullFormatter});
            colModels.push({name: 'status', index: 'status', edittype:'select', editable: true, formatter : 'select', editoptions:{value:messages['marketing.requests.statusselect']}});
            colModels.push({name: 'comment', index: 'comment', formatter: notNullFormatter});
            colModels.push({name: 'inCharge', index: 'inCharge', formatter: notNullFormatter});
            colModels.push({name: 'adCompany', index: 'adCompany', formatter: notNullFormatter});
            colModels.push({name: 'rejection', index: 'rejection', formatter: notNullFormatter});
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'orgid', index: 'orgid', edittype:'select', editable: true, formatter : 'select', editoptions:{value:':;'+ORGS_SELECT}});
            }
            colModels.push({name: 'marketingrequestid', index: 'marketingrequestid', sortable: false, align: "center", formatter: function (cellvalue, options, rowObject) {
                return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.requests.editMarketingRequest(' + cellvalue + ')">' + messages['common.edit'] + '</a>';
            }});

            requestsDataGrid = $('#marketingRequestsTable').jqGrid({
                datatype:loadMarketingRequests,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#marketingRequestsPager',
                sortname: 'createdDate', viewrecords: true, sortorder: "desc"
            });
            requestsDataGrid.jqGrid('setGridWidth', marketingHelper.TABLE_WIDTH);
        } else {
            requestsDataGrid.setGridParam({
                page: 1
            });
            requestsDataGrid.trigger("reloadGrid");
        }
    };

    var loadMarketingRequests = function (postdata) {
        postdata = $.extend(postdata, collectSearchParams());
        commonHelper.callAjaxMethod('marketing.htm', 'loadMarketingRequests',
            postdata, function (result) {
                requestsDataGrid.clearGridData(true);
                requestsDataGrid[0].addJSONData(result);
            }, true);
    };

    var collectSearchParams = function () {
        var params = {};
        $('#searchMarketingRequestParamForm').find('input, select').each(function(){
            params[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        params.requestId = AUTOCOMPLETE_SEARCH_FIELD.getValue('requestnamefilter');
        return params;
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    that.clearFilter = function () {
        $('#filtercreateddatefrom').val('');
        $('#filtercreateddateto').val('');
        $('#filterstatus').val('');
        $('#filterinfoSource').val('');
        $('#filterlocation').val('');
        $('#filterinCharge').val('');
        $('#filteradCompany').val('');
        $('#filterorganization').val('');
        $('#filteragefrom').val('');
        $('#filterageto').val('');
        $('#filterclient').val('');
        AUTOCOMPLETE_SEARCH_FIELD.setValue('requestnamefilter', '');

        that.loadMarketingRequestsTable();
    };

    that.addMarketingRequest = function (params) {
        DIALOGS.marketingRequestDialog.addMarketingRequest(params, function () {
            currentPage.requests.loadMarketingRequestsTable();
        })
    };

    that.editMarketingRequest = function (id) {
        DIALOGS.marketingRequestDialog.editMarketingRequest(id, {}, function () {
            currentPage.requests.loadMarketingRequestsTable();
        })
    };

    this.selectChild = function (checked, requestId) {
        selectedChild[requestId] = checked;
    };

    this.addRecipients = function () {
        var addRecipientsParams = {};
        addRecipientsParams.selectedRequests = selectedChild;

        commonHelper.callAjaxMethod('marketing.htm', 'addRecipients', {"objects": JSON.stringify(addRecipientsParams)}, function (data) {
            $('#messageRecipientsCount').html(data.currentRecipientsCount);
        });
    };

    this.createTasks = function () {
        DIALOGS.taskEditDialog(null, null, null, null, true, true, null, null, function (data) {
            var createTaskParams = {};
            createTaskParams.taskParams = data;
            createTaskParams.selectedRequests = selectedChild;
            commonHelper.callAjaxMethod('marketing.htm', 'createTasks', {"objects": JSON.stringify(createTaskParams)}, function (data) {
                //nothing to do
            });
        });
    };

    this.downloadExcel = function () {
        if (requestsDataGrid.jqGrid('getGridParam', 'reccount') > 0) {
            var params = collectSearchParams();

            var sortColumnName = requestsDataGrid.jqGrid('getGridParam', 'sortname');
            var sortOrder = requestsDataGrid.jqGrid('getGridParam', 'sortorder');

            var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&';
            var existNotEmptyParam = false;
            for (var param in params) {
                var paramValue = params[param];
                existNotEmptyParam |= (paramValue && param != 'filterorganization') ? true : false;
                paramsString += param + '=' + paramValue + '&';
            }

            var excelFunction = function () {
                window.location.assign("marketing.htm?method=downloadMarketingRequestsAsExcel" + (paramsString ? '&' + paramsString : ''));
            };
            if (!existNotEmptyParam) {
                DIALOGS.askYesNoDialog(messages['marketing.requests.filter.noparam'], messages['common.yes'], excelFunction);
            } else {
                excelFunction();
            }
        } else {
            commonHelper.showMessage(messages['marketing.requests.filter.nodata']);
        }
    };

    return this;
}function marketingSakesFunnel_helper(marketingHelper) {
    var that = this;

    that.display = function () {
        that.initFilterPane();
    };

    this.initFilterPane = function () {
        commonHelper.setDatePicker($('#searchMarketingSalesParamForm').find('#salesfiltercreateddatefrom'));
        commonHelper.setDatePicker($('#searchMarketingSalesParamForm').find('#salesfiltercreateddateto'));

        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.sourceInfos = [
                {name: '', infosourceid: ''}
            ].concat(result.sourceInfos.rows);
            references.locations = [
                {name: '', locationid: ''}
            ].concat(result.locations.rows);

            initReferenceSelect($('#searchMarketingSalesParamForm').find('#salesfilterinfoSource'), references, 'sourceInfo', 'infosourceid', 'name');
            initReferenceSelect($('#searchMarketingSalesParamForm').find('#salesfilterlocation'), references, 'location', 'locationid', 'name');
        });

        commonHelper.callAjaxMethod('settings.htm', 'loadTeachersReference', {}, function (result) {
            var references = {};
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchMarketingSalesParamForm').find('#salesfilterinCharge'), references, 'teacher', 'teacherid', 'name');
        });

        commonHelper.callAjaxMethod('marketing.htm', 'loadMarketingAdCompanies', {}, function (result) {
            var references = {};
            references.adCompanys = [
                {title: '', marketingadcompanyid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchMarketingSalesParamForm').find('#salesfilteradCompany'), references, 'adCompany', 'marketingadcompanyid', 'title');
        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };
    };

    that.loadDataTable = function(){
        var params = {};
        $('#searchMarketingSalesParamForm').find('input, select').each(function(){
            params[$(this).attr('name')] =  $(this).val();
        });
        commonHelper.callAjaxMethod('marketing.htm', 'loadSalesFunnelData', params, function (result) {
            var salesFunnelData = [0,0,0,0];

            for(var i=0; i<result.length; i++){
                console.log(result[i]);
                if(result[i].status == 'OPENED'){
                    salesFunnelData[0] += result[i].value;
                }
                else if(result[i].status == 'RECORD'){
                    salesFunnelData[0] += result[i].value;
                    salesFunnelData[1] += result[i].value;
                }
                else if(result[i].status == 'TRY'){
                    salesFunnelData[0] += result[i].value;
                    salesFunnelData[1] += result[i].value;
                    salesFunnelData[2] += result[i].value;
                }
                else if(result[i].status == 'CLIENT'){
                    salesFunnelData[0] += result[i].value;
                    salesFunnelData[1] += result[i].value;
                    salesFunnelData[2] += result[i].value;
                    salesFunnelData[3] += result[i].value;
                }
                else if(result[i].status == 'REJECTION'){
                    salesFunnelData[0] += result[i].value;
                }
                else if(result[i].status == 'REJECTION_RECORD'){
                    salesFunnelData[0] += result[i].value;
                    salesFunnelData[1] += result[i].value;
                }
                else if(result[i].status == 'REJECTION_TRY'){
                    salesFunnelData[0] += result[i].value;
                    salesFunnelData[1] += result[i].value;
                    salesFunnelData[2] += result[i].value;
                }
                else if(result[i].status == 'REJECTION_CLIENT'){
                    salesFunnelData[0] += result[i].value;
                    salesFunnelData[1] += result[i].value;
                    salesFunnelData[2] += result[i].value;
                    salesFunnelData[3] += result[i].value;
                }
            }
            console.log(salesFunnelData);
            $('#salesFunnelResults').empty();
            if(salesFunnelData[0] == 0){
                $('#salesFunnelResults').append('<p>' + messages['marketing.salesfunnel.norequests'] + '</p>');
            }
            else {
                var table = $('<table width="100%"></table>');
                table.append('<tr><th style="width:50%">&nbsp;</th><th>' + messages['marketing.salesfunnel.part'] + '</th><th>' + messages['marketing.salesfunnel.count'] + '</th><th>' + messages['marketing.salesfunnel.conversion'] + '</th></tr>');
                table.append('<tr><td id="line0">' + messages['marketing.salesfunnel.requests'] + ' (' + salesFunnelData[0] + ')</td><td>' + messages['marketing.salesfunnel.requests'] + '</td><td>' + salesFunnelData[0] + '</td><td>&nbsp;</td></tr>');
                if($('#searchMarketingSalesParamForm').find('#salesfiltertryLessons').is(':checked')){
                    table.append('<tr><td id="line1">' + messages['marketing.salesfunnel.subscribe'] + ' (' + salesFunnelData[1] + ')</td><td>' + messages['marketing.salesfunnel.subscribe'] + '</td><td>' + salesFunnelData[1] + '</td><td>' + (salesFunnelData[1]/salesFunnelData[0]).toFixed(2) + '</td></tr>');
                    table.append('<tr><td id="line2">' + messages['marketing.salesfunnel.trylesson'] + ' (' + salesFunnelData[2] + ')</td><td>' + messages['marketing.salesfunnel.trylesson'] + '</td><td>' + salesFunnelData[2] + '</td><td>' + ((salesFunnelData[1] == 0)?"0.00":((salesFunnelData[2]/salesFunnelData[1])).toFixed(2)) + '</td></tr>');
                }
                table.append('<tr><td id="line3">' + messages['marketing.salesfunnel.client'] + ' (' + salesFunnelData[3] + ')</td><td>' + messages['marketing.salesfunnel.client'] + '</td><td>' + salesFunnelData[3] + '</td><td>' + ((salesFunnelData[2] == 0)?"0.00":((salesFunnelData[3]/salesFunnelData[2])).toFixed(2)) + '</td></tr>');
                $('#salesFunnelResults').append(table);

                var initDiagramLine = function(elem, color, part){
                    var text = elem.text();
                    elem.html('<div style="width: 90%; height: 100%; position: relative; min-height: 30px; line-height: 30px;"><div style="position: absolute; width: ' + parseInt(part*100.0) + '%; height: 100%; background-color: ' + color + ';"></div>' + text + '</div>');
                }
                initDiagramLine(table.find('#line0'), 'rgba(185,205,229,0.5)', 1);
                initDiagramLine(table.find('#line1'), 'rgba(215,228,189,0.5)', (salesFunnelData[1] == 0)?0:(salesFunnelData[1]/salesFunnelData[0]));
                initDiagramLine(table.find('#line2'), 'rgba(252,213,181,0.5)', (salesFunnelData[2] == 0)?0:(salesFunnelData[2]/salesFunnelData[0]));
                initDiagramLine(table.find('#line3'), 'rgba(230,185,185,0.5)', (salesFunnelData[3] == 0)?0:(salesFunnelData[3]/salesFunnelData[0]));

                $('#salesFunnelResults').append('<p>' + messages['marketing.salesfunnel.totalconversion'] + ' ' + (salesFunnelData[3]/salesFunnelData[0]).toFixed(3) + '</p>');
            }
        });
    }

    return this;
}function notificationRecipientsList(listId) {
    var that = this;

    var list = $('#' + listId);

    that.deleteNotificationRecipient = function(event){
        commonHelper.callAjaxMethod('notifications.htm', 'removeRecipient', {id: $(event.target).attr('recipientId')}, function (result) {
            that.loadRecipientsList();
        });
    };

    that.loadRecipientsList = function (notificationSettingsId) {
        REFERENCE.fillReferenceList(listId, 'notifications.htm', 'loadSelectedNotificationRecipients', {
            filterParams: {notificationSettingsId : notificationSettingsId},
            sortOrder: 'asc',
            sortName: 'id',
            rowsOnPage: 5,
            fillCallback: function (list, template, data) {
                var row = template.clone();
                row.removeClass(listId + 'Template');
                row.show();
                row.appendTo(list);

                var rowName = '.' + listId + 'Row';
                var rowId = '.' + listId + 'RowId@value';
                var directives = {};
                directives[rowName] = {

                };
                directives[rowName]['row <- rows'] = {};
                directives[rowName]['row <- rows'][rowId] = 'row.id';
                directives[rowName]['row <- rows']['.name'] = 'row.name';
                directives[rowName]['row <- rows']['.name@href'] = 'client.htm?childid=#{row.id}';
                directives[rowName]['row <- rows']['.address'] = 'row.address';
                directives[rowName]['row <- rows']['.phone'] = 'row.phone';
                directives[rowName]['row <- rows']['.status'] = 'row.status';
                directives[rowName]['row <- rows']['.message'] = 'row.message';
                directives[rowName]['row <- rows']['.notificationRecipientDelete@recipientId'] = 'row.id';
                directives[rowName]['row <- rows']['.sendNotificationsNames'] = 'row.notificationsNames';
                directives[rowName]['row <- rows']['.sendNotifications'] = function (context) {
                    return context.item.sendNotifications ? '<span style="color: green;">' + messages['notifications.notoficationrecipientslist.on'] + '<span>' : '<span style="color: red;">' + messages['notifications.notoficationrecipientslist.off'] + '</span>';
                };

                var result = list.directives(directives).render(data);
                $('#' + listId).find('.notificationRecipientDelete').click(that.deleteNotificationRecipient);
                $('#messageRecipientsCount').html(data.records);

                $('.totalRecipientsCount').html(data.records);
                $('.recipientsWithoutSendingEmails').html(data.withoutSendingEmails);
                $('.recipientsWithoutEmails').html(data.withoutEmails);
                if (data.records > 0){
                    $('.recipientsCountInfo').show();
                } else {
                    $('.recipientsCountInfo').hide();
                }
                return result;
            }
        });
    };

    return that;
}function paymentSettings_helper(helper) {
    var that = this;

    that.display = function () {
        that.loadSettings();
    };

    that.loadSettings = function () {
        commonHelper.callAjaxMethod('payment.htm', 'loadPaymentSettings', {}, function (data) {

            $('#paymentIncomeType').children(null).remove();
            $('<option>', {value: ''}).appendTo($('#paymentIncomeType'));
            $('#paymentOutcomeType').children(null).remove();
            $('<option>', {value: ''}).appendTo($('#paymentOutcomeType'));
            for(var i=0; i<data.paymentTypes.rows.length; i++){
                var paymentType = data.paymentTypes.rows[i];
                if(paymentType.direction == 'INCOME'){
                    $('<option value="' + paymentType.id + '">' + paymentType.name + '</option>').appendTo($('#paymentIncomeType'));
                }
                else if(paymentType.direction == 'OUTCOME'){
                    $('<option value="' + paymentType.id + '">' + paymentType.name + '</option>').appendTo($('#paymentOutcomeType'));
                }
            }

            $('#paymentIncomeTypeRoboK').children(null).remove();
            $('<option>', {value: ''}).appendTo($('#paymentIncomeTypeRoboK'));
            $('#paymentOutcomeTypeRoboK').children(null).remove();
            $('<option>', {value: ''}).appendTo($('#paymentOutcomeTypeRoboK'));
            for(var i=0; i<data.paymentTypes.rows.length; i++){
                var paymentType = data.paymentTypes.rows[i];
                if(paymentType.direction == 'INCOME'){
                    $('<option value="' + paymentType.id + '">' + paymentType.name + '</option>').appendTo($('#paymentIncomeTypeRoboK'));
                }
                else if(paymentType.direction == 'OUTCOME'){
                    $('<option value="' + paymentType.id + '">' + paymentType.name + '</option>').appendTo($('#paymentOutcomeTypeRoboK'));
                }
            }

            $('#paymentSettings').directives({
                '.paymentComission@value' : 'paymentComission',
                '.paymentEmail@value' : 'paymentEmail',
                '.paymentTimeout@value' : 'paymentTimeout'
            }).render(data);

            if (data.paymentProlongSubscription) {
                $('#paymentProlongSubscription').attr('checked', 'checked');
            }
            if (data.paymentUseDeposit) {
                $('#paymentUseDeposit').attr('checked', 'checked');
            }
            if (data.paymentProlongReservation) {
                $('#paymentProlongReservation').attr('checked', 'checked');
            }
            else {
                $('#paymentProlongReservation').removeAttr('checked');
            }
            if(data.paymentIncomeType){
                $('#paymentIncomeType').val(data.paymentIncomeType);
            }
            if(data.paymentOutcomeType){
                $('#paymentOutcomeType').val(data.paymentOutcomeType);
            }
            if(data.paymentOutcomeTypeRoboK){
                $('#paymentOutcomeTypeRoboK').val(data.paymentOutcomeTypeRoboK);
            }
            if(data.paymentIncomeTypeRoboK){
                $('#paymentIncomeTypeRoboK').val(data.paymentIncomeTypeRoboK);
            }
            if (data.merchantLogin) {
                $('#robokassaMerchantLogin').val(data.merchantLogin)
            }
            if (data.robokassaPassword1) {
                $('#robokassaPassword1').val(data.robokassaPassword1)
            }
            if (data.robokassaPassword2) {
                $('#robokassaPassword2').val(data.robokassaPassword2)
            }
            if (data.recurring) {
                $('#robokassaRecurring').attr('checked', 'checked')
            }

            $('#paymentOrganizationSettings').find('.orgRow').remove();
            var cashSelect= '<option value=""></option>';
            for(var i=0; i<data.cashes.rows.length; i++) {
                var cash = data.cashes.rows[i];
                cashSelect += '<option value="' + cash.id + '">' + cash.name + '</option>';
            }
            $('#paymentOrganizationSettingsRoboK').find('.orgRow').remove();
            var cashSelect= '<option value=""></option>';
            for(var i=0; i<data.cashes.rows.length; i++) {
                var cash = data.cashes.rows[i];
                cashSelect += '<option value="' + cash.id + '">' + cash.name + '</option>';
            }
            var organizations = [];
            organizations.push({id:'', name: ''});
            if(ORGS_COUNT > 0){
                var orgs = ORGS_SELECT.split(';');
                for(var i=0; i<orgs.length; i++){
                    var org = orgs[i].split(':');
                    organizations.push({id:org[0], name: org[1]});
                }
            }
            for(var i=0; i<organizations.length; i++){
                organizations[i].cash = '';
                organizations[i].keyphrase = '';
                organizations[i].robokassaPassword1 = '';
                organizations[i].robokassaPassword2 = '';
                for(var j=0; j<data.paymentOrganizations.length; j++){
                    if((data.paymentOrganizations[j].organization == null && organizations[i].id == '') ||
                        (data.paymentOrganizations[j].organization != null && data.paymentOrganizations[j].organization.id == organizations[i].id)){
                        organizations[i].cash = data.paymentOrganizations[j].cash ? data.paymentOrganizations[j].cash.id : '';
                        organizations[i].keyphrase = data.paymentOrganizations[j].keyphrase ? data.paymentOrganizations[j].keyphrase : '';
                        organizations[i].robokassaPassword1 = data.paymentOrganizations[j].robokassaPassword1 ? data.paymentOrganizations[j].robokassaPassword1 : '';
                        organizations[i].robokassaPassword2 = data.paymentOrganizations[j].robokassaPassword2 ? data.paymentOrganizations[j].robokassaPassword2 : '';
                    }
                }
                var row = $('<tr class="orgRow" data-id="' + organizations[i].id + '"><td>' + organizations[i].name + '</td><td><input type="text" class="keyphrase" value="' + organizations[i].keyphrase + '" /></td><td><select class="cash">' + cashSelect + '</select></td></tr>');
                $('#paymentOrganizationSettings').append(row);
                row.find('.cash').val(organizations[i].cash);
                var row = $('<tr class="orgRow" data-id="' + organizations[i].id + '"><td>' + organizations[i].name + '</td><td><input type="text" class="robokassaPassword1" value="' + organizations[i].robokassaPassword1 + '" /></td><td><input type="text" class="robokassaPassword2" value="' + organizations[i].robokassaPassword2 + '" /></td><td><select class="cash">' + cashSelect + '</select></td></tr>');
                $('#paymentOrganizationSettingsRoboK').append(row);
                row.find('.cash').val(organizations[i].cash);
            }
        });
    };

    this.saveSettings = function () {
        var params = {};
        if($('#paymentIncomeType').val()){
            params.paymentIncomeType = $('#paymentIncomeType').val();
        }
        if($('#paymentOutcomeType').val()){
            params.paymentOutcomeType = $('#paymentOutcomeType').val();
        }
        params.paymentComission = $('#paymentComission').val();
        params.paymentProlongSubscription = $('#paymentProlongSubscription').is(":checked");
        params.paymentUseDeposit = $('#paymentUseDeposit').is(":checked");
        params.paymentEmail = $('#paymentEmail').val();
        params.paymentTimeout = $('#paymentTimeout').val();
        params.paymentProlongReservation = $('#paymentProlongReservation').is(":checked");

        var paymentOrganizations = [];
        $('#paymentOrganizationSettings').find('.orgRow').each(function(){
            var row = $(this);
            paymentOrganizations.push({
                organization: row.attr('data-id'),
                cash: row.find('.cash').val(),
                keyphrase: row.find('.keyphrase').val()
            });
        });
        params.paymentOrganizations = JSON.stringify(paymentOrganizations);

        commonHelper.callAjaxMethod('payment.htm', 'savePaymentSettings', params, function (data) {
            //nothing to do
        });
    };

    this.saveRobokassaSettings = function() {
        var params = {};
        if($('#paymentIncomeTypeRoboK').val()){
            params.paymentIncomeTypeRoboK = $('#paymentIncomeTypeRoboK').val();
        }
        if($('#paymentOutcomeTypeRoboK').val()){
            params.paymentOutcomeTypeRoboK = $('#paymentOutcomeTypeRoboK').val();
        }
        params.paymentComissionRoboK = $('#paymentComissionRoboK').val();
        params.merchantLogin = $('#robokassaMerchantLogin').val();
        params.robokassaPassword1 = $('#robokassaPassword1').val();
        params.robokassaPassword2 = $('#robokassaPassword2').val();
        params.recurring = $('#robokassaRecurring').is(":checked");

        var paymentOrganizations = [];
        $('#paymentOrganizationSettingsRoboK').find('.orgRow').each(function(){
            var row = $(this);
            paymentOrganizations.push({
                organization: row.attr('data-id'),
                cash: row.find('.cash').val(),
                robokassaPassword1: row.find('.robokassaPassword1').val(),
                robokassaPassword2: row.find('.robokassaPassword2').val()
            });
        });
        params.paymentOrganizations = JSON.stringify(paymentOrganizations);

        commonHelper.callAjaxMethod('payment.htm', 'saveRobokassaPaymentSettings', params, function (date) {

        });
    };

    return this;
}function paymentStatistic_helper(helper) {
    var that = this;

    var requestsDataGrid = null;

    that.display = function () {
        that.loadPaymentStatisticTable();
        that.initFilterPane();
    };

    this.initFilterPane = function () {
        commonHelper.setDatePicker($('#searchPaymentStatisticsParamForm').find('#filterdatefrom'));
        commonHelper.setDatePicker($('#searchPaymentStatisticsParamForm').find('#filterdateto'));

        if (ORGS_COUNT > 0) {
            $('#searchPaymentStatisticsParamForm').find('#filterOrganizationBlock').show();
        }
        else {
            $('#searchPaymentStatisticsParamForm').find('#filterOrganizationBlock').hide();
        }

        var customerautocompleteparams = {
            url: 'payment.htm',
            method: 'autoCompleteSearchCustomer',
            defaultValue: messages['payment.statistic.customerfilternotset'],
            inputDataTitle: messages['payment.statistic.customerfilteraction'],
            objectNotFound: messages['payment.statistic.customerfilternotfound'],
            objectFound: messages['payment.statistic.customerfilterfound'],

            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.title;
            },
            generateLabel: function (item) {
                return item.title;
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('filtercustomer', customerautocompleteparams);
    };

    this.loadPaymentStatisticTable = function () {
        if (!requestsDataGrid) {
            var colNames = [];
            if (ORGS_COUNT > 0) {
                colNames.push(messages['payment.statistic.organization']);
            }
            colNames.push(messages['payment.statistic.date']);
            colNames.push(messages['payment.statistic.price']);
            colNames.push(messages['payment.statistic.customer']);
            colNames.push(messages['payment.statistic.email']);
            colNames.push(messages['payment.statistic.phone']);
            colNames.push(messages['payment.statistic.product']);
            colNames.push(messages['payment.statistic.comment']);
            colNames.push(messages['payment.statistic.status']);

            var colModels = [];
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'organization', index: 'organization', formatter: notNullFormatter});
            }
            colModels.push({name: 'date', index: 'date', formatter: function (cellvalue, options, rowObject) {
                return cellvalue + ' ' + rowObject.time;
            }});
            colModels.push({name: 'price', index: 'price', formatter: notNullFormatter});
            colModels.push({name: 'customer', index: 'customer', formatter: function (cellvalue, options, rowObject) {
                if(rowObject.family){
                    return '<a href="client.htm?familyid=' + rowObject.family + '" target="_blank" ">' + cellvalue + '</a>';
                }
                else if(rowObject.request) {
                    return '<a href="marketing.htm?requestid=' + rowObject.request + '" target="_blank" ">' + cellvalue + '</a>';
                }
                else {
                    return cellvalue;
                }
            }});
            colModels.push({name: 'email', index: 'email', formatter: notNullFormatter});
            colModels.push({name: 'phone', index: 'phone', formatter: notNullFormatter});
            colModels.push({name: 'product', index: 'product', formatter: notNullFormatter});
            colModels.push({name: 'comment', index: 'comment', formatter: notNullFormatter});
            colModels.push({name: 'status', index: 'status', edittype:'select', editable: true, formatter : function (cellvalue, options, rowObject) {
                if(cellvalue == 'RESERVATION') return messages['payment.statistic.status.reservation'];
                else if(cellvalue == 'PURCHASE_DEPOSIT') return messages['payment.statistic.status.purchasedeposit'];
                else if(cellvalue == 'PURCHASE_SUBSCRIPTION') return messages['payment.statistic.status.purchasesubscription'];
                else if(cellvalue == 'PURCHASE_UNKNOWN') return messages['payment.statistic.status.purchaseunknown'] + '<a href="javascript:void(0)" onclick="currentPage.statistic.findChildForPayment(' + rowObject.paymentorderid + ')">' + messages['payment.statistic.status.purchaseunknownfind'] + '</a>';
                else if(cellvalue == 'CANCELLED') return messages['payment.statistic.status.cancelled'];
            }});

            requestsDataGrid = $('#paymentStatisticTable').jqGrid({
                datatype:loadPaymentStatistic,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#paymentStatisticPager',
                sortname: 'date', viewrecords: true, sortorder: "desc"
            });
            requestsDataGrid.jqGrid('setGridWidth', helper.TABLE_WIDTH);
        } else {
            requestsDataGrid.setGridParam({
                page: 1
            });
            requestsDataGrid.trigger("reloadGrid");
        }
    };

    var loadPaymentStatistic = function (postdata) {
        postdata = $.extend(postdata, collectSearchParams());
        commonHelper.callAjaxMethod('payment.htm', 'loadPaymentStatistic',
            postdata, function (result) {
                requestsDataGrid.clearGridData(true);
                requestsDataGrid[0].addJSONData(result);
            }, true);
    };

    var collectSearchParams = function () {
        var params = {};
        $('#searchPaymentStatisticsParamForm').find('input, select').each(function(){
            params[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        return params;
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    that.clearFilter = function () {
        $('#filterdatefrom').val('');
        $('#filterdateto').val('');
        $('#filterorganization').val('');
        $('#filterstatus').val('');
        $('#filterproduct').val('');
        $('#filterpricefrom').val('');
        $('#filterpriceto').val('');
        AUTOCOMPLETE_SEARCH_FIELD.setValue('filtercustomer', null, '');

        that.loadPaymentStatisticTable();
    };

    that.downloadExcel = function () {
        var sortColumnName = requestsDataGrid.jqGrid('getGridParam', 'sortname');
        var sortOrder = requestsDataGrid.jqGrid('getGridParam', 'sortorder');

        var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&' + getFilterUrlParams();
        window.location.assign("payment.htm?method=downloadPaymentStatisticAsExcel" + (paramsString ? '&' + paramsString : ''));
    };

    that.print = function () {
        var paramsString = getFilterUrlParams();
        commonHelper.openPdfPrintDialog('payment.htm?method=printPaymentStatisticFromClient' + (paramsString ? '&' + paramsString : ''));
    };

    var getFilterUrlParams = function (){
        var paramsString = '';
        var params = collectSearchParams();
        for (var param in params) {
            var paramValue = params[param];
            paramsString += param + '=' + paramValue + '&';
        }
        return paramsString;
    }

    that.findChildForPayment = function (paymentOrderId){
        var findClientDialog = $('#findClientDialog');
        findClientDialog.find('.paymentOrderId').val(paymentOrderId);
        findClientDialog.find('.familyInfo').hide();
        var buttons = {}
        buttons['attach'] = {
            title: messages['payment.statistic.findclient.attach'],
            action: function () {
                var paymentOrderId = $('#findClientDialog').find('.paymentOrderId').val();
                var familyId = AUTOCOMPLETE_SEARCH_FIELD.getValue('findClientSelector');
                var validate = function () {
                    if(!familyId){
                        $('#findClientDialog').find('.dialogMessages').html(messages['payment.statistic.findclient.noclient']);
                        return false;
                    }
                    return true;
                };
                $('#findClientDialog').find('.dialogMessages').html('');
                if (validate()) {
                    commonHelper.callAjaxMethod('payment.htm', 'attachClient', {
                        paymentOrderId: paymentOrderId,
                        familyId: familyId
                    }, function (data) {
                        that.loadPaymentStatisticTable();
                        REFERENCE.closeEditReferenceDialog('findClientDialog');
                        window.open('client.htm?familyid=' + familyId, '_blank');
                    });
                }
            }
        }
        REFERENCE.openEditReferenceDialog('findClientDialog', {
                buttons: buttons,
                onClose: function () {}
            }
        );
        var familyautocompleteparams = {
            url: 'family.htm',
            method: 'autoCompleteSearchFamily',
            defaultValue: messages['paymentdialog.familyfilternotset'],
            inputDataTitle: messages['paymentdialog.familyfilteraction'],
            objectNotFound: messages['paymentdialog.familyfilternotfound'],
            objectFound: messages['paymentdialog.familyfilterfound'],
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.value;
            },
            generateLabel: function (item) {
                return item.title;
            },
            selectCallback: function (objectId, selectedText, type) {
                $('#findClientDialog').find('.familyInfo .infoField').text('');
                if (objectId && objectId != '') {
                    commonHelper.callAjaxMethod('family.htm', 'getFamilyInformation', {familyId:objectId}, function (result) {
                        $('#findClientDialog').find('.familyInfo').directives(
                        {
                            '.parentName':'parentName',
                            '.familyName':'familyName',
                            '.phone':'phone',
                            '.additionalPhone':'additionalPhone',
                            '.email':'email',
                            '.additionalEmail':'additionalEmail'
                        }).render(result.family).show();
                    });
                }
                else {
                    $('#findClientDialog').find('.familyInfo').hide();
                }
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('findClientSelector', familyautocompleteparams);
    }

    return this;
}function phoneReferences_helper() {
    var that = this;

    that.display = function () {
        that.createPhoneScriptsTable();
        that.createPhoneSourcesTable();
        that.createPhoneInnerPhonesTable();
    };

    this.createPhoneScriptsTable = function () {
        var scriptTypes = messages['phone.references.scripts.typeselect'];
        commonHelper.checkFeature('MARKETING', function(){
            scriptTypes = messages['phone.references.scripts.typeselectmarketing'];
        });
        $('#phoneScriptsTable').jqGrid({
            caption: messages['phone.references.scripts'],
            url: "phone.htm?method=loadPhoneScripts",
            datatype: "json",
            colNames: [messages['phone.references.scripts.name'], messages['phone.references.scripts.type'], messages['phone.references.scripts.text']],
            colModel: [
                {name: 'name', index: 'name', formatter: 'string', editable: true, required: true, editoptions: {size: 47}},
                {name: 'type', index: 'type', edittype:'select', editable: true, formatter : 'select', editoptions:{value:scriptTypes}, hidden: true, editrules: { edithidden: true }},
                {name: 'text', index: 'text', formatter: 'string', editable: true, required: true, sortable: false, edittype: "textarea", editoptions: {rows: "20", cols: "45"}, hidden: true, editrules: { edithidden: true }}
            ],
            autowidth: true,
            height: "100%",
            jsonReader: { repeatitems: false, id: "phonescriptid"},
            rowNum: 10,
            pager: '#phoneScriptsPager',
            sortname: 'phonescriptid',
            viewrecords: true,
            sortorder: "desc",
            editurl: "phone.htm?method=savePhoneScript"

        });

        $("#phoneScriptsTable").jqGrid('setGridWidth', $('#bodyCell').width() / 4.1, true);

        if (!DEMO && !VIEWER) {
            $('#phoneScriptsTable').jqGrid('navGrid', '#phoneScriptsPager', {search: false}, //options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                {reloadAfterSubmit: true}, // del options
                {} // search options
            );
        }
    };

    this.createPhoneSourcesTable = function () {
        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.sourceInfos = [
                {name: '', infosourceid: ''}
            ].concat(result.sourceInfos.rows);

            var initSourceTable = function(references){
                var infoSources = [];
                var div = document.createElement('div');
                for(var i=0; i<references.sourceInfos.length; i++){
                    div.innerHTML = references.sourceInfos[i].name;
                    infoSources[i] = references.sourceInfos[i].infosourceid + ':' + div.textContent;
                }
                if(references.adCompanies){
                    var adCompanies = [];
                    for(var i=0; i<references.adCompanies.length; i++){
                        div.innerHTML = references.adCompanies[i].title;
                        adCompanies[i] = references.adCompanies[i].marketingadcompanyid + ':' + div.textContent;
                    }
                }

                var colNames = [];
                colNames.push(messages['phone.references.sources.phone']);
                colNames.push(messages['phone.references.sources.source']);
                if(references.adCompanies) {
                    colNames.push(messages['phone.references.sources.adcompany']);
                }
                if (ORGS_COUNT > 0) {
                    colNames.push(messages['phone.references.sources.organization']);
                }
                colNames.push(messages['phone.references.sources.startdate']);
                colNames.push(messages['phone.references.sources.enddate']);
                colNames.push(messages['phone.references.sources.comment']);

                var colModels = [];
                colModels.push({name: 'phone', index: 'phone', formatter: 'string', editable: true, required: true, editoptions: {size: 47}});
                colModels.push({name: 'infoSource', index: 'infoSource', edittype:'select', editable: true, formatter : 'select', editoptions:{value:infoSources.join(';')}});
                if(references.adCompanies){
                    colModels.push({name: 'adCompany', index: 'adCompany', edittype:'select', editable: true, formatter : 'select', editoptions:{value:adCompanies.join(';')}});
                }
                if (ORGS_COUNT > 0) {
                    colModels.push({name: 'orgid', index: 'orgid', edittype:'select', editable: true, formatter : 'select', editoptions:{value:':;'+ORGS_SELECT}});
                }
                colModels.push({name: 'startDate', index : 'startDate', sorttype:"datetime", formatter :"date", editable:true, required: true, formatoptions:{srcformat:"d\/m\/Y",newformat:"d\/m\/Y"}, editoptions:{
                    dataInit:function(el){
                        commonHelper.setDatePicker(jQuery(el));
                    }
                }});
                colModels.push({name: 'endDate', index : 'endDate', sorttype:"datetime", formatter :"date", editable:true, required: true, formatoptions:{srcformat:"d\/m\/Y",newformat:"d\/m\/Y"}, editoptions:{
                    dataInit:function(el){
                        commonHelper.setDatePicker(jQuery(el));
                    }
                }});
                colModels.push({name: 'comment', index: 'comment', formatter: 'string', editable: true, editoptions: {size: 47}, hidden: true, editrules: { edithidden: true }});

                $('#phoneSourcesTable').jqGrid({
                    caption: messages['phone.references.sources'],
                    url: "phone.htm?method=loadPhoneSources",
                    datatype: "json",
                    colNames: colNames,
                    colModel: colModels,
                    autowidth: true,
                    height: "100%",
                    jsonReader: { repeatitems: false, id: "phonesourceid"},
                    rowNum: 10,
                    pager: '#phoneSourcesPager',
                    sortname: 'phonesourceid',
                    viewrecords: true,
                    sortorder: "desc",
                    editurl: "phone.htm?method=savePhoneSource"

                });

                $("#phoneSourcesTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);

                if (!DEMO && !VIEWER) {
                    $('#phoneSourcesTable').jqGrid('navGrid', '#phoneSourcesPager', {search: false}, //options
                        {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                        {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                        {reloadAfterSubmit: true}, // del options
                        {} // search options
                    );
                }
            }

            commonHelper.checkFeature('MARKETING', function(){
                commonHelper.callAjaxMethod('marketing.htm', 'loadMarketingAdCompanies', {}, function (result) {
                    references.adCompanies = [
                        {title: '', marketingadcompanyid: ''}
                    ].concat(result.rows);
                    initSourceTable(references);
                });
            }, function(){
                initSourceTable(references);
            });

        });
    };

    this.createPhoneInnerPhonesTable = function () {
        commonHelper.callAjaxMethod('users.htm', 'loadUsers', {}, function (result) {
            var references = {};
            references.users = result.rows;

            var teachers = [];
            var div = document.createElement('div');
            for (var i = 0; i < references.users.length; i++) {
                div.innerHTML = references.users[i].name;
                teachers[i] = references.users[i].id + ':' + div.textContent;
            }

            var colNames = [];
            colNames.push(messages['phone.references.inner.user']);
            colNames.push(messages['phone.references.inner.phone']);
            colNames.push(messages['phone.references.inner.startdate']);
            colNames.push(messages['phone.references.inner.enddate']);

            var colModels = [];
            colModels.push({name: 'user', index: 'user', edittype:'select', editable: true, formatter : 'select', editoptions:{value:teachers.join(';')}});
            colModels.push({name: 'phone', index: 'phone', formatter: 'string', editable: true, required: true});
            colModels.push({name: 'startDate', index : 'startDate', sorttype:"datetime", formatter :"date", editable:true, required: true, formatoptions:{srcformat:"d\/m\/Y",newformat:"d\/m\/Y"}, editoptions:{
                dataInit:function(el){
                    commonHelper.setDatePicker(jQuery(el));
                }
            }});
            colModels.push({name: 'endDate', index : 'endDate', sorttype:"datetime", formatter :"date", editable:true, required: true, formatoptions:{srcformat:"d\/m\/Y",newformat:"d\/m\/Y"}, editoptions:{
                dataInit:function(el){
                    commonHelper.setDatePicker(jQuery(el));
                }
            }});

            $('#phoneInnerPhonesTable').jqGrid({
                caption: messages['phone.references.inner'],
                url: "phone.htm?method=loadPhoneInnerPhones",
                datatype: "json",
                colNames: colNames,
                colModel: colModels,
                autowidth: true,
                height: "100%",
                jsonReader: { repeatitems: false, id: "phoneinnerphoneid"},
                rowNum: 10,
                pager: '#phoneInnerPhonesPager',
                sortname: 'phoneinnerphoneid',
                viewrecords: true,
                sortorder: "desc",
                editurl: "phone.htm?method=savePhoneInnerPhone"

            });

            $("#phoneInnerPhonesTable").jqGrid('setGridWidth', $('#bodyCell').width() / 4.1, true);

            if (!DEMO && !VIEWER) {
                $('#phoneInnerPhonesTable').jqGrid('navGrid', '#phoneInnerPhonesPager', {search: false}, //options
                    {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                    {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                    {reloadAfterSubmit: true}, // del options
                    {} // search options
                );
            }
        });
    };

    return this;
}function phoneStatistics_helper(phoneHelper) {
    var that = this;

    var requestsDataGrid = null;

    that.display = function () {
        that.loadPhoneStatisticsTable();
        that.initFilterPane();
    };

    this.initFilterPane = function () {
        commonHelper.setDatePicker($('#searchPhoneStatisticsParamForm').find('#filterdatefrom'));
        commonHelper.setDatePicker($('#searchPhoneStatisticsParamForm').find('#filterdateto'));

        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.sourceInfos = [
                {name: '', infosourceid: ''}
            ].concat(result.sourceInfos.rows);

            initReferenceSelect($('#searchPhoneStatisticsParamForm').find('#filterinfoSource'), references, 'sourceInfo', 'infosourceid', 'name');
        });

        commonHelper.checkFeature('MARKETING', function(){
            commonHelper.callAjaxMethod('marketing.htm', 'loadMarketingAdCompanies', {}, function (result) {
                var references = {};
                references.adCompanys = [
                    {title: '', marketingadcompanyid: ''}
                ].concat(result.rows);

                initReferenceSelect($('#searchPhoneStatisticsParamForm').find('#filteradCompany'), references, 'adCompany', 'marketingadcompanyid', 'title');
            });
        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        if (ORGS_COUNT > 0) {
            $('#searchPhoneStatisticsParamForm').find('#filterOrganizationBlock').show();
        }
        else {
            $('#searchPhoneStatisticsParamForm').find('#filterOrganizationBlock').hide();
        }
    };

    this.loadPhoneStatisticsTable = function () {
        if (!requestsDataGrid) {
            var colNames = [];
            colNames.push(messages['phone.statistics.date']);
            colNames.push(messages['phone.statistics.phone']);
            colNames.push(messages['phone.statistics.status']);
            colNames.push(messages['phone.statistics.type']);
            colNames.push(messages['phone.statistics.internalphone']);
            colNames.push(messages['phone.statistics.externalphone']);
            colNames.push(messages['phone.statistics.user']);
            colNames.push(messages['phone.statistics.family']);
            commonHelper.checkFeature('MARKETING', function() {
                colNames.push(messages['phone.statistics.request']);
            });
            colNames.push(messages['phone.statistics.source']);
            commonHelper.checkFeature('MARKETING', function(){
                colNames.push(messages['phone.statistics.adcompany']);
            });
            if (ORGS_COUNT > 0) {
                colNames.push(messages['phone.statistics.organization']);
            }
            colNames.push(messages['phone.statistics.duration']);
            colNames.push(messages['phone.statistics.record']);

            var colModels = [];
            colModels.push({name: 'date', index: 'date', formatter: function (cellvalue, options, rowObject) {
                return cellvalue + ' ' + rowObject.time;
            }});
            colModels.push({name: 'phoneNumber', index: 'phoneNumber', formatter: notNullFormatter});
            colModels.push({name: 'status', index: 'status', edittype:'select', editable: true, formatter : 'select', editoptions:{value:messages['phone.statistics.statusselect']}});
            colModels.push({name: 'type', index: 'type', edittype:'select', editable: true, formatter : 'select', editoptions:{value:messages['phone.statistics.typeselect']}});
            colModels.push({name: 'internalPhone', index: 'internalPhone', formatter: notNullFormatter});
            colModels.push({name: 'externalPhone', index: 'externalPhone', formatter: notNullFormatter});
            colModels.push({name: 'user', index: 'user', formatter: notNullFormatter});
            colModels.push({name: 'family', index: 'family', formatter: notNullFormatter});
            commonHelper.checkFeature('MARKETING', function() {
                colModels.push({name: 'marketingRequest', index: 'marketingRequest', formatter: notNullFormatter});
            });
            colModels.push({name: 'infoSource', index: 'infoSource', formatter: notNullFormatter});
            commonHelper.checkFeature('MARKETING', function(){
                colModels.push({name: 'adCompany', index: 'adCompany', formatter: notNullFormatter});
            });
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'organization', index: 'organization', formatter: notNullFormatter});
            }
            colModels.push({name: 'duration', index: 'duration', formatter: notNullFormatter});
            colModels.push({name: 'record', index: 'record', sortable: false, formatter: function (cellvalue, options, rowObject) {
                if(cellvalue == 'LINK'){
                    return '<a href="javascript:void(0)" onclick="currentPage.statistics.loadRecordByLink(' + rowObject.phonecallid + ')">' + messages['phone.statistics.record.download'] + '</a>';
                }
                else if(cellvalue == 'DOWNLOADED') {
                    return '<a target="_blank" href="phone.htm?method=downloadFile&callid=' + rowObject.phonecallid + '">' + messages['phone.statistics.record.open'] + '</a>';
                }
                else {
                    return '&nbsp;';
                }
            }});

            requestsDataGrid = $('#phoneStatisticsTable').jqGrid({
                datatype:loadPhoneStatistics,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#phoneStatisticsPager',
                sortname: 'date', viewrecords: true, sortorder: "desc"
            });
            requestsDataGrid.jqGrid('setGridWidth', phoneHelper.TABLE_WIDTH);
        } else {
            requestsDataGrid.setGridParam({
                page: 1
            });
            requestsDataGrid.trigger("reloadGrid");
        }

        updateSummary();
    };

    var loadPhoneStatistics = function (postdata) {
        postdata = $.extend(postdata, collectSearchParams());
        commonHelper.callAjaxMethod('phone.htm', 'loadPhoneStatistics',
            postdata, function (result) {
                requestsDataGrid.clearGridData(true);
                requestsDataGrid[0].addJSONData(result);
            }, true);
    };

    var collectSearchParams = function () {
        var params = {};
        $('#searchPhoneStatisticsParamForm').find('input, select').each(function(){
            params[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        return params;
    };

    var updateSummary = function(){
        var postdata = collectSearchParams();
        commonHelper.callAjaxMethod('phone.htm', 'loadPhoneStatisticsSummary', postdata, function(result){
            $('#phoneStatisticsSummary').find('.count').text('0');
            $('#phoneStatisticsSummary').find('.duration').text('0 ' + messages['phone.statistics.second']);
            var totalCount = 0;
            var totalDuration = 0;
            for(var i=0; i<result.length; i++){
                var statusInfo = result[i];
                var tr = $('#phoneStatisticsSummary').find('tr#' + statusInfo[0]);
                tr.find('.count').text(statusInfo[1]);
                tr.find('.duration').text((parseFloat(statusInfo[2])/parseFloat(statusInfo[1])).toFixed(1) + " " + messages['phone.statistics.second']);
                totalCount += parseInt(statusInfo[1]);
                totalDuration += parseInt(statusInfo[2]);
            }
            var tr = $('#phoneStatisticsSummary').find('tr#SUMMARY');
            tr.find('.count').text(totalCount);
            tr.find('.duration').text(totalCount>0?(parseFloat(totalDuration)/parseFloat(totalCount)).toFixed(1):0 + " " + messages['phone.statistics.second']);
        });
    }

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    that.loadRecordByLink = function (phoneCallId){
        commonHelper.callAjaxMethod('phone.htm', 'getRecordLink', {
            callId: phoneCallId
        }, function (url) {
            if(url){
                window.open(url, '_blank');
            }
        });
        return false;
    }

    that.clearFilter = function () {
        $('#filterdatefrom').val('');
        $('#filterdateto').val('');
        $('#filterstatus').val('');
        $('#filtertype').val('');
        $('#filterphone').val('');
        $('#filterexternalPhone').val('');
        $('#filterinternalPhone').val('');
        $('#filterinfoSource').val('');
        $('#filteradCompany').val('');
        $('#filterorganization').val('');

        that.loadPhoneStatisticsTable();
    };

    that.downloadExcel = function () {
        if (requestsDataGrid.jqGrid('getGridParam', 'reccount') > 0) {
            var params = collectSearchParams();

            var sortColumnName = requestsDataGrid.jqGrid('getGridParam', 'sortname');
            var sortOrder = requestsDataGrid.jqGrid('getGridParam', 'sortorder');

            var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&';
            var existNotEmptyParam = false;
            for (var param in params) {
                var paramValue = params[param];
                existNotEmptyParam |= paramValue ? true : false;
                paramsString += param + '=' + paramValue + '&';
            }

            var excelFunction = function () {
                window.location.assign("phone.htm?method=downloadPhoneStatisticsAsExcel" + (paramsString ? '&' + paramsString : ''));
            };
            if (!existNotEmptyParam) {
                DIALOGS.askYesNoDialog(messages['phone.statistics.filter.noparam'], messages['common.yes'], excelFunction);
            } else {
                excelFunction();
            }
        } else {
            commonHelper.showMessage(messages['phone.statistics.filter.nodata']);
        }
    };

    return this;
}function productsComponents_helper(helper) {
    var that = this;

    var dataGrid = null;
    var productList = [];

    that.display = function () {
        this.loadCoursesTable();
        that.initFilterPane();
    };

    this.initFilterPane = function () {
        commonHelper.callAjaxMethod('products.htm', 'loadProductsGroups', {}, function (result) {
            var references = {};
            references.productsGroups = [
                {title: '', productsgroupid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchCourseForm').find('#filterproductgroup'), references, 'productsGroup', 'productsgroupid', 'title');
        });
        commonHelper.callAjaxMethod('settings.htm', 'loadCourseTypeReference', {}, function (result) {
            var references = {};
            references.courseTypes = [
                {name: '', coursetypeid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchCourseForm').find('#filtercoursetype'), references, 'courseType', 'coursetypeid', 'name');
        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        var productautocompleteparams = {
            url: 'products.htm',
            method: 'autoCompleteSearchProduct',
            defaultValue: messages['products.productfilternotset'],
            inputDataTitle: messages['products.productfilteraction'],
            objectNotFound: messages['products.productfilternotfound'],
            objectFound: messages['products.productfilterfound'],
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.title;
            },
            generateLabel: function (item) {
                return item.title + ' ' + (item.barcode ? item.barcode : '');
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('filterproduct', productautocompleteparams);
    };

    this.loadCoursesTable = function () {
        if (!dataGrid) {
            var colNames = [];
            colNames.push(messages['products.components.type']);
            colNames.push(messages['products.components.items']);
            colNames.push(messages['products.components.comment']);
            if (ORGS_COUNT > 0) {
                colNames.push(messages['products.components.organization']);
            }
            colNames.push('');

            var colModels = [];
            colModels.push({name: 'coursetype', index: 'coursetype', formatter: notNullFormatter});
            colModels.push({name: 'items', index: 'items', formatter: notNullFormatter, sortable: false});
            colModels.push({name: 'comment', index: 'comment', formatter: notNullFormatter});
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'orgid', index: 'orgid', edittype:'select', editable: true, formatter : 'select', editoptions:{value:':;'+ORGS_SELECT}});
            }
            colModels.push({name: 'courseid', index: 'courseid', sortable: false, formatter: function (cellvalue, options, rowObject) {
                return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.components.editCourse(' + cellvalue + ')">' + messages['common.edit'] + '</a>';
            }});

            dataGrid = $('#coursesTable').jqGrid({
                datatype:loadCourses,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#coursesPager',
                sortname: 'courseid', viewrecords: true, sortorder: "desc"
            });
            dataGrid.jqGrid('setGridWidth', helper.TABLE_WIDTH);
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    };

    var loadCourses = function (postdata) {
        $('#searchCourseForm').find('input, select').each(function(){
            postdata[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        commonHelper.callAjaxMethod('products.htm', 'loadCourses',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    this.addCourse = function () {
        that.editCourse(null);
    };

    this.editCourse = function (courseId) {
        var params = {};
        if(courseId){
            params['courseId'] = courseId;
        }
        commonHelper.callAjaxMethod('products.htm', 'loadCourse', params, function (data) {

            if (!data.course) {
                data.course = {}
            }

            var courseEditDialog = $('#courseEditDialog');
            
            var fillSelect = function(selector, listName, nameField, valueField){
                selector.children(null).remove();
                selector.append('<option>');
                var option = {};
                option['obj <- ' + listName + '.rows'] = {
                    '.': 'obj.' + nameField,
                    '@value': 'obj.' + valueField
                }
                selector.directives({
                    'option': option
                }).render(data);
            }
            fillSelect(courseEditDialog.find('.courseType'), 'courseTypeList', 'name', 'coursetypeid');
            productList = [];
            for(var i=0; i<data.productList.rows.length; i++){
                productList[data.productList.rows[i].productid] = data.productList.rows[i].title;
            }

            courseEditDialog.directives({
                '.courseId@value': 'course.id',
                '.comment': 'course.comment'
            }).render(data);
            if(data.course.courseType){
                $('#courseEditDialog').find('.courseType').val(data.course.courseType.id);
            }
            $('#coursePropuctsTable').find('tr.productRow').remove();
            if(data.course.products){
                for(var i=0; i<data.course.products.length; i++){
                    that.addProduct(data.course.products[i]['product']['id'], data.course.products[i]['count']);
                }
            }
            if (ORGS_COUNT > 0) {
                $('#courseEditDialog').find('.organizationBlock').show();
                if(data.course.organization){
                    $('#courseEditDialog').find('.organizationSelect').val(data.course.organization.id);
                }
            } else {
                $('#courseEditDialog').find('.organizationBlock').hide();
            }

            var buttons = {}
            if(courseId){
                buttons['removeButton'] = {
                    title: messages['common.remove'],
                    action: function () {
                        DIALOGS.askYesNoDialog(messages['products.components.confirm'], messages['common.yes'], function () {
                            var courseId = $('#courseEditDialog').find('.courseId').val();
                            if (courseId) {
                                commonHelper.callAjaxMethod('products.htm', 'deleteCourse', {courseId: courseId}, function (data) {
                                    that.loadCoursesTable();
                                    REFERENCE.closeEditReferenceDialog('courseEditDialog');
                                });
                            }
                        }, function(){}, messages['common.no']);
                    }
                }
            }
            buttons['saveButton'] = {
                title: messages['common.save'],
                action: function () {
                    var params = REFERENCE.collectParams('courseEditDialog');
                    var validate = function (params) {
                        var errors = [];
                        var products = [];
                        $('#coursePropuctsTable').find('tr.productRow').each(function(){
                            products.push({
                                productId: $(this).attr('data-productid'),
                                count: $(this).find('.count').val()
                            });
                        });
                        if(products.length < 1){
                            errors.push(messages['products.components.noproduct']);
                        }
                        params['products'] = JSON.stringify(products);
                        if(errors.length > 0){
                            $('#courseEditDialog').find('.dialogMessages').html(errors.join('<br>'));
                            return false;
                        }
                        return true;
                    };
                    $('#courseEditDialog').find('.dialogMessages').html('');
                    if (validate(params)) {
                        commonHelper.callAjaxMethod('products.htm', 'saveCourse', params, function (data) {
                            if (!data) {
                                commonHelper.showMessage(messages['products.components.error']);
                            } else {
                                that.loadCoursesTable();
                                REFERENCE.closeEditReferenceDialog('courseEditDialog');
                            }
                        });
                    }
                }
            }
            REFERENCE.openEditReferenceDialog('courseEditDialog', {
                buttons: buttons,
                onClose: function () {}
            });

            var productautocompleteparams = {
                url: 'products.htm',
                method: 'autoCompleteSearchProduct',
                defaultValue: messages['products.productfilternotset'],
                inputDataTitle: messages['products.productfilteraction'],
                objectNotFound: messages['products.productfilternotfound'],
                objectFound: messages['products.productfilterfound'],
                generateId: function (item) {
                    return item.id;
                },
                generateValue: function (item) {
                    return item.title;
                },
                generateLabel: function (item) {
                    return item.title + ' ' + (item.barcode ? item.barcode : '');
                }
            };
            AUTOCOMPLETE_SEARCH_FIELD.prepare('product', productautocompleteparams);

        }, false, false, false);
    };

    that.clearFilter = function () {
        AUTOCOMPLETE_SEARCH_FIELD.setValue('filterproduct', null, '');
        $('#searchCourseForm').find('#filterproductgroup').val('');
        $('#searchCourseForm').find('#filtercoursetype').val('');

        that.loadCoursesTable();
    };

    this.addProduct = function(productId, count) {
        if(!productId){
            productId = AUTOCOMPLETE_SEARCH_FIELD.getValue('product');
        }
        if(productId){
            if($('#coursePropuctsTable').find('tr[data-productid=' + productId + ']').length > 0){
                commonHelper.showMessage(messages['products.components.productexists']);
            }
            else {
                var productTitle = productList[productId];
                $('#coursePropuctsTable').append('<tr class="productRow" data-productid="' + productId + '"><td>' + productTitle + '</td><td><input type="text" class="count" name="count[]" value="' + count + '"/></td><td><a href="#" onclick="currentPage.components.deleteProduct(' + productId + ')">' + messages['common.remove'] + '</a></tr>')
            }
        }
    }

    this.deleteProduct = function(productId) {
        $('#coursePropuctsTable').find('tr[data-productid=' + productId + ']').remove();
    }

    return this;
}function productsProducts_helper(productHelper) {
    var that = this;

    var dataGrid = null;

    that.display = function () {
        this.loadProductsTable();
        that.initFilterPane();
    };

    this.initFilterPane = function () {
        commonHelper.callAjaxMethod('products.htm', 'loadProductsGroups', {}, function (result) {
            var references = {};
            references.productsGroups = [
                {title: '', productsgroupid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchProductForm').find('#filtergroup'), references, 'productsGroup', 'productsgroupid', 'title');
        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        var productautocompleteparams = {
            url: 'products.htm',
            method: 'autoCompleteSearchProduct',
            defaultValue: messages['products.productfilternotset'],
            inputDataTitle: messages['products.productfilteraction'],
            objectNotFound: messages['products.productfilternotfound'],
            objectFound: messages['products.productfilterfound'],
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.title;
            },
            generateLabel: function (item) {
                return item.title + ' ' + (item.barcode ? item.barcode : '');
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('filterproducts', productautocompleteparams);
    };

    this.loadProductsTable = function () {
        if (!dataGrid) {
            var colNames = [];
            colNames.push(messages['products.products.title']);
            colNames.push(messages['products.products.group']);
            colNames.push(messages['products.products.stock']);
            colNames.push(messages['products.products.uslugi']);
            colNames.push(messages['products.products.comment']);
            commonHelper.checkFeature('BARCODE', function(){
                colNames.push(messages['products.products.barcode']);
            });
            colNames.push('');

            var colModels = [];
            colModels.push({name: 'title', index: 'title', formatter: notNullFormatter});
            colModels.push({name: 'productgroup', index: 'productgroup', formatter: notNullFormatter});
            colModels.push({name: 'stock', index: 'stock', formatter: notNullFormatter});
            colModels.push({name: 'uslugi', index: 'uslugi', formatter: notNullFormatter});
            colModels.push({name: 'comment', index: 'comment', formatter: notNullFormatter});
            commonHelper.checkFeature('BARCODE', function(){
                colModels.push({name: 'barcode', index: 'barcode', formatter: notNullFormatter});
            });
            colModels.push({name: 'productid', index: 'productid', sortable: false, formatter: function (cellvalue, options, rowObject) {
                return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.products.editProduct(' + cellvalue + ')">' + messages['common.edit'] + '</a>';
            }});

            dataGrid = $('#productsTable').jqGrid({
                datatype:loadProducts,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#productsPager',
                sortname: 'productid', viewrecords: true, sortorder: "desc"
            });
            dataGrid.jqGrid('setGridWidth', productHelper.TABLE_WIDTH);
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    };

    var loadProducts = function (postdata) {
        $('#searchProductForm').find('input, select').each(function(){
            postdata[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        commonHelper.callAjaxMethod('products.htm', 'loadProducts',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    this.addProduct = function () {
        that.editProduct(null);
    };

    this.editProduct = function (productId) {
        var params = {};
        if(productId){
            params['productId'] = productId;
        }
        commonHelper.callAjaxMethod('products.htm', 'loadProduct', params, function (data) {

            if (!data.product) {
                data.product = {
                    
                }
            }

            var productEditDialog = $('#productEditDialog');
            
            var fillSelect = function(selector, listName, nameField, valueField){
                selector.children(null).remove();
                selector.append('<option>');
                var option = {};
                option['obj <- ' + listName + '.rows'] = {
                    '.': 'obj.' + nameField,
                    '@value': 'obj.' + valueField
                }
                selector.directives({
                    'option': option
                }).render(data);
            }

            fillSelect(productEditDialog.find('.productGroup'), 'groupList', 'title', 'productsgroupid');

            commonHelper.checkFeature('BARCODE', function(){
                productEditDialog.find('#barcodeBlock').show();
            });
            if(productId){
                productEditDialog.find('#createdBlock').show();
                productEditDialog.find('#editBlock').show();
            }

            productEditDialog.directives({
                '.productId@value': 'product.id',
                '.title@value': 'product.title',
                '.stock@value': 'product.stock',
                '.comment': 'product.comment',
                '.barcode@value': 'product.barcode',
                '.multiplicity@value': 'product.multiplicity',
                '.createdDate': 'product.createdDate',
                '.author': 'product.author.name',
                '.modifiedDate': 'product.modifiedDate',
                '.modifer': 'product.modifer.name'
            }).render(data);
            if(data.product.productGroup){
                $('#productEditDialog').find('.productGroup').val(data.product.productGroup.id);
            }

            var buttons = {}
            if(productId){
                buttons['removeButton'] = {
                    title: messages['common.remove'],
                    action: function () {
                        DIALOGS.askYesNoDialog(messages['products.products.confirm'], messages['common.yes'], function () {
                            var productId = $('#productEditDialog').find('.productId').val();
                            if (productId) {
                                commonHelper.callAjaxMethod('products.htm', 'deleteProduct', {productId: productId}, function (data) {
                                    that.loadProductsTable();
                                    REFERENCE.closeEditReferenceDialog('productEditDialog');
                                });
                            }
                        }, function(){}, messages['common.no']);
                    }
                }
            }
            buttons['saveButton'] = {
                title: messages['common.save'],
                action: function () {
                    var params = REFERENCE.collectParams('productEditDialog');
                    var validate = function (params) {
                        var errors = [];
                        if (params.title == '') {
                            errors.push(messages['products.products.noname']);
                        }
                        if(errors.length > 0){
                            $('#productEditDialog').find('.dialogMessages').html(errors.join('<br>'));
                            return false;
                        }
                        return true;
                    };
                    $('#productEditDialog').find('.dialogMessages').html('');
                    if (validate(params)) {
                        commonHelper.callAjaxMethod('products.htm', 'saveProduct', params, function (data) {
                            if (!data) {
                                commonHelper.showMessage(messages['products.products.error']);
                            } else {
                                that.loadProductsTable();
                                REFERENCE.closeEditReferenceDialog('productEditDialog');
                            }
                        });
                    }
                }
            }
            REFERENCE.openEditReferenceDialog('productEditDialog', {
                    buttons: buttons,
                    onClose: function () {}
                }
            );

        }, false, false, false);
    };

    that.clearFilter = function () {
        $('#searchProductForm').find('#filtergroup').val('');
        AUTOCOMPLETE_SEARCH_FIELD.setValue('filterproducts', null, '');
        
        that.loadProductsTable();
    };

    return this;
}function productsReferences_helper() {
    var that = this;

    that.display = function () {
        that.createProductsGroupsTable();
        that.createProductsTMCTypesTable();
        that.createProductsPriceTable();
    };

    this.createProductsGroupsTable = function () {

        $('#productsGroupsTable').jqGrid({
            caption: messages['products.references.groups'],
            url: "products.htm?method=loadProductsGroups",
            datatype: "json",
            colNames: [messages['products.references.groups.title'], messages['products.references.groups.comment']],
            colModel: [
                {name: 'title', index: 'title', formatter: 'string', editable: true, required: true, editoptions: {size: 47}},
                {name: 'comment', index: 'comment', formatter: 'string', editable: true, required: true, sortable: false, edittype: "textarea", editoptions: {rows: "20", cols: "45"}, editrules: { edithidden: true }}
            ],
            autowidth: true,
            height: "100%",
            jsonReader: { repeatitems: false, id: "productsgroupid"},
            rowNum: 10,
            pager: '#productsGroupsPager',
            sortname: 'productsgroupid',
            viewrecords: true,
            sortorder: "desc",
            editurl: "products.htm?method=saveProductsGroup"

        });

        $("#productsGroupsTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);

        if (!DEMO && !VIEWER) {
            $('#productsGroupsTable').jqGrid('navGrid', '#productsGroupsPager', {search: true}, //options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                {reloadAfterSubmit: true}, // del options
                {} // search options
            );
        }
    };

    this.createProductsTMCTypesTable = function () {
        var scriptTypes = messages['products.references.tmc.typeselect'];
        $('#productsTMCTypesTable').jqGrid({
            caption: messages['products.references.tmc'],
            url: "products.htm?method=loadProductsTMCTypes",
            datatype: "json",
            colNames: [messages['products.references.tmc.title'], messages['products.references.tmc.type'], messages['products.references.tmc.comment']],
            colModel: [
                {name: 'title', index: 'title', formatter: 'string', editable: true, required: true, editoptions: {size: 47}},
                {name: 'type', index: 'type', edittype:'select', editable: true, formatter : 'select', editoptions:{value:scriptTypes}, editrules: { edithidden: true }},
                {name: 'comment', index: 'comment', formatter: 'string', editable: true, required: true, sortable: false, edittype: "textarea", editoptions: {rows: "20", cols: "45"}, editrules: { edithidden: true }}
            ],
            autowidth: true,
            height: "100%",
            jsonReader: { repeatitems: false, id: "productstmctypeid"},
            rowNum: 10,
            pager: '#productsTMCTypesPager',
            sortname: 'productstmctypeid',
            viewrecords: true,
            sortorder: "desc",
            editurl: "products.htm?method=saveProductsTMCType"

        });

        $("#productsTMCTypesTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);

        if (!DEMO && !VIEWER) {
            $('#productsTMCTypesTable').jqGrid('navGrid', '#productsTMCTypesPager', {search: true}, //options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                {reloadAfterSubmit: true}, // del options
                {} // search options
            );
        }
    };

    this.createProductsPriceTable = function () {
        commonHelper.callAjaxMethod('products.htm', 'loadProducts', {}, function (result) {
            var products = [];
            var div = document.createElement('div');
            for (var i = 0; i < result.rows.length; i++) {
                div.innerHTML = result.rows[i].title;
                products[i] = result.rows[i].productid + ':' + div.textContent;
            }

            var colNames = [];
            colNames.push(messages['products.references.price.product']);
            if (ORGS_COUNT > 0) {
                colNames.push(messages['products.references.price.organization']);
            }
            colNames.push(messages['products.references.price.price']);

            var colModels = [];
            colModels.push({name: 'product', index: 'product', edittype:'select', editable: true, formatter : 'select', editoptions:{value:products.join(';')}});
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'orgid', index: 'orgid', edittype:'select', editable: true, formatter : 'select', editoptions:{value:':;'+ORGS_SELECT}});
            }
            colModels.push({name: 'price', index: 'price', formatter: 'string', editable: true});

            $('#productsPriceTable').jqGrid({
                caption: messages['products.references.price'],
                url: "products.htm?method=loadProductsPrices",
                datatype: "json",
                colNames: colNames,
                colModel: colModels,
                autowidth: true,
                height: "100%",
                jsonReader: { repeatitems: false, id: "productspriceid"},
                rowNum: 10,
                pager: '#productsPricePager',
                sortname: 'productspriceid',
                viewrecords: true,
                sortorder: "desc",
                editurl: "products.htm?method=saveProductsPrice"
            });

            $("#productsPriceTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);

            if (!DEMO && !VIEWER) {
                $('#productsPriceTable').jqGrid('navGrid', '#productsPricePager', {search: true}, //options
                    {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                    {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                    {reloadAfterSubmit: true}, // del options
                    {} // search options
                );
            }
        });
    };

    return this;
}function productsSell_helper(helper) {
    var that = this;

    var dataGrid = null;
    var currentGroupBy = '';

    that.display = function () {
        this.loadSellTable();
        that.initFilterPane();
    };

    this.initFilterPane = function () {
        commonHelper.setDatePicker($('#searchSellForm').find('#filterdatefrom'));
        commonHelper.setDatePicker($('#searchSellForm').find('#filterdateto'));

        var childautocompleteparams = {
            url: 'family.htm',
            method: 'autoCompleteSearchFamily',
            defaultValue: messages['paymentdialog.familyfilternotset'],
            inputDataTitle: messages['paymentdialog.familyfilteraction'],
            objectNotFound: messages['paymentdialog.familyfilternotfound'],
            objectFound: messages['paymentdialog.familyfilterfound'],

            foundStatusClick: function (event) {
                var familyid = $(this).parents().filter('#divcontainer_paymentdialogfamily').find('#paymentdialogfamily').val();
                DIALOGS.familyDialogs.editFamilyDialog(familyid, null);
            },
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.value;
            },
            generateLabel: function (item) {
                return item.title;
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('sellclientfilter', childautocompleteparams);

        var productautocompleteparams = {
            url: 'products.htm',
            method: 'autoCompleteSearchProduct',
            defaultValue: messages['products.productfilternotset'],
            inputDataTitle: messages['products.productfilteraction'],
            objectNotFound: messages['products.productfilternotfound'],
            objectFound: messages['products.productfilterfound'],
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.title;
            },
            generateLabel: function (item) {
                return item.title + ' ' + (item.barcode ? item.barcode : '');
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('sellproductfilter', productautocompleteparams);

        commonHelper.callAjaxMethod('products.htm', 'loadProductsGroups', {}, function (result) {
            var references = {};
            references.productsGroups = [
                {title: '', productsgroupid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchSellForm').find('#filtersellproductgroup'), references, 'productsGroup', 'productsgroupid', 'title');
        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        if (ORGS_COUNT > 0) {
            $('#searchSellForm').find('#filterOrganizationBlock').show();
        }
        else {
            $('#searchSellForm').find('#filterOrganizationBlock').hide();
            $('#searchSellForm').find('#filtergroupby option[value="organization"]').remove();
        }
    };

    this.loadSellTable = function () {
        var groupBy = $('#searchSellForm').find('#filtergroupby').val();
        if (!dataGrid || currentGroupBy != groupBy) {
            var colNames = [];
            var colModels = [];
            var sortname = null;
            var sortorder = 'asc';

            if(groupBy == ''){
                colNames.push(messages['products.sell.date']);
                colNames.push(messages['products.sell.title']);
                colNames.push(messages['products.sell.client']);
                colNames.push(messages['products.sell.price']);
                colNames.push(messages['products.sell.count']);
                colNames.push(messages['products.sell.cost']);
                colModels.push({name: 'date', index: 'date', formatter: notNullFormatter});
                colModels.push({name: 'title', index: 'title', formatter: notNullFormatter});
                colModels.push({name: 'client', index: 'client', formatter: notNullFormatter});
                colModels.push({name: 'price', index: 'price', formatter: notNullFormatter});
                colModels.push({name: 'count', index: 'count', formatter: notNullFormatter});
                colModels.push({name: 'cost', index: 'cost', formatter: notNullFormatter});
                sortname = 'sellid';
                sortorder = 'desc';
            }
            else if(groupBy == 'client'){
                colNames.push(messages['products.sell.client']);
                colNames.push(messages['products.sell.avgprice']);
                colNames.push(messages['products.sell.count']);
                colNames.push(messages['products.sell.cost']);
                colModels.push({name: 'client', index: 'client', formatter: notNullFormatter});
                colModels.push({name: 'avgprice', index: 'avgprice', formatter: notNullFormatter});
                colModels.push({name: 'count', index: 'count', formatter: notNullFormatter});
                colModels.push({name: 'cost', index: 'cost', formatter: notNullFormatter});
                sortname = 'client';
            }
            else if(groupBy == 'month'){
                colNames.push(messages['products.sell.month']);
                colNames.push(messages['products.sell.avgprice']);
                colNames.push(messages['products.sell.count']);
                colNames.push(messages['products.sell.cost']);
                colModels.push({name: 'month', index: 'month', formatter: notNullFormatter});
                colModels.push({name: 'avgprice', index: 'avgprice', formatter: notNullFormatter});
                colModels.push({name: 'count', index: 'count', formatter: notNullFormatter});
                colModels.push({name: 'cost', index: 'cost', formatter: notNullFormatter});
                sortname = 'month';
            }
            else if(groupBy == 'product'){
                colNames.push(messages['products.sell.title']);
                colNames.push(messages['products.sell.avgprice']);
                colNames.push(messages['products.sell.count']);
                colNames.push(messages['products.sell.cost']);
                colModels.push({name: 'title', index: 'title', formatter: notNullFormatter});
                colModels.push({name: 'avgprice', index: 'avgprice', formatter: notNullFormatter});
                colModels.push({name: 'count', index: 'count', formatter: notNullFormatter});
                colModels.push({name: 'cost', index: 'cost', formatter: notNullFormatter});
                sortname = 'title';
            }
            else if(groupBy == 'productgroup'){
                colNames.push(messages['products.sell.productgroup']);
                colNames.push(messages['products.sell.avgprice']);
                colNames.push(messages['products.sell.count']);
                colNames.push(messages['products.sell.cost']);
                colModels.push({name: 'productgroup', index: 'productgroup', formatter: notNullFormatter});
                colModels.push({name: 'avgprice', index: 'avgprice', formatter: notNullFormatter});
                colModels.push({name: 'count', index: 'count', formatter: notNullFormatter});
                colModels.push({name: 'cost', index: 'cost', formatter: notNullFormatter});
                sortname = 'productgroup';
            }
            else if(groupBy == 'organization'){
                colNames.push(messages['products.sell.organization']);
                colNames.push(messages['products.sell.avgprice']);
                colNames.push(messages['products.sell.count']);
                colNames.push(messages['products.sell.cost']);
                colModels.push({name: 'organization', index: 'organization', formatter: notNullFormatter});
                colModels.push({name: 'avgprice', index: 'avgprice', formatter: notNullFormatter});
                colModels.push({name: 'count', index: 'count', formatter: notNullFormatter});
                colModels.push({name: 'cost', index: 'cost', formatter: notNullFormatter});
                sortname = 'organization';
            }

            $('#sellTable').jqGrid('GridUnload');
            dataGrid = $('#sellTable').jqGrid({
                datatype:loadSell,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#sellPager',
                sortname: sortname, viewrecords: true, sortorder: sortorder
            });
            dataGrid.jqGrid('setGridWidth', helper.TABLE_WIDTH);
            currentGroupBy = groupBy;
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    };

    var loadSell = function (postdata) {
        $('#searchSellForm').find('input, select').each(function(){
            postdata[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        postdata.familyId = AUTOCOMPLETE_SEARCH_FIELD.getValue('sellclientfilter');
        postdata.productId = AUTOCOMPLETE_SEARCH_FIELD.getValue('sellproductfilter');
        commonHelper.callAjaxMethod('products.htm', 'loadSell',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);

                var totalPanel = $('#sellTotalInfo');
                var totalValues = result.additionalAggregationList[0];
                totalPanel.find('.totalcost').text(totalValues.totalcost ? totalValues.totalcost : 0);
                totalPanel.find('.totalcount').text(totalValues.totalcount ? totalValues.totalcount : 0);
                totalPanel.find('.totalavgprice').text(totalValues.totalavgprice ? totalValues.totalavgprice : 0);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    that.clearFilter = function () {
        $('#searchSellForm').find('#filterdatefrom').val('');
        $('#searchSellForm').find('#filterdateto').val('');
        AUTOCOMPLETE_SEARCH_FIELD.setValue('sellclientfilter', '');
        AUTOCOMPLETE_SEARCH_FIELD.setValue('sellproductfilter', '');
        $('#searchSellForm').find('#filtersellproductgroup').val('');
        $('#searchSellForm').find('#filterorganization').val('');
        $('#searchSellForm').find('#filtergroupby').val('');

        that.loadSellTable();
    };

    return this;
}function productsStatistics_helper(helper) {
    var that = this;

    var dataGrid = null;

    that.display = function () {
        this.loadStatisticsTable();
        that.initFilterPane();
    };

    this.initFilterPane = function () {
        commonHelper.callAjaxMethod('products.htm', 'loadProductsGroups', {}, function (result) {
            var references = {};
            references.productsGroups = [
                {title: '', productsgroupid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchStatisticsForm').find('#filterstatproductgroup'), references, 'productsGroup', 'productsgroupid', 'title');
        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        var productautocompleteparams = {
            url: 'products.htm',
            method: 'autoCompleteSearchProduct',
            defaultValue: messages['products.productfilternotset'],
            inputDataTitle: messages['products.productfilteraction'],
            objectNotFound: messages['products.productfilternotfound'],
            objectFound: messages['products.productfilterfound'],
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.title;
            },
            generateLabel: function (item) {
                return item.title + ' ' + (item.barcode ? item.barcode : '');
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('filterstatproduct', productautocompleteparams);

        if (ORGS_COUNT > 0) {
            $('#searchStatisticsForm').find('#filterOrganizationBlock').show();
        }
        else {
            $('#searchStatisticsForm').find('#filterOrganizationBlock').hide();
        }
    };

    this.loadStatisticsTable = function () {
        if (!dataGrid) {
            var colNames = [];
            colNames.push(messages['products.statistics.title']);
            colNames.push(messages['products.statistics.stock']);
            colNames.push(messages['products.statistics.rest']);
            colNames.push(messages['products.statistics.needorder']);
            if (ORGS_COUNT > 0) {
                colNames.push(messages['products.statistics.organization']);
            }

            var colModels = [];
            colModels.push({name: 'title', index: 'title', formatter: notNullFormatter});
            colModels.push({name: 'stock', index: 'stock', formatter: notNullFormatter});
            colModels.push({name: 'rest', index: 'rest', formatter: notNullFormatter});
            colModels.push({name: 'needorder', index: 'needorder', formatter: needOrderFormatter, sortable: false});
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'orgid', index: 'orgid', edittype:'select', editable: true, formatter : 'select', editoptions:{value:':;'+ORGS_SELECT}});
            }

            dataGrid = $('#statisticsTable').jqGrid({
                datatype:loadStatistics,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#statisticsPager',
                sortname: 'statid', viewrecords: true, sortorder: "desc"
            });
            dataGrid.jqGrid('setGridWidth', helper.TABLE_WIDTH);
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    };

    var loadStatistics = function (postdata) {
        $('#searchStatisticsForm').find('input, select').each(function(){
            postdata[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        commonHelper.callAjaxMethod('products.htm', 'loadStatistics',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    var needOrderFormatter = function (cellvalue, options, rowObject) {
        return cellvalue == 'yes' ? '<font color="red">!</font>' : '';
    };

    that.clearFilter = function () {
        AUTOCOMPLETE_SEARCH_FIELD.setValue('filterstatproduct', null, '');
        $('#searchStatisticsForm').find('#filterstatproductgroup').val('');
        $('#searchStatisticsForm').find('#filterstatneedorder').val('');
        $('#searchStatisticsForm').find('#filterstatorganization').val('');

        that.loadStatisticsTable();
    };

    that.downloadExcel = function () {
        var sortColumnName = dataGrid.jqGrid('getGridParam', 'sortname');
        var sortOrder = dataGrid.jqGrid('getGridParam', 'sortorder');

        var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&' + getFilterUrlParams();
        window.location.assign("products.htm?method=downloadStatisticsAsExcel" + (paramsString ? '&' + paramsString : ''));
    };

    that.print = function () {
        var paramsString = getFilterUrlParams();
        commonHelper.openPdfPrintDialog('products.htm?method=printStatisticsFromClient' + (paramsString ? '&' + paramsString : ''));
    };

    var getFilterUrlParams = function (){
        var paramsString = '';
        var params = {};
        $('#searchStatisticsForm').find('input, select').each(function(){
            params[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });

        for (var param in params) {
            var paramValue = params[param];
            paramsString += param + '=' + paramValue + '&';
        }
        return paramsString;
    }

    return this;
}function productsTMC_helper(helper) {
    var that = this;

    var dataGrid = null;

    that.display = function () {
        this.loadTMCTable();
        that.initFilterPane();
    };

    this.initFilterPane = function () {
        commonHelper.callAjaxMethod('products.htm', 'loadProductsGroups', {}, function (result) {
            var references = {};
            references.productsGroups = [
                {title: '', productsgroupid: ''}
            ].concat(result.rows);

            initReferenceSelect($('#searchTMCForm').find('#filtertmcproductgroup'), references, 'productsGroup', 'productsgroupid', 'title');
        });
        commonHelper.callAjaxMethod('products.htm', 'loadProductsTMCTypes', {}, function (result) {
            var references = {};
            references.productsTMCTypes = [
                {title: '', productstmctypeid: ''},
                {title: messages['products.tmc.type.purchase'], productstmctypeid: 'PURCHASE'},
                {title: messages['products.tmc.type.sell'], productstmctypeid: 'SELL'},
                {title: messages['products.tmc.type.consumption'], productstmctypeid: 'CONSUMPTION'}
            ].concat(result.rows);

            initReferenceSelect($('#searchTMCForm').find('#filtertmctype'), references, 'productsTMCType', 'productstmctypeid', 'title');
        });
        

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.' + titlename,
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        var productautocompleteparams = {
            url: 'products.htm',
            method: 'autoCompleteSearchProduct',
            defaultValue: messages['products.productfilternotset'],
            inputDataTitle: messages['products.productfilteraction'],
            objectNotFound: messages['products.productfilternotfound'],
            objectFound: messages['products.productfilterfound'],
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.title;
            },
            generateLabel: function (item) {
                return item.title + ' ' + (item.barcode ? item.barcode : '');
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('filtertmcproduct', productautocompleteparams);
    };

    this.loadTMCTable = function () {
        if (!dataGrid) {
            var colNames = [];
            colNames.push(messages['products.tmc.date']);
            colNames.push(messages['products.tmc.title']);
            colNames.push(messages['products.tmc.type']);
            colNames.push(messages['products.tmc.count']);
            colNames.push(messages['products.tmc.comment']);
            if (ORGS_COUNT > 0) {
                colNames.push(messages['products.tmc.organization']);
            }
            colNames.push('');

            var colModels = [];
            colModels.push({name: 'date', index: 'date', formatter: notNullFormatter});
            colModels.push({name: 'title', index: 'title', formatter: notNullFormatter});
            colModels.push({name: 'type', index: 'type', formatter: function (cellvalue, options, rowObject) {
                if(cellvalue == 'PURCHASE') return messages['products.tmc.type.purchase'];
                else if(cellvalue == 'SELL') return messages['products.tmc.type.sell'];
                else if(cellvalue == 'INVENTORY') return rowObject.tmctype;
                else if(cellvalue == 'CONSUMPTION') return messages['products.tmc.type.consumption'];
                return '&nbsp;';
            }});
            colModels.push({name: 'count', index: 'count', formatter: coloredFormatter});
            colModels.push({name: 'comment', index: 'comment', formatter: notNullFormatter});
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'orgid', index: 'orgid', edittype:'select', editable: true, formatter : 'select', editoptions:{value:':;'+ORGS_SELECT}});
            }
            colModels.push({name: 'tmcid', index: 'tmcid', sortable: false, formatter: function (cellvalue, options, rowObject) {
                if(rowObject.type == 'INVENTORY'){
                    return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.tmc.editTMC(' + cellvalue + ')">' + messages['common.edit'] + '</a>';
                }
                return '&nbsp;';
            }});

            dataGrid = $('#tmcTable').jqGrid({
                datatype:loadTMC,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#tmcPager',
                sortname: 'date', viewrecords: true, sortorder: "desc"
            });
            dataGrid.jqGrid('setGridWidth', helper.TABLE_WIDTH);
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    };

    var loadTMC = function (postdata) {
        $('#searchTMCForm').find('input, select').each(function(){
            postdata[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        commonHelper.callAjaxMethod('products.htm', 'loadTMCs',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);

                var totalPanel = $('#tncTotalInfo');
                var totalValues = result.additionalAggregationList[0];
                totalPanel.find('.totalcount').text(totalValues.totalcount ? totalValues.totalcount : 0);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    var coloredFormatter = function (cellvalue, options, rowObject) {
        if(rowObject.count >= 0){
            return cellvalue != null ? '<font color="green">' + cellvalue + '</font>' : '';
        }
        else {
            return cellvalue != null ? '<font color="red">' + cellvalue + '</font>' : '';
        }
    };

    this.addTMC = function () {
        that.editTMC(null);
    };

    this.editTMC = function (tmcId) {
        var params = {};
        if(tmcId){
            params['tmcId'] = tmcId;
        }
        commonHelper.callAjaxMethod('products.htm', 'loadTMC', params, function (data) {

            if (!data.tmc) {
                data.tmc = {
                    
                }
            }

            var tmcEditDialog = $('#tmcEditDialog');

            var fillSelect = function(selector, listName, nameField, valueField){
                selector.children(null).remove();
                selector.append('<option>');
                var option = {};
                option['obj <- ' + listName + '.rows'] = {
                    '.': 'obj.' + nameField,
                    '@value': 'obj.' + valueField
                }
                selector.directives({
                    'option': option
                }).render(data);
            }
            fillSelect(tmcEditDialog.find('.tmctype'), 'tmcTypeList', 'title', 'productstmctypeid');

            tmcEditDialog.directives({
                '.tmcId@value': 'tmc.id',
                '.tmccount@value': 'tmc.count',
                '.tmccomment': 'tmc.comment'
            }).render(data);
            if(data.tmc.product){
                $('#tmcEditDialog').find('.tmcproduct').val(data.tmc.product.id);
            }
            if(data.tmc.tmcType){
                $('#tmcEditDialog').find('.tmctype').val(data.tmc.tmcType.id);
            }
            if (ORGS_COUNT > 0) {
                $('#tmcEditDialog').find('.organizationBlock').show();
                if(data.tmc.organization){
                    $('#tmcEditDialog').find('.organizationSelect').val(data.tmc.organization.id);
                }
            } else {
                $('#tmcEditDialog').find('.organizationBlock').hide();
            }

            var buttons = {}
            if(tmcId){
                buttons['removeButton'] = {
                    title: messages['common.remove'],
                    action: function () {
                        DIALOGS.askYesNoDialog(messages['products.tmc.confirm'], messages['common.yes'], function () {
                            var tmcId = $('#tmcEditDialog').find('.tmcId').val();
                            if (tmcId) {
                                commonHelper.callAjaxMethod('products.htm', 'deleteTMC', {tmcId: tmcId}, function (data) {
                                    that.loadTMCTable();
                                    REFERENCE.closeEditReferenceDialog('tmcEditDialog');
                                });
                            }
                        }, function(){}, messages['common.no']);
                    }
                }
            }
            buttons['saveButton'] = {
                title: messages['common.save'],
                action: function () {
                    var params = REFERENCE.collectParams('tmcEditDialog');
                    params['tmcproduct'] = AUTOCOMPLETE_SEARCH_FIELD.getValue('tmcproduct');
                    var validate = function (params) {
                        var errors = [];
                        if (params.tmccount == '') {
                            errors.push(messages['products.tmc.validate.count']);
                        }
                        else if(parseInt(params.tmccount) == 0){
                            errors.push(messages['products.tmc.validate.count2']);
                        }
                        if(errors.length > 0){
                            $('#tmcEditDialog').find('.dialogMessages').html(errors.join('<br>'));
                            return false;
                        }
                        return true;
                    };
                    $('#tmcEditDialog').find('.dialogMessages').html('');
                    if (validate(params)) {
                        commonHelper.callAjaxMethod('products.htm', 'saveTMC', params, function (data) {
                            if (!data) {
                                commonHelper.showMessage(messages['products.tmc.error']);
                            } else {
                                that.loadTMCTable();
                                REFERENCE.closeEditReferenceDialog('tmcEditDialog');
                            }
                        });
                    }
                }
            }
            REFERENCE.openEditReferenceDialog('tmcEditDialog', {
                    buttons: buttons,
                    onClose: function () {}
                }
            );

            commonHelper.setDatePicker($('#tmcEditDialog').find('.tmcdate'));
            if(data.tmc.actionDate) {
                $('#tmcEditDialog').find('.tmcdate').val(data.tmc.actionDate);
            }
            else {
                $('#tmcEditDialog').find('.tmcdate').val($.datepicker.formatDate(DATE_FORMAT, new Date()));
            }

            var productautocompleteparams = {
                url: 'products.htm',
                method: 'autoCompleteSearchProduct',
                defaultValue: messages['products.productfilternotset'],
                inputDataTitle: messages['products.productfilteraction'],
                objectNotFound: messages['products.productfilternotfound'],
                objectFound: messages['products.productfilterfound'],
                generateId: function (item) {
                    return item.id;
                },
                generateValue: function (item) {
                    return item.title;
                },
                generateLabel: function (item) {
                    return item.title + ' ' + (item.barcode ? item.barcode : '');
                }
            };
            AUTOCOMPLETE_SEARCH_FIELD.prepare('tmcproduct', productautocompleteparams);
            if (tmcId) {
                AUTOCOMPLETE_SEARCH_FIELD.setValue('tmcproduct', data.tmc.product.id, data.tmc.product.title);
            }

        }, false, false, false);
    };

    that.clearFilter = function () {
        AUTOCOMPLETE_SEARCH_FIELD.setValue('filtertmcproduct', null, '');
        $('#searchTMCForm').find('#filtertmcproductgroup').val('');
        $('#searchTMCForm').find('#filtertmctype').val('');

        that.loadTMCTable();
    };

    that.downloadExcel = function () {
        var sortColumnName = dataGrid.jqGrid('getGridParam', 'sortname');
        var sortOrder = dataGrid.jqGrid('getGridParam', 'sortorder');

        var paramsString = 'sidx=' + sortColumnName + '&sord' + '=' + sortOrder + '&' + getFilterUrlParams();
        window.location.assign("products.htm?method=downloadTMCsAsExcel" + (paramsString ? '&' + paramsString : ''));
    };

    that.print = function () {
        var paramsString = getFilterUrlParams();
        commonHelper.openPdfPrintDialog('products.htm?method=printTMCsFromClient' + (paramsString ? '&' + paramsString : ''));
    };

    var getFilterUrlParams = function (){
        var paramsString = '';
        var params = {};
        $('#searchTMCForm').find('input, select').each(function(){
            params[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });

        for (var param in params) {
            var paramValue = params[param];
            paramsString += param + '=' + paramValue + '&';
        }
        return paramsString;
    }

    return this;
}function receiptErrors_helper(helper) {
    var that = this;

    var dataGrid = null;

    that.display = function () {
        this.loadErrorsTable();
    };

    this.loadErrorsTable = function () {
        if (!dataGrid) {
            var colNames = [];
            colNames.push(messages['receipt.errors.date']);
            colNames.push(messages['receipt.errors.time']);
            colNames.push(messages['receipt.errors.operator']);
            colNames.push(messages['receipt.errors.type']);
            colNames.push(messages['receipt.errors.summ']);
            colNames.push(messages['receipt.errors.resultcode']);
            colNames.push(messages['receipt.errors.message']);

            var colModels = [];
            colModels.push({name: 'date', index: 'date', formatter: notNullFormatter});
            colModels.push({name: 'time', index: 'time', sortable: false, formatter: notNullFormatter});
            colModels.push({name: 'operator', index: 'operator', formatter: notNullFormatter});
            colModels.push({name: 'type', index: 'type', formatter: 'select', editoptions:{value:messages['receipt.errors.typeselect']}});
            colModels.push({name: 'summ', index: 'summ', formatter: notNullFormatter});
            colModels.push({name: 'resultcode', index: 'resultcode', formatter: notNullFormatter});
            colModels.push({name: 'description', index: 'description', formatter: notNullFormatter});

            dataGrid = $('#receiptErrorsTable').jqGrid({
                datatype:loadErrors,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#receiptErrorsPager',
                sortname: 'casherrorid', viewrecords: true, sortorder: "desc"
            });
            dataGrid.jqGrid('setGridWidth', helper.TABLE_WIDTH);
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    };

    var loadErrors = function (postdata) {
        commonHelper.callAjaxMethod('receipt.htm', 'loadErrors',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };
    
    return this;
}function receiptsettings_helper(helper) {
    var that = this;

    var dataGrid = null;

    that.display = function () {
        commonHelper.callAjaxMethod('receipt.htm', 'loadReceiptSettings', {}, function (data) {
            var settings = $('#receiptSettings');
            settings.find('.receiptSettingsPath').val(data.receiptPath);
            settings.find('.receiptSettingsPort').val(data.receiptPort);
            settings.find('.receiptSettingsModel').val(data.receiptModel);
            settings.find('.receiptSettingsBitrate').val(data.receiptBitrate);
            settings.find('.receiptSettingsTCPIP').val(data.receiptTCPIP);
            settings.find('.receiptSettingsTCPPort').val(data.receiptTCPPort);
            settings.find('.receiptTestMode').attr('checked', data.receiptTestMode);
            settings.find('.receiptEmail').attr('checked', data.receiptEmail);

            commonHelper.setTimePicker(settings.find('.receiptSettingsAutosessionTime'));
            var userInfo = settings.find('.receiptSettingsAutosessionUser');
            userInfo.children(null).remove();
            userInfo.append('<option>');
            var option = {};
            option['user <- userInfoList'] = {
                '.': 'user.name',
                '@value': 'user.id'
            }
            userInfo.directives({
                'option': option
            }).render(data);
            if(data.receiptAutosessionTime && data.receiptAutosessionUser){
                settings.find('.receiptSettingsAutosession').attr('checked', true);
                settings.find('.receiptSettingsAutosessionTime').val(data.receiptAutosessionTime);
                settings.find('.receiptSettingsAutosessionUser').val(data.receiptAutosessionUser);
            }
            else {
                settings.find('.receiptSettingsAutosession').attr('checked', false);
            }
            settings.find('.receiptSettingsAutosession').change(function(){
                updateAutosessionBlock();
            });
            updateAutosessionBlock();

            settings.find('.receiptSettingsPort').change(function(){
                updatePortBlock();
            });
            updatePortBlock();
        });
        that.loadOperatorTable();
    };

    that.save = function() {
        var settings = $('#receiptSettings');
        var params = {
            receiptPath: settings.find('.receiptSettingsPath').val(),
            receiptPort: settings.find('.receiptSettingsPort').val(),
            receiptModel: settings.find('.receiptSettingsModel').val(),
            receiptBitrate: settings.find('.receiptSettingsBitrate').val(),
            receiptTCPIP: settings.find('.receiptSettingsTCPIP').val(),
            receiptTCPPort: settings.find('.receiptSettingsTCPPort').val(),
            receiptTestMode: settings.find('.receiptTestMode:checked').val() ? true : false,
            receiptEmail: settings.find('.receiptEmail:checked').val() ? true : false
        }
        if(settings.find('.receiptSettingsAutosession:checked').val()){
            params['receiptAutosessionTime'] = settings.find('.receiptSettingsAutosessionTime').val()
            params['receiptAutosessionUser'] = settings.find('.receiptSettingsAutosessionUser').val()
        }
        commonHelper.callAjaxMethod('receipt.htm', 'saveReceiptSettings', {
            data: JSON.stringify(params)
        });
    }

    that.loadOperatorTable = function () {
        if (!dataGrid) {
            var colNames = [];
            colNames.push(messages['receipt.settings.operator.username']);
            colNames.push(messages['receipt.settings.operator.userlogin']);
            colNames.push(messages['receipt.settings.operator.operatorcode']);
            colNames.push("&nbsp");

            var colModels = [];
            colModels.push({name: 'username', index: 'username', formatter: notNullFormatter});
            colModels.push({name: 'userlogin', index: 'userlogin', formatter: notNullFormatter});
            colModels.push({name: 'operatorcode', index: 'operatorcode', formatter: notNullFormatter});
            colModels.push({name: 'operatorid', index: 'operatorid', sortable: false, align: "right", formatter: function (cellvalue, options, rowObject) {
                return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.settings.editOperator(' + cellvalue + ')">' + messages['common.edit'] + '</a>';
            }});

            dataGrid = $('#receiptOperatorTable').jqGrid({
                datatype:loadOperators,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#receiptOperatorPager',
                sortname: 'operatorid', viewrecords: true, sortorder: "desc"
            });
            dataGrid.jqGrid('setGridWidth', helper.TABLE_WIDTH * 0.65);
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    }

    var loadOperators = function (postdata) {
        commonHelper.callAjaxMethod('receipt.htm', 'loadOperators',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    that.addOperator = function () {
        that.editOperator();
    }

    that.editOperator = function (operatorId) {
        var params = {};
        if(operatorId){
            params['operatorId'] = operatorId;
        }
        commonHelper.callAjaxMethod('receipt.htm', 'loadOperator', params, function (data) {

            if (!data.operator) {
                data.operator = {

                }
            }

            var dialog = $('#operatorEditDialog');

            dialog.directives({
                '.operatorId@value': 'operator.id',
                '.operatorCode@value': 'operator.operatorCode',
                '.operatorPassword@value': 'operator.operatorPassword'
            }).render(data);

            var userInfo = $('#operatorEditDialog').find('#userInfo');
            userInfo.children(null).remove();
            userInfo.append('<option>');
            var option = {};
            option['user <- userInfoList'] = {
                '.': 'user.name',
                '@value': 'user.id'
            }
            userInfo.directives({
                'option': option
            }).render(data);
            if(data.operator.user){
                $('#operatorEditDialog').find('#userInfo').val(data.operator.user.id);
            }

            updatePassword('password');
            $('#operatorEditDialog').find('#operatorPasswordShow').click(function() {
                if ($(this).is(':checked')) {
                    updatePassword('text');
                }
                else {
                    updatePassword('password');
                }
            });

            var buttons = {}
            if(operatorId){
                buttons['removeButton'] = {
                    title: messages['common.remove'],
                    action: function () {
                        DIALOGS.askYesNoDialog(messages['receipt.settings.operator.confirmremove'], messages['common.yes'], function () {
                            var operatorId = $('#operatorEditDialog').find('.operatorId').val();
                            if (operatorId) {
                                commonHelper.callAjaxMethod('receipt.htm', 'deleteOperator', {operatorId: operatorId}, function (data) {
                                    that.loadOperatorTable();
                                    REFERENCE.closeEditReferenceDialog('operatorEditDialog');
                                });
                            }
                        }, function(){}, messages['common.no']);
                    }
                }
            }
            buttons['saveButton'] = {
                title: messages['common.save'],
                action: function () {
                    var params = REFERENCE.collectParams('operatorEditDialog');
                    commonHelper.callAjaxMethod('receipt.htm', 'saveOperator', params, function (data) {
                        if (data) {
                            that.loadOperatorTable();
                            REFERENCE.closeEditReferenceDialog('operatorEditDialog');
                        }
                    });
                }
            }
            REFERENCE.openEditReferenceDialog('operatorEditDialog', {
                    buttons: buttons,
                    onClose: function () {}
                }
            );
        }, false, false, false);
    };

    var updatePassword = function(type){
        var input = $('#operatorEditDialog').find('#operatorPassword');
        var rep = $("<input type='" + type + "' />")
            .attr("id", input.attr("id"))
            .attr("name", input.attr("name"))
            .attr('class', input.attr('class'))
            .val(input.val())
            .insertBefore(input);
        input.remove();
    }

    var updateAutosessionBlock = function() {
        var settings = $('#receiptSettings');
        if(settings.find('.receiptSettingsAutosession:checked').val()){
            settings.find('.receiptSettingsAutosessionTime').prop('disabled', false);
            settings.find('.receiptSettingsAutosessionUser').prop('disabled', false);
        }
        else {
            settings.find('.receiptSettingsAutosessionTime').prop('disabled', true);
            settings.find('.receiptSettingsAutosessionUser').prop('disabled', true);
        }
    }

    var updatePortBlock = function() {
        var settings = $('#receiptSettings');
        if(settings.find('.receiptSettingsPort').val() == 'TCPIP'){
            settings.find('.receiptSettingsBitrate').prop('disabled', true);
            settings.find('.receiptSettingsTCPIP').prop('disabled', false);
            settings.find('.receiptSettingsTCPPort').prop('disabled', false);
        }
        else {
            settings.find('.receiptSettingsBitrate').prop('disabled', false);
            settings.find('.receiptSettingsTCPIP').prop('disabled', true);
            settings.find('.receiptSettingsTCPPort').prop('disabled', true);
        }
    }

    return this;
}function receiptStat_helper(helper) {
    var that = this;

    var dataGrid = null;

    that.display = function () {
        this.initFilterPane();
        this.loadStatTable();
    };

    this.initFilterPane = function () {
        var searchPanel = $('#searchReceiptStatParamForm');

        commonHelper.setDatePicker(searchPanel.find('#filterdatefrom'));
        commonHelper.setDatePicker(searchPanel.find('#filterdateto'));
    }

    this.loadStatTable = function () {
        if (!dataGrid) {
            var colNames = [];
            colNames.push(messages['receipt.stat.date']);
            colNames.push(messages['receipt.stat.time']);
            colNames.push(messages['receipt.stat.operator']);
            colNames.push(messages['receipt.stat.type']);
            colNames.push(messages['receipt.stat.kpk']);
            colNames.push(messages['receipt.stat.session']);
            colNames.push(messages['receipt.stat.checknumber']);
            colNames.push(messages['receipt.stat.checkstate']);
            colNames.push(messages['receipt.stat.checktype']);
            colNames.push(messages['receipt.stat.typeclose']);
            colNames.push(messages['receipt.stat.summ']);
            colNames.push(messages['receipt.stat.resultcode']);

            var colModels = [];
            colModels.push({name: 'date', index: 'date', formatter: notNullFormatter});
            colModels.push({name: 'time', index: 'time', sortable: false, formatter: notNullFormatter});
            colModels.push({name: 'operator', index: 'operator', formatter: notNullFormatter});
            colModels.push({name: 'type', index: 'type', formatter: 'select', editoptions:{value:messages['receipt.errors.typeselect']}});
            colModels.push({name: 'kpk', index: 'kpk', formatter: notNullFormatter});
            colModels.push({name: 'session', index: 'session', formatter: notNullFormatter});
            colModels.push({name: 'checknumber', index: 'checknumber', formatter: notNullFormatter});
            colModels.push({name: 'checkstate', index: 'checkstate', formatter: notNullFormatter});
            colModels.push({name: 'checktype', index: 'checktype', formatter: notNullFormatter});
            colModels.push({name: 'typeclose', index: 'typeclose', formatter: notNullFormatter});
            colModels.push({name: 'summ', index: 'summ', formatter: notNullFormatter});
            colModels.push({name: 'resultcode', index: 'resultcode', formatter: notNullFormatter});

            dataGrid = $('#receiptStatTable').jqGrid({
                datatype:loadStat,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#receiptStatPager',
                sortname: 'cashoperationid', viewrecords: true, sortorder: "desc"
            });
            dataGrid.jqGrid('setGridWidth', helper.TABLE_WIDTH);
        } else {
            dataGrid.setGridParam({
                page: 1
            });
            dataGrid.trigger("reloadGrid");
        }
    };

    var loadStat = function (postdata) {
        $('#searchReceiptStatParamForm').find('input, select').each(function(){
            postdata[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        commonHelper.callAjaxMethod('receipt.htm', 'loadStat',
            postdata, function (result) {
                dataGrid.clearGridData(true);
                dataGrid[0].addJSONData(result);

                var totalPane = $('#totalPane');
                var totalValues = result.additionalAggregationList[0];
                if(totalValues){
                    totalPane.show();
                    totalPane.find('#totalSession').text(totalValues.totalsession);
                    totalPane.find('#totalSumm').text(totalValues.totalsumm);
                }
                else {
                    totalPane.hide();
                }
            }, true);
    };

    that.clearFilter = function () {
        var searchPanel = $('#searchReceiptStatParamForm');
        searchPanel.find('#filterdatefrom').val('');
        searchPanel.find('#filterdateto').val('');
        searchPanel.find('#filterchecknumber').val('');
        searchPanel.find('#filterchecktype').val('');
        searchPanel.find('#filtersession').val('');
        searchPanel.find('#filtertype').val('');

        that.loadStatTable();
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };
    
    return this;
}function receiptwork_helper(helper) {
    var that = this;

    that.display = function () {
        that.refresh();
    };

    that.refresh = function() {
        commonHelper.callAjaxMethod('receipt.htm', 'refreshReceiptStatus', {}, function (data) {
            var message = data.status;
            if(data.status == 0){
                message += ' - ' + messages['receipt.work.status.connected'];
            }
            else {
                message += ' - ' + data.error;
            }
            $('#cashstatus').html(message);
        });
    }

    that.openSession = function() {
        DIALOGS.askYesNoDialog(messages['receipt.work.operations.opensessionconfirm'], messages['receipt.work.operations.opensession'], function () {
            commonHelper.callAjaxMethod('receipt.htm', 'openSession', {}, function (data) {
               if(data.status >= 0){
                   data.message = messages['receipt.work.operations.opensessionsuccess'] + data.session;
               }
               processOperationResult(data);
            });
        });
    }

    that.zReport = function() {
        DIALOGS.askYesNoDialog(messages['receipt.work.operations.zreportconfirm'], messages['receipt.work.operations.zreport'], function () {
            commonHelper.callAjaxMethod('receipt.htm', 'zReport', {}, function (data) {
                if(data.status >= 0){
                    data.message = messages['receipt.work.operations.zreportsuccess'];
                }
                processOperationResult(data);
            });
        });
    }

    that.xReport = function() {
        DIALOGS.askYesNoDialog(messages['receipt.work.operations.xreportconfirm'], messages['receipt.work.operations.xreport'], function () {
            commonHelper.callAjaxMethod('receipt.htm', 'xReport', {}, function (data) {
                if(data.status >= 0){
                    data.message = messages['receipt.work.operations.xreportsuccess'];
                }
                processOperationResult(data);
            });
        });
    }

    that.returnCheck = function() {
        DIALOGS.askYesNoDialog(messages['receipt.work.returns.checkconfirm'], messages['receipt.work.returns.check'], function () {
            commonHelper.callAjaxMethod('receipt.htm', 'returnCheck', {checkNumber: $('#returnCheckNumber').val()}, function (data) {
                if(data.status >= 0){
                    data.message = messages['receipt.work.returns.checksuccess'];
                }
                processReturnResult(data);
            });
        });
    }

    var processOperationResult = function (data) {
        if(data.status >= 0){
            $('#operationResult').html(data.message);
        }
        else {
            $('#operationResult').html('<span style="color: red">' + data.message + '</span>');
        }
    }

    var processReturnResult = function (data) {
        if(data.status >= 0){
            $('#returnsResult').html(data.message);
        }
        else {
            $('#returnsResult').html('<span style="color: red">' + data.message + '</span>');
        }
    }

    return this;
}function references_helper() {
    var that = this;
    var currentOrgId = null;

    var priceTableInited = false;
    var locationTableInited = false;
    var roomTableInited = false;
    that.init = function () {
        that.createTeacherTable();
        that.createSourceInfoTable();
        that.createMembershipTypeTable();
        that.createCourseTypeTable();

        if (ORGS_COUNT == 0 || CURRENT_ORG) {
            that.currentOrgId = CURRENT_ORG;
            $('#referenceOrganizations').find('[orgid=' + that.currentOrgId + ']').addClass('ui-selectee').addClass('ui-selected');
            reloadOrgReferences();
            $('.priceControl').show();
        } else {
            $('.priceControl').hide();
        }

        $('#splitted-references').tabs();


        if (ORGS_COUNT == 0){
            $('#splitted-references').tabs("option", "disabled", [2]);
        }

        $("#referenceOrganizations").selectable({
            selected: function (event, ui) {
                that.currentOrgId = $(ui.selected).attr('orgid');
                reloadOrgReferences();
            }
        });

        loadOrgTeacherConnection();
        loadOrgCourseTypeConnection();
    };

    var reloadOrgReferences = function () {
        that.refreshPriceTable();
        that.refreshRoomTable();
        that.refreshLocationTable();
    };

    var loadOrgTeacherConnection = function(){
        commonHelper.callPageByAjaxMethod('settings.htm', 'loadOrgConnectionPage', {}, function (data) {
            $('#teacherorgconnection').html(data);
        });
    };

    var loadOrgCourseTypeConnection = function(){
        commonHelper.callPageByAjaxMethod('settings.htm', 'loadCourseTypeOrgConnectionPage', {}, function (data) {
            $('#coursetypeorgconnection').html(data);
        });
    };



    this.selectOrgToTeacher = function(ui, selected){
        var orgid = $(ui).attr('orgid');
        var teacherid =  $(ui).attr('teacherid');

        commonHelper.callAjaxMethod('settings.htm', 'saveOrgToTeacherConnection', {'orgid': orgid, 'teacherid' : teacherid, 'selected': selected})
    };

    this.selectOrgToCourseType = function(ui, selected){
        var orgid = $(ui).attr('orgid');
        var coursetypeid =  $(ui).attr('coursetypeid');

        commonHelper.callAjaxMethod('settings.htm', 'saveOrgToCourseTypeConnection', {'orgid': orgid, 'coursetypeid' : coursetypeid, 'selected': selected})
    };



    this.createTeacherTable = function () {
        $('#teacherTable').jqGrid({
            caption: messages['references.teachers'],
            "url": "settings.htm?method=loadTeachersReference",
            "datatype": "json",
            colNames: [messages['references.teachers.name'], messages['references.teachers.phone'], messages['references.teachers.teacher'], messages['references.teachers.comment']],
            colModel: [
                {name: 'name', index: 'name', formatter: 'string', editable: true, required: true, editoptions: {size: 47}},
                {name: 'phone', index: 'phone', formatter: 'string', editable: true, required: true, editoptions: {size: 47}},
                {name: 'teacher', index: 'teacher', formatter: 'checkbox', editable: true, required: true, edittype: 'checkbox', editoptions: {value: 'true:false'}},
                {name: 'comment', index: 'comment', formatter: 'string', editable: true, required: true, sortable: false, edittype: "textarea", editoptions: {rows: "20", cols: "45"}}
            ],
            autowidth: true,
            height: "100%",
            jsonReader: { repeatitems: false, id: "teacherid"},
            rowNum: 10,
            pager: '#teacherPager',
            sortname: 'teacherid',
            viewrecords: true,
            sortorder: "desc",
            editurl: "settings.htm?method=saveTeacher"

        });

        $("#teacherTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);

        if (!DEMO && !VIEWER) {
            $('#teacherTable').jqGrid('navGrid', '#teacherPager', {}, //options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                {reloadAfterSubmit: true}, // del options
                {} // search options
            );
        }
    };

    this.createSourceInfoTable = function () {
        $('#infoSourceTable').jqGrid({
            caption: messages['references.sources'],
            "url": "settings.htm?method=loadInfoSource",
            "datatype": "json",
            colNames: [messages['references.sources.name']],
            colModel: [
                {name: 'name', index: 'name', formatter: 'string', editable: true, required: true, editoptions: {size: 47}}
            ],
            autowidth: true,
            height: "100%",
            jsonReader: { repeatitems: false, id: "infosourceid"},
            rowNum: 10,
            pager: '#infoSourcePager',
            sortname: 'infosourceid',
            viewrecords: true,
            sortorder: "desc",
            editurl: "settings.htm?method=saveInfoSource"
        });

        $("#infoSourceTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);

        if (!DEMO && !VIEWER) {
            $('#infoSourceTable').jqGrid('navGrid', '#infoSourcePager', {}, //options
                {width: 500, height: 270, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                {width: 500, height: 270, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                {reloadAfterSubmit: true}, // del options
                {} // search options
            );
        }
    };

    this.refreshLocationTable = function () {
        if (!locationTableInited) {
            locationTableInited = true;
            $('#locationTable').jqGrid({
                caption: messages['references.locations'],
                "url": "settings.htm?method=loadLocations&orgid=" + (that.currentOrgId ? that.currentOrgId : ''),
                "datatype": "json",
                colNames: [messages['references.locations.name']],
                colModel: [
                    {name: 'name', index: 'name', formatter: 'string', editable: true, required: true, editoptions: {size: 47}}
                ],
                autowidth: true,
                height: "100%",
                jsonReader: { repeatitems: false, id: "locationid"},
                rowNum: 10,
                pager: '#locationPager',
                sortname: 'locationid',
                viewrecords: true,
                sortorder: "desc",
                editurl: "settings.htm?method=saveLocation&orgid=" + (that.currentOrgId ? that.currentOrgId : '')
            });

            $("#locationTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.5, true);

            if (!DEMO && !VIEWER) {
                $('#locationTable').jqGrid('navGrid', '#locationPager', {}, //options
                    {width: 500, height: 270, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                    {width: 500, height: 270, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                    {reloadAfterSubmit: true}, // del options
                    {} // search options
                );
            }
        } else {
            $('#locationTable').setGridParam({
                page: 1,
                "url": "settings.htm?method=loadLocations&orgid=" + (that.currentOrgId ? that.currentOrgId : ''),
                editurl: "settings.htm?method=saveLocation&orgid=" + (that.currentOrgId ? that.currentOrgId : ''),
                "datatype": "json"
            });
            $('#locationTable').jqGrid().trigger("reloadGrid");
        }
    };

    this.createMembershipTypeTable = function () {
        $('#membershipTypeTable').jqGrid({
            caption: messages['references.membershiptypes'],
            "url": "settings.htm?method=loadMembershipType",
            "datatype": "json",
            colNames: [messages['references.membershiptypes.name'], messages['references.membershiptypes.subscription']],
            colModel: [
                {name: 'name', index: 'name', formatter: 'string', editable: true, required: true, editoptions: {size: 47}},
                {name: 'subscription', index: 'subscription', formatter: 'checkbox', editable: true, required: true, edittype: 'checkbox', editoptions: {value: 'true:false'}}
            ],
            autowidth: true,
            height: "100%",
            jsonReader: { repeatitems: false, id: "membershiptypeid"},
            rowNum: 10,
            pager: '#membershipTypePager',
            sortname: 'membershiptypeid',
            viewrecords: true,
            sortorder: "desc",
            editurl: "settings.htm?method=saveMembershipType"
        });

        $("#membershipTypeTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);
        if (!DEMO && !VIEWER) {
            $('#membershipTypeTable').jqGrid('navGrid', '#membershipTypePager', {}, //options
                {width: 500, height: 270, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                {width: 500, height: 270, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                {reloadAfterSubmit: true}, // del options
                {} // search options
            );
        }
    };

    this.refreshRoomTable = function () {
        if (!roomTableInited) {
            roomTableInited = true;
            $('#roomTable').jqGrid({
                caption: messages['references.rooms'],
                "url": "settings.htm?method=loadRooms&orgid=" + (that.currentOrgId ? that.currentOrgId : ''),
                "datatype": "json",
                colNames: [messages['references.rooms.name']],
                colModel: [
                    {name: 'title', index: 'title', formatter: 'string', editable: true, required: true, editoptions: {size: 47}}
                ],
                autowidth: true,
                height: "100%",
                jsonReader: { repeatitems: false, id: "roomid"},
                rowNum: 10,
                pager: '#roomPager',
                sortname: 'roomid',
                viewrecords: true,
                sortorder: "desc",
                editurl: "settings.htm?method=saveRoom&orgid=" + (that.currentOrgId ? that.currentOrgId : '')
            });
            $("#roomTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.5, true);

            if (!DEMO && !VIEWER) {
                $('#roomTable').jqGrid('navGrid', '#roomPager', {}, //options
                    {width: 500, height: 270, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                    {width: 500, height: 270, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                    {reloadAfterSubmit: true}, // del options
                    {} // search options
                );
            }
        } else {
            $('#roomTable').setGridParam({
                page: 1,
                "url": "settings.htm?method=loadRooms&orgid=" + (that.currentOrgId ? that.currentOrgId : ''),
                editurl: "settings.htm?method=saveRoom&orgid=" + (that.currentOrgId ? that.currentOrgId : ''),
                "datatype": "json"
            });
            $('#roomTable').jqGrid().trigger("reloadGrid");
        }
    };

    this.createCourseTypeTable = function () {
        $('#courseTypeTable').jqGrid({
            caption: messages['references.coursetypes'],
            "url": "settings.htm?method=loadCourseTypeReference",
            "datatype": "json",
            colNames: [messages['references.coursetypes.name'], messages['references.coursetypes.active'],  messages['references.coursetypes.comment']],
            colModel: [
                {name: 'name', index: 'name', formatter: commonHelper.notNullFormatter, editable: true, required: true, editoptions: {size: 47}},
                {name: 'active', index: 'active', formatter: 'checkbox', editable: true, required: true, edittype: 'checkbox', editoptions: {value: 'true:false'}},
                {name: 'comment', index: 'comment', formatter: commonHelper.notNullFormatter, editable: true, required: true, sortable: false, edittype: "textarea", editoptions: {rows: "20", cols: "45"}}
            ],
            autowidth: true,
            height: "100%",
            jsonReader: { repeatitems: false, id: "coursetypeid"},
            rowNum: 10,
            pager: '#courseTypePager',
            sortname: 'coursetypeid',
            viewrecords: true,
            sortorder: "desc",
            editurl: "settings.htm?method=saveCourseType"

        });

        $("#courseTypeTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);

        if (!DEMO && !VIEWER) {
            $('#courseTypeTable').jqGrid('navGrid', '#courseTypePager', {}, //options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                {reloadAfterSubmit: true}, // del options
                {} // search options
            );
        }
    };

    this.refreshPriceTable = function () {
        $('#addPrice').button().show();
        $('.priceControl').show();

        if (!priceTableInited) {
            priceTableInited = true;

            var colNames = [];
            colNames.push(messages['references.prices.course']);
            colNames.push(messages['references.prices.type']);
            colNames.push(messages['references.prices.value']);
            commonHelper.checkFeature('PRICING', function(){
                colNames.push(messages['references.prices.onelesson']);
            });
            commonHelper.checkFeature('BARCODE', function(){
                colNames.push(messages['references.prices.barcode']);
            });

            var colModels = [];
            colModels.push({name: 'course.name', index: 'course.name', formatter: 'string', width: "30%"});
            colModels.push({name: 'membershipType.name', index: 'membershipType', formatter: priceMembershipTypeNameFormatter, width: "30%"});
            colModels.push({name: 'value', index: 'value', formatter: 'string', width: "20%"});
            commonHelper.checkFeature('PRICING', function(){
                colModels.push({name: 'onelesson', index: 'onelesson', formatter: 'checkbox', editable: true, edittype: 'checkbox', editoptions: {value: 'true:false'}, width: "20%"});
            });
            commonHelper.checkFeature('BARCODE', function(){
                colModels.push({name: 'barcode', index: 'barcode', sortable: false, width: "30%", formatter: function (cellvalue, options, rowObject) {
                    if(cellvalue){
                        return '<div style="text-align:center;"><img src="barcode.htm?method=showBarcode&amp;code=' + cellvalue + '" alt="' + cellvalue + '"><br/>' + cellvalue + '</div>';
                    }
                    return '&nbsp;';
                }});
            });

            $('#priceTable').jqGrid({
                caption: messages['references.prices'],
                "url": "settings.htm?method=loadPrices&orgid=" + (that.currentOrgId ? that.currentOrgId : ''),
                "datatype": "json",
                colNames: colNames,
                colModel: colModels,
                ondblClickRow: function (rowid, iRow, iCol, e) {
                    if (!DEMO && !VIEWER) {
                        DIALOGS.openPriceDialog(rowid, that.currentOrgId, function () {
                            $('#priceTable').trigger("reloadGrid");
                        });
                    }
                },
                autowidth: true,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                rowNum: 25,
                pager: '#pricePager',
                sortname: 'id',
                viewrecords: true,
                sortorder: "desc"
            });

            $("#priceTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.5, true);
        } else {
            $('#priceTable').setGridParam({
                page: 1,
                "url": "settings.htm?method=loadPrices&orgid=" + (that.currentOrgId ? that.currentOrgId : ''),
                "datatype": "json"
            });
            $('#priceTable').jqGrid().trigger("reloadGrid");

        }
    };


    this.addPrice = function () {
        DIALOGS.openPriceDialog('', that.currentOrgId, function () {
            $('#priceTable').trigger("reloadGrid");
        });
    };

    this.downloadPricesAsExcel = function(){
        window.location.assign("settings.htm?method=downloadPricesAsExcel&orgid=" + that.currentOrgId);
    };

    var priceMembershipTypeNameFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : messages['references.subscription'];
    };


    return this;
}function compositeschedules_helper(schedulesHelper) {
    var that = this;

    var scheduleTableInited = false;

    this.pageReady = function(){
        that.refreshCompositeScheduleTable();
    };

    this.addCompositeSchedule = function () {
        DIALOGS.scheduleDialogs.openCompositeScheduleDialog('', {orgid: schedulesHelper.currentOrgId}, function () {
            that.refreshCompositeScheduleList();
        });
    };


    that.refreshCompositeScheduleTable = function () {
        $('#compositeScheduleTableContainer').show();
        $('#addCompositeSchedule').button().show();
        $('#showAllCompositeScheduleDiv').show();

        if (!scheduleTableInited) {
            scheduleTableInited = true;

            var colNames = [];
            var colModel = [];

            if (ORGS_COUNT > 0) {
                colNames.push(messages['schedule.compositeschedules.organization']);
                colModel.push({name: 'organization', index: 'organization', width: "20px", formatter: schedulesHelper.notNullFormatter});
            }
            colNames.push(messages['schedule.compositeschedules.active']);
            colNames.push(messages['schedule.compositeschedules.course']);
            colNames.push(messages['schedule.compositeschedules.details']);
            colNames.push(messages['schedule.compositeschedules.comment']);
            colNames.push('');

            colModel.push({name: 'active', index: 'active', width: "5%", formatter: schedulesHelper.activeMembershipFormatter});
            colModel.push({name: 'courseTypeName', index: 'courseTypeName', formatter: 'string', width: "15%"});
            colModel.push({name: 'scheduleDetails', index: 'scheduleDetails', sortable: false, formatter: 'string', width: "40%"});
            colModel.push({name: 'comment', index: 'comment', formatter: 'string', width: "20%"});
            colModel.push({name: 'data', index: 'data', sortable: false, width: '15%', formatter: formatScheduleElementFormatter});


            $('#compositeScheduleTable').jqGrid({
                caption: messages['schedule.compositeschedules'],
                "url": "settings.htm?method=loadCompositeSchedules&showall=" + ($('#showallcompositeschedule:checked').val() ? true : false) + '&orgid=' + (schedulesHelper.currentOrgId ? schedulesHelper.currentOrgId : ''),
                "datatype": "json",
                colNames: colNames,
                colModel: colModel,
                ondblClickRow: function (rowid, iRow, iCol, e) {
                    if (!DEMO && !VIEWER) {
                        DIALOGS.scheduleDialogs.openCompositeScheduleDialog(rowid, {ogrid: schedulesHelper.currentOrgId}, function () {
                            $('#compositeScheduleTable').trigger("reloadGrid");
                        });
                    }
                },
                autowidth: true,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                rowNum: 25,
                pager: '#compositeSchedulePager',
                sortname: 'id',
                viewrecords: true,
                sortorder: "desc"
            });

            $("#compositeScheduleTable").jqGrid('setGridWidth', $('#bodyCell').width() / 1.02, true);

        } else {
            $('#compositeScheduleTable').setGridParam({
                page: 1,
                "url": "settings.htm?method=loadCompositeSchedules&showall=" + ($('#showallcompositeschedule:checked').val() ? true : false) + '&orgid=' + (schedulesHelper.currentOrgId ? schedulesHelper.currentOrgId : ''),
                "datatype": "json"
            });
            $('#compositeScheduleTable').jqGrid().trigger("reloadGrid");
        }
    };

    this.refreshCompositeScheduleList = function () {
        $('#compositeScheduleTable').jqGrid().setGridParam(
            {url: "settings.htm?method=loadCompositeSchedules&showall=" + ($('#showallcompositeschedule:checked').val() ? true : false) + '&orgid=' + (schedulesHelper.currentOrgId ? schedulesHelper.currentOrgId : '')}).trigger("reloadGrid");
    };


    this.editCompositeScheduleRow = function (id) {
        if (!DEMO) {
            DIALOGS.scheduleDialogs.openCompositeScheduleDialog(id, {orgid: schedulesHelper.currentOrgId}, function () {
                that.refreshCompositeScheduleList();
            });
        }
    };

    var formatScheduleElementFormatter = function (cellvalue, options, rowObject) {
        return $('#compositeScheduleData').clone().directives({
            '.compositeScheduleRowData': {
                'element <- elements': {
                    '.teacher': 'element.teacher.name',
                    '.day': 'element.day.title',
                    '.startTime': 'element.startTime',
                    '.finishTime': 'element.finishTime',
                    '.room': 'element.room.title'
                }
            }
        }).render(rowObject).html();

    };

    return this;
}function multisubscriptiondescription_helper(schedulesHelper) {
    var that = this;
    var multiSubscriptionDescriptionTable;
    this.pageReady = function () {
        that.refreshSubscriptionDescriptions();
    };

    this.refreshSubscriptionDescriptions = function () {
        var colNames = [];
        var colModel = [];

        if (ORGS_COUNT > 0) {
            colNames.push(messages['schedule.multisubscriptiondescription.organization']);
            colModel.push({name: 'organization', index: 'organization', width: "20px", formatter: commonHelper.notNullFormatter});
        }
        colNames.push(messages['schedule.multisubscriptiondescription.active']);
        colNames.push(messages['schedule.multisubscriptiondescription.name']);
        colNames.push(messages['schedule.multisubscriptiondescription.course']);
        colNames.push(messages['schedule.multisubscriptiondescription.teacher']);
        colNames.push(messages['schedule.multisubscriptiondescription.price']);
        colNames.push(messages['schedule.multisubscriptiondescription.fromdate']);
        colNames.push(messages['schedule.multisubscriptiondescription.todate']);
        colNames.push(messages['schedule.multisubscriptiondescription.fromtime']);
        colNames.push(messages['schedule.multisubscriptiondescription.totime']);

        colModel.push({name: 'active', index: 'active', formatter: function(cellvalue, options, rowObject){
            return rowObject.active ? messages['schedule.multisubscriptiondescription.active.yes'] : messages['schedule.multisubscriptiondescription.active.no']
        }, width: "20%"});
        colModel.push({name: 'name', index: 'name', formatter: commonHelper.notNullFormatter, width: "20%"});
        colModel.push({name: 'courseType', index: 'courseType', formatter: commonHelper.notNullFormatter, width: "20%"});
        colModel.push({name: 'teacher', index: 'teacher', formatter: commonHelper.notNullFormatter, width: "20%"});
        colModel.push({name: 'price', index: 'price', formatter: commonHelper.notNullFormatter, width: "20%"});
        colModel.push({name: 'fromDate', index: 'fromDate', formatter: commonHelper.notNullFormatter, width: "5%"});
        colModel.push({name: 'toDate', index: 'toDate', formatter: commonHelper.notNullFormatter, width: "5%"});
        colModel.push({name: 'fromTime', index: 'fromTime', formatter: commonHelper.notNullFormatter, width: "5%"});
        colModel.push({name: 'toTime', index: 'toTime', formatter: commonHelper.notNullFormatter, width: "5%"});

        if (!multiSubscriptionDescriptionTable) {
            multiSubscriptionDescriptionTable = $('#multiSubscriptionDescriptionTable').jqGrid({
                caption: messages['schedule.multisubscriptiondescription'],
                "url": "settings.htm?method=loadMultiSubscriptionDescriptions&" + 'orgid=' + (schedulesHelper.currentOrgId ? schedulesHelper.currentOrgId : '') + '&showAll=' + ($('#multiSubscriptionShowAll:checked').length > 0),
                "datatype": "json",
                colNames: colNames,
                colModel: colModel,
                ondblClickRow: function (rowid, iRow, iCol, e) {
                    if (!DEMO && !VIEWER) {
                        that.openMultiSubscriptionDescriptionDialog(rowid);
                    }
                },
                autowidth: true,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                rowNum: 25,
                pager: '#multiSubscriptionDescriptionPager',
                sortname: 'id',
                viewrecords: true,
                sortorder: "desc"
            });
        } else {
            $('#multiSubscriptionDescriptionTable').setGridParam({
                page: 1,
                "url": "settings.htm?method=loadMultiSubscriptionDescriptions&" + 'orgid=' + (schedulesHelper.currentOrgId ? schedulesHelper.currentOrgId : '') + '&showAll=' + ($('#multiSubscriptionShowAll:checked').length > 0),
                "datatype": "json"
            });
            $('#multiSubscriptionDescriptionTable').jqGrid().trigger("reloadGrid");
        }
        $("#multiSubscriptionDescriptionTable").jqGrid('setGridWidth', $('#bodyCell').width() / 1.02, true);
    };

    this.openMultiSubscriptionDescriptionDialog = function (id) {
        $('#multiSubscriptionId').val('');
        $('#multiSubscriptionOrganization').val('');
        $('#multiSubscriptionName').val('');
        $('#multiSubscriptionTeacher').val('');
        $('#multiSubscriptionCourse').val('');
        $('#multiSubscriptionLessonsCount').val('');
        $('#multiSubscriptionDateFrom').val('');
        $('#multiSubscriptionDateTo').val('');
        $('#multiSubscriptionTimeFrom').val('');
        $('#multiSubscriptionTimeTo').val('');
        $('#multiSubscriptionPrice').val('');
        $('#multiSubscriptionDuration').val('');
        $('#multiSubscriptionActive').removeAttr('checked');

        var params = {id: id ? id : ''};
        commonHelper.callAjaxMethod('settings.htm', 'loadMultiSubscriptionDescription', {params: JSON.stringify(params)}, function (data) {
            showMultiSubscriptionDescriptionDialog();
            initReferences(data);
            if (data.description) {
                $('#multiSubscriptionId').val(data.description.id);
                $('#multiSubscriptionOrganization').val(data.description.organization ? data.description.organization.id : '');
                $('#multiSubscriptionName').val(commonHelper.decodeHtmlString(data.description.name));
                $('#multiSubscriptionTeacher').val(data.description.teacher ? data.description.teacher.id : '');
                $('#multiSubscriptionCourse').val(data.description.courseType ? data.description.courseType.id : '');
                $('#multiSubscriptionLessonsCount').val(data.description.lessonsCount ? data.description.lessonsCount : '');
                $('#multiSubscriptionDateFrom').val(data.description.fromDate ? data.description.fromDate : '');
                $('#multiSubscriptionDateTo').val(data.description.toDate ? data.description.toDate : '');
                $('#multiSubscriptionTimeFrom').val(data.description.fromTime ? data.description.fromTime : '');
                $('#multiSubscriptionTimeTo').val(data.description.toTime ? data.description.toTime : '');
                $('#multiSubscriptionPrice').val(data.description.price ? data.description.price : '');
                $('#multiSubscriptionDuration').val(data.description.duration ? data.description.duration : '');
                if (data.description.active){
                    $('#multiSubscriptionActive').attr('checked', 'checked');
                }
            } else {
                $('#multiSubscriptionActive').attr('checked', 'checked');
            }
        });
    };

    this.deleteMultiSubscriptionDescription = function () {
        commonHelper.callAjaxMethod('settings.htm', 'deleteMultiSubscriptionDescription', {id: $('#multiSubscriptionId').val()}, function (data) {
            that.closeMultiSubscriptionDescription();
            $('#multiSubscriptionDescriptionTable').trigger("reloadGrid");
        });

    };

    this.saveMultiSubscriptionDescription = function () {
        var params = {
            id: $('#multiSubscriptionId').val() ? $('#multiSubscriptionId').val() : '',
            orgid: $('#multiSubscriptionOrganization').val() ? $('#multiSubscriptionOrganization').val() : '',
            name: $('#multiSubscriptionName').val() ? commonHelper.decodeHtmlString($('#multiSubscriptionName').val()) : '',
            teacherId: $('#multiSubscriptionTeacher').val() ? $('#multiSubscriptionTeacher').val() : '',
            courseId: $('#multiSubscriptionCourse').val() ? $('#multiSubscriptionCourse').val() : '',
            lessonsCount: $('#multiSubscriptionLessonsCount').val() ? $('#multiSubscriptionLessonsCount').val() : '',
            dateFrom: $('#multiSubscriptionDateFrom').val() ? $('#multiSubscriptionDateFrom').val() : '',
            dateTo: $('#multiSubscriptionDateTo').val() ? $('#multiSubscriptionDateTo').val() : '',
            timeFrom: $('#multiSubscriptionTimeFrom').val() ? $('#multiSubscriptionTimeFrom').val() : '',
            timeTo: $('#multiSubscriptionTimeTo').val() ? $('#multiSubscriptionTimeTo').val() : '',
            price: $('#multiSubscriptionPrice').val() ? $('#multiSubscriptionPrice').val() : '',
            duration: $('#multiSubscriptionDuration').val() ? $('#multiSubscriptionDuration').val() : '',
            active: $('#multiSubscriptionActive:checked').length > 0
        };
        commonHelper.callAjaxMethod('settings.htm', 'saveMultiSubscriptionDescription', {params: JSON.stringify(params)}, function (data) {
            that.closeMultiSubscriptionDescription();
            $('#multiSubscriptionDescriptionTable').trigger("reloadGrid");
        });
    };

    this.refreshMultiSubscriptionDescriptions = function () {
        $('#multiSubscriptionDescriptionTable').setGridParam({
            page: 1,
            "url": "settings.htm?method=loadMultiSubscriptionDescriptions&" + 'orgid=' + (schedulesHelper.currentOrgId ? schedulesHelper.currentOrgId : '') + '&showAll=' + ($('#multiSubscriptionShowAll:checked').length > 0),
            "datatype": "json"
        });
        $('#multiSubscriptionDescriptionTable').jqGrid().trigger("reloadGrid");
    };

    var initReferences = function (data) {
        var references = {};
        references.courses = [
            {name: '', courseid: ''}
        ].concat(data.courses.rows);
        references.teachers = [
            {name: '', teacherid: ''}
        ].concat(data.teachers.rows);

        $('#multiSubscriptionDateFrom').val('');
        $('#multiSubscriptionDateTo').val('');

        $('#multiSubscriptionTimeFrom').val('');
        $('#multiSubscriptionTimeTo').val('');

        commonHelper.setDatePicker($('#multiSubscriptionDateFrom'));
        commonHelper.setDatePicker($('#multiSubscriptionDateTo'));

        commonHelper.generateTimepickers($('#multiSubscriptionTimeFrom'), $('#multiSubscriptionTimeTo'), false);

        var courseSelect = $('#multiSubscriptionCourse');
        initReferenceSelect(courseSelect, references, 'course', 'coursetypeid');

        var teacherSelect = $('#multiSubscriptionTeacher');
        initReferenceSelect(teacherSelect, references, 'teacher', 'teacherid');

    };

    var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename) {
        referenceSelect.children(null).remove();
        $('<option>', {
            value: ''
        }).appendTo(referenceSelect);

        var optionParams = {};
        optionParams[referencename + ' <- ' + referencename + 's'] = {
            '.': referencename + '.name',
            '@value': referencename + '.' + referencevaluename
        };

        referenceSelect.directives({
            'option': optionParams
        }).render(references);
    };


    this.closeMultiSubscriptionDescription = function () {
        $('#editMultiSubscriptionDialog').overlay().close();
    };

    var showMultiSubscriptionDescriptionDialog = function (data) {
        var orgid = data ? data.orgid : null;
        commonHelper.closeDialog('editMultiSubscriptionDialog');
        $('#editMultiSubscriptionDialog').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5
            },
            fixed: false,
            closeOnClick: false
        });


        if (ORGS_COUNT > 0) {
            $('.multiSubscriptionOrganization').show();
        } else {
            $('.multiSubscriptionOrganization').hide();
        }

        $('#editMultiSubscriptionDialog').overlay().load();
        $('#editMultiSubscriptionDialog').css('z-index', commonHelper.getMaxZIndex() + 1);

    };

    return this;
}function schedulescalendar_helper(schedulesHelper) {
    var that = this;
    var calendar;
    var scheduleCalendarControlPanel;
    var schedulesData;
    var dayInfoDialog;
    var schedulesModificationData = {
        elements: []
    };
    var scheduleElementId = 0;

    that.pageReady = function () {
        calendar = $('#scheduleCalendar');
        scheduleCalendarControlPanel = $('.scheduleCalendarControlPanel');

        if ($.browser.msie && ($.browser.version == '6.0' || $.browser.version == '7.0' || $.browser.version == '8.0')) {
            calendar.html(messages['schedule.schedulecalendar.ieerror']);
        } else {
            commonHelper.setDatePicker(scheduleCalendarControlPanel.find('.weekDayPicker'), that.refreshCalendar);
            scheduleCalendarControlPanel.find('.weekDayPicker').datepicker("setDate", commonHelper.formatDate(new Date()));


            window.onscroll = function (event) {
                that.eventCallbacks.onWindowScroll(event);
            };

            if (window.addEventListener)  // W3C DOM
                window.addEventListener('resize', recalculateElementsPosition, false);
            else if (window.attachEvent) { // IE DOM
                window.attachEvent("onresize", recalculateElementsPosition);
            }

            scheduleCalendarControlPanel.show().dialog({
                title: messages['schedule.schedulecalendar.weekdaypicker'],
                dialogClass: "noClose",
                zIndex: commonHelper.getMaxZIndex(),
                width: 600,
                height: 350,
                closeOnEscape: false,
                autoOpen: false
            });
            $('.controlDiv').focus();

            var controlDiv = calendar.find('.controlDiv');

            controlDiv.css('position', 'fixed');
            controlDiv.css('top', window.innerHeight - 70);
            controlDiv.css('left', window.innerWidth - 220);
        }
    };

    that.showControlDialog = function () {
        scheduleCalendarControlPanel.dialog({zIndex: commonHelper.getMaxZIndex(), position: { my: "center", at: "center", of: window }}).dialog('open');
    };

    that.destroyControlDialog = function () {
        scheduleCalendarControlPanel.dialog().dialog('close');
    };

    that.prevWeek = function () {
        var weekDay = scheduleCalendarControlPanel.find('.weekDayPicker');
        var date = weekDay.datepicker("getDate");
        date.setDate(date.getDate() - 7);
        scheduleCalendarControlPanel.find('.weekDayPicker').datepicker("setDate", commonHelper.formatDate(date));
        that.refreshCalendar();
    };

    that.nextWeek = function () {
        var weekDay = scheduleCalendarControlPanel.find('.weekDayPicker');
        var date = weekDay.datepicker("getDate");
        date.setDate(date.getDate() + 7);
        scheduleCalendarControlPanel.find('.weekDayPicker').datepicker("setDate", commonHelper.formatDate(date));
        that.refreshCalendar();
    };

    that.deleteNewScheduleElements = function () {
        $('.newScheduleElements').children().filter(':not(.template)').remove();
        $('.notSavedTimeElement').removeClass('notSavedTimeElement');
        $.each(schedulesModificationData.elements, function (index, element) {
            if (element.id.startsWith('new-schedule-element')) {
                $('#event-' + element.id).remove();
            }
        });

        schedulesModificationData.elements = [];
        that.destroyControlDialog();
        recalculateElementsPosition();
    };

    that.closeScheduleElementsDialog = function () {
        that.destroyControlDialog();
    };

    that.createSchedule = function () {
        var currentTeacher = null;
        var currentAdditionalTeacher = null;
        var currentCourse = null;
        var differentTeachersOrCourses = false;
        var differentElementTypes = false;
        var currentElementType = null;

        $.each(schedulesModificationData.elements, function (index, element) {
            differentTeachersOrCourses = differentTeachersOrCourses || (currentTeacher !== null && element.teacher.teacherid != currentTeacher.teacherid);
            differentTeachersOrCourses = differentTeachersOrCourses || (currentAdditionalTeacher !== null && element.additionalTeacher.teacherid != currentAdditionalTeacher.teacherid);
            differentTeachersOrCourses = differentTeachersOrCourses || (currentCourse !== null && element.courseType.coursetypeid != currentCourse.coursetypeid);
            differentElementTypes = differentElementTypes || (currentElementType != null && element.timeElementType != currentElementType);
            currentTeacher = element.teacher;
            currentAdditionalTeacher = element.additionalTeacher;
            currentCourse = element.courseType;
            currentElementType = element.timeElementType;
        });

        if (differentElementTypes) {
            commonHelper.showError(messages['schedule.schedulecalendar.diffetenttypes']);
            return;
        }

        if (differentTeachersOrCourses) {
            commonHelper.showError(messages['schedule.schedulecalendar.differentteachers']);
        }

        if (!differentTeachersOrCourses && !differentElementTypes) {
            if (currentElementType == 'eventInput') {
                commonHelper.callAjaxMethod('settings.htm', 'saveEventDays', {objects: JSON.stringify({elements: schedulesModificationData.elements})}, function (data) {
                    $('.newScheduleElements').children().filter(':not(.template)').remove();
                    that.destroyControlDialog();
                    schedulesModificationData.elements = [];
                    that.refreshCalendar();
                })
            } else {
                DIALOGS.scheduleDialogs.openSimpleScheduleDialog('', {
                    orgid: schedulesHelper.currentOrgId,
                    teacher: currentTeacher,
                    additionalTeacher: currentAdditionalTeacher,
                    elements: schedulesModificationData.elements,
                    courseType: currentCourse
                }, function (response) {
                    $('.newScheduleElements').children().filter(':not(.template)').remove();
                    that.destroyControlDialog();
                    schedulesModificationData.elements = [];
                    that.refreshCalendar();
                });
            }
        }

    };

    that.refreshCalendar = function () {
        if (!CURRENT_ORG && ORGS_COUNT > 0) {
            $('.scheduleCalendarLoading').html(messages['schedule.schedulecalendar.selectorganization']);
        } else {
            commonHelper.callAjaxMethod('settings.htm', 'loadSchedulesAsEvents', {'weekDay': commonHelper.formatDate(scheduleCalendarControlPanel.find('.weekDayPicker').datepicker("getDate"))}, function (data) {
                schedulesData = data;
                $('.scheduleCalendarLoading').show();
                $('#eventCourseInput').children(null).remove();
                $('<option>').appendTo($('#eventCourseInput'));
                $('#eventCourseInput').directives({
                    'option': {
                        'course <- courses': {
                            '.': 'course.name',
                            '@value': 'course.coursetypeid'
                        }
                    }
                }).render({'courses': schedulesData.courses});


                $('#eventTeacherInput').children(null).remove();
                $('<option>').appendTo($('#eventTeacherInput'));
                $('#eventTeacherInput').directives({
                    'option': {
                        'teacher <- teachers': {
                            '.': 'teacher.name',
                            '@value': 'teacher.teacherid'
                        }
                    }
                }).render({'teachers': schedulesData.teachers});

                $('#eventAdditionalTeacherInput').children(null).remove();
                $('<option>').appendTo($('#eventAdditionalTeacherInput'));
                $('#eventAdditionalTeacherInput').directives({
                    'option': {
                        'teacher <- additionalteachers': {
                            '.': 'teacher.name',
                            '@value': 'teacher.teacherid'
                        }
                    }
                }).render({'additionalteachers': [{name:'',teacherid:''}].concat(schedulesData.teachers)});

                openProgressImage();
                buildScheduleCalendar();
                closeProgressImage();
                $('.scheduleCalendarLoading').hide();
            }, true, true);
        }
    };

    that.addModifiedTimeEventElement = function (eventElement) {
        schedulesModificationData.elements.push(eventElement);

        var elementTemplate = $('.newScheduleElements .template');
        var scheduleElement = elementTemplate.clone().removeClass('template').show();
        scheduleElement.find('.course').html(eventElement.courseType.name);
        scheduleElement.find('.teacher').html(eventElement.teacher.name + ((eventElement.additionalTeacher.name != '')?', ' + eventElement.additionalTeacher.name:''));
        scheduleElement.find('.time').html(commonHelper.timeObjectToString(eventElement.startTime) + '-' + commonHelper.timeObjectToString(eventElement.finishTime));
        scheduleElement.find('.room').html(eventElement.room.title);
        scheduleElement.find('.day').html(eventElement.day.title);
        scheduleElement.find('.deleteLink').click(function () {
            var newElements = [];
            $.each(schedulesModificationData.elements, function (index, element) {
                if (element != eventElement) {
                    newElements.push(element);
                } else {
                    if (element.id.startsWith('new-schedule-element')) {
                        $('#event-' + element.id).remove();
                    }
                }
            });
            schedulesModificationData.elements = newElements;
            scheduleElement.remove();
        });
        scheduleElement.appendTo($('.newScheduleElements'));
    };

    var buildScheduleCalendar = function () {
        var roomsInfo = buildRoomsHeader();

        //var start = new Date();
        buildDays();
        //if (console) console.log('buildDays ' + (new Date().getTime() - start.getTime()));
        calendar.css('width', '');
        if (roomsInfo.roomWidth < 250) {
            calendar.css('width', 250 * roomsInfo.roomCount);
            recalculateElementsPosition();
        }

        //if (console) console.log('buildScheduleCalendar ' + (new Date().getTime() - start.getTime()));
    };

    var buildRoomsHeader = function () {
        var calendarTable = calendar.find('.scheduleCalendarTable');
        var roomTemplate = calendarTable.find('thead .roomHeader.template');
        var roomLegendTemplate = calendar.find('.roomTitle.template');

        calendarTable.parent().hover(null, that.eventCallbacks.calendarTableContainerHoverOff);

        var legendEmptyCell = calendar.find('.legendEmptyCell');
        var emptyCell = calendarTable.find('.emptyCell');

        roomLegendTemplate.parent().children().filter(':not(.template)').remove();
        roomTemplate.parent().children().filter(':not(.template)').remove();
        var roomWidth = 0;

        $.each(schedulesData.rooms, function (index, element) {
            var room = roomTemplate.clone().removeClass('template').show();
            var roomLegend = roomLegendTemplate.clone().removeClass('template').show();

            room.appendTo(roomTemplate.parent());
            roomLegend.appendTo(roomLegendTemplate.parent());
            room.css('width', 95 / schedulesData.rooms.length + '%');
            roomWidth = room.width();

            roomLegend.html(element.title);
            roomLegend.css('width', roomWidth + 'px');

        });
        legendEmptyCell.css('width', emptyCell.width() + 'px');

        return {roomWidth: roomWidth, roomCount: schedulesData.rooms.length};
    };

    var buildDays = function () {
        var calendarTable = calendar.find('.scheduleCalendarTable');
        var dayTemplate = calendarTable.find('tbody .day.template');
        var daySeparatorTemplate = calendarTable.find('tbody .daySeparator.template');
        var container = dayTemplate.parent();
        container.children().filter(':not(.template)').remove();
        calendar.find('.scheduleCalendarAbsoluteElements').children().remove();
        $.each(schedulesData.daysData, function (index, day) {
            var dayRow = dayTemplate.clone().removeClass('template').show();
            dayRow.attr('id', 'day-' + day.dateKey);
            dayRow.appendTo(container);

            //var start = new Date();
            buildDay(dayRow, calendar, day);
            //if (console) console.log('buildDay ' + (new Date().getTime() - start.getTime()));

            var dayRowSeparator = daySeparatorTemplate.clone().removeClass('template').show();
            dayRowSeparator.find('td').attr('colspan', schedulesData.rooms.length + 1);
            dayRowSeparator.appendTo(container);

        });
        recalculateElementsPosition();

    };

    var recalculateElementsPosition = function () {
        if (calendar && schedulesData) {
            var container = calendar.find('.scheduleCalendarTable>tbody');
            var calendarAbsoluteElements = calendar.find('.scheduleCalendarAbsoluteElements');

            var containerInfo = {};

            containerInfo.dayRoomInfoWidth = $(container.find('.roomInfo')[2]).width();
            containerInfo.firstTitleElement = $(container.find('.timeTitle:not(.template)')[0]);
            containerInfo.firstTitleElementWidth = containerInfo.firstTitleElement.width();
            containerInfo.pixelsInStep = $(container.find('.timeTitle:not(.template)')[0]).height();

            var standardFirstElementInfoPosition = containerInfo.firstTitleElement.offset();

            $.each(schedulesData.daysData, function (index, day) {
                var currentRoomPosition = 0;
                containerInfo.container = container.find('[id=day-' + day.dateKey + ']');
                var dayOffset = containerInfo.container.offset();

                $.each(schedulesData.rooms, function (index, _roomInfo) {
                    $.each(day.rooms, function (roomId, roomData) {
                        var roomInfo;
                        if (_roomInfo.roomid == roomId) {
                            roomInfo = _roomInfo;
                            roomInfo.id = roomInfo.roomid;

                            containerInfo.firstTitleElementOffset = {left: currentRoomPosition + standardFirstElementInfoPosition.left, top: dayOffset.top};
                            currentRoomPosition += containerInfo.dayRoomInfoWidth;

                            var timeTitleObjects = prepareTimeTitleRecalculationInfo(containerInfo, calendarAbsoluteElements, day, roomId);

                            $.each(timeTitleObjects.timeRows, function (index, row) {
                                $(row).data('fillingEvent', null);
                                $(row).data('date', day.date);
                            });

                            if (roomData.events) {
                                $.each(roomData.events, function (index, event) {
                                    recalculateEventPosition(event, timeTitleObjects);
                                });
                            }
                        }
                    });
                });


            });
        }
    };

    var prepareTimeTitleRecalculationInfo = function (containerInfo, calendarAbsoluteElements, calendarDayInfo, roomId) {
        var dayRow = containerInfo.container;

        var startTime = commonHelper.timeToMinutes(calendarDayInfo.minTime);
        var timeStep = htmlElementsGenerator.calculateTimeStep(calendarDayInfo);

        if (timeStep == 0) {
            alert(messages['schedule.schedulecalendar.calendarerror']);
        }

        var dayRoomInfo = dayRow.find('[id=day-' + calendarDayInfo.dateKey + '-room-' + roomId + ']');
        var firstTitleElement = $(dayRoomInfo.find('.timeTitle:not(.template)')[0]);

        return {
            calendarAbsoluteElements: calendarAbsoluteElements,
            dayRoomInfo: dayRoomInfo,
            dayRoomInfoWidth: containerInfo.dayRoomInfoWidth,
            timeTitles: dayRoomInfo.find('.timeTitle:not(.template)'),
            timeRows: dayRoomInfo.find('.timeRow:not(.template)'),
            firstTimeTitle: firstTitleElement,
            firstElementPosition: containerInfo.firstTitleElementOffset,
            firstElementWidth: containerInfo.firstTitleElementWidth,
            pixelsInStep: containerInfo.pixelsInStep,
            startTime: startTime,
            timeStep: timeStep
        };
    };

    var generateAndRecalculateEvent = function (event, day, room) {
        var container = calendar.find('.scheduleCalendarTable>tbody');
        var containerInfo = {};
        containerInfo.container = container;

        var dayRoomInfo = container.find('[id=day-' + day.dateKey + '-room-' + room.id + ']');

        containerInfo.dayRoomInfoWidth = dayRoomInfo.width();
        containerInfo.firstTitleElement = $(dayRoomInfo.find('.timeTitle:not(.template)')[0]);
        containerInfo.firstTitleElementWidth = containerInfo.firstTitleElement.width();
        containerInfo.pixelsInStep = $(dayRoomInfo.find('.timeTitle:not(.template)')[0]).height();
        containerInfo.firstTitleElementOffset = containerInfo.firstTitleElement.offset();

        var recalculateInfo = prepareTimeTitleRecalculationInfo(containerInfo, calendar.find('.scheduleCalendarAbsoluteElements'), day, room.roomid);
        generateEvent(event, true).appendTo(recalculateInfo.calendarAbsoluteElements);
        var start = new Date();
        recalculateEventPosition(event, recalculateInfo);
        //if (console) console.log('generateAndRecalculateEvent ' + (new Date().getTime() - start.getTime()));
    };

    var recalculateEventPosition = function (event, timeTitleObjects) {
        var start = new Date(timeTitleObjects);

        var firstElementPosition = timeTitleObjects.firstElementPosition;
        var lessonInfo = timeTitleObjects.calendarAbsoluteElements.find('.lessonInfo[id="event-' + event.id + '"]');
        lessonInfo.data('event', event);

        //left y
        var eventStartStepsIndex = Math.floor((commonHelper.timeToMinutes(event.startTime) - timeTitleObjects.startTime) / timeTitleObjects.timeStep);
        var eventStartPixels = timeTitleObjects.pixelsInStep * ((commonHelper.timeToMinutes(event.startTime) - timeTitleObjects.startTime) % timeTitleObjects.timeStep / timeTitleObjects.timeStep);

        var eventStart = Math.floor(firstElementPosition.top + (eventStartStepsIndex >= 0 ? eventStartStepsIndex : 0) * timeTitleObjects.pixelsInStep + eventStartPixels);

        //height
        var eventFinishStepsIndex = Math.floor((commonHelper.timeToMinutes(event.finishTime) - timeTitleObjects.startTime) / timeTitleObjects.timeStep);
        var eventFinishPixels = timeTitleObjects.pixelsInStep * ((commonHelper.timeToMinutes(event.finishTime) - timeTitleObjects.startTime) % timeTitleObjects.timeStep / timeTitleObjects.timeStep);

        var eventFinish = Math.floor(firstElementPosition.top + (eventFinishStepsIndex < $(timeTitleObjects.timeTitles).length ? eventFinishStepsIndex : $(timeTitleObjects.timeTitles).length - 1) * timeTitleObjects.pixelsInStep + eventFinishPixels) + (eventFinishStepsIndex < $(timeTitleObjects.timeTitles).length ? 0 : timeTitleObjects.pixelsInStep);

        var lessonInfoMargin = 5;
        var start1 = new Date();
        lessonInfo.offset({left: firstElementPosition.left + timeTitleObjects.firstElementWidth + lessonInfoMargin, top: eventStart});
        //if (console) console.log('part1 offset ' + (new Date().getTime() - start1.getTime()));
        var start2 = new Date();
        lessonInfo.width(timeTitleObjects.dayRoomInfoWidth - timeTitleObjects.firstElementWidth - 2 * lessonInfoMargin);
        //if (console) console.log('part2 width ' + (new Date().getTime() - start2.getTime()));
        lessonInfo.height(eventFinish - eventStart - 2);
        for (var i = eventStartStepsIndex; i <= eventFinishStepsIndex; i++) {
            var timeTitleRow = timeTitleObjects.timeRows[i];
            if (timeTitleRow) {
                $(timeTitleRow).data('fillingEvent', lessonInfo);
            }
        }
        //if (console) console.log('recalculateEventPosition ' + (new Date().getTime() - start.getTime()));
    };

    var buildDay = function (dayRow, calendar, day) {
        var start = new Date();
        dayRow = dayRow.directives({
            '.date': 'date',
            '.weekDay': 'weekDay.title'
        }).render(day);
        var dayInfoTemplate = dayRow.find('.roomInfo.template');

        var timeStep = htmlElementsGenerator.calculateTimeStep(day);

        dayRow.data('timeStep', timeStep);

        if (timeStep == 0) {
            alert(messages['schedule.schedulecalendar.calendarerror']);
        }

        var timeRowTemplate = dayInfoTemplate.find('.timeRow.template');
        var timeTitleRows = generateTimeTitles(timeRowTemplate, day, timeStep);
        var calendarAbsoluteElements = calendar.find('.scheduleCalendarAbsoluteElements');
        var preparedDayInfoTemplate = dayInfoTemplate.clone().removeClass('template').show();
        preparedDayInfoTemplate.hover(null, that.eventCallbacks.calendarTableContainerHoverOff);
        $.each(timeTitleRows, function (index, item) {
            item.clone(true).appendTo(preparedDayInfoTemplate);
        });

        //if (console) console.log('timeTitleRows prepare ' + (new Date().getTime() - start.getTime()));

        $.each(schedulesData.rooms, function (index, _roomInfo) {
            $.each(day.rooms, function (roomId, roomData) {
                var roomInfo;
                if (_roomInfo.roomid == roomId) {
                    roomInfo = _roomInfo;
                    roomInfo.id = roomInfo.roomid;

                    //var start1 = new Date();
                    var dayRoomInfo = preparedDayInfoTemplate.clone(true);
                    //if (console) console.log('timeTitleRows room ' + (new Date().getTime() - start1.getTime()));

                    dayRoomInfo.attr('id', 'day-' + day.dateKey + '-room-' + roomId);
                    dayRoomInfo.data('dayRoomInfo', {day: day, room: roomInfo});
                    dayRoomInfo.appendTo(dayRow);


                    if (roomData.events) {
                        $.each(roomData.events, function (index, event) {
                            generateEvent(event).appendTo(calendarAbsoluteElements);
                        });
                    }
                }
            });

        });
        //if (console) console.log('timeTitleRows generateEvent ' + (new Date().getTime() - start.getTime()));

    };

    var generateEvent = function (eventData, isNewEvent) {
        var lessonInfo = calendar.find('.lessonInfo.template').clone().removeClass('template').show();
        if (isNewEvent) {
            lessonInfo.addClass('notSavedTimeElement');
        } else {
            if (eventData.plannedRecord) {
                lessonInfo.css('background-color', 'rgba(255, 230, 194, 0.53)');
            } else {
                lessonInfo.css('background-color', 'rgba(173, 216, 230, 0.53)');
            }
        }
        lessonInfo.css('position', 'absolute');
        lessonInfo.attr('id', 'event-' + eventData.id);
        lessonInfo.attr('scheduleId', eventData.scheduleId);
        lessonInfo.attr('currentDate', eventData.currentDate);
        lessonInfo.attr('startTime', commonHelper.timeObjectToString(eventData.startTime));


        var renderedLessonInfo = lessonInfo.directives({
            '.title': function (context) {
                return context.context.courseType.name.length < 7 * 20 ? context.context.courseType.name : context.context.courseType.name.substring(0, 7 * 20) + '...';
            },
            '.teacher': function (context) {
                var result = context.context.teacher.name;
                if(context.context.additionalTeacher && context.context.additionalTeacher.name.length > 0){
                    result += ', ' + context.context.additionalTeacher.name;
                }
                return result.length < 7 * 20 ? result : result.substring(0, 7 * 20) + '...';
            },
            '.lessonCounts': '#{childCount}/#{reservationCount}/#{visitedCount}'

        }).render(eventData);

        renderedLessonInfo.hover(that.eventCallbacks.lessonInfoHoverOn, null);
        renderedLessonInfo.mousedown(that.eventCallbacks.stopDragging);

        renderedLessonInfo.find('.title').click(that.eventCallbacks.editScheduleOnClick);
        renderedLessonInfo.find('.teacher').click(that.eventCallbacks.editScheduleOnClick);
        renderedLessonInfo.find('.lessonCounts').click(that.eventCallbacks.openActualDayInfo);
        return renderedLessonInfo;
    };

    var generateTimeTitles = function (timeRowTemplate, day, timeStep) {
        var startTime = commonHelper.timeToMinutes(day.minTime);
        var finishTime = commonHelper.timeToMinutes(day.maxTime);

        var preparedTemplate = timeRowTemplate.clone();
        preparedTemplate.removeClass('template').show();
        preparedTemplate.mousedown(that.eventCallbacks.selectTimeMouseDown);
        preparedTemplate.mouseup(that.eventCallbacks.selectTimeMouseUp);
        preparedTemplate.mouseover(that.eventCallbacks.selectTimeMouseOver);
        preparedTemplate.hover(that.eventCallbacks.timeRowHoverOn, that.eventCallbacks.timeRowHoverOff);

        var result = [];
        var rowIndex = 0;
        for (var currentTime = startTime; currentTime <= finishTime; currentTime += timeStep) {
            var timeRow = preparedTemplate.clone(true);

            var hour = Math.floor(currentTime / 60);
            var minutes = currentTime - hour * 60;

            var time = (hour.toString().length == 1 ? '0' + hour : hour) + ':' + (minutes.toString().length == 1 ? '0' + minutes : minutes);
            timeRow.attr('timeRow-id', time);
            timeRow.find('.timeTitle').removeClass('template').find('.timeTitleText').html(time);

            timeRow.addClass(rowIndex++ % 2 == 1 ? 'evenRow2' : 'oddRow2');

            result.push(timeRow);
        }
        return result;
    };


    var htmlElementsGenerator = new function () {
        this.calculateTimeStep = function (day) {
            var min = Math.round(day.minDuration / 2);
            if (min == 0) {
                return 60;
            }
            var step = Math.floor(min / 10) * 10;
            if (step == 0) {
                return 5;
            }

            return step;
        };
    };

    that.eventCallbacks = new function () {
        var selectionParams = null;
        var timeElementEditor = null;

        var stopTimeSelection = function (source, lastRow) {
            if (selectionParams) {
                timeElementEditor = function () {
                    var thatEditor = this;
                    thatEditor.selectedParams = selectionParams;
                    thatEditor.selectedTime = selectTimeElements(selectionParams.firstSelectedRow, lastRow);
                    thatEditor.day = selectionParams.day;
                    thatEditor.room = selectionParams.room;
                    thatEditor.date = lastRow.data('date');
                    thatEditor.show = function () {
                        $('.timeElementEditor').overlay({
                            oneInstance: false,
                            fixed: false,
                            mask: {
                                color: '#fff',
                                loadSpeed: 0,
                                opacity: 0.5,
                                zIndex: commonHelper.getMaxZIndex()
                            },
                            closeOnClick: false,
                            onBeforeLoad: function () {

                                $('.timeElementEditor').find('.timeElementFrom').val(commonHelper.timeObjectToString(thatEditor.selectedTime.startTime));
                                $('.timeElementEditor').find('.timeElementTo').val(commonHelper.timeObjectToString(thatEditor.selectedTime.finishTime));
                                $('.timeElementEditor').find('.timeElementDay').html(thatEditor.day.weekDay.title);
                                $('.timeElementEditor').find('.timeElementRoom').html(thatEditor.room.title);

                                commonHelper.generateTimepickers($('.timeElementEditor').find('.timeElementFrom'), $('.timeElementEditor').find('.timeElementTo'), true);

                            },
                            onBeforeClose: function () {
                                $('.selectedTimeRow').removeClass('selectedTimeRow');
                                $('.selectingTimeRow').removeClass('selectingTimeRow');
                            }
                        });
                        $('.timeElementEditor').overlay().load();
                    };

                    thatEditor.getSelectedCourse = function () {
                        return $('.timeElementEditor').find('#eventCourseInput').find('option:selected').html();
                    };

                    thatEditor.getSelectedCourseId = function () {
                        return $('.timeElementEditor').find('#eventCourseInput').val();
                    };

                    thatEditor.getSelectedTeacher = function () {
                        return $('.timeElementEditor').find('#eventTeacherInput').find('option:selected').html();
                    };

                    thatEditor.getSelectedTeacherId = function () {
                        return $('.timeElementEditor').find('#eventTeacherInput').val();
                    };

                    thatEditor.getSelectedAdditionalTeacher = function () {
                        return $('.timeElementEditor').find('#eventAdditionalTeacherInput').find('option:selected').html();
                    };

                    thatEditor.getSelectedAdditionalTeacherId = function () {
                        return $('.timeElementEditor').find('#eventAdditionalTeacherInput').val();
                    };

                    return thatEditor;
                }();
                timeElementEditor.show();
                selectionParams = null;
            }
        };

        this.createTimeElement = function () {
            var timeElementType = $('[name=timeElementType]:checked').val();
            var newEvent = {
                id: 'new-schedule-element-' + (scheduleElementId++),
                courseType: {
                    coursetypeid: timeElementEditor.getSelectedCourseId(),
                    name: timeElementEditor.getSelectedCourse()
                },
                teacher: {
                    teacherid: timeElementEditor.getSelectedTeacherId(),
                    name: timeElementEditor.getSelectedTeacher()
                },
                additionalTeacher: {
                    teacherid: timeElementEditor.getSelectedAdditionalTeacherId(),
                    name: timeElementEditor.getSelectedAdditionalTeacher()
                },
                day: timeElementEditor.day.weekDay,
                date: timeElementEditor.date,
                room: timeElementEditor.room,
                visitedCount: '0',
                reservationCount: '0',
                childCount: '0',
                startTime: commonHelper.stringToTimeObject($('.timeElementFrom').val()),
                finishTime: commonHelper.stringToTimeObject($('.timeElementTo').val()),
                timeElementType: timeElementType,
                createDate: timeElementEditor.date
            };
            if (timeElementType == 'eventInput') {
                that.addModifiedTimeEventElement(newEvent);
                that.createSchedule();
                that.deleteNewScheduleElements();
            } else {
                that.addModifiedTimeEventElement(newEvent);
                generateAndRecalculateEvent(newEvent, timeElementEditor.selectedParams.day, timeElementEditor.selectedParams.room);
                that.showControlDialog();
            }
            $('.timeElementEditor').overlay().close();
        };


        this.selectTimeMouseDown = function (event, ui) {
            var dayRoomInfo = $(event.currentTarget).parent().data('dayRoomInfo');
            selectionParams = {
                timeSelectorStarted: true,
                firstSelectedRow: $(event.currentTarget),
                day: dayRoomInfo.day,
                room: dayRoomInfo.room
            };

            selectionParams.firstSelectedRow.addClass('selectingTimeRow');
            return false;
        };

        this.selectTimeMouseUp = function (event, ui) {
            if (selectionParams) {
                if (!selectionParams.lastSelectedRow) {
                    selectionParams.lastSelectedRow = selectionParams.firstSelectedRow;
                    selectionParams.timeSelectorDirection = 0;
                }
                stopTimeSelection('mouseUp', selectionParams.lastSelectedRow);
            }
        };

        this.selectTimeMouseOver = function (event) {
            if (selectionParams && selectionParams.timeSelectorStarted) {

                var firstSelectedRow = selectionParams.firstSelectedRow;
                var lastSelectedRow = selectionParams.lastSelectedRow;
                var timeSelectorDirection = selectionParams.timeSelectorDirection;

                var oldLastSelectedRow = lastSelectedRow;
                selectionParams.lastSelectedRow = $(event.currentTarget);
                lastSelectedRow = selectionParams.lastSelectedRow;
                if (lastSelectedRow.parent().attr('id') && lastSelectedRow.parent().attr('id') == firstSelectedRow.parent().attr('id')) {

                    selectionParams.timeSelectorDirection = compareRows(lastSelectedRow, firstSelectedRow);
                    timeSelectorDirection = selectionParams.timeSelectorDirection;

                    var minRow = timeSelectorDirection == 1 ? firstSelectedRow : lastSelectedRow;
                    var maxRow = timeSelectorDirection == 1 ? lastSelectedRow : firstSelectedRow;

                    var oldDirectionMin = compareRows(oldLastSelectedRow, minRow);
                    var oldDirectionMax = compareRows(oldLastSelectedRow, maxRow);

                    var oldMinRow = oldDirectionMin == 1 ? minRow : oldLastSelectedRow;
                    var oldMaxRow = oldDirectionMax == 1 ? oldLastSelectedRow : maxRow;

                    if (timeSelectorDirection != 0) {
                        var currentRow = oldMinRow;
                        while (currentRow && currentRow.attr('timeRow-id') != oldMaxRow.attr('timeRow-id')) {
                            if (compareRows(maxRow, currentRow) == 1 && compareRows(minRow, currentRow) == -1) {
                                currentRow.addClass('selectingTimeRow');
                            } else {
                                currentRow.removeClass('selectingTimeRow');
                            }
                            currentRow = currentRow.next();
                        }

                    }
                } else {
                    stopTimeSelection('mouseOver', null);
                }
            }
        };

        var selectTimeElements = function (startRow, finishRow) {
            if (startRow) {
                if (finishRow && startRow.parent().attr('id') != finishRow.parent().attr('id')) {
                    finishRow = null;
                }

                var currentRow = startRow;
                var startEqualsFinish = finishRow && startRow.attr('timeRow-id') == finishRow.attr('timeRow-id');
                var foundEvent = null;
                do {
                    var releaseRow = currentRow;
                    currentRow.addClass('selectedTimeRow');
                    if (selectionParams.timeSelectorDirection == 1) {
                        currentRow = currentRow.next();
                    } else if (selectionParams.timeSelectorDirection == -1) {
                        currentRow = currentRow.prev();
                    } else {
                        currentRow = null;
                    }
                    if (currentRow && currentRow.data('fillingEvent')) {
                        foundEvent = currentRow.data('fillingEvent').data('event');
                    }

                } while (currentRow && !currentRow.data('fillingEvent') && currentRow.attr('timeRow-id') && !startEqualsFinish && (!finishRow || currentRow.attr('timeRow-id') != finishRow.attr('timeRow-id')));
                //select last row
                if (currentRow && currentRow.attr('timeRow-id')) {
                    releaseRow = currentRow;
                    releaseRow.addClass('selectedTimeRow');
                }
                var resultMinTime;
                var resultMaxTime;

                var time1;
                var time2;

                var timeStep = startRow.parent().parent().data('timeStep');

                //calculate time1
                var startRowEvent = startRow.data('fillingEvent') ? startRow.data('fillingEvent').data('event') : null;
                if (startRowEvent) {
                    if (selectionParams.timeSelectorDirection == 0 || selectionParams.timeSelectorDirection == 1) {
                        time1 = startRowEvent.finishTime;
                    } else {
                        time1 = startRowEvent.startTime;
                    }
                } else {
                    var startTime = commonHelper.stringToTimeObject(startRow.attr('timeRow-id'));
                    if (selectionParams.timeSelectorDirection == -1) {
                        time1 = addMinutes(startTime, timeStep);
                    } else {
                        time1 = startTime;
                    }
                }

                //calculate time2
                if (foundEvent) {
                    if (selectionParams.timeSelectorDirection == 0 || selectionParams.timeSelectorDirection == 1) {
                        time2 = foundEvent.startTime;
                    } else {
                        time2 = foundEvent.finishTime;
                    }
                } else {
                    var releaseTime = commonHelper.stringToTimeObject(releaseRow.attr('timeRow-id'));
                    if (selectionParams.timeSelectorDirection == 0 || selectionParams.timeSelectorDirection == 1) {
                        time2 = addMinutes(releaseTime, timeStep);
                    } else {
                        time2 = releaseTime;
                    }
                }

                if (compareTimes(time1, time2) == 1) {
                    resultMinTime = time2;
                    resultMaxTime = time1;
                } else {
                    resultMinTime = time1;
                    resultMaxTime = time2;
                }


                return {
                    'startTime': resultMinTime,
                    'finishTime': resultMaxTime
                };

            }
            return null;
        };

        this.stopDragging = function (event) {
            event.preventDefault ? event.preventDefault() : event.returnValue = false;
            return false;
        };

        this.lessonInfoHoverOn = function (event, ui) {
            stopTimeSelection('hoverOn', null);
        };

        this.calendarTableContainerHoverOff = function () {
            stopTimeSelection('leave table', selectionParams ? selectionParams.lastSelectedRow : null);
        };

        var addMinutes = function (time, addedMinutes) {
            var hours = Math.floor((time.hours * 60 + time.minutes + addedMinutes) / 60);
            var minutes = (time.minutes + addedMinutes) % 60;
            return {hours: hours, minutes: minutes};
        };

        var compareRows = function (row1, row2) {
            if (!row1 || !row1) {
                return 0;
            }

            return compareTimes(commonHelper.stringToTimeObject(row1.attr('timeRow-id')), commonHelper.stringToTimeObject(row2.attr('timeRow-id')));
        };

        var compareTimes = function (time1, time2) {
            return time1.hours > time2.hours ? 1 : time1.hours == time2.hours && time1.minutes > time2.minutes ? 1 : -1;
        };

        this.editScheduleOnClick = function (event) {
            var scheduleId = $(event.currentTarget).parent().parent().parent().attr('scheduleId');
            currentPage.schedules.simpleSchedules.editSimpleScheduleRow(scheduleId, function (response) {
                if (response === true) {
                    $('.lessonInfo[scheduleid=' + scheduleId + ']').remove();
                } else if (response) {
                    that.refreshCalendar();
                }

                recalculateElementsPosition();

            });
        };

        this.onWindowScroll = function (event) {
            var roomTitleDiv = calendar.find('.roomTitleDiv');
            var controlDiv = calendar.find('.controlDiv');

            controlDiv.css('position', 'fixed');
            controlDiv.css('top', window.innerHeight - 70);
            controlDiv.css('left', window.innerWidth - 220);


            var top = window.pageYOffset ? window.pageYOffset : document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;
            var left = window.pageXOffset ? window.pageXOffset : document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft;


            if (top > calendar.offset().top) {
                roomTitleDiv.css('position', 'fixed');
                roomTitleDiv.css('top', 0);
                roomTitleDiv.css('left', calendar.offset().left - (window.pageXOffset ? window.pageXOffset : document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft));
                roomTitleDiv.css('width', calendar.width() - 2);

            } else {
                roomTitleDiv.css('position', 'relative');
                roomTitleDiv.css('left', '');
                roomTitleDiv.css('top', '');
            }
        };

        this.timeRowHoverOn = function (event) {
            var element = $(event.currentTarget);
            var rowId = element.attr('timeRow-id');
            if (rowId) {
                var day = element.parents().filter('.day');
                var timeRows = day.find('[timeRow-id="' + rowId + '"]');
                timeRows.addClass('timeRowHover');
            }
        };

        this.timeRowHoverOff = function (event) {
            var element = $(event.currentTarget);
            var rowId = element.attr('timeRow-id');
            if (rowId) {
                var day = element.parents().filter('.day');
                var timeRows = day.find('[timeRow-id="' + rowId + '"]');
                timeRows.removeClass('timeRowHover');
            }
        };

        that.openActualDayInfo = function (button) {
            var currentDate = button.parents().filter('.lessonInfo').attr('currentDate');
            var startTime = button.parents().filter('.lessonInfo').attr('startTime');
            var scheduleId = button.parents().filter('.lessonInfo').attr('scheduleId');

            ACTUAL_DAY_INFO_INSTANCE = ACTUAL_DAY_INFO(function () {
                return dayInfoDialog;
            }, function () {

            }, function () {

            }, function (data) {
                that.refreshCalendar();

            }, function (data) {
                that.refreshCalendar();
            }, function (data) {
                that.refreshCalendar();
            });

            dayInfoDialog = DIALOGS.openDayInfo(dayInfoDialog, currentDate, startTime, scheduleId, false);

        };
    };

}function schedules_helper() {
    var that = this;

    that.currentOrgId = CURRENT_ORG;
    
    that.schedulesCalendar = new schedulescalendar_helper(that);
    that.simpleSchedules = new simpleschedules_helper(that);
    that.compositeSchedules = new compositeschedules_helper(that);
    that.multiSubscriptionDescription = new multisubscriptiondescription_helper(that);

    that.init = function () {
        var refTabs = $('#tabs-schedules');
        refTabs.tabs({
            select: function (event, ui) {
                $(ui.panel).show();
                if (ui.index == 3){
                    that.schedulesCalendar.refreshCalendar();
                }
            }
        });

        that.simpleSchedules.pageReady();
        that.compositeSchedules.pageReady();
        that.schedulesCalendar.pageReady();
        that.multiSubscriptionDescription.pageReady();

        commonHelper.registerChangeOrganizationListener(function (orgid) {
            that.currentOrgId = orgid;
            DIALOGS.scheduleDialogs.simpleScheduleCache = null;
            showSchedulesForOrg();
        });
    };

    var showSchedulesForOrg = function () {
        that.simpleSchedules.refreshSimpleScheduleTable();
        that.compositeSchedules.refreshCompositeScheduleTable();
        that.schedulesCalendar.refreshCalendar();
        that.multiSubscriptionDescription.refreshSubscriptionDescriptions();
    };

    that.notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    that.activeMembershipFormatter = function (cellvalue, options, rowObject) {
        return rowObject.active ? messages['schedule.schedules.avtive.on'] : messages['schedule.schedules.active.off'];
    };



    return this;
}function simpleschedules_helper(schedulesHelper) {
    var that = this;
    var scheduleTableInited = false;

    this.pageReady = function(){
        that.refreshSimpleScheduleTable();
    };

    this.addSimpleSchedule = function () {
        DIALOGS.scheduleDialogs.openSimpleScheduleDialog('', {orgid: schedulesHelper.currentOrgId}, function () {
            $('#simpleScheduleTable').trigger("reloadGrid");
        });
    };


    this.refreshSimpleScheduleTable = function () {
        $('#simpleScheduleTableContainer').show();

        $('#addSimpleSchedule').button().show();
        $('#showAllSimpleScheduleDiv').show();


        if (!scheduleTableInited) {
            scheduleTableInited = true;

            var colNames = [];
            var colModel = [];

            colNames.push('');
            if (ORGS_COUNT > 0) {
                colNames.push(messages['schedule.simpleschedules.organization']);
            }
            colNames.push(messages['schedule.simpleschedules.active']);
            colNames.push(messages['schedule.simpleschedules.course']);
            colNames.push(messages['schedule.simpleschedules.teacher']);
            colNames.push(messages['schedule.simpleschedules.startdate']);
            colNames.push(messages['schedule.simpleschedules.finishdate']);
            colNames.push(messages['schedule.simpleschedules.maxchildcount']);
            colNames.push(messages['schedule.simpleschedules.comment']);
            colNames.push(messages['schedule.simpleschedules.data']);

            colModel.push({name: 'id', index: 'id', formatter: schedulesHelper.notNullFormatter, width: "3%"});
            if (ORGS_COUNT > 0) {
                colModel.push({name: 'organization.name', index: 'organization', width: "20px", formatter: schedulesHelper.notNullFormatter});
            }
            colModel.push({name: 'active', index: 'active', width: "10%", formatter: schedulesHelper.activeMembershipFormatter});
            colModel.push({name: 'courseType.name', index: 'courseType.name', formatter: 'string', width: "20%"});
            colModel.push({name: 'teacher.name', index: 'teacher.name', width: "30%", formatter: function (cellvalue, options, rowObject) {
                var teachers = cellvalue;
                if(rowObject.additionalTeacher){
                    teachers += ', ' + rowObject.additionalTeacher.name;
                }
                return teachers;
            }});
            colModel.push({name: 'startDate', index: 'startDate', formatter: schedulesHelper.notNullFormatter, width: "10%"});
            colModel.push({name: 'finishDate', index: 'finishDate', formatter: schedulesHelper.notNullFormatter, width: "10%"});
            colModel.push({name: 'maxLessonChildrenCount', index: 'maxLessonChildrenCount', formatter: schedulesHelper.notNullFormatter, width: "20%"});
            colModel.push({name: 'comment', index: 'comment', formatter: 'string', width: "20%"});
            colModel.push({name: 'data', index: 'data', sortable: false, formatter: formatScheduleElementFormatter});


            $('#simpleScheduleTable').jqGrid({
                caption: messages['schedule.simpleschedules'],
                "url": "settings.htm?method=loadSimpleSchedules&showall=" + ($('#showallsimpleschedule:checked').val() ? true : false) + '&orgid=' + (schedulesHelper.currentOrgId ? schedulesHelper.currentOrgId : ''),
                "datatype": "json",
                colNames: colNames,
                colModel: colModel,
                ondblClickRow: function (rowid, iRow, iCol, e) {
                    if (!DEMO && !VIEWER) {
                        DIALOGS.scheduleDialogs.openSimpleScheduleDialog(rowid, {orgid: schedulesHelper.currentOrgId}, function () {
                            $('#simpleScheduleTable').trigger("reloadGrid");
                        });
                    }
                },
                autowidth: true,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                rowNum: 25,
                pager: '#simpleSchedulePager',
                sortname: 'id',
                viewrecords: true,
                sortorder: "desc"
            });

            $("#simpleScheduleTable").jqGrid('setGridWidth', $('#bodyCell').width() / 1.02, true);

        } else {
            $('#simpleScheduleTable').setGridParam({
                page: 1,
                "url": "settings.htm?method=loadSimpleSchedules&showall=" + ($('#showallsimpleschedule:checked').val() ? true : false) + '&orgid=' + (schedulesHelper.currentOrgId ? schedulesHelper.currentOrgId : ''),
                "datatype": "json"
            });
            $('#simpleScheduleTable').jqGrid().trigger("reloadGrid");
        }
    };

    this.refreshSimpleScheduleList = function () {
        $('#simpleScheduleTable').jqGrid().setGridParam(
            {url: "settings.htm?method=loadSimpleSchedules&showall=" + ($('#showallsimpleschedule:checked').val() ? true : false) + '&orgid=' + (schedulesHelper.currentOrgId ? schedulesHelper.currentOrgId : '')}).trigger("reloadGrid");
    };


    this.editSimpleScheduleRow = function (id, callback) {
        if (!DEMO) {
            DIALOGS.scheduleDialogs.openSimpleScheduleDialog(id, {orgid: schedulesHelper.currentOrgId}, function (response) {
                $('#simpleScheduleTable').trigger("reloadGrid");
                if (callback){
                    callback(response);
                }
            });
        }
    };

    var formatScheduleElementFormatter = function (cellvalue, options, rowObject) {
        if (rowObject.elements) {
            return $('#scheduleData').clone().directives({
                '.scheduleRowData': {
                    'element <- elements': {
                        '.day': 'element.day.title',
                        '.startTime': 'element.startTime',
                        '.finishTime': 'element.finishTime',
                        '.room': 'element.room.title'
                    }
                }
            }).render(rowObject).html();
        } else {
            return $('#eventScheduleData').html();
        }
    };

    return this;
}function schedulerGradebook_helper(helper, showChild) {
    var that = this;

    var selectedChildrenGroupScheduleId = null;
    var fixedChildId = null;

    that.display = function () {
        that.initFilterPane();
    };

    that.initFilterPane = function () {
        commonHelper.setDatePicker($('#filterGradebookParamForm').find('#filterdatefrom'));
        commonHelper.setDatePicker($('#filterGradebookParamForm').find('#filterdateto'));

        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.courses = [
                {name: '', courseid: ''}
            ].concat(result.courses.rows);
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.teachers.rows);

            commonHelper.initReferenceSelect($('#filterGradebookParamForm').find('#filtercourse'), references, 'course', 'coursetypeid', 'name');
            commonHelper.initReferenceSelect($('#filterGradebookParamForm').find('#filterteacher'), references, 'teacher', 'teacherid', 'name');
        });
        commonHelper.callAjaxMethod('gradebook.htm', 'loadScoreTypes', {}, function (result) {
            var references = {};
            references.types = [
                {title: '', typeid: ''}
            ].concat(result.rows);

            commonHelper.initReferenceSelect($('#filterGradebookParamForm').find('#filtertype'), references, 'type', 'typeid', 'title');
        });

        if(showChild){
            AUTOCOMPLETE_SEARCH_FIELD.clear('gradebookchild');
            var childautocompleteparams = {
                generateId: function (item) {
                    return item.id;
                },
                generateValue: function (item) {
                    return item.value;
                },
                generateLabel: function (item) {
                    return item.title;
                },
                generateType: function (item) {
                    return item.objtype;
                },
                url: 'family.htm',
                method: 'autoCompleteSearchFamilyOrChild',
                defaultValue: messages['common.familyfilternotset'],
                inputDataTitle: messages['common.familyfiltertitle'],
                objectNotFound: messages['common.familyfilternotfound'],
                objectFound: messages['common.familyfilterfound']
            };
            AUTOCOMPLETE_SEARCH_FIELD.prepare('gradebookchild', childautocompleteparams);
        }
    };

    that.openGroupScheduleMenu = function() {
        DIALOGS.scheduleDialogs.openSimpleSchedulesMenu('#childGroupScheduleMenu', function (id, options, menuElement) {
            selectedChildrenGroupScheduleId = id.split('-')[1];

            var teacherInfo;
            $.each(DIALOGS.scheduleDialogs.simpleScheduleCache, function (index, item) {
                if (item.id == selectedChildrenGroupScheduleId) {
                    teacherInfo = item.teacher;
                }
            });
            $('#filterGradebookParamForm').find('#scheduleSelectedTitle').html(teacherInfo.name + '<br>' + $(menuElement).html());
        });
    }

    that.unselectGroupSchedule = function() {
        selectedChildrenGroupScheduleId = null;
        $('#filterGradebookParamForm').find('#scheduleSelectedTitle').html('');
    }

    that.clearFilter = function () {
        $('#filterGradebookParamForm').find('#filterdatefrom').val('');
        $('#filterGradebookParamForm').find('#filterdateto').val('');
        $('#filterGradebookParamForm').find('#filterteacher').val('');
        $('#filterGradebookParamForm').find('#filtercourse').val('');
        $('#filterGradebookParamForm').find('#filtertype').val('');
        if(showChild){
            AUTOCOMPLETE_SEARCH_FIELD.clear('gradebookchild');
        }
        selectedChildrenGroupScheduleId = null;
        $('#filterGradebookParamForm').find('#scheduleSelectedTitle').html('');
    };

    that.loadGradebook = function() {
        $('#gradebookTable').empty();
        if($('#filterGradebookParamForm').find('#filterdatefrom').val().length == 0 || $('#filterGradebookParamForm').find('#filterdateto').val().length == 0){
            commonHelper.showMessage(messages['gradebook.filter.dateerror']);
            return;
        }
        var params = collectFilterParams();
        commonHelper.callAjaxMethod('gradebook.htm', 'loadGradebook', params, function (result) {
            var dates = [];
            var current = commonHelper.parseDate(params.from);
            var end = commonHelper.parseDate(params.to);
            while (current <= end) {
                dates.push(commonHelper.formatDate(current));
                current.setDate(current.getDate() + 1);
            }
            var table = $('<table></table>');
            var head = $('<tr><th>&nbsp;</th></tr>');
            for(var i=0; i<dates.length; i++){
                head.append('<th>' + dates[i] + '</th>');
            }
            table.append(head);
            for(var i=0; i<result.length; i++){
                var row = $('<tr></tr>');
                if(result[i].childid){
                    row.append('<td><a href="client.htm?childid=' + result[i].childid + '" target="_blank">' + result[i].title + '</a></td>');
                }
                else {
                    row.append('<td>' + result[i].title + '</td>');
                }
                for(var j=0; j<dates.length; j++){
                    var cell = $('<td></td>');
                    if(result[i].dates && result[i].dates[dates[j]]){
                        for(var k=0; k<result[i].dates[dates[j]].length; k++){
                            var e = result[i].dates[dates[j]][k];
                            cell.append(createCellElement(dates[j], e));
                        }
                    }
                    row.append(cell);
                }
                table.append(row);
            }
            $('#gradebookTable').append(table);
        });
    }

    var collectFilterParams = function(){
        var params = {};
        params.from = $('#filterGradebookParamForm').find('#filterdatefrom').val();
        params.to = $('#filterGradebookParamForm').find('#filterdateto').val();
        if(showChild){
            params.childid = AUTOCOMPLETE_SEARCH_FIELD.getValue('gradebookchild');
        }
        else {
            params.childid = fixedChildId;
        }
        params.courseid = $('#filterGradebookParamForm').find('#filtercourse').val();
        params.teacherid = $('#filterGradebookParamForm').find('#filterteacher').val();
        params.scheduleid = (selectedChildrenGroupScheduleId != null) ? selectedChildrenGroupScheduleId : '';
        params.typeid = $('#filterGradebookParamForm').find('#filtertype').val();
        return params;
    }

    var createCellElement = function(date, e){
        var result = $('<div class="cellElement"></div>');
        if(new Date() > commonHelper.parseDate(date)){
            var visitSign = '';
            if(e.visited){
                visitSign = '&#10003;';
            }
            else if(e.notVisitedGoodReason){
                visitSign = '&#8776;';
            }
            else {
                visitSign = '&#10060;';
            }
            var statusLink = $('<div class="visit">' + visitSign + '</div>');
            statusLink.click(function(){
                if(e.visited){
                    commonHelper.callAjaxMethod('visits.htm', 'markAsNotVisitedWithReason', {subscriptionElementId: e.subscriptionElementId}, function (data) {
                        that.loadGradebook();
                    });
                }
                else if(e.notVisitedGoodReason){
                    commonHelper.callAjaxMethod('visits.htm', 'cancelNotVisitedWithReason', {subscriptionElementId: e.subscriptionElementId}, function (data) {
                        that.loadGradebook();
                    });
                }
                else {
                    commonHelper.callAjaxMethod('visits.htm', 'markAsVisited', {subscriptionElementId: e.subscriptionElementId}, function (data) {
                        that.loadGradebook();
                    });
                }
            });
            result.html(statusLink);
        }

        if(e.scores){
            for(var i=0; i<e.scores.length; i++){
                new function(score){
                    var type = score.type ? (' ' +  score.type) : '';
                    var scoreLink = $('<div class="editscore' + type + '">' + score.value + '</div>');
                    scoreLink.click(function(){
                        that.editScore(score.scoreId, score.subscriptionElementId);
                    });
                    result.append(scoreLink);
                }(e.scores[i]);
            }
        }

        var addLink = $('<div class="addscore"><img src="images/add.png"></div>');
        addLink.click(function(){
            that.addScore(e.subscriptionElementId);
        });
        result.append(addLink);

        return result;
    }

    that.addScore = function(subscriptionElementId){
        that.editScore(null, subscriptionElementId);
    }

    that.editScore = function(scoreId, subscriptionElementId){
        var params = {};
        if(scoreId){
            params['scoreElementId'] = scoreId;
        }
        commonHelper.callAjaxMethod('gradebook.htm', 'loadScoreElement', params, function (data) {

            if (!data.scoreElement) {
                data.scoreElement = {
                    subscriptionElement: {
                        id: subscriptionElementId
                    }
                }
            }

            var dialog = $('#scoreElementEditDialog');

            var references = {};
            references.types = data.typeList.rows;
            commonHelper.initReferenceSelect(dialog.find('#type'), references, 'type', 'typeid', 'title');

            dialog.directives({
                '.scoreElementId@value': 'scoreElement.id',
                '.subscriptionElementId@value': 'scoreElement.subscriptionElement.id',
                '.value@value': 'scoreElement.value',
                '.comment': 'scoreElement.comment'
            }).render(data);

            if(data.scoreElement.type){
                $('#scoreElementEditDialog').find('.type').val(data.scoreElement.type.id);
            }

            if(data.scoreElement.history){
                var table = $('#scoreElementEditDialog').find('#history table');
                table.empty();
                table.append('<tr><th>' + messages['gradebook.edit.author'] + '</th><th>' + messages['gradebook.edit.date'] + '</th><th>' + messages['gradebook.edit.value'] + '</th></tr>');
                for(var i=0; i<data.scoreElement.history.length; i++){
                    var h = data.scoreElement.history[i];
                    table.append('<tr><td>' + (h.author ? h.author.name : '') + '</td><td>' + h.created + '</td><td>' + h.value + '</td></tr>');
                }
                $('#scoreElementEditDialog').find('#history').show();
            }
            else {
                $('#scoreElementEditDialog').find('#history').hide();
            }
            
            var buttons = {}
            buttons['saveButton'] = {
                title: messages['common.save'],
                action: function () {
                    var params = REFERENCE.collectParams('scoreElementEditDialog');
                    var validate = function (params) {
                        var errors = [];
                        if (params.value == '' || parseInt(params.value) == 0) {
                            errors.push(messages['gradebook.edit.novalue']);
                        }
                        if(errors.length > 0){
                            $('#scoreElementEditDialog').find('.dialogMessages').html(errors.join('<br>'));
                            return false;
                        }
                        return true;
                    };
                    $('#scoreElementEditDialog').find('.dialogMessages').html('');
                    if (validate(params)) {
                        commonHelper.callAjaxMethod('gradebook.htm', 'saveScoreElement', {"objects": JSON.stringify(params)}, function (data) {
                            REFERENCE.closeEditReferenceDialog('scoreElementEditDialog');
                            that.loadGradebook();
                        });
                    }
                }
            }
            REFERENCE.openEditReferenceDialog('scoreElementEditDialog', {
                    buttons: buttons,
                    onClose: function () {}
                }
            );
        }, false, false, false);
    }

    that.downloadExcel = function () {
        if($('#filterGradebookParamForm').find('#filterdatefrom').val().length == 0 || $('#filterGradebookParamForm').find('#filterdateto').val().length == 0){
            commonHelper.showMessage(messages['gradebook.filter.dateerror']);
            return;
        }
        var params = collectFilterParams();
        var paramsString = '';
        for (var param in params) {
            paramsString += param + '=' + params[param] + '&';
        }

        window.location.assign("gradebook.htm?method=downloadGradebookAsExcel" + (paramsString ? '&' + paramsString : ''));
    }

    that.print = function () {
        if($('#filterGradebookParamForm').find('#filterdatefrom').val().length == 0 || $('#filterGradebookParamForm').find('#filterdateto').val().length == 0){
            commonHelper.showMessage(messages['gradebook.filter.dateerror']);
            return;
        }
        var params = collectFilterParams();
        commonHelper.callAjaxMethod('gradebook.htm', 'printGradebook', params, function (result) {
            if(result == true){
                commonHelper.showMessage(messages['gradebook.print']);
            }
            else {
                var paramsString = '';
                for (var param in params) {
                    paramsString += param + '=' + params[param] + '&';
                }
                commonHelper.openPdfPrintDialog('gradebook.htm?method=printGradebookFromClient' + (paramsString ? '&' + paramsString : ''));
            }
        });
    }

    that.setFixedChild = function(childId) {
        if(childId){
            fixedChildId = childId;
            $('#filterGradebookParamForm').show();
        }
        else {
            $('#filterGradebookParamForm').hide();
        }
        $('#gradebookTable').empty();
    }
}function schedulerMonth_helper(helper) {
    var that = this;
    var isInit = false;

    var filterType = 'typeall';

    var calculateCalendarHeight = function () {
        return $(window).height() - 250;
    };

    that.display = function () {
        if(!isInit){
            that.initFilter();
            this.initCalendar();
            isInit = true;
        }
    };

    that.changeOrganization = function(orgid){
        if(isInit) {
            that.initFilter();
            $('#monthcalendar').fullCalendar('refetchEvents');
        }
    };

    that.initFilter = function(){
        var filterPanel = $('#tab-scheduler-month');
        commonHelper.callAjaxMethod('scheduler.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.courseTypes = [
                {name: '', coursetypeid: ''}
            ].concat(result.courseTypeList.rows);
            references.rooms = [
                {title: '', roomid: ''}
            ].concat(result.roomList.rows);
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.teacherList.rows);
            commonHelper.initReferenceSelect(filterPanel.find('#filterteacher'), references, 'teacher', 'teacherid', 'name');
            commonHelper.initReferenceSelect(filterPanel.find('#filtercourse'), references, 'courseType', 'coursetypeid', 'name');
            commonHelper.initReferenceSelect(filterPanel.find('#filterroom'), references, 'room', 'roomid', 'title');
        });

        filterPanel.find('[name="filterteacher"]').live('change', function(){
            var teacherId = $(this).val();
            if(teacherId){
                filterPanel.find('#showteachertime').removeAttr("disabled");
            }
            else {
                filterPanel.find('#showteachertime').attr("disabled", true);
            }
            $('#monthcalendar').fullCalendar('refetchEvents');
        });
        filterPanel.find('#filtercourse').live('change', function(){
            $('#monthcalendar').fullCalendar('refetchEvents');
        });
        filterPanel.find('#filterroom').live('change', function(){
            $('#monthcalendar').fullCalendar('refetchEvents');
        });
        filterPanel.find('#showteachertime').change(function(){
            $('#monthcalendar').fullCalendar('refetchEvents');
        });
        filterPanel.find('#showteachertime').attr("disabled", true);
    }

    that.initCalendar = function(){
        ACTUAL_DAY_INFO_INSTANCE = ACTUAL_DAY_INFO(
            function () {
                return helper.currentBubbleDialog;
            },
            function () {
            },
            function () {
            },
            function (result) {
                $('#monthcalendar').fullCalendar('refetchEvents');
            },
            function (result) {
                $('#monthcalendar').fullCalendar('refetchEvents');
            },
            function (result) {
                $('#monthcalendar').fullCalendar('refetchEvents');
            }
        );

        $('#monthcalendar').fullCalendar({
            header: {left: 'today prev,next',
                center: 'title',
                right: ''
            },
            monthNames: [messages['common.month1'], messages['common.month2'], messages['common.month3'], messages['common.month4'], messages['common.month5'], messages['common.month6'], messages['common.month7'], messages['common.month8'], messages['common.month9'], messages['common.month10'], messages['common.month11'], messages['common.month12']],
            monthNamesShort: [messages['common.smonth1'], messages['common.smonth2'], messages['common.smonth3'], messages['common.smonth4'], messages['common.smonth5'], messages['common.smonth6'], messages['common.smonth7'], messages['common.smonth8'], messages['common.smonth9'], messages['common.smonth10'], messages['common.smonth11'], messages['common.smonth12']],
            dayNames: [messages['common.day7'], messages['common.day1'], messages['common.day2'], messages['common.day3'], messages['common.day4'], messages['common.day5'], messages['common.day6']],
            dayNamesShort: [messages['common.sday7'], messages['common.sday1'], messages['common.sday2'], messages['common.sday3'], messages['common.sday4'], messages['common.sday5'], messages['common.sday6']],
            buttonText: {
                today: messages['calendar.today']
            },
            theme: false,
            firstDay: 1,
            selectable: false,
            allDayText: messages['calendar.allday'],
            axisFormat: 'HH:mm',
            timeFormat: 'HH:mm',
            displayEventEnd: true,
            slotMinutes: 10,
            weekMode: 'liquid',
            height: calculateCalendarHeight(),
            windowResize: function () {
                $('#monthcalendar').fullCalendar('option', 'height', calculateCalendarHeight());
            },
            events: function (start, end, timezone, callback) {
                commonHelper.callAjaxMethod('scheduler.htm', 'loadEvents', collectFilterParams(), function (data) {
                    callback(data);
                }, false);
            },
            viewDisplay: function () {
                $('.fc-agenda-slots').parent().parent().scroll(function () {});
            },
            dayDblClick: function (date, allDay, jsEvent, view) {

            },
            beforeClearEvents: function () {

            },
            eventRender: function( event, element, view ) {
                var $title = element.find( '.fc-title' );
                $title.html( $title.text() );
            },
            eventClick: function (calEvent, jsEvent, view) {
                if($(jsEvent.target).prop("tagName") != 'IMG'){
                    helper.showEventInfo(calEvent.type, calEvent.id, $(jsEvent.currentTarget));
                }
            },
            eventMouseover: function (event, jsEvent, view) {
                $(jsEvent.currentTarget).addClass('hovered');
            },
            eventMouseout: function (event, jsEvent, view) {
                $(jsEvent.currentTarget).removeClass('hovered');
            }
        });
    }

    that.setFilterType = function(type){
        filterType = type;
        $('#monthcalendar').fullCalendar('refetchEvents');
    }

    that.downloadExcel = function () {
        var params = collectFilterParams();
        var paramsString = '';
        for (var param in params) {
            paramsString += param + '=' + params[param] + '&';
        }

        window.location.assign("scheduler.htm?method=downloadEventsAsExcel" + (paramsString ? '&' + paramsString : ''));
    }

    that.print = function () {
        var params = collectFilterParams();
        commonHelper.callAjaxMethod('scheduler.htm', 'printEvents', params, function (result) {
            if(result == true){
                commonHelper.showMessage(messages['scheduler.month']);
            }
            else {
                var paramsString = '';
                for (var param in params) {
                    paramsString += param + '=' + params[param] + '&';
                }
                commonHelper.openPdfPrintDialog('scheduler.htm?method=printEventsFromClient' + (paramsString ? '&' + paramsString : ''));
            }
        });
    }

    var collectFilterParams = function(){
        var view = $('#monthcalendar').fullCalendar('getView');
        var params = {};
        params.start = commonHelper.formatDate(view.start.toDate());
        params.end = commonHelper.formatDate(view.end.toDate());
        params.type = filterType;
        params.filterteacher = $('#tab-scheduler-month').find('#filterteacher').val();
        params.filtercourse = $('#tab-scheduler-month').find('#filtercourse').val();
        params.filterroom = $('#tab-scheduler-month').find('#filterroom').val();
        params.showteachertime = $('#tab-scheduler-month').find('[name="showteachertime"]:checked').val();
        return params;
    }

    return this;
}function schedulerReferences_helper(helper) {
    var that = this;

    var references = {};
    var elements = [];

    var workinghoursDataGrid = null;

    that.display = function () {
        that.loadPreferencesWorkinghours();
        that.initFilterPane();
        that.loadPreferencesTypesTable();
    };

    that.loadPreferencesTypesTable = function(){
        var colNames = [];
        colNames.push(messages['gradebook.references.types.title']);
        colNames.push(messages['gradebook.references.types.comment']);
        
        var colModels = [];
        colModels.push({name: 'title', index: 'title', formatter: 'string', editable: true, required: true, editoptions: {size: 45}});
        colModels.push({name: 'comment', index: 'comment', formatter: 'string', editable: true, required: false, sortable: false, edittype: "textarea", editoptions: {rows: "5", cols: "44"}});
        
        $('#preferencesTypesTable').jqGrid({
            caption: messages['gradebook.references.types'],
            url: "gradebook.htm?method=loadScoreTypes",
            datatype: "json",
            colNames: colNames,
            colModel: colModels,
            autowidth: true,
            height: "100%",
            jsonReader: { repeatitems: false, id: "typeid"},
            rowNum: 10,
            pager: '#preferencesTypesPager',
            sortname: 'typeid',
            viewrecords: true,
            sortorder: "desc",
            editurl: "gradebook.htm?method=saveScoreType"
        });

        $("#preferencesTypesTable").jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);

        if (!DEMO && !VIEWER) {
            $('#preferencesTypesTable').jqGrid('navGrid', '#preferencesTypesPager', {search: false}, //options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterEdit: true}, // edit options
                {width: 500, height: 470, reloadAfterSubmit: true, closeAfterAdd: true}, // add options
                {reloadAfterSubmit: true}, // del options
                {} // search options
            );
        }
    }

    that.initFilterPane = function () {
        commonHelper.setDatePicker($('#filterWorkinghoursParamForm').find('#workinghoursfilterdatefrom'));
        commonHelper.setDatePicker($('#filterWorkinghoursParamForm').find('#workinghoursfilterdateto'));

        commonHelper.callAjaxMethod('gradebook.htm', 'loadWorkinghours', {}, function (data) {
            var references = {};
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(data.teacherList.rows);
            references.rooms = [
                {title: '', roomid: ''}
            ].concat(data.roomList.rows);

            commonHelper.initReferenceSelect($('#filterWorkinghoursParamForm').find('#workinghoursfilterteacher'), references, 'teacher', 'teacherid', 'name');
            commonHelper.initReferenceSelect($('#filterWorkinghoursParamForm').find('#workinghoursfilterroom'), references, 'room', 'roomid', 'title');
        });
    };

    that.clearFilter = function () {
        $('#workinghoursfilterdatefrom').val('');
        $('#workinghoursfilterdateto').val('');
        $('#workinghoursfilterteacher').val('');
        $('#workinghoursfilterroom').val('');

        that.loadPreferencesWorkinghours();
    };

    that.loadPreferencesWorkinghours = function(){
        if(!workinghoursDataGrid){
            var colNames = [];
            colNames.push(messages['gradebook.references.workinghours.teacher']);
            colNames.push(messages['gradebook.references.workinghours.startdate']);
            colNames.push(messages['gradebook.references.workinghours.finishdate']);
            colNames.push('');

            var colModels = [];
            colModels.push({name: 'teacher', index: 'teacher', formatter: notNullFormatter});
            colModels.push({name: 'startdate', index: 'startdate', formatter: notNullFormatter});
            colModels.push({name: 'finishdate', index: 'finishdate', formatter: notNullFormatter});
            colModels.push({name: 'workinghoursid', index: 'workinghoursid', sortable: false, formatter: function (cellvalue, options, rowObject) {
                return '<a href="javascript:void(0)" class="paymentEditLink" onclick="currentPage.references.editWorkinghours(' + cellvalue + ')">' + messages['common.edit'] + '</a>';
            }});

            workinghoursDataGrid = $('#preferencesWorkinghoursTable').jqGrid({
                caption: messages['gradebook.references.workinghours'],
                datatype:loadWorkinghours,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#preferencesWorkinghoursPager',
                sortname: 'startDate', viewrecords: true, sortorder: "desc"
            });
            workinghoursDataGrid.jqGrid('setGridWidth', $('#bodyCell').width() / 2.1, true);
        }
        else {
            workinghoursDataGrid.setGridParam({
                page: 1
            });
            workinghoursDataGrid.trigger("reloadGrid");
        }
    }

    var loadWorkinghours = function (postdata) {
        $('#filterWorkinghoursParamForm').find('input, select').each(function(){
            postdata[$(this).attr('name')] = $(this).val() ? $(this).val() : '';
        });
        commonHelper.callAjaxMethod('gradebook.htm', 'loadWorkinghoursList',
            postdata, function (result) {
                workinghoursDataGrid.clearGridData(true);
                workinghoursDataGrid[0].addJSONData(result);
            }, true);
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    var updateWorkinghoursElementTable = function(){
        var table = $('#workinghoursEditDialog').find('#workinghoursElementsTable');
        table.empty();
        for(var i=0; i<elements.length; i++){
            var element = elements[i];
            var typeTitle = $('#workinghoursElementEditDialog').find('#type option[value=' + element.type + ']').text();
            var roomTitle = "";
            for(var j=0; j<references.rooms.length; j++){
                if(references.rooms[j].roomid == element.room) roomTitle = references.rooms[j].title;
            }
            table.append('<tr data-ind="' + i + '"><td>' + typeTitle + '</td><td>' + roomTitle + '</td><td>' + element.startTime + '</td><td>' + element.finishTime + '</td><td><a href="#" class="editWorkinghoursElementLink">' + messages['common.edit'] + '</a></td></tr>');
        }
        $('#workinghoursEditDialog').css('z-index',(commonHelper.getMaxZIndex() + 1));
    }

    $('.editWorkinghoursElementLink').live('click', function(){
        var i = $(this).closest('tr').attr('data-ind');
        that.editWorkinghoursElement($('#workinghoursEditDialog'), elements[i]);
    });

    that.addWorkinghours = function(){
        that.editWorkinghours();
    }

    that.editWorkinghours = function (workinghoursId) {
        var params = {};
        if(workinghoursId){
            params['workinghoursId'] = workinghoursId;
        }
        commonHelper.callAjaxMethod('gradebook.htm', 'loadWorkinghours', params, function (data) {

            if (!data.workinghours) {
                data.workinghours = {
                }
            }

            var workinghoursEditDialog = $('#workinghoursEditDialog');

            references.teachers = data.teacherList.rows;
            references.rooms = data.roomList.rows;
            commonHelper.initReferenceSelect(workinghoursEditDialog.find('#teacher'), references, 'teacher', 'teacherid', 'name');
            
            workinghoursEditDialog.directives({
                '.workinghoursId@value': 'workinghours.id'
            }).render(data);

            if(data.workinghours.teacher){
                $('#workinghoursEditDialog').find('.teacher').val(data.workinghours.teacher.id);
            }
            if(data.workinghours.startDate && data.workinghours.finishDate){
                $('#workinghoursEditDialog').find('.startDate').val(data.workinghours.startDate);
                $('#workinghoursEditDialog').find('.finishDate').val(data.workinghours.finishDate);
            }
            else {
                $('#workinghoursEditDialog').find('.startDate').val('');
                $('#workinghoursEditDialog').find('.finishDate').val('');
            }

            elements = [];
            if(data.workinghours.elements){
                for(var i=0; i<data.workinghours.elements.length; i++){
                    var e = data.workinghours.elements[i];
                    var element = {
                        type: e.type,
                        room: e.room.id,
                        startTime: e.startTime,
                        finishTime: e.finishTime
                    };
                    element.weekdays = [];
                    for(var j = 0; j < e.weekDays.length; j++){
                        element.weekdays.push(e.weekDays[j].value);
                    }
                    element.calendardays = [];
                    for(var j = 0; j < e.dates.length; j++){
                        element.calendardays.push(e.dates[j]);
                    }
                    elements.push(element);
                }
            }

            updateWorkinghoursElementTable();

            var buttons = {}
            buttons['saveButton'] = {
                title: messages['common.save'],
                action: function () {
                    var params = REFERENCE.collectParams('workinghoursEditDialog');
                    params.elements = elements;
                    var validate = function (params) {
                        var errors = [];
                        if (params.startDate == '' || params.finishDate == '') {
                            errors.push(messages['gradebook.references.workinghours.nodate']);
                        }
                        if (params.elements.length == 0){
                            errors.push(messages['gradebook.references.workinghours.noelements']);
                        }
                        if(errors.length > 0){
                            $('#workinghoursEditDialog').find('.dialogMessages').html(errors.join('<br>'));
                            return false;
                        }
                        return true;
                    };
                    $('#workinghoursEditDialog').find('.dialogMessages').html('');
                    if (validate(params)) {
                        commonHelper.callAjaxMethod('gradebook.htm', 'saveWorkinghours', {"objects": JSON.stringify(params)}, function (data) {
                            if (!data) {
                                commonHelper.showMessage(messages['gradebook.references.workinghours.saveerror']);
                            } else {
                                REFERENCE.closeEditReferenceDialog('workinghoursEditDialog');
                                that.loadPreferencesWorkinghours();
                            }
                        });
                    }
                }
            }
            REFERENCE.openEditReferenceDialog('workinghoursEditDialog', {
                    buttons: buttons,
                    onClose: function () {}
                }
            );

            commonHelper.setDatePicker($('#workinghoursEditDialog').find('#startDate'));
            commonHelper.setDatePicker($('#workinghoursEditDialog').find('#finishDate'));

        }, false, false, false);
    };

    that.addWorkinghoursElement = function(parentDialog){
        that.editWorkinghoursElement(parentDialog);
    }

    that.editWorkinghoursElement = function(parentDialog, elementObject){
        var workinghoursElementEditDialog = $('#workinghoursElementEditDialog');

        commonHelper.initReferenceSelect(workinghoursElementEditDialog.find('#room'), references, 'room', 'roomid', 'title');

        workinghoursElementEditDialog.find('#byweekday').hide();
        workinghoursElementEditDialog.find('#bycalendar').hide();
        workinghoursElementEditDialog.find('#type').change(function(){
            var type = $(this).val();
            if(type == 'BYWEEKDAY')
                workinghoursElementEditDialog.find('#byweekday').show();
            else
                workinghoursElementEditDialog.find('#byweekday').hide();
            if(type == 'BYCALENDAR')
                workinghoursElementEditDialog.find('#bycalendar').show();
            else
                workinghoursElementEditDialog.find('#bycalendar').hide();
        });

        var weekdays = [];
        var calendardays = [];
        if(elementObject) {
            workinghoursElementEditDialog.find('#type').val(elementObject.type);
            if (elementObject.type == 'BYWEEKDAY') workinghoursElementEditDialog.find('#byweekday').show();
            if (elementObject.type == 'BYCALENDAR') workinghoursElementEditDialog.find('#bycalendar').show();
            workinghoursElementEditDialog.find('#room').val(elementObject.room);
            workinghoursElementEditDialog.find('#startTime').val(elementObject.startTime);
            workinghoursElementEditDialog.find('#finishTime').val(elementObject.finishTime);
            weekdays = elementObject.weekdays;
            calendardays = elementObject.calendardays;
        }
        else {
            workinghoursElementEditDialog.find('#type').val('EVERYDAY');
            workinghoursElementEditDialog.find('#startTime').val('');
            workinghoursElementEditDialog.find('#finishTime').val('');
        }

        var updateWeekdays = function () {
            var shortNames = [];
            if(weekdays.indexOf('MONDAY') >= 0 ) shortNames.push(messages['common.sday1']);
            if(weekdays.indexOf('TUESDAY') >= 0 ) shortNames.push(messages['common.sday2']);
            if(weekdays.indexOf('WEDNESDAY') >= 0 ) shortNames.push(messages['common.sday3']);
            if(weekdays.indexOf('THURSDAY') >= 0 ) shortNames.push(messages['common.sday4']);
            if(weekdays.indexOf('FRIDAY') >= 0 ) shortNames.push(messages['common.sday5']);
            if(weekdays.indexOf('SATURDAY') >= 0 ) shortNames.push(messages['common.sday6']);
            if(weekdays.indexOf('SUNDAY') >= 0 ) shortNames.push(messages['common.sday7']);
            workinghoursElementEditDialog.find('#byweekday-result').text(shortNames.join(', '));
        };
        updateWeekdays();
        workinghoursElementEditDialog.find('#byweekday-button').unbind( "click" ).click(function(){
            var weekday = $(this).parent().find('#byweekday-select').val();
            if(weekdays.indexOf(weekday) == -1){
                weekdays.push(weekday);
                updateWeekdays();
            }
        });

        var updateCalendardays = function () {
            workinghoursElementEditDialog.find('#bycalendar-result').text(calendardays.join(', '));
        };
        updateCalendardays();
        workinghoursElementEditDialog.find('#bycalendar-button').unbind( "click" ).click(function(){
            var day = $(this).parent().find('#bycalendar-date').val();
            if(calendardays.indexOf(day) == -1){
                calendardays.push(day);
                updateCalendardays();
            }
        });

        var buttons = {}
        buttons['saveButton'] = {
            title: messages['common.save'],
            action: function () {
                var params = REFERENCE.collectParams('workinghoursElementEditDialog');
                params.weekdays = weekdays;
                params.calendardays = calendardays;
                var validate = function (params) {
                    var errors = [];
                    if (params.startTime == '' || params.finishTime == '') {
                        errors.push(messages['gradebook.references.workinghours.notime']);
                    }
                    if (params.type == 'BYWEEKDAY' && params.weekdays.length == 0){
                        errors.push(messages['gradebook.references.workinghours.noweekday']);
                    }
                    if (params.type == 'BYCALENDAR' && params.calendardays.length == 0){
                        errors.push(messages['gradebook.references.workinghours.nocalendarday']);
                    }
                    if(errors.length > 0){
                        $('#workinghoursElementEditDialog').find('.dialogMessages').html(errors.join('<br>'));
                        return false;
                    }
                    return true;
                };
                $('#workinghoursElementEditDialog').find('.dialogMessages').html('');
                if (validate(params)) {
                    var element = {};
                    if(elementObject) element = elementObject;
                    else elements.push(element);
                    element.type = params.type;
                    element.room = params.room;
                    element.startTime = params.startTime;
                    element.finishTime = params.finishTime;
                    element.weekdays = params.weekdays;
                    element.calendardays = params.calendardays;
                    updateWorkinghoursElementTable();
                    REFERENCE.closeEditReferenceDialog('workinghoursElementEditDialog');
                }
            }
        }
        REFERENCE.openEditReferenceDialog('workinghoursElementEditDialog', {
                buttons: buttons,
                onClose: function () {
                    var fixZ = commonHelper.getMaxZIndex() + 1;
                    parentDialog.css('z-index',fixZ);
                    window.setTimeout(function () {
                        parentDialog.css('z-index',fixZ);
                    }, 300);
                }
            }
        );
        
        commonHelper.setTimePicker($('#workinghoursElementEditDialog').find('#startTime'));
        commonHelper.setTimePicker($('#workinghoursElementEditDialog').find('#finishTime'));
        commonHelper.setDatePicker($('#workinghoursElementEditDialog').find('#bycalendar-date'));
    }
}function schedulerTasks_helper(helper) {
    var that = this;
    var isInit = false;

    var filterType = 'typeall';

    var calculateCalendarHeight = function () {
        return $(window).height() - 250;
    };

    that.display = function () {
        if(!isInit){
            that.initFilter();
            this.initCalendar();
            isInit = true;
        }
    };

    that.changeOrganization = function(orgid){
        if(isInit) {
            that.initFilter();
            $('#taskscalendar').fullCalendar('refetchEvents');
        }
    };

    that.initFilter = function(){
        var filterPanel = $('#tab-scheduler-tasks');
        commonHelper.callAjaxMethod('scheduler.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.teacherList.rows);
            commonHelper.initReferenceSelect(filterPanel.find('#filtertasksuser'), references, 'teacher', 'teacherid', 'name');
        });

        filterPanel.find('[name="filtertasksuser"]').live('change', function(){
            $('#taskscalendar').fullCalendar('refetchEvents');
        });
        filterPanel.find('#showbirthday').change(function(){
            $('#taskscalendar').fullCalendar('refetchEvents');
        });
        filterPanel.find('#showsubscriptionfinish').change(function(){
            $('#taskscalendar').fullCalendar('refetchEvents');
        });
    }

    that.initCalendar = function(){
        $('#taskscalendar').fullCalendar({
            header: {left: 'today prev,next',
                center: 'title',
                right: ''
            },
            monthNames: [messages['common.month1'], messages['common.month2'], messages['common.month3'], messages['common.month4'], messages['common.month5'], messages['common.month6'], messages['common.month7'], messages['common.month8'], messages['common.month9'], messages['common.month10'], messages['common.month11'], messages['common.month12']],
            monthNamesShort: [messages['common.smonth1'], messages['common.smonth2'], messages['common.smonth3'], messages['common.smonth4'], messages['common.smonth5'], messages['common.smonth6'], messages['common.smonth7'], messages['common.smonth8'], messages['common.smonth9'], messages['common.smonth10'], messages['common.smonth11'], messages['common.smonth12']],
            dayNames: [messages['common.day7'], messages['common.day1'], messages['common.day2'], messages['common.day3'], messages['common.day4'], messages['common.day5'], messages['common.day6']],
            dayNamesShort: [messages['common.sday7'], messages['common.sday1'], messages['common.sday2'], messages['common.sday3'], messages['common.sday4'], messages['common.sday5'], messages['common.sday6']],
            buttonText: {
                today: messages['calendar.today']
            },
            theme: false,
            firstDay: 1,
            allDayText: messages['calendar.allday'],
            axisFormat: 'HH:mm',
            timeFormat: 'HH:mm',
            displayEventEnd: true,
            slotMinutes: 10,
            weekMode: 'liquid',
            height: calculateCalendarHeight(),
            windowResize: function () {
                $('#monthcalendar').fullCalendar('option', 'height', calculateCalendarHeight());
            },
            events: function (start, end, timezone, callback) {
                var params = {};
                params.start = commonHelper.formatDate(start.toDate());
                params.end = commonHelper.formatDate(end.toDate());
                params.type = filterType;
                params.filteruser = $('#tab-scheduler-tasks').find('#filtertasksuser').val();
                params.showbirthday = $('#tab-scheduler-tasks').find('[name="showbirthday"]:checked').val();
                params.showsubscriptionfinish = $('#tab-scheduler-tasks').find('[name="showsubscriptionfinish"]:checked').val();
                commonHelper.callAjaxMethod('scheduler.htm', 'loadTasks', params, function (data) {
                    callback(data);
                }, false);
            },
            viewDisplay: function () {
                $('.fc-agenda-slots').parent().parent().scroll(function () {});
            },
            dayDblClick: function (date, allDay, jsEvent, view) {

            },
            beforeClearEvents: function () {

            },
            eventRender: function( event, element, view ) {
                var $title = element.find( '.fc-title' );
                $title.html( $title.text() );
            },
            eventClick: function (calEvent, jsEvent, view) {
                helper.showEventInfo(calEvent.type, calEvent.id, $(jsEvent.currentTarget));
            },
            eventMouseover: function (event, jsEvent, view) {
                $(jsEvent.currentTarget).addClass('hovered');
            },
            eventMouseout: function (event, jsEvent, view) {
                $(jsEvent.currentTarget).removeClass('hovered');
            },
            selectable: true,
            select: function(start, end, event) {
                var date = commonHelper.formatDate(start.toDate());
                commonHelper.checkFeature('MARKETING', function () {
                    $('#menuTaskTypeDiv').css('z-index', commonHelper.getMaxZIndex() + 1);
                    $('#menuTaskTypeDiv').css('left', (event.clientX) + 'px');
                    $('#menuTaskTypeDiv').css('top', (event.clientY) + 'px');
                    $('#menuTaskTypeDiv').show(10, 'linear', function () {
                        $('html').one('click', function () {
                            $('#menuTaskTypeDiv').hide();
                        });
                        $('#menuTaskTypeDiv').find('a').one('click', function(){
                            if($(this).hasClass('addtask-client')){
                                DIALOGS.taskEditDialog(null, null, null, null, false, true, function (data) {
                                    $('#taskscalendar').fullCalendar('refetchEvents');
                                }, null, null, {date:date});
                            }
                            else if($(this).hasClass('addtask-request')){
                                DIALOGS.taskEditDialog(null, null, -1, null, false, true, function (data) {
                                    $('#taskscalendar').fullCalendar('refetchEvents');
                                }, null, null, {date:date});
                            }
                        });
                    });
                }, function () {
                    DIALOGS.taskEditDialog(null, null, null, null, false, true, function (data) {
                        $('#taskscalendar').fullCalendar('refetchEvents');
                    }, null, null, {date:date});
                });
            }
        });
    }

    that.setFilterType = function(type){
        filterType = type;
        $('#taskscalendar').fullCalendar('refetchEvents');
    }

    return this;
}function schedulerWeek_helper(helper) {
    var that = this;
    var calendar;
    var scheduleCalendarControlPanel;
    var schedulesData;
    var dayInfoDialog;
    var schedulesModificationData = {
        elements: []
    };
    var scheduleElementId = 0;
    var isWeekInit = false;

    var filterType = 'typeall';

    that.display = function () {
        if(!isWeekInit){
            that.initFilter();
            that.initCalendar();
            isWeekInit = true;
        }
        that.refreshCalendar();
    };

    that.changeOrganization = function(orgid){
        if(isWeekInit) {
            that.initFilter();
            that.refreshCalendar();
        }
    }

    that.initFilter = function(){
        var filterPanel = $('#tab-scheduler-week');
        commonHelper.callAjaxMethod('scheduler.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.courseTypes = [
                {name: '', coursetypeid: ''}
            ].concat(result.courseTypeList.rows);
            references.rooms = [
                {title: '', roomid: ''}
            ].concat(result.roomList.rows);
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.teacherList.rows);
            commonHelper.initReferenceSelect(filterPanel.find('#filterweekteacher'), references, 'teacher', 'teacherid', 'name');
        });

        filterPanel.find('[name="filterweekteacher"]').live('change', function(){
            var teacherId = $(this).val();
            if(teacherId){
                filterPanel.find('#showweekteachertime').removeAttr("disabled");
            }
            else {
                filterPanel.find('#showweekteachertime').attr("disabled", true);
            }
            that.refreshCalendar();
        });
        filterPanel.find('#showweekteachertime').change(function(){
            that.refreshCalendar();
        });
        filterPanel.find('#showweekteachertime').attr("disabled", true);
    }

    that.initCalendar = function () {
        calendar = $('#scheduleCalendar');
        scheduleCalendarControlPanel = $('.scheduleCalendarControlPanel');

        if ($.browser.msie && ($.browser.version == '6.0' || $.browser.version == '7.0' || $.browser.version == '8.0')) {
            calendar.html(messages['schedule.schedulecalendar.ieerror']);
        } else {
            commonHelper.setDatePicker(scheduleCalendarControlPanel.find('.weekDayPicker'), that.refreshCalendar);
            scheduleCalendarControlPanel.find('.weekDayPicker').datepicker("setDate", commonHelper.formatDate(new Date()));


            window.onscroll = function (event) {
                that.eventCallbacks.onWindowScroll(event);
            };

            if (window.addEventListener)  // W3C DOM
                window.addEventListener('resize', recalculateElementsPosition, false);
            else if (window.attachEvent) { // IE DOM
                window.attachEvent("onresize", recalculateElementsPosition);
            }

            scheduleCalendarControlPanel.show().dialog({
                title: messages['schedule.schedulecalendar.weekdaypicker'],
                dialogClass: "noClose",
                zIndex: commonHelper.getMaxZIndex(),
                width: 600,
                height: 350,
                closeOnEscape: false,
                autoOpen: false
            });
            $('.controlDiv').focus();

            var controlDiv = calendar.find('.controlDiv');

            controlDiv.css('position', 'fixed');
            controlDiv.css('top', window.innerHeight - 70);
            controlDiv.css('left', window.innerWidth - 220);
        }
    };

    that.showControlDialog = function () {
        scheduleCalendarControlPanel.dialog({zIndex: commonHelper.getMaxZIndex(), position: { my: "center", at: "center", of: window }}).dialog('open');
    };

    that.destroyControlDialog = function () {
        scheduleCalendarControlPanel.dialog().dialog('close');
    };

    that.prevWeek = function () {
        var weekDay = scheduleCalendarControlPanel.find('.weekDayPicker');
        var date = weekDay.datepicker("getDate");
        date.setDate(date.getDate() - 7);
        scheduleCalendarControlPanel.find('.weekDayPicker').datepicker("setDate", commonHelper.formatDate(date));
        that.refreshCalendar();
    };

    that.nextWeek = function () {
        var weekDay = scheduleCalendarControlPanel.find('.weekDayPicker');
        var date = weekDay.datepicker("getDate");
        date.setDate(date.getDate() + 7);
        scheduleCalendarControlPanel.find('.weekDayPicker').datepicker("setDate", commonHelper.formatDate(date));
        that.refreshCalendar();
    };

    that.deleteNewScheduleElements = function () {
        $('.newScheduleElements').children().filter(':not(.template)').remove();
        $('.notSavedTimeElement').removeClass('notSavedTimeElement');
        $.each(schedulesModificationData.elements, function (index, element) {
            if (element.id.startsWith('new-schedule-element')) {
                $('#event-' + element.id).remove();
            }
        });

        schedulesModificationData.elements = [];
        that.destroyControlDialog();
        recalculateElementsPosition();
    };

    that.closeScheduleElementsDialog = function () {
        that.destroyControlDialog();
    };

    that.createSchedule = function () {
        var currentTeacher = null;
        var currentAdditionalTeacher = null;
        var currentCourse = null;
        var differentTeachersOrCourses = false;
        var differentElementTypes = false;
        var currentElementType = null;

        $.each(schedulesModificationData.elements, function (index, element) {
            differentTeachersOrCourses = differentTeachersOrCourses || (currentTeacher !== null && element.teacher.teacherid != currentTeacher.teacherid);
            differentTeachersOrCourses = differentTeachersOrCourses || (currentAdditionalTeacher !== null && element.additionalTeacher.teacherid != currentAdditionalTeacher.teacherid);
            differentTeachersOrCourses = differentTeachersOrCourses || (currentCourse !== null && element.courseType.coursetypeid != currentCourse.coursetypeid);
            differentElementTypes = differentElementTypes || (currentElementType != null && element.timeElementType != currentElementType);
            currentTeacher = element.teacher;
            currentAdditionalTeacher = element.additionalTeacher;
            currentCourse = element.courseType;
            currentElementType = element.timeElementType;
        });

        if (differentElementTypes) {
            commonHelper.showError(messages['schedule.schedulecalendar.diffetenttypes']);
            return;
        }

        if (differentTeachersOrCourses) {
            commonHelper.showError(messages['schedule.schedulecalendar.differentteachers']);
        }

        if (!differentTeachersOrCourses && !differentElementTypes) {
            if (currentElementType == 'eventInput') {
                commonHelper.callAjaxMethod('settings.htm', 'saveEventDays', {objects: JSON.stringify({elements: schedulesModificationData.elements})}, function (data) {
                    $('.newScheduleElements').children().filter(':not(.template)').remove();
                    that.destroyControlDialog();
                    schedulesModificationData.elements = [];
                    that.refreshCalendar();
                })
            } else {
                DIALOGS.scheduleDialogs.openSimpleScheduleDialog('', {
                    orgid: helper.currentOrgId,
                    teacher: currentTeacher,
                    additionalTeacher: currentAdditionalTeacher,
                    elements: schedulesModificationData.elements,
                    courseType: currentCourse
                }, function (response) {
                    $('.newScheduleElements').children().filter(':not(.template)').remove();
                    that.destroyControlDialog();
                    schedulesModificationData.elements = [];
                    that.refreshCalendar();
                });
            }
        }

    };

    that.refreshCalendar = function () {
        commonHelper.callAjaxMethod('scheduler.htm', 'loadWeekEvents', collectFilterWeekParams(), function (data) {
            schedulesData = data;
            $('.scheduleCalendarLoading').show();
            $('#eventCourseInput').children(null).remove();
            $('<option>').appendTo($('#eventCourseInput'));
            $('#eventCourseInput').directives({
                'option': {
                    'course <- courses': {
                        '.': 'course.name',
                        '@value': 'course.coursetypeid'
                    }
                }
            }).render({'courses': schedulesData.courses});


            $('#eventTeacherInput').children(null).remove();
            $('<option>').appendTo($('#eventTeacherInput'));
            $('#eventTeacherInput').directives({
                'option': {
                    'teacher <- teachers': {
                        '.': 'teacher.name',
                        '@value': 'teacher.teacherid'
                    }
                }
            }).render({'teachers': schedulesData.teachers});

            $('#eventAdditionalTeacherInput').children(null).remove();
            $('<option>').appendTo($('#eventAdditionalTeacherInput'));
            $('#eventAdditionalTeacherInput').directives({
                'option': {
                    'teacher <- additionalteachers': {
                        '.': 'teacher.name',
                        '@value': 'teacher.teacherid'
                    }
                }
            }).render({'additionalteachers': [{name:'',teacherid:''}].concat(schedulesData.teachers)});

            openProgressImage();
            buildScheduleCalendar();
            closeProgressImage();
            $('.scheduleCalendarLoading').hide();
        }, true, true);
    };

    that.addModifiedTimeEventElement = function (eventElement) {
        schedulesModificationData.elements.push(eventElement);

        var elementTemplate = $('.newScheduleElements .template');
        var scheduleElement = elementTemplate.clone().removeClass('template').show();
        scheduleElement.find('.course').html(eventElement.courseType.name);
        scheduleElement.find('.teacher').html(eventElement.teacher.name + ((eventElement.additionalTeacher.name != '')?', ' + eventElement.additionalTeacher.name:''));
        scheduleElement.find('.time').html(commonHelper.timeObjectToString(eventElement.startTime) + '-' + commonHelper.timeObjectToString(eventElement.finishTime));
        scheduleElement.find('.room').html(eventElement.room.title);
        scheduleElement.find('.day').html(eventElement.day.title);
        scheduleElement.find('.deleteLink').click(function () {
            var newElements = [];
            $.each(schedulesModificationData.elements, function (index, element) {
                if (element != eventElement) {
                    newElements.push(element);
                } else {
                    if (element.id.startsWith('new-schedule-element')) {
                        $('#event-' + element.id).remove();
                    }
                }
            });
            schedulesModificationData.elements = newElements;
            scheduleElement.remove();
        });
        scheduleElement.appendTo($('.newScheduleElements'));
    };

    var buildScheduleCalendar = function () {
        var roomsInfo = buildRoomsHeader();

        //var start = new Date();
        buildDays();
        //if (console) console.log('buildDays ' + (new Date().getTime() - start.getTime()));
        calendar.css('width', '');
        if (roomsInfo.roomWidth < 250) {
            calendar.css('width', 250 * roomsInfo.roomCount);
            recalculateElementsPosition();
        }

        //if (console) console.log('buildScheduleCalendar ' + (new Date().getTime() - start.getTime()));
    };

    var buildRoomsHeader = function () {
        var calendarTable = calendar.find('.scheduleCalendarTable');
        var roomTemplate = calendarTable.find('thead .roomHeader.template');
        var roomLegendTemplate = calendar.find('.roomTitle.template');

        calendarTable.parent().hover(null, that.eventCallbacks.calendarTableContainerHoverOff);

        var legendEmptyCell = calendar.find('.legendEmptyCell');
        var emptyCell = calendarTable.find('.emptyCell');

        roomLegendTemplate.parent().children().filter(':not(.template)').remove();
        roomTemplate.parent().children().filter(':not(.template)').remove();
        var roomWidth = 0;

        $.each(schedulesData.rooms, function (index, element) {
            var room = roomTemplate.clone().removeClass('template').show();
            var roomLegend = roomLegendTemplate.clone().removeClass('template').show();

            room.appendTo(roomTemplate.parent());
            roomLegend.appendTo(roomLegendTemplate.parent());
            room.css('width', 95 / schedulesData.rooms.length + '%');
            roomWidth = room.width();

            roomLegend.html(element.title);
            roomLegend.css('width', roomWidth + 'px');

        });
        legendEmptyCell.css('width', emptyCell.width() + 'px');

        return {roomWidth: roomWidth, roomCount: schedulesData.rooms.length};
    };

    var buildDays = function () {
        var calendarTable = calendar.find('.scheduleCalendarTable');
        var dayTemplate = calendarTable.find('tbody .day.template');
        var daySeparatorTemplate = calendarTable.find('tbody .daySeparator.template');
        var container = dayTemplate.parent();
        container.children().filter(':not(.template)').remove();
        calendar.find('.scheduleCalendarAbsoluteElements').children().remove();
        $.each(schedulesData.daysData, function (index, day) {
            var dayRow = dayTemplate.clone().removeClass('template').show();
            dayRow.attr('id', 'day-' + day.dateKey);
            dayRow.appendTo(container);

            //var start = new Date();
            buildDay(dayRow, calendar, day);
            //if (console) console.log('buildDay ' + (new Date().getTime() - start.getTime()));

            var dayRowSeparator = daySeparatorTemplate.clone().removeClass('template').show();
            dayRowSeparator.find('td').attr('colspan', schedulesData.rooms.length + 1);
            dayRowSeparator.appendTo(container);

        });
        recalculateElementsPosition();

    };

    var recalculateElementsPosition = function () {
        if (calendar && schedulesData) {
            var container = calendar.find('.scheduleCalendarTable>tbody');
            var calendarAbsoluteElements = calendar.find('.scheduleCalendarAbsoluteElements');

            var containerInfo = {};

            containerInfo.dayRoomInfoWidth = $(container.find('.roomInfo')[2]).width();
            containerInfo.firstTitleElement = $(container.find('.timeTitle:not(.template)')[0]);
            containerInfo.firstTitleElementWidth = containerInfo.firstTitleElement.width();
            containerInfo.pixelsInStep = $(container.find('.timeTitle:not(.template)')[0]).height();

            var standardFirstElementInfoPosition = containerInfo.firstTitleElement.offset();

            $.each(schedulesData.daysData, function (index, day) {
                var currentRoomPosition = 0;
                containerInfo.container = container.find('[id=day-' + day.dateKey + ']');
                var dayOffset = containerInfo.container.offset();

                $.each(schedulesData.rooms, function (index, _roomInfo) {
                    $.each(day.rooms, function (roomId, roomData) {
                        var roomInfo;
                        if (_roomInfo.roomid == roomId) {
                            roomInfo = _roomInfo;
                            roomInfo.id = roomInfo.roomid;

                            containerInfo.firstTitleElementOffset = {left: currentRoomPosition + standardFirstElementInfoPosition.left, top: dayOffset.top};
                            currentRoomPosition += containerInfo.dayRoomInfoWidth;

                            var timeTitleObjects = prepareTimeTitleRecalculationInfo(containerInfo, calendarAbsoluteElements, day, roomId);

                            $.each(timeTitleObjects.timeRows, function (index, row) {
                                $(row).data('fillingEvent', null);
                                $(row).data('date', day.date);
                            });

                            if (roomData.events) {
                                $.each(roomData.events, function (index, event) {
                                    recalculateEventPosition(event, timeTitleObjects);
                                });
                            }
                        }
                    });
                });


            });
        }
    };

    var prepareTimeTitleRecalculationInfo = function (containerInfo, calendarAbsoluteElements, calendarDayInfo, roomId) {
        var dayRow = containerInfo.container;

        var startTime = commonHelper.timeToMinutes(calendarDayInfo.minTime);
        var timeStep = htmlElementsGenerator.calculateTimeStep(calendarDayInfo);

        if (timeStep == 0) {
            alert(messages['schedule.schedulecalendar.calendarerror']);
        }

        var dayRoomInfo = dayRow.find('[id=day-' + calendarDayInfo.dateKey + '-room-' + roomId + ']');
        var firstTitleElement = $(dayRoomInfo.find('.timeTitle:not(.template)')[0]);

        return {
            calendarAbsoluteElements: calendarAbsoluteElements,
            dayRoomInfo: dayRoomInfo,
            dayRoomInfoWidth: containerInfo.dayRoomInfoWidth,
            timeTitles: dayRoomInfo.find('.timeTitle:not(.template)'),
            timeRows: dayRoomInfo.find('.timeRow:not(.template)'),
            firstTimeTitle: firstTitleElement,
            firstElementPosition: containerInfo.firstTitleElementOffset,
            firstElementWidth: containerInfo.firstTitleElementWidth,
            pixelsInStep: containerInfo.pixelsInStep,
            startTime: startTime,
            timeStep: timeStep
        };
    };

    var generateAndRecalculateEvent = function (event, day, room) {
        var container = calendar.find('.scheduleCalendarTable>tbody');
        var containerInfo = {};
        containerInfo.container = container;

        var dayRoomInfo = container.find('[id=day-' + day.dateKey + '-room-' + room.id + ']');

        containerInfo.dayRoomInfoWidth = dayRoomInfo.width();
        containerInfo.firstTitleElement = $(dayRoomInfo.find('.timeTitle:not(.template)')[0]);
        containerInfo.firstTitleElementWidth = containerInfo.firstTitleElement.width();
        containerInfo.pixelsInStep = $(dayRoomInfo.find('.timeTitle:not(.template)')[0]).height();
        containerInfo.firstTitleElementOffset = containerInfo.firstTitleElement.offset();

        var recalculateInfo = prepareTimeTitleRecalculationInfo(containerInfo, calendar.find('.scheduleCalendarAbsoluteElements'), day, room.roomid);
        generateEvent(event, true).appendTo(recalculateInfo.calendarAbsoluteElements);
        var start = new Date();
        recalculateEventPosition(event, recalculateInfo);
        //if (console) console.log('generateAndRecalculateEvent ' + (new Date().getTime() - start.getTime()));
    };

    var recalculateEventPosition = function (event, timeTitleObjects) {
        var start = new Date();

        var firstElementPosition = timeTitleObjects.firstElementPosition;
        var lessonInfo = timeTitleObjects.calendarAbsoluteElements.find('.lessonInfo[id="event-' + event.id + '"]');
        lessonInfo.data('event', event);

        //left y
        var eventStartStepsIndex = Math.floor((commonHelper.timeToMinutes(event.startTime) - timeTitleObjects.startTime) / timeTitleObjects.timeStep);
        var eventStartPixels = timeTitleObjects.pixelsInStep * ((commonHelper.timeToMinutes(event.startTime) - timeTitleObjects.startTime) % timeTitleObjects.timeStep / timeTitleObjects.timeStep);

        var eventStart = Math.floor(firstElementPosition.top + (eventStartStepsIndex >= 0 ? eventStartStepsIndex : 0) * timeTitleObjects.pixelsInStep + eventStartPixels);

        //height
        var eventFinishStepsIndex = Math.floor((commonHelper.timeToMinutes(event.finishTime) - timeTitleObjects.startTime) / timeTitleObjects.timeStep);
        var eventFinishPixels = timeTitleObjects.pixelsInStep * ((commonHelper.timeToMinutes(event.finishTime) - timeTitleObjects.startTime) % timeTitleObjects.timeStep / timeTitleObjects.timeStep);

        var eventFinish = Math.floor(firstElementPosition.top + (eventFinishStepsIndex < $(timeTitleObjects.timeTitles).length ? eventFinishStepsIndex : $(timeTitleObjects.timeTitles).length - 1) * timeTitleObjects.pixelsInStep + eventFinishPixels) + (eventFinishStepsIndex < $(timeTitleObjects.timeTitles).length ? 0 : timeTitleObjects.pixelsInStep);

        var lessonInfoMargin = 5;
        var start1 = new Date();
        lessonInfo.offset({left: firstElementPosition.left + timeTitleObjects.firstElementWidth + lessonInfoMargin, top: eventStart});
        //if (console) console.log('part1 offset ' + (new Date().getTime() - start1.getTime()));
        var start2 = new Date();
        lessonInfo.width(timeTitleObjects.dayRoomInfoWidth - timeTitleObjects.firstElementWidth - 2 * lessonInfoMargin);
        //if (console) console.log('part2 width ' + (new Date().getTime() - start2.getTime()));
        lessonInfo.height(eventFinish - eventStart - 2);
        for (var i = eventStartStepsIndex; i <= eventFinishStepsIndex; i++) {
            var timeTitleRow = timeTitleObjects.timeRows[i];
            if (timeTitleRow) {
                $(timeTitleRow).data('fillingEvent', lessonInfo);
            }
        }
    };

    var buildDay = function (dayRow, calendar, day) {
        var start = new Date();
        dayRow = dayRow.directives({
            '.date': 'date',
            '.weekDay': 'weekDay.title'
        }).render(day);
        var dayInfoTemplate = dayRow.find('.roomInfo.template');

        var timeStep = htmlElementsGenerator.calculateTimeStep(day);

        dayRow.data('timeStep', timeStep);

        if (timeStep == 0) {
            alert(messages['schedule.schedulecalendar.calendarerror']);
        }

        var timeRowTemplate = dayInfoTemplate.find('.timeRow.template');
        var timeTitleRows = generateTimeTitles(timeRowTemplate, day, timeStep);
        var calendarAbsoluteElements = calendar.find('.scheduleCalendarAbsoluteElements');
        var preparedDayInfoTemplate = dayInfoTemplate.clone().removeClass('template').show();
        preparedDayInfoTemplate.hover(null, that.eventCallbacks.calendarTableContainerHoverOff);
        $.each(timeTitleRows, function (index, item) {
            item.clone(true).appendTo(preparedDayInfoTemplate);
        });

        $.each(schedulesData.rooms, function (index, _roomInfo) {
            $.each(day.rooms, function (roomId, roomData) {
                var roomInfo;
                if (_roomInfo.roomid == roomId) {
                    roomInfo = _roomInfo;
                    roomInfo.id = roomInfo.roomid;

                    //var start1 = new Date();
                    var dayRoomInfo = preparedDayInfoTemplate.clone(true);
                    //if (console) console.log('timeTitleRows room ' + (new Date().getTime() - start1.getTime()));

                    dayRoomInfo.attr('id', 'day-' + day.dateKey + '-room-' + roomId);
                    dayRoomInfo.data('dayRoomInfo', {day: day, room: roomInfo});
                    dayRoomInfo.appendTo(dayRow);


                    if (roomData.events) {
                        $.each(roomData.events, function (index, event) {
                            generateEvent(event).appendTo(calendarAbsoluteElements);
                        });
                    }
                }
            });

        });
    };

    var generateEvent = function (eventData, isNewEvent) {
        var lessonInfo = calendar.find('.lessonInfo.template').clone().removeClass('template').show();
        if (isNewEvent) {
            lessonInfo.addClass('notSavedTimeElement');
        }

        lessonInfo.css('position', 'absolute');
        lessonInfo.attr('id', 'event-' + eventData.id);
        lessonInfo.attr('currentDate', eventData.currentDate);
        lessonInfo.attr('startTime', commonHelper.timeObjectToString(eventData.startTime));

        var renderedLessonInfo;

        if(eventData.type == 'teacher'){
            renderedLessonInfo = lessonInfo;
            renderedLessonInfo.addClass('typeteacher');
            renderedLessonInfo.find('.icons').remove();
        }
        else {
            lessonInfo.attr('scheduleId', eventData.scheduleId);

            renderedLessonInfo = lessonInfo.directives({
                '.title': function (context) {
                    return context.context.courseType.name.length < 7 * 20 ? context.context.courseType.name : context.context.courseType.name.substring(0, 7 * 20) + '...';
                },
                '.teacher': function (context) {
                    var result = context.context.teacher.name;
                    if(context.context.additionalTeacher && context.context.additionalTeacher.name.length > 0){
                        result += ', ' + context.context.additionalTeacher.name;
                    }
                    return result.length < 7 * 20 ? result : result.substring(0, 7 * 20) + '...';
                },
                '.lessonCounts': '(<abbr title="'+messages['scheduler.week.tooltip.childcount']+'">#{childCount}</abbr>)(<abbr title="'+messages['scheduler.week.tooltip.reservation']+'">#{reservationCount}</abbr>)(<abbr title="'+messages['scheduler.week.tooltip.visited']+'">#{visitedCount}</abbr>)'

            }).render(eventData);

            var date = eventData.currentDate.split('/');
            renderedLessonInfo.find('.icons a').attr('data-scheduleid', eventData.scheduleId).attr('data-date', date[0] + '/' + date[1] + '/' + date[2]);

            if(eventData.scheduleType && eventData.scheduleType == 'eventschedule'){
                renderedLessonInfo.addClass('typeevent');
            }
            if(eventData.childCount == 0){
                renderedLessonInfo.addClass('typenorecord');
            }

            renderedLessonInfo.hover(that.eventCallbacks.lessonInfoHoverOn, null);
            renderedLessonInfo.mousedown(that.eventCallbacks.stopDragging);

            renderedLessonInfo.click(function(e) {
                if($(e.target).prop("tagName") != 'IMG'){
                    if(eventData.actualDayId){
                        helper.showEventInfo('subscriptions', 'subscription-' + eventData.actualDayId, $(this));
                    }
                    else if(eventData.scheduleElementId){
                        helper.showEventInfo('subscriptions', 'scheduleelement--' + eventData.scheduleElementId + '-' + eventData.currentDate, $(this));
                    }
                }
            });
        }

        return renderedLessonInfo;
    };

    var generateTimeTitles = function (timeRowTemplate, day, timeStep) {
        var startTime = commonHelper.timeToMinutes(day.minTime);
        var finishTime = commonHelper.timeToMinutes(day.maxTime);

        var preparedTemplate = timeRowTemplate.clone();
        preparedTemplate.removeClass('template').show();
        preparedTemplate.mousedown(that.eventCallbacks.selectTimeMouseDown);
        preparedTemplate.mouseup(that.eventCallbacks.selectTimeMouseUp);
        preparedTemplate.mouseover(that.eventCallbacks.selectTimeMouseOver);
        preparedTemplate.hover(that.eventCallbacks.timeRowHoverOn, that.eventCallbacks.timeRowHoverOff);

        var result = [];
        var rowIndex = 0;
        for (var currentTime = startTime; currentTime <= finishTime; currentTime += timeStep) {
            var timeRow = preparedTemplate.clone(true);

            var hour = Math.floor(currentTime / 60);
            var minutes = currentTime - hour * 60;

            var time = (hour.toString().length == 1 ? '0' + hour : hour) + ':' + (minutes.toString().length == 1 ? '0' + minutes : minutes);
            timeRow.attr('timeRow-id', time);
            timeRow.find('.timeTitle').removeClass('template').find('.timeTitleText').html(time);

            timeRow.addClass(rowIndex++ % 2 == 1 ? 'evenRow2' : 'oddRow2');

            result.push(timeRow);
        }
        return result;
    };


    var htmlElementsGenerator = new function () {
        this.calculateTimeStep = function (day) {
            var min = Math.round(day.minDuration / 2);
            if (min == 0) {
                return 60;
            }
            var step = Math.floor(min / 10) * 10;
            if (step == 0) {
                return 5;
            }

            return step;
        };
    };

    that.eventCallbacks = new function () {
        var selectionParams = null;
        var timeElementEditor = null;

        var stopTimeSelection = function (source, lastRow) {
            if (selectionParams) {
                timeElementEditor = function () {
                    var thatEditor = this;
                    thatEditor.selectedParams = selectionParams;
                    thatEditor.selectedTime = selectTimeElements(selectionParams.firstSelectedRow, lastRow);
                    thatEditor.day = selectionParams.day;
                    thatEditor.room = selectionParams.room;
                    thatEditor.date = lastRow.data('date');
                    thatEditor.show = function () {
                        $('.timeElementEditor').overlay({
                            oneInstance: false,
                            fixed: false,
                            mask: {
                                color: '#fff',
                                loadSpeed: 0,
                                opacity: 0.5,
                                zIndex: commonHelper.getMaxZIndex()
                            },
                            closeOnClick: false,
                            onBeforeLoad: function () {

                                $('.timeElementEditor').find('.timeElementFrom').val(commonHelper.timeObjectToString(thatEditor.selectedTime.startTime));
                                $('.timeElementEditor').find('.timeElementTo').val(commonHelper.timeObjectToString(thatEditor.selectedTime.finishTime));
                                $('.timeElementEditor').find('.timeElementDay').html(thatEditor.day.weekDay.title);
                                $('.timeElementEditor').find('.timeElementRoom').html(thatEditor.room.title);

                                commonHelper.generateTimepickers($('.timeElementEditor').find('.timeElementFrom'), $('.timeElementEditor').find('.timeElementTo'), true);

                            },
                            onBeforeClose: function () {
                                $('.selectedTimeRow').removeClass('selectedTimeRow');
                                $('.selectingTimeRow').removeClass('selectingTimeRow');
                            }
                        });
                        $('.timeElementEditor').overlay().load();
                    };

                    thatEditor.getSelectedCourse = function () {
                        return $('.timeElementEditor').find('#eventCourseInput').find('option:selected').html();
                    };

                    thatEditor.getSelectedCourseId = function () {
                        return $('.timeElementEditor').find('#eventCourseInput').val();
                    };

                    thatEditor.getSelectedTeacher = function () {
                        return $('.timeElementEditor').find('#eventTeacherInput').find('option:selected').html();
                    };

                    thatEditor.getSelectedTeacherId = function () {
                        return $('.timeElementEditor').find('#eventTeacherInput').val();
                    };

                    thatEditor.getSelectedAdditionalTeacher = function () {
                        return $('.timeElementEditor').find('#eventAdditionalTeacherInput').find('option:selected').html();
                    };

                    thatEditor.getSelectedAdditionalTeacherId = function () {
                        return $('.timeElementEditor').find('#eventAdditionalTeacherInput').val();
                    };

                    return thatEditor;
                }();
                timeElementEditor.show();
                selectionParams = null;
            }
        };

        this.createTimeElement = function () {
            var timeElementType = $('[name=timeElementType]:checked').val();
            var newEvent = {
                id: 'new-schedule-element-' + (scheduleElementId++),
                courseType: {
                    coursetypeid: timeElementEditor.getSelectedCourseId(),
                    name: timeElementEditor.getSelectedCourse()
                },
                teacher: {
                    teacherid: timeElementEditor.getSelectedTeacherId(),
                    name: timeElementEditor.getSelectedTeacher()
                },
                additionalTeacher: {
                    teacherid: timeElementEditor.getSelectedAdditionalTeacherId(),
                    name: timeElementEditor.getSelectedAdditionalTeacher()
                },
                day: timeElementEditor.day.weekDay,
                date: timeElementEditor.date,
                room: timeElementEditor.room,
                visitedCount: '0',
                reservationCount: '0',
                childCount: '0',
                startTime: commonHelper.stringToTimeObject($('.timeElementFrom').val()),
                finishTime: commonHelper.stringToTimeObject($('.timeElementTo').val()),
                timeElementType: timeElementType,
                createDate: timeElementEditor.date
            };
            if (timeElementType == 'eventInput') {
                that.addModifiedTimeEventElement(newEvent);
                that.createSchedule();
                that.deleteNewScheduleElements();
            } else {
                that.addModifiedTimeEventElement(newEvent);
                generateAndRecalculateEvent(newEvent, timeElementEditor.selectedParams.day, timeElementEditor.selectedParams.room);
                that.showControlDialog();
            }
            $('.timeElementEditor').overlay().close();
        };


        this.selectTimeMouseDown = function (event, ui) {
            var dayRoomInfo = $(event.currentTarget).parent().data('dayRoomInfo');
            selectionParams = {
                timeSelectorStarted: true,
                firstSelectedRow: $(event.currentTarget),
                day: dayRoomInfo.day,
                room: dayRoomInfo.room
            };

            selectionParams.firstSelectedRow.addClass('selectingTimeRow');
            return false;
        };

        this.selectTimeMouseUp = function (event, ui) {
            if (selectionParams) {
                if (!selectionParams.lastSelectedRow) {
                    selectionParams.lastSelectedRow = selectionParams.firstSelectedRow;
                    selectionParams.timeSelectorDirection = 0;
                }
                stopTimeSelection('mouseUp', selectionParams.lastSelectedRow);
            }
        };

        this.selectTimeMouseOver = function (event) {
            if (selectionParams && selectionParams.timeSelectorStarted) {

                var firstSelectedRow = selectionParams.firstSelectedRow;
                var lastSelectedRow = selectionParams.lastSelectedRow;
                var timeSelectorDirection = selectionParams.timeSelectorDirection;

                var oldLastSelectedRow = lastSelectedRow;
                selectionParams.lastSelectedRow = $(event.currentTarget);
                lastSelectedRow = selectionParams.lastSelectedRow;
                if (lastSelectedRow.parent().attr('id') && lastSelectedRow.parent().attr('id') == firstSelectedRow.parent().attr('id')) {

                    selectionParams.timeSelectorDirection = compareRows(lastSelectedRow, firstSelectedRow);
                    timeSelectorDirection = selectionParams.timeSelectorDirection;

                    var minRow = timeSelectorDirection == 1 ? firstSelectedRow : lastSelectedRow;
                    var maxRow = timeSelectorDirection == 1 ? lastSelectedRow : firstSelectedRow;

                    var oldDirectionMin = compareRows(oldLastSelectedRow, minRow);
                    var oldDirectionMax = compareRows(oldLastSelectedRow, maxRow);

                    var oldMinRow = oldDirectionMin == 1 ? minRow : oldLastSelectedRow;
                    var oldMaxRow = oldDirectionMax == 1 ? oldLastSelectedRow : maxRow;

                    if (timeSelectorDirection != 0) {
                        var currentRow = oldMinRow;
                        while (currentRow && currentRow.attr('timeRow-id') != oldMaxRow.attr('timeRow-id')) {
                            if (compareRows(maxRow, currentRow) == 1 && compareRows(minRow, currentRow) == -1) {
                                currentRow.addClass('selectingTimeRow');
                            } else {
                                currentRow.removeClass('selectingTimeRow');
                            }
                            currentRow = currentRow.next();
                        }

                    }
                } else {
                    stopTimeSelection('mouseOver', null);
                }
            }
        };

        var selectTimeElements = function (startRow, finishRow) {
            if (startRow) {
                if (finishRow && startRow.parent().attr('id') != finishRow.parent().attr('id')) {
                    finishRow = null;
                }

                var currentRow = startRow;
                var startEqualsFinish = finishRow && startRow.attr('timeRow-id') == finishRow.attr('timeRow-id');
                var foundEvent = null;
                do {
                    var releaseRow = currentRow;
                    currentRow.addClass('selectedTimeRow');
                    if (selectionParams.timeSelectorDirection == 1) {
                        currentRow = currentRow.next();
                    } else if (selectionParams.timeSelectorDirection == -1) {
                        currentRow = currentRow.prev();
                    } else {
                        currentRow = null;
                    }
                    if (currentRow && currentRow.data('fillingEvent')) {
                        foundEvent = currentRow.data('fillingEvent').data('event');
                    }

                } while (currentRow && !currentRow.data('fillingEvent') && currentRow.attr('timeRow-id') && !startEqualsFinish && (!finishRow || currentRow.attr('timeRow-id') != finishRow.attr('timeRow-id')));
                //select last row
                if (currentRow && currentRow.attr('timeRow-id')) {
                    releaseRow = currentRow;
                    releaseRow.addClass('selectedTimeRow');
                }
                var resultMinTime;
                var resultMaxTime;

                var time1;
                var time2;

                var timeStep = startRow.parent().parent().data('timeStep');

                //calculate time1
                var startRowEvent = startRow.data('fillingEvent') ? startRow.data('fillingEvent').data('event') : null;
                if (startRowEvent) {
                    if (selectionParams.timeSelectorDirection == 0 || selectionParams.timeSelectorDirection == 1) {
                        time1 = startRowEvent.finishTime;
                    } else {
                        time1 = startRowEvent.startTime;
                    }
                } else {
                    var startTime = commonHelper.stringToTimeObject(startRow.attr('timeRow-id'));
                    if (selectionParams.timeSelectorDirection == -1) {
                        time1 = addMinutes(startTime, timeStep);
                    } else {
                        time1 = startTime;
                    }
                }

                //calculate time2
                if (foundEvent) {
                    if (selectionParams.timeSelectorDirection == 0 || selectionParams.timeSelectorDirection == 1) {
                        time2 = foundEvent.startTime;
                    } else {
                        time2 = foundEvent.finishTime;
                    }
                } else {
                    var releaseTime = commonHelper.stringToTimeObject(releaseRow.attr('timeRow-id'));
                    if (selectionParams.timeSelectorDirection == 0 || selectionParams.timeSelectorDirection == 1) {
                        time2 = addMinutes(releaseTime, timeStep);
                    } else {
                        time2 = releaseTime;
                    }
                }

                if (compareTimes(time1, time2) == 1) {
                    resultMinTime = time2;
                    resultMaxTime = time1;
                } else {
                    resultMinTime = time1;
                    resultMaxTime = time2;
                }


                return {
                    'startTime': resultMinTime,
                    'finishTime': resultMaxTime
                };

            }
            return null;
        };

        this.stopDragging = function (event) {
            event.preventDefault ? event.preventDefault() : event.returnValue = false;
            return false;
        };

        this.lessonInfoHoverOn = function (event, ui) {
            stopTimeSelection('hoverOn', null);
        };

        this.calendarTableContainerHoverOff = function () {
            stopTimeSelection('leave table', selectionParams ? selectionParams.lastSelectedRow : null);
        };

        var addMinutes = function (time, addedMinutes) {
            var hours = Math.floor((time.hours * 60 + time.minutes + addedMinutes) / 60);
            var minutes = (time.minutes + addedMinutes) % 60;
            return {hours: hours, minutes: minutes};
        };

        var compareRows = function (row1, row2) {
            if (!row1 || !row1) {
                return 0;
            }

            return compareTimes(commonHelper.stringToTimeObject(row1.attr('timeRow-id')), commonHelper.stringToTimeObject(row2.attr('timeRow-id')));
        };

        var compareTimes = function (time1, time2) {
            return time1.hours > time2.hours ? 1 : time1.hours == time2.hours && time1.minutes > time2.minutes ? 1 : -1;
        };

        this.onWindowScroll = function (event) {
            var roomTitleDiv = calendar.find('.roomTitleDiv');
            var controlDiv = calendar.find('.controlDiv');

            controlDiv.css('position', 'fixed');
            controlDiv.css('top', window.innerHeight - 70);
            controlDiv.css('left', window.innerWidth - 220);


            var top = window.pageYOffset ? window.pageYOffset : document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop;
            var left = window.pageXOffset ? window.pageXOffset : document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft;


            if (top > calendar.offset().top) {
                roomTitleDiv.css('position', 'fixed');
                roomTitleDiv.css('top', 0);
                roomTitleDiv.css('left', calendar.offset().left - (window.pageXOffset ? window.pageXOffset : document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft));
                roomTitleDiv.css('width', calendar.width() - 2);

            } else {
                roomTitleDiv.css('position', 'relative');
                roomTitleDiv.css('left', '');
                roomTitleDiv.css('top', '');
            }
        };

        this.timeRowHoverOn = function (event) {
            var element = $(event.currentTarget);
            var rowId = element.attr('timeRow-id');
            if (rowId) {
                var day = element.parents().filter('.day');
                var timeRows = day.find('[timeRow-id="' + rowId + '"]');
                timeRows.addClass('timeRowHover');
            }
        };

        this.timeRowHoverOff = function (event) {
            var element = $(event.currentTarget);
            var rowId = element.attr('timeRow-id');
            if (rowId) {
                var day = element.parents().filter('.day');
                var timeRows = day.find('[timeRow-id="' + rowId + '"]');
                timeRows.removeClass('timeRowHover');
            }
        };
    };

    that.setFilterType = function(type){
        filterType = type;
        that.refreshCalendar();
    }

    that.addTeacherSet = function(){
        var dialog = $('#workingSetEditDialog');

        commonHelper.callAjaxMethod('scheduler.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.courseTypes = result.courseTypeList.rows;
            references.rooms = result.roomList.rows;
            references.teachers = result.teacherList.rows;
            commonHelper.initReferenceSelect(dialog.find('#teacher'), references, 'teacher', 'teacherid', 'name');
            commonHelper.initReferenceSelect(dialog.find('#course'), references, 'courseType', 'coursetypeid', 'name');
            commonHelper.initReferenceSelect(dialog.find('#room'), references, 'room', 'roomid', 'title');

            dialog.find('#teacher').val($('#tab-scheduler-week').find('#filterweekteacher').val());
        });

        var buttons = {}
        buttons['saveButton'] = {
            title: messages['common.save'],
            action: function () {
                var params = REFERENCE.collectParams('workingSetEditDialog');
                var validate = function (params) {
                    var errors = [];
                    if (params.step == '' || parseInt(params.step) == 0) {
                        errors.push(messages['scheduler.week.teacherset.nostep']);
                    }
                    if(errors.length > 0){
                        $('#workingSetEditDialog').find('.dialogMessages').html(errors.join('<br>'));
                        return false;
                    }
                    return true;
                };
                $('#workingSetEditDialog').find('.dialogMessages').html('');
                if (validate(params)) {
                    commonHelper.callAjaxMethod('scheduler.htm', 'addTeacherSet', params, function (result) {
                        if(result == true){
                            that.refreshCalendar();
                            REFERENCE.closeEditReferenceDialog('workingSetEditDialog');
                        }
                        else {
                            $('#workingSetEditDialog').find('.dialogMessages').html(messages['scheduler.week.teacherset.noworkinghours']);
                        }
                    });
                }
            }
        }
        REFERENCE.openEditReferenceDialog('workingSetEditDialog', {
                buttons: buttons,
                onClose: function () {}
            }
        );

        commonHelper.setDatePicker($('#workingSetEditDialog').find('#fromDate'));
        commonHelper.setDatePicker($('#workingSetEditDialog').find('#toDate'));
        $('#workingSetEditDialog').find('#fromDate').datepicker("setDate", schedulesData.daysData[0].date);
        $('#workingSetEditDialog').find('#toDate').datepicker("setDate", schedulesData.daysData[schedulesData.daysData.length - 1].date);
    }
    
    that.removeTeacherSet = function(){
        var dialog = $('#workingSetRemoveDialog');

        commonHelper.callAjaxMethod('scheduler.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.courseTypes = result.courseTypeList.rows;
            references.rooms = result.roomList.rows;
            references.teachers = result.teacherList.rows;
            commonHelper.initReferenceSelect(dialog.find('#teacher'), references, 'teacher', 'teacherid', 'name');
            commonHelper.initReferenceSelect(dialog.find('#course'), references, 'courseType', 'coursetypeid', 'name');
            commonHelper.initReferenceSelect(dialog.find('#room'), references, 'room', 'roomid', 'title');

            dialog.find('#teacher').val($('#tab-scheduler-week').find('#filterweekteacher').val());
        });

        var buttons = {}
        buttons['saveButton'] = {
            title: messages['common.remove'],
            action: function () {
                var params = REFERENCE.collectParams('workingSetRemoveDialog');
                var validate = function (params) {
                    var errors = [];
                    if (params.step == '' || parseInt(params.step) == 0) {
                        errors.push(messages['scheduler.week.teacherset.nostep']);
                    }
                    if(errors.length > 0){
                        $('#workingSetRemoveDialog').find('.dialogMessages').html(errors.join('<br>'));
                        return false;
                    }
                    return true;
                };
                $('#workingSetRemoveDialog').find('.dialogMessages').html('');
                if (validate(params)) {
                    commonHelper.callAjaxMethod('scheduler.htm', 'removeTeacherSet', params, function (result) {
                        that.refreshCalendar();
                        REFERENCE.closeEditReferenceDialog('workingSetRemoveDialog');
                    });
                }
            }
        }
        REFERENCE.openEditReferenceDialog('workingSetRemoveDialog', {
                buttons: buttons,
                onClose: function () {}
            }
        );

        commonHelper.setDatePicker($('#workingSetRemoveDialog').find('#fromDateRemove'));
        commonHelper.setDatePicker($('#workingSetRemoveDialog').find('#toDateRemove'));
        $('#workingSetRemoveDialog').find('#fromDateRemove').datepicker("setDate", schedulesData.daysData[0].date);
        $('#workingSetRemoveDialog').find('#toDateRemove').datepicker("setDate", schedulesData.daysData[schedulesData.daysData.length - 1].date);
    }

    that.downloadExcel = function () {
        var params = collectFilterWeekParams();
        var paramsString = '';
        for (var param in params) {
            paramsString += param + '=' + params[param] + '&';
        }

        window.location.assign("scheduler.htm?method=downloadEventsAsExcel" + (paramsString ? '&' + paramsString : ''));
    }

    that.print = function () {
        var params = collectFilterWeekParams();
        commonHelper.callAjaxMethod('scheduler.htm', 'printEvents', params, function (result) {
            if(result == true){
                commonHelper.showMessage(messages['scheduler.month']);
            }
            else {
                var paramsString = '';
                for (var param in params) {
                    paramsString += param + '=' + params[param] + '&';
                }
                commonHelper.openPdfPrintDialog('scheduler.htm?method=printEventsFromClient' + (paramsString ? '&' + paramsString : ''));
            }
        });
    }

    var collectFilterWeekParams = function(){
        var params = {};
        params.weekDay = commonHelper.formatDate(scheduleCalendarControlPanel.find('.weekDayPicker').datepicker("getDate"));
        params.type = filterType;
        params.filterteacher = $('#tab-scheduler-week').find('#filterweekteacher').val();
        params.showteachertime = $('#tab-scheduler-week').find('[name="showweekteachertime"]:checked').val();
        return params;
    }

    return this;
}function usersAndOrganizations_helper() {
    var that = this;
    var activeUsersGrid;
    that.init = function(){
        $('#tabs-users-organizations').tabs({
            selected: 0,
            select: function (event, ui) {
                switch (ui.index) {
                    case 0:

                        break;
                    case 1:
                        initActiveUsers();
                        break;
                }
            }
        });
    };

    var initActiveUsers = function(){
        if (!activeUsersGrid) {
            activeUsersGrid = $('#activeUsers').jqGrid({
                datatype: function(){
                    commonHelper.callAjaxMethod('users.htm', 'loadActiveUsers',
                        {}, function (result) {
                            activeUsersGrid.clearGridData(true);
                            activeUsersGrid[0].addJSONData(result);
                        }, true, true, false, function(){return true;})
                },
                colNames: [
                    messages['usersandorganizations.loginname'],
                    messages['usersandorganizations.name'],
                    messages['usersandorganizations.logindate'],
                    messages['usersandorganizations.session'],
                    messages['usersandorganizations.description']
                ],
                colModel: [
                    {name: 'loginName', index: 'loginName', formatter: commonHelper.notNullFormatter},
                    {name: 'name', index: 'name', formatter: commonHelper.notNullFormatter},
                    {name: 'loginDate', index: 'loginDate', formatter: commonHelper.notNullFormatter},
                    {name: 'sessionId', index: 'sessionId', formatter: commonHelper.notNullFormatter},
                    {name: 'description', index: 'description', formatter: commonHelper.notNullFormatter},
                ],
                height: "100%",
                jsonReader: {repeatitems: false, id: "loginName"},
                sortname: 'loginDate',
                viewrecords: true,
                sortorder: "asc",
                rowNum: -1
            });

            updateActiveUsers();
        } else {
            activeUsersGrid.trigger("reloadGrid");
        }
    };

    var updateActiveUsers = function(){
        activeUsersGrid.trigger("reloadGrid");
        activeUsersGrid.jqGrid('setGridWidth', $('#tabs-users-organizations-active-users').parent(null).width() - 70);
        setTimeout(updateActiveUsers, 5000)
    };


    that.loadUsers = function () {
        REFERENCE.fillReferenceList('users', 'users.htm', 'loadUsers', {
                sortOrder: 'asc',
                sortName: 'loginName',
                fillCallback: function (list, template, data) {
                    var row = template.clone();
                    row.removeClass('usersTemplate');
                    row.show();
                    row.appendTo(list);

                    return list.directives({
                            '.usersRow': {
                                'row <- rows': {
                                    '.loginName': 'row.loginName',
                                    '.name': 'row.name',
                                    '.active': function (context) {
                                        return context.item.active ? '<span style="color: green;">' + messages['usersandorganizations.active.on'] + '</span>' : '<span style="color: red;">' + messages['usersandorganizations.active.off'] + '</span>';
                                    },
                                    '.userType': function (context) {
                                        switch (context.item.userType) {
                                            case 'ADMIN' :
                                                return messages['usersandorganizations.type.admin'];
                                            case 'USER' :
                                                return messages['usersandorganizations.type.user'];
                                        }
                                        return messages['usersandorganizations.type.unknown'];
                                    },
                                    '.editUser@userid': 'row.id',
                                    '.deleteUser@userid': 'row.id',
                                    '.changePassword@userid': 'row.id',
                                    '.userListPermission': {
                                        'permission <- row.authoritiesSet': {
                                            '.': 'permission.title'
                                        }
                                    },
                                    '.organizationsList': {
                                        'organization <- row.availableOrganizations': {
                                            '.': 'organization.name'
                                        }
                                    }
                                }
                            }
                        }
                    ).render(data);
                }
            }
        );

    };

    this.addUser = function () {
        that.editUser(null);
    };

    this.editUser = function (userid) {
        commonHelper.callAjaxMethod('users.htm', 'loadUser', {userId: userid}, function (data) {

            if (!data) {
                data = {
                    name: '',
                    loginname: '',
                    description: '',
                    userInfo: {
                        active: true
                    }
                }
            }

            var userDialog = $('#usersDialog').directives({
                '.userId@value': 'userInfo.id',
                '.userName@value': 'userInfo.name',
                '.userLogin@value': 'userInfo.loginName',
                '.description@value': 'userInfo.description',
                '.active@checked': function (context) {
                    return context.context.userInfo.active ? 'checked' : '';
                }

            }).render(data);

            userDialog.find('.userType').val(data.userInfo.userType);
            userDialog.find('.userLanguage').val(data.userInfo.userLanguage);

            var permissionInputs = userDialog.find('[id^="permission."]');
            var organizationInputs = userDialog.find('.userInfoOrganizations');
            var index = 0;

            if (data.userInfo.userType == 'ADMIN') {
                for (index = 0; index < permissionInputs.length; index++) {
                    $(permissionInputs[index]).attr('checked', 'checked');
                    $(permissionInputs[index]).attr('disabled', 'disabled');
                }

                for (index = 0; index < organizationInputs.length; index++) {
                    $(organizationInputs[index]).attr('checked', 'checked');
                    $(organizationInputs[index]).attr('disabled', 'disabled');
                }

            } else {

                for (index = 0; index < permissionInputs.length; index++) {
                    $(permissionInputs[index]).removeAttr('checked');
                    $(permissionInputs[index]).removeAttr('disabled');
                }

                for (index = 0; index < organizationInputs.length; index++) {
                    $(organizationInputs[index]).removeAttr('checked');
                    $(organizationInputs[index]).removeAttr('disabled');
                }

                if (data.userInfo.authorities) {
                    for (var j = 0; j < data.userInfo.authorities.length; j++) {
                        userDialog.find('[id="permission.' + data.userInfo.authorities[j] + '"]').attr('checked', 'checked');
                    }
                }

                if (data.userInfo.availableOrganizations) {
                    for (var k = 0; k < data.userInfo.availableOrganizations.length; k++) {
                        userDialog.find('[id="userinfo.organization.' + data.userInfo.availableOrganizations[k].id + '"]').attr('checked', 'checked');
                    }
                }
            }

            commonHelper.checkFeature('LANGUAGES', function () {
                userDialog.find('.languageRow').show();
            }, function () {});

            REFERENCE.openEditReferenceDialog('usersDialog', {
                    buttons: {
                        'saveButton': {
                            title: messages['common.save'],
                            action: function () {

                                var params = REFERENCE.collectParams('usersDialog');
                                params.organizations = {};
                                var usersOrganizations = $('#usersDialog').find('.userInfoOrganizations');
                                $.each(usersOrganizations, function (index, item) {
                                    var orgItem = $(item);
                                    if (orgItem.attr('checked') == 'checked') {
                                        params.organizations[orgItem.attr('orgid')] = orgItem.attr('orgid');
                                    }
                                });
                                var validate = function (params) {
                                    if (params.userLogin == '') {
                                        $('#usersDialog').find('.dialogMessages').html(messages['usersandorganizations.validate.login']);
                                        return false;
                                    }
                                    return true;
                                };

                                if (validate(params)) {
                                    commonHelper.callAjaxMethod('users.htm', 'saveUser', params, function (data) {
                                        if (!data) {
                                            commonHelper.showMessage(messages['usersandorganizations.error']);
                                        } else {
                                            that.loadUsers();
                                            REFERENCE.closeEditReferenceDialog('usersDialog');
                                        }
                                    });
                                }
                            }
                        }
                    },
                    onClose: function () {

                    }
                }
            );

        }, false, false, !userid);
    };

    this.deleteUser = function (userid) {
        DIALOGS.askYesNoDialog(messages['usersandorganizations.confirmremove'], messages['common.remove'], function () {
            commonHelper.callAjaxMethod('users.htm', 'deleteUser', {userId: userid}, function (data) {
                that.loadUsers();
            });
        });
    };

    this.changePassword = function (userid, showCurrent) {
        DIALOGS.openChangePasswordDialog('changePasswordDialog', userid, function () {
            commonHelper.showMessage(messages['usersandorganizations.passwordchanged']);
        }, showCurrent);
    };

    this.changePasswordRequired = function (passwordRequired) {
        if (passwordRequired) {
            DIALOGS.askYesNoDialog(messages['usersandorganizations.confirmpasswordrequired'], messages['common.yes'], function () {
                changePasswordRequired(passwordRequired);
            }, function(){
                $('#passwordsRequired').removeAttr('checked');
            });
        } else {
            changePasswordRequired(passwordRequired);
        }
    };

    var changePasswordRequired = function(passwordRequired){
        commonHelper.callAjaxMethod('users.htm', 'changePasswordRequired', {passwordRequired: passwordRequired}, function (data) {
            if (data) {
                window.location = '/crm';
            }
        }, true, false, false, function () {
            $('#passwordsRequired').removeAttr('checked');
        });
    };

    this.addOrganization = function () {
        that.editOrganization(null);
    };

    this.editOrganization = function (organiationid) {
        commonHelper.callAjaxMethod('organizations.htm', 'loadOrganization', {organizationId: organiationid}, function (data) {

            if (!data) {
                data = {
                    name: '',
                    smallName: '',
                    phone: ''
                }
            }

            var organizationsDialog = $('#organizationsDialog').directives({
                '.organizationId@value': 'id',
                '.organizationName@value': 'name',
                '.organizationSmallName@value': 'smallName',
                '.organizationPhone@value': 'phone'

            }).render(data);

            organizationsDialog.find('[id^="feature."]').removeAttr('checked');
            if (data.features) {
                for (var j = 0; j < data.features.length; j++) {
                    organizationsDialog.find('[id="feature.' + data.features[j] + '"]').attr('checked', 'checked');
                }
            }

            REFERENCE.openEditReferenceDialog('organizationsDialog', {
                    buttons: {
                        'saveButton': {
                            title: messages['common.save'],
                            action: function () {

                                var params = REFERENCE.collectParams('organizationsDialog');
                                var validate = function (params) {
                                    if (params.name == '') {
                                        $('#organizationsDialog').find('.dialogMessages').html(messages['usersandorganizations.org.validate.name']);
                                        return false;
                                    }
                                    return true;
                                };

                                if (validate(params)) {
                                    commonHelper.callAjaxMethod('organizations.htm', 'saveOrganization', params, function (data) {
                                        if (!data) {
                                            commonHelper.showMessage(messages['usersandorganizations.org.error']);
                                        } else {
                                            that.loadOrganizations();
                                            REFERENCE.closeEditReferenceDialog('organizationsDialog');
                                        }
                                    });
                                }
                            }
                        }
                    },
                    onClose: function () {

                    }
                }
            );

        }, false, false, !organiationid);
    };

    this.deleteOrganization = function (organizationid) {
        DIALOGS.askYesNoDialog(messages['usersandorganizations.org.confirmremove'], messages['common.remove'], function () {
            commonHelper.callAjaxMethod('organizations.htm', 'deleteOrganization', {organizationId: organizationid}, function (data) {
                that.loadOrganizations();
            });
        });
    };

    this.markOrganizationAsDefault = function(organizationid){
        DIALOGS.askYesNoDialog(messages['usersandorganizations.org.confirmdefault'], messages['common.yes'], function () {
            commonHelper.callAjaxMethod('organizations.htm', 'markOrganizationAsDefault', {organizationId: organizationid}, function (data) {
                that.loadOrganizations();
            });
        });
    };


    that.loadOrganizations = function () {
        REFERENCE.fillReferenceList('organizations', 'organizations.htm', 'loadOrganizations', {
                sortOrder: 'asc',
                sortName: 'name',
                fillCallback: function (list, template, data) {
                    var row = template.clone();
                    row.removeClass('organizationsTemplate');
                    row.show();
                    row.appendTo(list);

                    return list.directives({
                            '.organizationsRow': {
                                'row <- rows': {
                                    '.name': 'row.name',
                                    '.smallName': 'row.smallName',
                                    '.phone': 'row.phone',
                                    '.editOrganization@organizationid': 'row.id',
                                    '.deleteOrganization@organizationid': 'row.id',
                                    '.markOrganizationAsDefault@organizationid': 'row.id'
                                }
                            }
                        }
                    ).render(data);
                }
            }
        );

    };


    return this;
}function index_helper() {
    var that = this;
    var todayTasksSelectedPage = 1;
    var weekTasksSelectedPage = 1;
    var testWithoutSubscriptionClientsPage = 1;
    var oldActivityClientsPage = 1;
    var oldActivityForAllCoursesClientsPage = 1;
    var lastLessonClientsPage = 1;
    var potentialClientsPage = 1;
    var notPaidLessonPage = 1;

    var activeTaskTab = 'todayTasks';
    var activeClientsTab = 'oldActivityForAllCoursesClients';

    this.pageReady = function () {
        $('.desktopFilterWeeksTo').html(DESKTOP_FILTER_WEEKS_TO);
        $('.desktopFilterWeeksFrom').html(DESKTOP_FILTER_WEEKS_FROM);

        that.preparePage();
        that.refreshLists();
        commonHelper.registerChangeOrganizationListener(function (selectOrganizationId) {
            that.refreshLists();
        });
        commonHelper.prepareViewer([
            {filter: '#mailWeekLink', action: 'delete'},
            {filter: '#taskWeekLink', action: 'delete'},
            {filter: '#callTaskWeekLink', action: 'delete'},
            {filter: '#mailTodayLink', action: 'delete'},
            {filter: '#taskTodayLink', action: 'delete'},
            {filter: '#callTaskTodayLink', action: 'delete'}
        ]);

        commonHelper.checkServerVersion(true);
    };

    this.preparePage = function () {
        $("input:submit, button").button();
    };

    this.editTask = function (buttonObject) {
        var taskid = buttonObject.parents().filter('.taskRow').attr('id');
        if (taskid) {
            DIALOGS.taskEditDialog(taskid, null, null, null, false, false, refreshTasks);
        }
    };

    this.addTaskDialog = function (link, taskType) {
        commonHelper.checkFeature('MARKETING', function () {
            var offset = $(link).offset();
            $('#menuTaskTypeDiv').css('z-index', commonHelper.getMaxZIndex() + 1);
            $('#menuTaskTypeDiv').css('left', (offset.left) + 'px');
            $('#menuTaskTypeDiv').css('top', (offset.top + $(link).height() + 3) + 'px');
            $('#menuTaskTypeDiv').show(10, 'linear', function () {
                $('html').one('click', function () {
                    $('#menuTaskTypeDiv').hide();
                });
                $('#menuTaskTypeDiv').find('a').one('click', function(){
                    if($(this).hasClass('addtask-client')){
                        DIALOGS.taskEditDialog(null, null, null, taskType, false, false, refreshTasks);
                    }
                    else if($(this).hasClass('addtask-request')){
                        DIALOGS.taskEditDialog(null, null, -1, taskType, false, false, refreshTasks);
                    }
                });
            });
        }, function () {
            DIALOGS.taskEditDialog(null, null, null, taskType, false, false, refreshTasks);
        });
    };

    this.refreshLists = function () {
        refreshTasks();
        refreshTestsWithoutSubscriptionClients();
        refreshActivityClients();
        refreshPotentialClients();
        refreshNotPaidLessons();
    };

    var refreshTestsWithoutSubscriptionClients = function () {
        commonHelper.callAjaxMethod('index.htm', 'refreshTestsWithoutSubscriptionClients',
            {
                page: testWithoutSubscriptionClientsPage,
                rows: 7,
                sord: 'desc',
                sidx: 'finishDate'
            },
            function (result) {
                fillTestWithoutSubscriptionsClientsInfo('testWithoutSubscriptionClientsList', result, function (page) {
                    testWithoutSubscriptionClientsPage = page;
                    refreshTestsWithoutSubscriptionClients();
                }, testWithoutSubscriptionClientsPage);
            });
    };


    var refreshNotPaidLessons = function () {
        commonHelper.callAjaxMethod('index.htm', 'refreshNotPaidLessons',
            {
                page: notPaidLessonPage,
                rows: 7,
                sord: 'desc',
                sidx: 'fullPrice'
            },
            function (result) {
                fillNotPaidLessonInfo('notPaidLessonsList', result, function (page) {
                    notPaidLessonPage = page;
                    refreshNotPaidLessons();
                }, notPaidLessonPage);
            });
    };

    var refreshPotentialClients = function () {
        commonHelper.callAjaxMethod('index.htm', 'refreshPotentialClients',
            {
                page: potentialClientsPage,
                rows: 7,
                sord: 'desc',
                sidx: 'createDate'
            },
            function (result) {
                fillPotentialClientsInfo('potentialClientsList', result, function (page) {
                    potentialClientsPage = page;
                    refreshPotentialClients();
                }, potentialClientsPage);
            });
    };


    var refreshActivityClients = function(){
        if (activeClientsTab == 'oldActivityForAllCoursesClients') {
            that.showOldActivityForAllCoursesClients();
        } else if (activeClientsTab == 'oldActivityClients') {
            that.showOldActivityClients();
        } else {
            that.showLastLessonClients();
        }
    };

    that.showLastLessonClients = function(){
        activeClientsTab = 'lastLessonClients';
        $('#oldActivityClientsDiv').hide();
        $('#oldActivityForAllCoursesClientsDiv').hide();
        $('#lastLessonClientsDiv').show();

        $('#lastLessonClientsLink').addClass('activeTabLink');
        $('#lastLessonClientsLink').removeClass('notActiveTabLink');

        $('#oldActivityForAllCoursesClientsLink').removeClass('activeTabLink');
        $('#oldActivityForAllCoursesClientsLink').addClass('notActiveTabLink');

        $('#oldActivityClientsLink').removeClass('activeTabLink');
        $('#oldActivityClientsLink').addClass('notActiveTabLink');

        commonHelper.callAjaxMethod('index.htm', 'refreshLastLessonClients',
            {
                page: lastLessonClientsPage,
                rows: 7,
                sord: 'desc',
                sidx: 'lastcoursedate'
            },
            function (result) {
                fillLastLessonClientsInfo('lastLessonClientsList', result, function (page) {
                    lastLessonClientsPage = page;
                    refreshActivityClients();
                }, lastLessonClientsPage);
            });
    };

    that.showOldActivityForAllCoursesClients = function(){
        activeClientsTab = 'oldActivityForAllCoursesClients';
        $('#oldActivityClientsDiv').hide();
        $('#oldActivityForAllCoursesClientsDiv').show();
        $('#lastLessonClientsDiv').hide();

        $('#oldActivityClientsLink').removeClass('activeTabLink');
        $('#oldActivityClientsLink').addClass('notActiveTabLink');

        $('#oldActivityForAllCoursesClientsLink').addClass('activeTabLink');
        $('#oldActivityForAllCoursesClientsLink').removeClass('notActiveTabLink');

        $('#lastLessonClientsLink').removeClass('activeTabLink');
        $('#lastLessonClientsLink').addClass('notActiveTabLink');


        commonHelper.callAjaxMethod('index.htm', 'refreshOldActivityForAllCoursesClients',
            {
                page: oldActivityForAllCoursesClientsPage,
                rows: 7,
                sord: 'desc',
                sidx: 'lastCourseDate'
            },
            function (result) {
                fillOldSubscriptionForAllCoursesClientsInfo('oldActivityForAllCoursesClientsList', result, function (page) {
                    oldActivityForAllCoursesClientsPage = page;
                    refreshActivityClients();
                }, oldActivityForAllCoursesClientsPage);
            });
    };

    that.showOldActivityClients = function () {
        activeClientsTab = 'oldActivityClients';
        $('#oldActivityClientsDiv').show();
        $('#lastLessonClientsDiv').hide();
        $('#oldActivityForAllCoursesClientsDiv').hide();

        $('#oldActivityClientsLink').addClass('activeTabLink');
        $('#oldActivityClientsLink').removeClass('notActiveTabLink');

        $('#oldActivityForAllCoursesClientsLink').removeClass('activeTabLink');
        $('#oldActivityForAllCoursesClientsLink').addClass('notActiveTabLink');

        $('#lastLessonClientsLink').removeClass('activeTabLink');
        $('#lastLessonClientsLink').addClass('notActiveTabLink');


        commonHelper.callAjaxMethod('index.htm', 'refreshOldActivityClients',
            {
                page: oldActivityClientsPage,
                rows: 7,
                sord: 'desc',
                sidx: 'lastCourseDate'
            },
            function (result) {
                fillOldSubscriptionClientsInfo('oldActivityClientsList', result, function (page) {
                    oldActivityClientsPage = page;
                    refreshActivityClients();
                }, oldActivityClientsPage);
            });
    };


    var refreshTasks = function () {
        if (activeTaskTab == 'todayTasks') {
            that.showTodayTasks();
        } else {
            that.showWeekTasks();
        }
    };

    that.showWeekTasks = function () {
        activeTaskTab = 'weekTasks';
        $('#weekTasksTable').show();
        $('#todayTasksTable').hide();

        $('#weekActivateLink').addClass('activeTabLink');
        $('#weekActivateLink').removeClass('notActiveTabLink');

        $('#todayActivateLink').removeClass('activeTabLink');
        $('#todayActivateLink').addClass('notActiveTabLink');

        commonHelper.callAjaxMethod('index.htm', 'loadWeekTasks',
            {
                page: weekTasksSelectedPage,
                rows: 7,
                sord: 'desc',
                sidx: 'date'
            },
            function (result) {
                fillTasksInfo('weekTasksList', result, function (page) {
                    weekTasksSelectedPage = page;
                    that.showWeekTasks();
                }, weekTasksSelectedPage);
            });
    };

    that.showTodayTasks = function () {
        activeTaskTab = 'todayTasks';
        $('#weekTasksTable').hide();
        $('#todayTasksTable').show();

        $('#todayActivateLink').addClass('activeTabLink');
        $('#todayActivateLink').removeClass('notActiveTabLink');

        $('#weekActivateLink').removeClass('activeTabLink');
        $('#weekActivateLink').addClass('notActiveTabLink');

        commonHelper.callAjaxMethod('index.htm', 'loadTodayTasks',
            {
                page: todayTasksSelectedPage,
                rows: 7,
                sord: 'desc',
                sidx: 'date'
            },
            function (result) {
                fillTasksInfo('todayTasksList', result, function (page) {
                    todayTasksSelectedPage = page;
                    that.showTodayTasks();
                }, todayTasksSelectedPage);
            });
    };

    var fillNotPaidLessonInfo = function (listQ, data, pagerCallback, currentPage) {
        var taskList = $('#' + listQ);
        taskList.children(null).remove();
        if (data.rows.length > 0) {
            var rowsTable = $('#notPaidLessonTemplate').clone();
            rowsTable.attr('id', 'notPaidLessonTable-' + listQ);
            rowsTable.appendTo(taskList);
            taskList.directives({
                    '.subscriptionRow': {
                        'row <- rows': {
                            '@id': 'row.id',
                            '.child': '#{row.firstName} #{row.lastName}',
                            '.phone': 'row.phone',
                            '.course': 'row.course',
                            '.organization': 'row.organizationName',
                            '.dept': 'row.dept',
                            '.parentName': 'row.parentName',
                            '.childlink@href': 'client.htm?childid=#{row.id}',
                            '.childinfolink@id': 'row.id'
                        }
                    }}
            ).render(data);
            $('#notPaidLessonTable-' + listQ).show();

            commonHelper.hideEmptyList(listQ);
            commonHelper.generatePaginator(listQ, currentPage, data.total, pagerCallback);
        } else {
            commonHelper.hidePaginator(listQ);
            commonHelper.showEmptyList(listQ);
        }
    };

    var fillLastLessonClientsInfo = function (listQ, data, pagerCallback, currentPage) {
        var taskList = $('#' + listQ);
        taskList.children(null).remove();
        if (data.rows.length > 0) {
            var rowsTable = $('#oldActivityClientsTemplate').clone();
            rowsTable.attr('id', 'oldActivityClientsTable-' + listQ);
            rowsTable.appendTo(taskList);
            taskList.directives({
                    '.childRow': {
                        'row <- rows': {
                            '@id': 'row.id',
                            '.child': '#{row.firstname} #{row.lastname}',
                            '.phone': 'row.phone',
                            '.course': 'row.course',
                            '.organization': 'row.organizationname',
                            '.childlink@href': 'client.htm?childid=#{row.id}',
                            '.lastCourseDate': 'row.lastcoursedate',
                            '.childinfolink@id': 'row.id'
                        }
                    }}
            ).render(data);
            $('#oldActivityClientsTable-' + listQ).show();

            commonHelper.hideEmptyList(listQ);
            commonHelper.generatePaginator(listQ, currentPage, data.total, pagerCallback);
        } else {
            commonHelper.hidePaginator(listQ);
            commonHelper.showEmptyList(listQ);
        }
    };

    var fillOldSubscriptionForAllCoursesClientsInfo = function (listQ, data, pagerCallback, currentPage) {
        var taskList = $('#' + listQ);
        taskList.children(null).remove();
        if (data.rows.length > 0) {
            var rowsTable = $('#oldActivityForAllCoursesClientsTemplate').clone();
            rowsTable.attr('id', 'oldActivityForAllCoursesClientsTable-' + listQ);
            rowsTable.appendTo(taskList);
            taskList.directives({
                    '.childRow': {
                        'row <- rows': {
                            '@id': 'row.id',
                            '.child': '#{row.firstName} #{row.lastName}',
                            '.phone': 'row.phone',
                            '.organization': 'row.organizationName',
                            '.childlink@href': 'client.htm?childid=#{row.id}',
                            '.lastCourseDate': 'row.lastCourseDate',
                            '.childinfolink@id': 'row.id'
                        }
                    }}
            ).render(data);
            $('#oldActivityForAllCoursesClientsTable-' + listQ).show();

            commonHelper.hideEmptyList(listQ);
            commonHelper.generatePaginator(listQ, currentPage, data.total, pagerCallback);
        } else {
            commonHelper.hidePaginator(listQ);
            commonHelper.showEmptyList(listQ);
        }
    };

    var fillOldSubscriptionClientsInfo = function (listQ, data, pagerCallback, currentPage) {
        var taskList = $('#' + listQ);
        taskList.children(null).remove();
        if (data.rows.length > 0) {
            var rowsTable = $('#oldActivityClientsTemplate').clone();
            rowsTable.attr('id', 'oldActivityClientsTable-' + listQ);
            rowsTable.appendTo(taskList);
            taskList.directives({
                    '.childRow': {
                        'row <- rows': {
                            '@id': 'row.id',
                            '.child': '#{row.firstName} #{row.lastName}',
                            '.phone': 'row.phone',
                            '.course': 'row.course',
                            '.organization': 'row.organizationName',
                            '.childlink@href': 'client.htm?childid=#{row.id}',
                            '.lastCourseDate': 'row.lastCourseDate',
                            '.childinfolink@id': 'row.id'
                        }
                    }}
            ).render(data);
            $('#oldActivityClientsTable-' + listQ).show();

            commonHelper.hideEmptyList(listQ);
            commonHelper.generatePaginator(listQ, currentPage, data.total, pagerCallback);
        } else {
            commonHelper.hidePaginator(listQ);
            commonHelper.showEmptyList(listQ);
        }
    };

    var fillTestWithoutSubscriptionsClientsInfo = function (listQ, data, pagerCallback, currentPage) {
        var taskList = $('#' + listQ);
        taskList.children(null).remove();
        if (data.rows.length > 0) {
            var rowsTable = $('#testWithoutSubscriptionsClientsTemplate').clone();
            rowsTable.attr('id', 'testWithoutSubscriptionsClientsTable-' + listQ);
            rowsTable.appendTo(taskList);
            taskList.directives({
                    '.childRow': {
                        'row <- rows': {
                            '@id': 'row.childid',
                            '.child': '#{row.firstname} #{row.lastname}',
                            '.phone': 'row.phone',
                            '.course': 'row.course',
                            '.organization': 'row.organizationName',
                            '.childlink@href': 'client.htm?childid=#{row.childid}',
                            '.testLessonDate': 'row.testlessondate',
                            '.childinfolink@id': 'row.childid'
                        }
                    }}
            ).render(data);
            $('#testWithoutSubscriptionsClientsTable-' + listQ).show();

            commonHelper.hideEmptyList(listQ);
            commonHelper.generatePaginator(listQ, currentPage, data.total, pagerCallback);
        } else {
            commonHelper.hidePaginator(listQ);
            commonHelper.showEmptyList(listQ);
        }
    };

    var fillPotentialClientsInfo = function (listQ, data, pagerCallback, currentPage) {
        var taskList = $('#' + listQ);
        taskList.children(null).remove();
        if (data.rows.length > 0) {
            var rowsTable = $('#potentialClientsTemplate').clone();
            rowsTable.attr('id', 'potentialClientsTable-' + listQ);
            rowsTable.appendTo(taskList);
            taskList.directives({
                    '.childRow': {
                        'row <- rows': {
                            '@id': 'row.id',
                            '.child': '#{row.firstName} #{row.lastName}',
                            '.phone': 'row.family.phone',
                            '.organizations': function (context) {
                                var item = context.item;
                                var result = '';
                                $.each(item.family.organizations, function (index, element) {
                                    result += element.name;
                                    if (index < item.family.organizations.length - 1) {
                                        result += ', ';
                                    }
                                });
                                return result;
                            },
                            '.childlink@href': 'client.htm?childid=#{row.id}',
                            '.createDate': 'row.createDate',
                            '.childinfolink@id': 'row.id',
                            '.desiredCourses': desiredCourses
                        }
                    }}
            ).render(data);
            $('#potentialClientsTable-' + listQ).show();

            commonHelper.hideEmptyList(listQ);
            commonHelper.generatePaginator(listQ, currentPage, data.total, pagerCallback);
        } else {
            commonHelper.hidePaginator(listQ);
            commonHelper.showEmptyList(listQ);
        }
    };

    var desiredCourses = function (context) {
        var item = context.item;
        var result = '';
        $.each(item.desiredCourses, function (index, element) {
            result += element.name;
            if (index < item.desiredCourses.length - 1) {
                result += ', ';
            }
        });
        return result;
    };

    var fillTasksInfo = function (listQ, data, pagerCallback, currentPage) {
        var taskList = $('#' + listQ);
        taskList.children(null).remove();
        if (data.rows.length > 0) {
            var rowsTable = $('#taskRowTemplate').clone();
            rowsTable.attr('id', 'taskTable-' + listQ);
            rowsTable.appendTo(taskList);
            taskList.directives({
                    '.taskRow': {
                        'row <- rows': {
                            '@id': 'row.id',
                            '.subject': 'row.subject',
                            '.type': 'row.type.title',
                            '.childlink@href': 'client.htm?childid=#{row.childId}',
                            '.date': 'row.date',
                            '.child': '#{row.childFirstName} #{row.childLastName}',
                            '.parent': '#{row.familyParentName}',
                            '.parentPhone': '#{row.familyPhone}',
                            '.taskorganization': '#{row.organizationName}',
                            '.requestlink@href': 'marketing.htm?requestid=#{row.requestId}',
                            '.request': '#{row.requestFirstName} #{row.requestLastName}',
                            '.requestParent': '#{row.requestContactName}',
                            '.requestPhone': '#{row.requestPhone}',
                            '.user': '#{row.userName}'
                        }
                    }}
            ).render(data);
            $('#taskTable-' + listQ).show();

            commonHelper.hideEmptyList(listQ);

            commonHelper.generatePaginator(listQ, currentPage, data.total, pagerCallback);
        } else {
            commonHelper.hidePaginator(listQ);
            commonHelper.showEmptyList(listQ);
        }
    };

    return this;
}function marketing_helper() {
    var that = this;

    var openedTab = {};

    that.requests = new marketingRequests_helper(that);
    that.salesFunnel = new marketingSakesFunnel_helper(that);
    that.rejections = new marketingRejections_helper(that);
    that.references = new marketingReferences_helper();

    that.TABLE_WIDTH = 0;

    this.pageReady = function () {
        $('#tabs-marketing').tabs();
        that.TABLE_WIDTH = $('#tabs-marketing').parent(null).width() - 70;

        $('#tabs-marketing').tabs({
            show: function (event, ui) {
                $(ui.panel).show();
                onTabSelected(ui.index);
            }
        });

        prepareTabs();

        var action = $('#action').val();
        if(action != ''){
            if(action == 'openDialog'){
                var params = {};
                var actionParameters = $('#actionParameters').val();
                if(actionParameters != ''){
                    params = JSON.parse(actionParameters);
                    if(params.requestid){
                        that.requests.editMarketingRequest(params.requestid);
                    }
                    else {
                        that.requests.addMarketingRequest(params);
                    }
                    if(params.scriptType) DIALOGS.openScriptDialog(null, params.scriptType);
                }
            }
        }
    };

    var prepareTabs = function () {
        var disabledTabs = [];
        onTabSelected(0);
        $('#tab-marketing-requests').show();
        commonHelper.checkPermission('marketing', function () {
        }, function () {
            disabledTabs.push(1);
            disabledTabs.push(2);
            disabledTabs.push(3);
        });

        $('#tabs-marketing').tabs("option", "disabled", disabledTabs);

        commonHelper.prepareViewer([
            {filter: '#createMarketingRequestButton', action: 'delete'}
        ]);

        $('button').button();
    };

    var onTabSelected = function (index) {
        switch (index) {
            case 0:
                that.requests.display();
                break;
            case 1:
                that.salesFunnel.display();
                break;
            case 2:
                that.rejections.display();
                break;
            case 3:
                that.references.display();
                break;
        }
    };


    return this;
}function notifications_helper() {
    var that = this;
    that.searchSettingsText = '';
    that.selectedNotificationSettingsId = null;

    that.organizationSMSSettings = {};
    that.organizationPushSettings = {};
    that.organizationVoiceSettings = {};
    that.currentOrganization = null;

    var notificationsStatisticDataGrid;
    this.recipientsList = new notificationRecipientsList('notificationsRecipientsList');
    this.pageReady = function () {
        $('#tabs-notifications').tabs();
        $('button').button();

        commonHelper.setDateTimePicker($('#notificationNowDate'), commonHelper.formatDateTime(new Date()));
        commonHelper.setDatePicker($('#notificationStatisticFrom'));
        commonHelper.setDatePicker($('#notificationStatisticTo'));

        that.refreshNotificationsSettingsList();
        that.refreshNotificationStatistic();
        that.loadNotificationParams();
        that.loadMobileSettings();

        commonHelper.prepareViewer([
            {filter: '.mobileLogin', action: 'disable'},
            {filter: '.mobilePassword', action: 'disable'},
            {filter: '.smtpHost', action: 'disable'},
            {filter: '.smtpPort', action: 'disable'},
            {filter: '.smtpUser', action: 'disable'},
            {filter: '.smtpPassword', action: 'disable'},
            {filter: '.smtpSsl', action: 'disable'},
            {filter: '.smtpTls', action: 'disable'},
            {filter: '.smtpFrom', action: 'disable'},
            {filter: '.emailNotificationsOn', action: 'disable'},
            {filter: '.imapUser', action: 'disable'},
            {filter: '.imapHost', action: 'disable'},
            {filter: '.imapPort', action: 'disable'},
            {filter: '.imapPassword', action: 'disable'},
            {filter: '.mailEmailSettings', action: 'disable'},
            {filter: '.testMailEmailSettings', action: 'disable'},
            {filter: '.testReceiveMailEmailSettings', action: 'disable'},
            {filter: '.smsNotificationsOn', action: 'disable'},
            {filter: '.smsProvider', action: 'disable'},
            {filter: '.smsAccountId', action: 'disable'},
            {filter: '.smsToken', action: 'disable'},
            {filter: '.smsFrom', action: 'disable'},
            {filter: '.saveSmsSettings', action: 'disable'},
            {filter: '.testSmsSettings', action: 'disable'},
            {filter: '.testVoiceSettings', action: 'disable'},
            {filter: '.wtSyncNotificationsOn', action: 'disable'},
            {filter: '.editNotificationSettings', action: 'disable'},
            {filter: '.sendAllNotifications', action: 'delete'},
            {filter: '.deleteNotificationSettings', action: 'delete'},
            {filter: '.sendMessages', action: 'delete'},
            {filter: '.editNotificationSettings', action: 'delete'},
            {filter: '.deleteNotification', action: 'delete'},
            {filter: '.voiceProvider', action: 'disable'},
            {filter: '.apiKey', action: 'disable'},
            {filter: '.voiceNotificationsOn', action: 'disable'},
            {filter: '.pushChannelId', action: 'disable'},
            {filter: '.pushChannelKey', action: 'disable'},
            {filter: '.pushNotificationsOn', action: 'disable'},
            {filter: '.savePushSettings', action: 'disable'},
            {filter: '.testPushSettings', action: 'disable'},
            {filter: '.notificationSettingsTransportPushApiType', action: 'disable'},
            {filter: '.notificationSettingsTransportPushApiURL', action: 'disable'},
            {filter: '.notificationSettingsTransportPushApiTTL', action: 'disable'}
        ]);

    };

    that.loadMobileSettings = function () {
        $('#tabs-mobile').show();
        commonHelper.callAjaxMethod('settings.htm', 'loadMobileSettings', {}, function (data) {
            $('.mobileLogin').val(data.mobileLogin);
            $('.mobilePassword').val(data.mobilePassword);
            if (data.wtSyncNotificationsOn) {
                $('[name=wtSyncNotificationsOn]').attr('checked', 'checked');
            } else {
                $('[name=wtSyncNotificationsOn]').removeAttr('checked');
            }

        });
    };

    that.loadNotificationParams = function () {
        commonHelper.callAjaxMethod('notifications.htm', 'loadNotificationParams', {}, function (data) {
            //email
            $('[name=smtpHost]').val(data.smtpHost);
            $('[name=smtpPort]').val(data.smtpPort);
            $('[name=smtpUser]').val(data.smtpUser);
            $('[name=smtpPassword]').val(data.smtpPassword);
            if (data.smtpSsl) {
                $('[name=smtpSsl]').attr('checked', 'checked');
            } else {
                $('[name=smtpSsl]').removeAttr('checked');
            }
            if (data.smtpTls) {
                $('[name=smtpTls]').attr('checked', 'checked');
            } else {
                $('[name=smtpTls]').removeAttr('checked');
            }

            if (data.emailNotificationsOn) {
                $('[name=emailNotificationsOn]').attr('checked', 'checked');
            } else {
                $('[name=emailNotificationsOn]').removeAttr('checked');
            }

            if (data.smsNotificationsOn) {
                $('[name=smsNotificationsOn]').attr('checked', 'checked');
            } else {
                $('[name=smsNotificationsOn]').removeAttr('checked');
            }

            if(data.voiceNotificationsOn){
                $('[name=voiceNotificationsOn]').attr('checked', 'checked');
            }else{
                $('[name=voiceNotificationsOn]').removeAttr('checked');
            }
            //console.log(data.pushChannelOn);
            if (data.pushChannelOn) {
                $('[name=pushChannelOn]').attr('checked', 'checked');
                //console.log(1);
            }else{
                $('[name=pushChannelOn]').removeAttr('checked');
            }

            $('[name=smtpFrom]').val(data.smtpFrom);
            $('[name=imapHost]').val(data.imapHost);
            $('[name=imapPort]').val(data.imapPort);
            $('[name=imapUser]').val(data.imapUser);
            $('[name=imapPassword]').val(data.imapPassword);
            //sms
            that.organizationSMSSettings[0] = {
                'smsProvider': data.smsProvider,
                'smsFrom':data.smsFrom,
                'smsToken':data.smsToken,
                'smsAccountId':data.smsAccountId
            };
            that.organizationPushSettings[0] = {
                'pushChannelId':data.pushChannelId,
                'pushChannelKey':data.pushChannelKey
            };
            $('[name=smsProvider]').val(data.smsProvider);
            $('[name=smsFrom]').val(data.smsFrom);
            $('[name=smsToken]').val(data.smsToken);
            $('[name=smsAccountId]').val(data.smsAccountId);
            //voice
            $('[name=voiceProvider]').val(data.voiceProvider);
            $('[name=voiceApiKey]').val(data.voiceApiKey);
            $('[name=voiceProviderPhone]').val(data.voiceProviderPhone);

            // pushapi
            $('[name=pushChannelId]').val(data.pushChannelId);
            $('[name=pushChannelKey]').val(data.pushChannelKey);


            for (var orgid in data.organizations) {
                that.organizationSMSSettings[orgid] = data.organizations[orgid];
            }
            for (var orgid in data.organizations) {
                that.organizationPushSettings[orgid] = data.organizations[orgid];
            }
            for (var orgid in data.organizations) {
                that.organizationVoiceSettings[orgid] = data.organizations[orgid];
            }

            var notificationStatisticMessage = $('#notificationStatisticMessage');
            $('<option>', {value: '', text: ''}).appendTo(notificationStatisticMessage);
            $.each(data.notificationsSettings, function (index, element) {
                $('<option>', {value: index, text: commonHelper.decodeHtmlString(element)}).appendTo(notificationStatisticMessage);
            });

            if (ORGS_COUNT > 0) {
                $('.organizationBlock').show();
                $('.smsOrganization').on('change', function(){
                    that.switchOrganizationSMSSettings($(this).val());
                });
                that.switchOrganizationSMSSettings($('.smsOrganization').val());
            } else {
                $('.organizationBlock').hide();
                that.switchOrganizationSMSSettings(0);
            }
            if (ORGS_COUNT > 0) {
                $('.organizationBlock').show();
                $('.pushOrganization').on('change', function(){
                    that.switchOrganizationPushSettings($(this).val());
                });
                that.switchOrganizationPushSettings($('.pushOrganization').val());
            } else {
                $('.organizationBlock').hide();
                that.switchOrganizationPushSettings(0);
            }
            if (ORGS_COUNT > 0) {
                $('.organizationBlock').show();
                $('.voiceOrganization').on('change', function(){
                    that.switchOrganizationVoiceSettings($(this).val());
                });
                that.switchOrganizationVoiceSettings($('.voiceOrganization').val());
            } else {
                $('.organizationBlock').hide();
                that.switchOrganizationVoiceSettings(0);
            }
        });
    };

    that.switchOrganizationSMSSettings = function(orgid){
        if(orgid == ' ') orgid = 0;
        if(that.currentOrganization != null){
            that.organizationSMSSettings[that.currentOrganization] = {
                'smsProvider': $('[name=smsProvider]').val(),
                'smsFrom':$('[name=smsFrom]').val(),
                'smsToken':$('[name=smsToken]').val(),
                'smsAccountId':$('[name=smsAccountId]').val()
            }
        }
        that.currentOrganization = orgid;
        $('[name=smsProvider]').val(that.organizationSMSSettings[orgid].smsProvider);
        $('[name=smsFrom]').val(that.organizationSMSSettings[orgid].smsFrom);
        $('[name=smsToken]').val(that.organizationSMSSettings[orgid].smsToken);
        $('[name=smsAccountId]').val(that.organizationSMSSettings[orgid].smsAccountId);
    };
    that.switchOrganizationPushSettings = function(orgid){
        if(orgid == ' ') orgid = 0;
        if(that.currentOrganization != null){
            that.organizationPushSettings[that.currentOrganization] = {
                'pushChannelId': $('[name=pushChannelId]').val(),
                'pushChannelKey':$('[name=pushChannelKey]').val()
            }
        }
        that.currentOrganization = orgid;
        $('[name=pushChannelId]').val(that.organizationPushSettings[orgid].pushChannelId);
        $('[name=pushChannelKey]').val(that.organizationPushSettings[orgid].pushChannelKey);
    };
    that.switchOrganizationVoiceSettings = function(orgid){
        if(orgid == ' ') orgid = 0;
        if(that.currentOrganization != null){
            that.organizationVoiceSettings[that.currentOrganization] = {
                'voiceProvider': $('[name=voiceProvider]').val(),
                'voiceApiKey':$('[name=voiceApiKey]').val(),
                'voiceProviderPhone':$('[name=voiceProviderPhone]').val()
            }
        }
        that.currentOrganization = orgid;
        $('[name=voiceProvider]').val(that.organizationVoiceSettings[orgid].voiceProvider);
        $('[name=voiceApiKey]').val(that.organizationVoiceSettings[orgid].voiceApiKey);
        $('[name=voiceProviderPhone]').val(that.organizationVoiceSettings[orgid].voiceProviderPhone);
    };
    that.searchNotificationByText = function () {
        var newSearchSettingsText = $('#notificationSearchText').val();
        var textIsChanged = that.searchSettingsText != newSearchSettingsText;
        that.searchSettingsText = newSearchSettingsText;
        if (textIsChanged) {
            that.refreshNotificationsSettingsList(1);
        }
    };

    that.sendNotifications = function () {
        commonHelper.callAjaxMethod('notifications.htm', 'sendNotifications', {
            notificationNow: $('#notificationNowDate').val()
        });
    };

    that.sendMessages = function (notificationSettingsId) {
        DIALOGS.sendMessageDialog.open(notificationSettingsId);
    };

    that.saveSmsSettings = function () {
        if(that.currentOrganization != null){
            that.organizationSMSSettings[that.currentOrganization] = {
                'smsProvider': $('[name=smsProvider]').val(),
                'smsFrom':$('[name=smsFrom]').val(),
                'smsToken':$('[name=smsToken]').val(),
                'smsAccountId':$('[name=smsAccountId]').val()
            }
        }
        that.organizationSMSSettings[0].smsNotificationsOn = !!$('[name=smsNotificationsOn]:checked').val();
        commonHelper.callAjaxMethod('notifications.htm', 'saveSmsNotificationSettings', {
            data: JSON.stringify(that.organizationSMSSettings)
        });
    };

    that.savePushSettings = function () {
        if(that.currentOrganization != null){
            that.organizationPushSettings[that.currentOrganization] = {
                'pushChannelKey':$('[name=pushChannelKey]').val(),
                'pushChannelId':$('[name=pushChannelId]').val()
            }
        }
        that.organizationPushSettings[0].pushChannelOn = !!$('[name=pushChannelOn]:checked').val();
        commonHelper.callAjaxMethod('notifications.htm', 'savePushNotificationSettings', {
            data: JSON.stringify(that.organizationPushSettings)
        });
    };

    that.saveVoiceSettings = function() {
        if (null != that.currentOrganization) {
            that.organizationVoiceSettings[that.currentOrganization] = {
                'voiceProvider':$('[name=voiceProvider]').val(),
                'apiKey':$('[name=voiceApiKey]').val(),
                'voiceProviderPhone': $('[name=voiceProviderPhone]').val()
            }
        }
        that.organizationVoiceSettings[0].voiceNotificationsOn = !!$('[name=voiceNotificationsOn]:checked').val();
        commonHelper.callAjaxMethod('notifications.htm', 'saveVoiceNotificationSettings', {
            data: JSON.stringify(that.organizationVoiceSettings)
        });
    };

    that.sendTestSmsMessage = function () {
        DIALOGS.sendMessageDialog.openTestMessageDialog('sms');
    };

    that.sendTestVoiceMessage = function(){
        DIALOGS.sendMessageDialog.openTestMessageDialog('voice');
    };
    that.saveEmailSettings = function () {
        commonHelper.callAjaxMethod('notifications.htm', 'saveEmailNotificationSettings', {
            smtpHost: $('[name=smtpHost]').val(),
            smtpPort: $('[name=smtpPort]').val(),
            smtpUser: $('[name=smtpUser]').val(),
            smtpPassword: $('[name=smtpPassword]').val(),
            smtpSsl: $('[name=smtpSsl]:checked').val() ? true : false,
            smtpTls: $('[name=smtpTls]:checked').val() ? true : false,
            smtpFrom: $('[name=smtpFrom]').val(),
            imapHost: $('[name=imapHost]').val(),
            imapPort: $('[name=imapPort]').val(),
            imapUser: $('[name=imapUser]').val(),
            imapPassword: $('[name=imapPassword]').val(),
            emailNotificationsOn: $('[name=emailNotificationsOn]:checked').val() ? true : false
        }, function (data) {
            if (data.smtpInited) {
                $('#smtpState').css('color', 'green');
                $('#smtpState').html(messages['notifications.smtp.ok']);
            } else {
                $('#smtpState').css('color', 'red');
                $('#smtpState').html(messages['notifications.smtp.fail']);
            }

            if (data.supportDsn) {
                $('#smtpDsnState').css('color', 'green');
                $('#smtpDsnState').html(messages['notifications.dsn.ok']);
            } else {
                $('#smtpDsnState').css('color', 'red');
                $('#smtpDsnState').html(messages['notifications.dsn.fail']);
            }

            if (data.imapInited) {
                $('#imapState').css('color', 'green');
                $('#imapState').html(messages['notifications.imap.ok']);
            } else {
                $('#imapState').css('color', 'red');
                $('#imapState').html(messages['notifications.imap.fail']);
            }
        });
    };

    that.sendTestSmtpMessage = function () {
        that.saveEmailSettings();
        DIALOGS.sendMessageDialog.openTestMessageDialog('smtp');
    };

    that.sendTestVoiceMessage = function () {
        that.saveVoiceSettings();
        DIALOGS.sendMessageDialog.openTestMessageDialog('voice');
    };

    that.sendTestImapMessage = function () {
        that.saveEmailSettings();
        DIALOGS.sendMessageDialog.openTestMessageDialog('imap');
    };

    that.sendTestPushMessage = function() {
        //that.savePushSettings();
        DIALOGS.sendMessageDialog.openTestMessageDialog('push');
    };

    that.openNotificationReceiversList = function (notificationId) {
        DIALOGS.recipientsListDialog.show(notificationId);
    };

    that.deleteNotification = function (notificationId) {
        commonHelper.callAjaxMethod('notifications.htm', 'deleteNotification', {notificationId: notificationId}, function (data) {
            currentPage.listNotifications(that.selectedNotificationSettingsId)
        });
    };

    that.editTagToNotification = function (notificationSettingsId, tagId) {
        commonHelper.callAjaxMethod('notifications.htm', 'loadNotificationTag', {tagId: tagId}, function (data) {
            $('#notificationTagDialog').overlay({
                oneInstance: false,
                mask: {
                    color: '#fff',
                    loadSpeed: 0,
                    opacity: 0.5,
                    zIndex: 100
                },
                fixed: true,
                closeOnClick: true
            });

            $('#tagTitle').val('');
            $('#tagMandatory').removeAttr('checked');

            if (data) {
                $('#tagTitle').val(data.title);
                if (data.mandatory) {
                    $('#tagMandatory').attr('checked', 'checked');
                }

            }

            $('#notificationTagDialog').overlay().load();
            $('#notificationTagDialog').css('z-index', (commonHelper.getMaxZIndex() + 1));

            $('#saveNewNotificationTag').unbind();

            $('#saveNewNotificationTag').click(function () {
                commonHelper.callAjaxMethod('notifications.htm', 'saveNotificationTag', {tagId: tagId, tagTitle: $('#tagTitle').val(), mandatory: $('#tagMandatory:checked').val() ? true : false}, function (data) {
                    $('<option>', {text: $('#tagTitle').val(), val: data}).appendTo($('#notificationTagList'));
                    that.addTagToNotification(notificationSettingsId, data);
                });
                $('#notificationTagDialog').overlay().close();
            });
        });
    };

    that.addTagToNotification = function (notificationSettingsId, tagId) {
        if (tagId) {
            commonHelper.callAjaxMethod('notifications.htm', 'addTagToNotificationSettings', {notificationSettingsId: notificationSettingsId, tagId: tagId}, function (data) {
                if (data) {
                    addTagDiv(tagId, data.title);
                }
            });
        }
    };

    var addTagDiv = function (id, title) {
        var tagTemplate = $('.tagTemplate');
        var tag = tagTemplate.clone().removeClass('tagTemplate');
        tag.show().find('.title').html(title);
        tag.attr('tagid', id);
        tag.appendTo($('.notificationSettingsTags'));
    };

    that.removeNotificationTag = function (notificationSettingsId, tagId) {
        commonHelper.callAjaxMethod('notifications.htm', 'removeNotificationTag', {notificationSettingsId: notificationSettingsId, tagId: tagId}, function (data) {
            $('div[tagid=' + tagId + ']').remove();
            if (data) {
                $('#notificationTagList>option[value=' + tagId + ']').remove();
            }
        });
    };

    that.editNotificationTag = function (notificationSettingsId, tagId) {
        that.editTagToNotification(notificationSettingsId, tagId);
    };

    that.listNotifications = function (notificationSettingsId) {
        that.selectedNotificationSettingsId = notificationSettingsId;
        REFERENCE.fillReferenceList('notifications', 'notifications.htm', 'loadGeneratedNotifications', {
            filterParams: {notificationSettingsId: notificationSettingsId},
            sortOrder: 'asc',
            sortName: 'id',
            selectedPage: 1,
            fillCallback: function (list, template, data) {
                var row = template.clone();
                row.removeClass('notificationsTemplate');
                row.show();
                row.appendTo(list);

                return list.directives({
                        '.notificationsRow': {
                            'row <- rows': {
                                '.notificationIdRow@value': 'row.id',
                                '.subject': 'row.subject',
                                '.sendDate': 'row.senddate',
                                '.organization': 'row.orgname',
                                '.status': function (context) {
                                    switch (context.item.status) {
                                        case 'Finished':
                                            return messages['notifications.status.finished'];
                                        case 'Progress':
                                            return messages['notifications.status.progress'];
                                    }
                                    return context.item.status;
                                },
                                '.successNotificationCount': 'row.successnotifications',
                                '.failedNotificationCount': 'row.failednotifications'
                            }
                        }
                    }
                ).render(data);

            }
        });
    };

    that.editNotificationSettings = function (notificationSettingsId) {
        commonHelper.callAjaxMethod('notifications.htm', 'loadNotificationSettings', {id: notificationSettingsId}, function (data) {
            if (!data) {
                data = {};
                data.notificationSettings = {
                    name: '',
                    subject: '',
                    daysBeforeSend: '',
                    sendTime: '',
                    dueSendingTime: '',
                    transport: '',
                    transportBase: true,
                    transportAdditional: false,
                    text: '',
                    notificationSettingsActive: '',
                    voiceBare: '',
                    fileId: '',
                    managerPhone: '',
                    voiceGender: '',
                    pushType: '',
                    pushURL: '',
                    pushTTL: ''
                };
            }

            var notificationSettingsDialog = $('#notificationSettingsDialog').directives({
                '.notificationSettingsId@value': 'notificationSettings.id',
                '.notificationSettingsName@value': 'notificationSettings.name',
                '.notificationSettingsSubject@value': 'notificationSettings.subject',
                '.notificationSettingsDaysBeforeSend@value': 'notificationSettings.daysBeforeSending',
                '.notificationSettingsText': 'notificationSettings.template',
                '.notificationSettingsActive@checked': function (context) {
                    return context.context.notificationSettings ? context.context.notificationSettings.active ? 'checked' : '' : '';
                },
                '.notificationSettingsTransportBase@checked': function (context) {
                    return context.context.notificationSettings ? context.context.notificationSettings.transportBase ? 'checked' : '' : '';
                },
                '.notificationSettingsTransportAdditional@checked': function (context) {
                    return context.context.notificationSettings ? context.context.notificationSettings.transportAdditional ? 'checked' : '' : '';
                },
                '.voiceBare@checked' : function (context) {
                    return context.context.notificationSettings ? context.context.notificationSettings.voiceBare ==='File' ? 'checked' : '' : '';
                },
                '.notificationSettingsTransportTypeVoiceFileId@value' : 'notificationSettings.fileId',
                '.notificationSettingsTransportTypeVoiceManagerPhone@value' : 'notificationSettings.managerPhone',
                '#notificationSettingsTransportTypeVoiceTextGenderMale@value':'male',
                '#notificationSettingsTransportTypeVoiceTextGenderFemale@value':'female',
                '#notificationSettingsTransportTypeVoiceTextGenderMale@checked': function (context) {
                    return context.context.notificationSettings ? context.context.notificationSettings.voiceGender ==='Male' ? 'checked' : '' : '';
                },
                '#notificationSettingsTransportTypeVoiceTextGenderFemale@checked':function (context) {
                    return context.context.notificationSettings ? context.context.notificationSettings.voiceGender ==='Female' ? 'checked' : '' : '';
                }
            }).render(data);

            commonHelper.setTimePicker(notificationSettingsDialog.find('#notificationSettingsSendTime'));
            commonHelper.setTimePicker(notificationSettingsDialog.find('#notificationSettingsDueSendingTime'));


            if (data.tags) {
                $('#notificationTagList').children().remove();
                $.each(data.tags, function (index, item) {
                    $('<option>', {text: item.title, val: item.id}).appendTo($('#notificationTagList'));
                });
            }
            $('.templateVariable').remove();
            $('<div>', {'class': 'templateVariable'}).appendTo($('#notificationSettingsDialog').find('.templateVariables'));
            $('#notificationSettingsDialog').find('.templateVariables').directives({
                '.templateVariable': {
                    'variable <- variables': {
                        '.': '${#{variable}}'
                    }
                }
            }).render(data);

            if (data.notificationSettings) {
                notificationSettingsDialog.find('.notificationSettingsTransport').val(data.notificationSettings.transport);
                notificationSettingsDialog.find('.notificationSettingsSendTime').val(data.notificationSettings.sendingTime);
                notificationSettingsDialog.find('.notificationSettingsDueSendingTime').val(data.notificationSettings.dueSendingTime);


                $('.notificationSettingsTags').children().remove();
                if (data.notificationSettings.tags) {
                    $.each(data.notificationSettings.tags, function (index, item) {
                        addTagDiv(item.id, item.title);
                    });
                }
                $('.tagPanel').show();
            } else {
                $('.tagPanel').hide();
            }

            notificationSettingsDialog.find('.notificationSettingsTransport').change(function(){
                var val = $(this).val();
                if(val === 'Email' || val === 'Sms' || val === 'Voice' || val === 'Push'){
                    notificationSettingsDialog.find('.notificationSettingsTransportTypes').show();
                }
                else {
                    notificationSettingsDialog.find('.notificationSettingsTransportTypes').hide();
                }
                if(val === 'Voice'){
                    notificationSettingsDialog.find('.notificationSettingsTransportTypeVoice').show();
                }else {
                    notificationSettingsDialog.find('.notificationSettingsTransportTypeVoice').hide();
                }
                if (val === "Push") {
                    notificationSettingsDialog.find('.notificationSettingsTransportTypePush').show();
                } else {
                    notificationSettingsDialog.find('.notificationSettingsTransportTypePush').hide();
                }

            });
            notificationSettingsDialog.find('.notificationSettingsTransport').trigger("change");
            $('.notificationSettingsTransportTypeVoiceBare input').on('change', function() {
                var bare = $('input[name=voiceBare]:checked', '.notificationSettingsTransportTypeVoiceBare').attr('id');
                if(bare === 'notificationSettingsTransportTypeVoiceBareFile'){
                    $('.notificationSettingsTransportTypeVoiceFile').find('.notificationSettingsTransportTypeVoiceFile').show();
                    $('.notificationSettingsTransportTypeVoiceText').find('.notificationSettingsTransportTypeVoiceText').hide();
                }else if (bare === 'notificationSettingsTransportTypeVoiceBareText'){
                    $('.notificationSettingsTransportTypeVoiceFile').find('.notificationSettingsTransportTypeVoiceFile').hide();
                    $('.notificationSettingsTransportTypeVoiceText').find('.notificationSettingsTransportTypeVoiceText').show();
                }
            });
            REFERENCE.openEditReferenceDialog('notificationSettingsDialog', {
                    buttons: {
                        'saveButton': {
                            title: messages['common.save'],
                            action: function () {

                                var params = collectionNotificationSettingsParams();
                                var validate = function (params) {

                                    return true;
                                };

                                if (validate(params)) {
                                    commonHelper.callAjaxMethod('notifications.htm', 'saveNotificationSettings', {data: JSON.stringify(params)}, function (data) {
                                        if (!data) {
                                            commonHelper.showMessage(messages['notifications.saveerror']);
                                        } else {
                                            that.refreshNotificationsSettingsList();
                                            REFERENCE.closeEditReferenceDialog('notificationSettingsDialog');
                                        }
                                    });
                                }
                            }
                        },
                        'deleteButton': {
                            title: messages['common.remove'],
                            position: 'left',
                            action: function () {
                                that.deleteNotificationSettings(notificationSettingsId);
                            }
                        }
                    },
                    onClose: function () {

                    }
                }
            );

            var collectionNotificationSettingsParams = function () {
                var dialog = $('#notificationSettingsDialog');
                return {
                    id: dialog.find('.notificationSettingsId').val(),
                    name: dialog.find('.notificationSettingsName').val(),
                    subject: dialog.find('.notificationSettingsSubject').val(),
                    daysBeforeSend: dialog.find('.notificationSettingsDaysBeforeSend').val(),
                    sendTime: dialog.find('.notificationSettingsSendTime').val(),
                    sendDueTime: dialog.find('.notificationSettingsDueSendingTime').val(),
                    transport: dialog.find('.notificationSettingsTransport').val(),
                    transportBase: !!dialog.find('.notificationSettingsTransportBase:checked').val(),
                    transportAdditional: !!dialog.find('.notificationSettingsTransportAdditional:checked').val(),
                    text: dialog.find('.notificationSettingsText').val(),
                    active: !!dialog.find('.notificationSettingsActive:checked').val(),
                    voiceBare: !!dialog.find('.voiceBare:checked').val(),
                    fileId: $('[name=notificationSettingsTransportTypeVoiceFileId]').val(),
                    managerPhone: $('[name=notificationSettingsTransportTypeVoiceManagerPhone]').val(),
                    voiceGender: $('[name=gender]:checked').val(),
                    pushType: $('#notificationSettingsTransportPushApiType').val(),
                    pushTTL: $('#notificationSettingsTransportPushApiTTL').val(),
                    pushURL: $('#notificationSettingsTransportPushApiURL').val()
                };
            }
        });

    };

    that.deleteNotificationSettings = function (notificationSettingsId) {
        DIALOGS.askYesNoDialog(messages['notifications.removeconfirm'], messages['common.remove'], function () {
            commonHelper.callAjaxMethod('notifications.htm', 'deleteNotificationSettings', {notificationSettingsId: notificationSettingsId}, function (data) {
                that.refreshNotificationsSettingsList();
                REFERENCE.closeEditReferenceDialog('notificationSettingsDialog');
            });
        });
    };

    that.clearNotificationStatisticFilter = function () {
        $('#notificationStatisticFrom').val('');
        $('#notificationStatisticTo').val('');
        $('#notificationStatisticStatus').val('');
        $('#notificationStatisticMessage').val('');
    };

    that.refreshNotificationStatistic = function () {
        if (!notificationsStatisticDataGrid) {
            var colNames = [];
            if (ORGS_COUNT > 0) {
                colNames.push(messages['notifications.stat.organization']);
            }
            colNames.push(messages['notifications.stat.name']);
            colNames.push(messages['notifications.stat.transport']);
            colNames.push(messages['notifications.stat.receiver']);
            colNames.push(messages['notifications.stat.createdate']);
            colNames.push(messages['notifications.stat.actiondate']);
            colNames.push(messages['notifications.stat.planneddate']);
            colNames.push(messages['notifications.stat.actualdate']);
            colNames.push(messages['notifications.stat.status']);
            colNames.push('');

            var colModels = [];
            if (ORGS_COUNT > 0) {
                colModels.push({name: 'orgid', index: 'orgid', edittype:'select', formatter : 'select', editoptions:{value:':;'+ORGS_SELECT}});
            }
            colModels.push({name: 'name', index: 'name', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'transport', index: 'transport', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'receiver', index: 'receiver', formatter: function (cellvalue, options, rowObject) {
                return '<a href="client.htm?childid=' + rowObject.receiverid + '">' + cellvalue + '</a>';
            }});
            colModels.push({name: 'createdate', index: 'createdate', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'actiondate', index: 'actiondate', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'plannedsenddate', index: 'plannedsenddate', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'actualsentdate', index: 'actualsentdate', formatter: commonHelper.notNullFormatter});
            colModels.push({name: 'status', index: 'status', formatter: function (context) {
                switch (context) {
                    case 'Ok' :
                        return '<span style="color:green">' + messages['notifications.stat.status.ok'] + '</span>';
                    case 'Failed' :
                        return '<span style="color:red">' + messages['notifications.stat.status.failed'] + '</span>';
                    case 'Progress' :
                        return '<span style="color:blue">' + messages['notifications.stat.status.progress'] + '</span>';
                    case 'Sending' :
                        return '<span style="color:blue">' + messages['notifications.stat.status.sending'] + '</span>';
                    case 'Overdue' :
                        return '<span style="color:orange">' + messages['notifications.stat.status.overdue'] + '</span>';
                }
                return '';
            }});
            colModels.push({name: 'resulttitle', index: 'resulttitle', formatter: commonHelper.notNullFormatter});

            notificationsStatisticDataGrid = $('#notificationsStatistic').jqGrid({
                datatype: loadNotificationsStatisticLists,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                jsonReader: { repeatitems: false, id: "id"},
                pager: '#notificationsStatisticPager',
                sortname: 'plannedsenddate', viewrecords: true, sortorder: "asc",
                ondblClickRow: function (rowid, iRow, iCol, e) {
                    commonHelper.callAjaxMethod('notifications.htm', 'loadNotificationResultMessage',
                        {notificationResultId: rowid}, function (result) {
                            commonHelper.showBigMessage(result != '' ? result : messages['notifications.nocomment']);
                        }, true);

                }
            });
            notificationsStatisticDataGrid.jqGrid('setGridWidth', $('#tabs-notificationsList').parent(null).width() - 70);
        } else {
            notificationsStatisticDataGrid.setGridParam({
                page: 1
            });
            notificationsStatisticDataGrid.trigger("reloadGrid");
        }
    };

    var loadNotificationsStatisticLists = function (postdata) {
        postdata.notificationStatisticFrom = $('#notificationStatisticFrom').val() ? $('#notificationStatisticFrom').val() : '';
        postdata.notificationStatisticTo = $('#notificationStatisticTo').val() ? $('#notificationStatisticTo').val() : '';
        postdata.notificationStatisticStatus = $('#notificationStatisticStatus').val() ? $('#notificationStatisticStatus').val() : '';
        postdata.notificationStatisticMessage = $('#notificationStatisticMessage').val() ? $('#notificationStatisticMessage').val() : '';

        commonHelper.callAjaxMethod('notifications.htm', 'loadNotificationsStatistic',
            postdata, function (result) {
                notificationsStatisticDataGrid.clearGridData(true);
                notificationsStatisticDataGrid[0].addJSONData(result);
            }, true);
    };

    that.refreshNotificationsSettingsList = function (selectedPage) {
        REFERENCE.fillReferenceList('notificationSettings', 'notifications.htm', 'loadNotificationsSettings', {
            selectedPage: selectedPage,
            sortOrder: 'asc',
            sortName: 'id',
            rowsOnPage: 4,
            filterParams: {
                searchSettingsText: that.searchSettingsText
            },
            fillCallback: function (list, template, data) {
                var row = template.clone();
                row.removeClass('notificationSettingsTemplate');
                row.show();
                row.appendTo(list);

                return list.directives({
                        '.notificationSettingsRow': {
                            'row <- rows': {
                                '.notificationSettingsRowId@value': 'row.notificationSettings.id',
                                '.name': 'row.notificationSettings.name',
                                '.subject': 'row.notificationSettings.subject',
                                '.transport': 'row.notificationSettings.transport',
                                '.daysBeforeSending': 'row.notificationSettings.daysBeforeSending',
                                '.sendingTime': 'row.notificationSettings.sendingTime',
                                '.dueSendingTime': 'row.notificationSettings.dueSendingTime',
                                '.active': function (context) {
                                    return context.item.notificationSettings.active ? messages['notifications.active.yes'] : messages['notifications.active.no']
                                },
                                '.active@style': function (context) {
                                    return context.item.notificationSettings.active ? 'color: green' : 'color: red'
                                },
                                '.tags': function (context) {
                                    var result = '';
                                    $.each(context.item.notificationSettings.tags, function (index, item) {
                                        result += item.title + ';';
                                    });
                                    return result;
                                },
                                '.text': function (context) {
                                    var textLength = Math.min(4 * 400, context.item.notificationSettings.template.length);
                                    return context.item.notificationSettings.template.substring(0, textLength) + (textLength != context.item.notificationSettings.template.length ? '...' : '');
                                }
                            }
                        }
                    }
                ).render(data);

            }
        });
    };

    this.saveMobileSettings = function () {
        commonHelper.callAjaxMethod('notifications.htm', 'saveMobileSettings', {
            mobileLogin: $('.mobileLogin').val(),
            mobilePassword: $('.mobilePassword').val(),
            wtSyncOn: $('[name=wtSyncNotificationsOn]:checked').val() ? true : false
        }, function (data) {

        });
    };

    /**this.savePushSettings = function() {
        commonHelper.callAjaxMethod('notifications.htm', 'savePushSettings', {
            pushChannelId: $('.pushChannelId').val(),
            pushChannelKey: $('.pushChannelKey').val()
        }, function (data) {

        });
    };*/

    this.restartApp = function () {
        $.ajax({
            url: '/updater/restart',
            type: 'get',
            async: false,
            data: {},
            dataType: 'json',
            success: function (result) {
                window.location = 'index.htm'
            },
            error: function (data) {
                $('#serverversiondescription').html(messages['notifications.restarterror']);
            }
        });
    };

    return this;
}function payment_helper() {
    var that = this;

    var openedTab = {};

    that.settings = new paymentSettings_helper(that);
    that.statistic = new paymentStatistic_helper(that);

    that.TABLE_WIDTH = 0;

    this.pageReady = function () {
        $('#tabs-payment').tabs();
        that.TABLE_WIDTH = $('#tabs-payment').parent(null).width() - 70;

        $('#tabs-payment').tabs({
            show: function (event, ui) {
                $(ui.panel).show();
                onTabSelected(ui.index);
            }
        });
        prepareTabs();
    };

    var prepareTabs = function () {
        var disabledTabs = [];

        $('#tabs-payment').tabs({selected: 1});
        onTabSelected(1);
        commonHelper.checkPermission('paymentsettings', function () {
        }, function () {
            disabledTabs.push(0);
        });
        $('#tab-payment-stat').show();

        $('#tabs-payment').tabs("option", "disabled", disabledTabs);
        $('button').button();
    };

    var onTabSelected = function (index) {
        switch (index) {
            case 0:
                that.settings.display();
                break;
            case 1:
                that.statistic.display();
                break;
        }
    };

    return this;
}function phone_helper() {
    var that = this;

    var openedTab = {};

    that.statistics = new phoneStatistics_helper(that);
    that.references = new phoneReferences_helper();

    that.TABLE_WIDTH = 0;

    that.organizationSettings = {}
    that.currentOrganization = null;

    this.pageReady = function () {
        $('#tabs-phone').tabs();
        that.TABLE_WIDTH = $('#tabs-phone').parent(null).width() - 70;

        $('#tabs-phone').tabs({
            show: function (event, ui) {
                $(ui.panel).show();
                onTabSelected(ui.index);
            }
        });

        prepareTabs();

        that.loadPhoneSettings();
    };

    var prepareTabs = function () {
        var disabledTabs = [];
        var firstTabSelected = true;

        commonHelper.checkPermission('phone', function () {
            onTabSelected(0);
        }, function () {
            onTabSelected(0);
            disabledTabs.push(1);
            disabledTabs.push(2);
            disabledTabs.push(3);
        });

        $('#tab-phone-stat').show();
        $('#tabs-phone').tabs("option", "disabled", disabledTabs);

        $('button').button();
    };

    var onTabSelected = function (index) {
        switch (index) {
            case 0:
                that.statistics.display();
                break;
            case 1:
                that.references.display();
                break;
        }
    };

    that.loadPhoneSettings = function () {
        if (ORGS_COUNT > 0) {
            $('.organizationBlock').show();
            $('.phoneOrganization').on('change', function(){
                that.switchOrganizationSettings($(this).val());
            });
        } else {
            $('.organizationBlock').hide();
        }
        
        commonHelper.callAjaxMethod('phone.htm', 'loadPhoneSettings', {}, function (data) {
            that.organizationSettings[0] = {
                'phoneKey': data.phoneKey,
                'phoneSecret':data.phoneSecret,
                'pbxProvider':data.pbxProvider,
                'realm':data.realm
            }
            for (var orgid in data.organizations) {
                that.organizationSettings[orgid] = data.organizations[orgid];
            }
            that.switchOrganizationSettings(0);
            
            $('#phoneLastSyncDate').text(data.phoneLastSyncDate);
            $('[name=phoneDownloadRecords]').attr('checked', data.phoneDownloadRecords);
            $('[name=phoneExceptions]').val(data.phoneExceptions);
        });
    };

    that.switchOrganizationSettings = function(orgid){
        if(orgid == ' ') orgid = 0;
        if(that.currentOrganization != null){
            that.organizationSettings[that.currentOrganization] = {
                'phoneKey': $('[name=phoneKey]').val(),
                'phoneSecret':$('[name=phoneSecret]').val(),
                'pbxProvider':$('[name=pbxProvider]').val(),
                'realm':$('[name=realm]').val()
            }
        }
        that.currentOrganization = orgid;
        $('[name=phoneKey]').val(that.organizationSettings[orgid].phoneKey);
        $('[name=phoneSecret]').val(that.organizationSettings[orgid].phoneSecret);
        $('[name=pbxProvider]').val(that.organizationSettings[orgid].pbxProvider);
        $('[name=realm]').val(that.organizationSettings[orgid].realm);
    }

    that.savePhoneSettings = function () {
        if(that.currentOrganization != null){
            that.organizationSettings[that.currentOrganization] = {
                'phoneKey': $('[name=phoneKey]').val(),
                'phoneSecret':$('[name=phoneSecret]').val(),
                'pbxProvider':$('[name=pbxProvider]').val(),
                'realm':$('[name=realm]').val()
            }
        }
        that.organizationSettings[0].phoneDownloadRecords = $('#phoneDownloadRecords:checked').val() ? true : false;
        that.organizationSettings[0].phoneExceptions = $('#phoneExceptions').val();
        commonHelper.callAjaxMethod('phone.htm', 'savePhoneSettings', {
            data: JSON.stringify(that.organizationSettings)
        });
    };

    that.synchronizePhoneCalls = function () {
        commonHelper.callAjaxMethod('phone.htm', 'synchronizePhoneCalls', {}, function (data) {
            if(data.phoneLastSyncDate){
                $('#phoneLastSyncDate').text(data.phoneLastSyncDate);
                commonHelper.showMessage(messages['phone.sync'] + ' ' + data.addedCount + ' ' + messages['phone.sync2']);
            }
        });
    }

    that.sendSMS = function () {
        commonHelper.callAjaxMethod('phone.htm', 'sendSMS', {
            phoneSMSPhone: $('#phoneSMSPhone').val(),
            phoneSMSMessage: $('#phoneSMSMessage').val()
        }, function (data) {
            if(data.status == 'ok'){
                commonHelper.showMessage(messages['phone.messagesend']);
            }
            else if(data.status == 'error'){
                commonHelper.showMessage(data.error);
            }
        });
        return false;
    };

    return this;
}function products_helper() {
    var that = this;

    var openedTab = {};

    that.products = new productsProducts_helper(that);
    that.components = new productsComponents_helper(that);
    that.tmc = new productsTMC_helper(that);
    that.statistics = new productsStatistics_helper(that);
    that.references = new productsReferences_helper();
    that.sell = new productsSell_helper(that);

    that.TABLE_WIDTH = 0;

    this.pageReady = function () {
        $('#tabs-products').tabs();
        that.TABLE_WIDTH = $('#tabs-products').parent(null).width() - 70;

        $('#tabs-products').tabs({
            show: function (event, ui) {
                $(ui.panel).show();
                onTabSelected(ui.index);
            }
        });

        prepareTabs();
    };

    var prepareTabs = function () {
        onTabSelected(0);
        $('#tab-products-products').show();
        $('button').button();
    };

    var onTabSelected = function (index) {
        switch (index) {
            case 0:
                that.products.display();
                break;
            case 1:
                that.components.display();
                break;
            case 2:
                that.tmc.display();
                break;
            case 3:
                that.statistics.display();
                break;
            case 4:
                that.references.display();
                break;
            case 5:
                that.sell.display();
                break;
        }
    };

    return this;
}function receipt_helper() {
    var that = this;

    var openedTab = {};

    that.stat = new receiptStat_helper(that);
    that.settings = new receiptsettings_helper(that);
    that.errors = new receiptErrors_helper(that);
    that.work = new receiptwork_helper(that);

    that.TABLE_WIDTH = 0;

    this.pageReady = function () {
        $('#tabs-receipt').tabs();
        that.TABLE_WIDTH = $('#tabs-receipt').parent(null).width() - 70;

        $('#tabs-receipt').tabs({
            show: function (event, ui) {
                $(ui.panel).show();
                onTabSelected(ui.index);
            }
        });

        prepareTabs();
    };

    var prepareTabs = function () {
        var disabledTabs = [];
        var tabSelected = false;
        commonHelper.checkPermission('receiptcash', function () {
            if(!tabSelected){
                onTabSelected(0);
                $('#tab-receipt-stat').show();
                tabSelected = true;
            }
        }, function () {
            disabledTabs.push(0);
            disabledTabs.push(2);
        });

        commonHelper.checkPermission('receiptsettings', function () {
            if(!tabSelected){
                $("#tabs-receipt").tabs({selected: 1});
                onTabSelected(1);
                $('#tab-receipt-settings').show();
                tabSelected = true;
            }
        }, function () {
            disabledTabs.push(1);
        });

        commonHelper.checkPermission('receiptwork', function () {
            if(!tabSelected){
                $("#tabs-receipt").tabs({selected: 3});
                onTabSelected(3);
                $('#tab-receipt-work').show();
                tabSelected = true;
            }
        }, function () {
            disabledTabs.push(3);
        });

        $('#tabs-receipt').tabs("option", "disabled", disabledTabs);

        $('button').button();
    };

    var onTabSelected = function (index) {
        switch (index) {
            case 0:
                that.stat.display();
                break;
            case 1:
                that.settings.display();
                break;
            case 2:
                that.errors.display();
                break;
            case 3:
                that.work.display();
                break;
        }
    };

    return this;
}function scheduler_helper() {
    var that = this;

    that.currentOrgId = CURRENT_ORG;
    that.currentBubbleDialog = null;

    that.month = new schedulerMonth_helper(that);
    that.week = new schedulerWeek_helper(that);
    that.tasks = new schedulerTasks_helper(that);

    this.pageReady = function () {
        $('#tabs-scheduler').tabs();
        $('#tabs-scheduler').tabs({
            show: function (event, ui) {
                $(ui.panel).show();
                onTabSelected(ui.index);
            }
        });

        prepareTabs();

        commonHelper.registerChangeOrganizationListener(function (orgid) {
            that.currentOrgId = orgid;
            that.month.changeOrganization(orgid);
            that.week.changeOrganization(orgid);
            that.tasks.changeOrganization(orgid);
        });

        $('.icon-addsubscription').live('click', function(e){
            e.stopPropagation();
            var _that = $(this);
            DIALOGS.subscriptionDialogs.openSubscriptionDialogForScheduleActualDay({
                subscriptionType: 'subscription',
                scheduleId: _that.attr('data-scheduleid'),
                plannedDate: _that.attr('data-date'),
                callbackFunction: function () {
                    //TODO: update current tab
                }
            });
            return false;
        });
        $('.icon-addoncelesson').live('click', function(e){
            e.stopPropagation();
            var _that = $(this);
            DIALOGS.subscriptionDialogs.openSubscriptionDialogForScheduleActualDay({
                subscriptionType: 'onceLesson',
                scheduleId: _that.attr('data-scheduleid'),
                plannedDate: _that.attr('data-date'),
                callbackFunction: function () {
                    //TODO: update current tab
                }
            });
            return false;
        });
        $('.icon-addreservation').live('click', function(e){
            e.stopPropagation();
            var _that = $(this);
            DIALOGS.subscriptionDialogs.openSubscriptionDialogForScheduleActualDay({
                subscriptionType: 'reservation',
                scheduleId: _that.attr('data-scheduleid'),
                plannedDate: _that.attr('data-date'),
                callbackFunction: function () {
                    //TODO: update current tab
                }
            });
            return false;
        });
    };

    var prepareTabs = function () {
        $('#tab-scheduler-month').show();
        onTabSelected(0);
        $('button').button();
    };

    var onTabSelected = function (index) {
        switch (index) {
            case 0:
                that.month.display();
                break;
            case 1:
                that.week.display();
                break;
            case 2:
                that.tasks.display();
                break;
        }
    };
    
    that.showEventInfo = function(type, id, target) {
        if(type == 'subscriptionfinish'){
            var params = id.split('-');
            window.open('client.htm?action=openChild&actionParameters=' + JSON.stringify({
                    childId: params[1]
                }), '_blank');
        }
        else {
            var params = {};
            params.type = type;
            params.id = id;
            commonHelper.callAjaxMethod('calendar.htm', 'loadObjectInfo', params, function (data) {
                var content;
                if (type == 'task') {
                    content = $('#eventTemplate').clone().directives({
                        '.eventContainer@id': 'task.id',
                        '.eventContainer@type': '"task.task"',
                        '.eventContainer@status': 'task.status',
                        '.taskchild': '#{task.child.firstName}  #{task.child.lastName}',
                        '.tasksubject': 'task.subject',
                        '.tasktype': 'task.type.title',
                        '.taskdate': 'task.date',
                        '.taskphone' : 'family.phone',
                        '.taskparent' : 'family.parentName'
                    }).render(data);
                } else if (type == 'subscriptions') {
                    content = $('#subscriptionsTemplate').clone().directives({
                        '.subscriptionContainer@id': 'subscriptions-#{actualDay.id}',
                        '.subscriptionContainer@type': '"subscriptions"',
                        '.plannedDate': '#{actualDay.plannedDate} #{actualDay.plannedStartTime}-#{actualDay.plannedFinishTime}',
                        '.actualDate': '#{actualDay.actualDate} #{actualDay.actualStartTime}-#{actualDay.actualFinishTime}',
                        '.course': 'course.name',
                        '.comment': 'scheduleComment',
                        '.teacher': 'teacher.name',
                        '.room': 'actualDay.plannedRoom.title',
                        '.actualdaycomment': 'actualDay.comment',
                        '.removedateLink@style': activeStatus,
                        '.changedateLink@style': activeStatus,
                        '.changeTeacherLink@style': activeStatus,
                        '.reservationRow@style': activeStatus,
                        '.childRow@style': activeStatus,
                        '.separatorRow@style': activeStatus,
                        '.canceledLesson': lessonStatus,
                        '.kidrow': {
                            'element <-children': {
                                '.childinfo': '<a href="client.htm?childid=#{element.child.id}">#{element.child.firstName} #{element.child.lastName}</a>',
                                '.childage': '#{element.child.age}',
                                '.visited': generateVisited,
                                '.phone': '#{element.phone}',
                                '.familylink@id': 'element.familyId'
                            }
                        },
                        '.reservationrow': {
                            'element <-reservation': {
                                '.reservchildinfo': '<a href="client.htm?childid=#{element.child.id}">#{element.child.firstName} #{element.child.lastName}</a>',
                                '.reservchildage': '#{element.child.age}',
                                '.reservphone': '#{element.phone}',
                                '.reservfamilylink@id': 'element.familyId'
                            }
                        }

                    }).render(data);
                    if (data.actualTeacher.id != data.teacher.id) {
                        content.find('.actualTeacher').html(data.actualTeacher.name);
                        content.find('.actualTeacherDiv').show();
                    }
                    if (data.additionalTeacher) {
                        content.find('.additionalTeacher').html(data.additionalTeacher.name);
                    }
                    if (data.actualAdditionalTeacher && (!data.additionalTeacher || data.actualAdditionalTeacher.id != data.additionalTeacher.id)) {
                        content.find('.actualAdditionalTeacher').html(data.actualAdditionalTeacher.name);
                        content.find('.actualAdditionalTeacherDiv').show();
                    }

                    var cancelDayLink = content.find('#canceldaylink');
                    cancelDayLink.attr('canceled', data.actualDay.canceled);

                    if (data.actualDay.canceled) {
                        cancelDayLink.html(messages['calendar.activate']);
                    } else {
                        cancelDayLink.html(messages['calendar.cancel']);
                    }

                    commonHelper.prepareViewer([
                        {filter: '#canceldaylink', action: 'hide'},
                        {filter: '.changedateLink', action: 'hide'},
                        {filter: '.removedateLink', action: 'hide'},
                        {filter: '.changeTeacherLink', action: 'hide'}
                    ], content);
                }

                if (target) {
                    that.currentBubbleDialog = BUBBLE_DIALOG.show(target, content);
                }

            }, true, true);
        }
    }

    that.openTask = function (buttonObject) {
        var taskId = $(buttonObject).parents().filter('.eventContainer').attr('id');
        that.currentBubbleDialog = false;
        DIALOGS.taskEditDialog(taskId, null, null, null, false, false, function (task) {
            $('#taskscalendar').fullCalendar('refetchEvents');
        }, function (event) {
            that.currentBubbleDialog = true;
        });
    };

    var lessonStatus = function (context) {
        return context.context.actualDay.canceled ? messages['calendar.canceled'] : '';
    };

    var activeStatus = function (context) {
        return context.context.actualDay.canceled ? 'display: none' : '';
    };

    var generateVisited = function (context) {
        return context.item.visited ? '\u2714' : context.item.missed ? 'x' : '';
    };

    return this;
}function settings_helper() {
    var that = this;
    var clientPrinting = false;
    var openedTab = {};

    that.usersAndOrganizations = new usersAndOrganizations_helper();
    that.references = new references_helper();
    that.schedules = new schedules_helper();
    that.contracts = new contracts_helper();

    this.pageReady = function () {
        var refTabs = $('#tabs-reference');
        refTabs.tabs();

        refTabs.tabs({
            show: function (event, ui) {
                $(ui.panel).css('visibility', "visible");
                onTabSelected(ui.index);
            }
        });

        onTabSelected(refTabs.tabs('option', 'selected'));

        openedTab[0] = true;
        that.schedules.init();
        that.usersAndOrganizations.init();

        var disabledTabs = [];
        commonHelper.checkPermission('usersOrganizations', function () {

        }, function () {
            disabledTabs.push(5);
        });

        commonHelper.checkPermission('backup', function () {

        }, function () {
            disabledTabs.push(4);
        });

        commonHelper.checkFeature('SALARY', function () {
            $('.maxSalaryLessonPriceCount').show();
        }, function () {
            $('.maxSalaryLessonPriceCount').hide();
        });

        if (!AUTHORITIES) {
            disabledTabs.push(6);
        }

        refTabs.tabs("option", "disabled", disabledTabs);

        $('button').button();
        commonHelper.prepareViewer([
            {filter: '#addSimpleSchedule', action: 'delete'},
            {filter: '#addCompositeSchedule', action: 'delete'},
            {filter: '.addDayButton', action: 'delete'},
            {filter: '#addPrice', action: 'delete'},
            {filter: '#personalChangePassword', action: 'delete'},
            {filter: '#usersAddUser', action: 'delete'},
            {filter: '.deleteUser', action: 'hide'},
            {filter: '.changePassword', action: 'hide'},
            {filter: '.editUser', action: 'hide'},
            {filter: '#passwordsRequiredDiv', action: 'delete'},
            {filter: '#generateBirthDate', action: 'disable'},
            {filter: '#organizationsAddOrganization', action: 'delete'},
            {filter: '.mobileLogin', action: 'disable'},
            {filter: '.mobilePassword', action: 'disable'},
            {filter: '.csvReport', action: 'disable'},
            {filter: '.maxSalaryLessonPriceCount', action: 'disable'},
            {filter: '.sessionDuration', action: 'disable'}
        ]);

        loadUpdateDescription();
        disableForDemo();
    };

    var onTabSelected = function (tabIndex) {
        switch (tabIndex) {
            case 0:
                if (!openedTab[0]) {
                    openedTab[0] = true;
                    that.schedules.init();
                }
                break;

            case 1:
                if (!openedTab[1]) {
                    openedTab[1] = true;
                    that.references.init();
                }
                break;

            case 2:
                if (!openedTab[2]) {
                    openedTab[2] = true;
                    openedTab[3] = true;
                    that.loadSettings();
                }
                break;

            case 3:
                if (!openedTab[3]) {
                    openedTab[2] = true;
                    openedTab[3] = true;
                    that.loadSettings();
                }
                break;

            case 4:
                that.loadSettings();
                break;

            case 5:
                if (!openedTab[5]) {
                    openedTab[5] = true;
                    that.loadSettings();
                    that.usersAndOrganizations.loadUsers();
                    commonHelper.checkFeature('ORGANIZATIONS', function () {
                        that.usersAndOrganizations.loadOrganizations();
                    }, function () {
                    });
                }
                break;
            case 6:
                break;
            case 7:
                if (!openedTab[7]) {
                    openedTab[7] = true;
                    that.contracts.init();
                }
                break;
        }
    };

    this.loadSettings = function () {
        commonHelper.callAjaxMethod('settings.htm', 'loadSettings', {}, function (data) {
            var printersList = $('#printersList');
            printersList.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(printersList);
            printersList.directives({
                'option': {
                    'printer <- printers': {
                        '.': 'printer.name',
                        '@value': 'printer.name',
                        '@selected': function (context) {
                            if (context.item.selected == true) {
                                return 'selected';
                            } else {
                                return '';
                            }

                        }
                    }
                }
            }).render(data.printers);
            //yearFormat
            $('#companyInfo').directives({
                '.subscriptionText': 'subscriptionText',
                '.subscriptionFooter@value' : 'subscriptionFooter',
                '.companyPhone@value': 'companyPhone',
                '.subscriptionTitle@value': 'subscriptionTitle',
                '.companyName@value': 'companyName',
                '.organizationTitle@value': 'organizationTitle',
                '.clientTitle@value': 'clientTitle',
                '.teacherTitle@value': 'teacherTitle',
                '.printPriceAndPaid@checked': 'printPriceAndPaid',
                '.printVisitMark@checked': 'printVisitMark',
                '.printSimpleSubscriptionPack@checked': 'printSimpleSubscriptionPack',
                '.maxGroupElementsCount@value': 'maxGroupElementsCount',
                '.desktopFilterWeeksFrom@value': 'desktopFilterWeeksFrom',
                '.desktopFilterWeeksTo@value': 'desktopFilterWeeksTo',
                '.maxGroupElementsCountWithReservation@checked': 'maxGroupElementsCountWithReservation',
                '.moneyName@value': 'moneyName',
                '.compensationCountLessons@value': 'compensationCountLessons',
                '.compensationDiscountCountLessons@value': 'compensationDiscountCountLessons',
                '.compensationDiscountForMissedLessons@value': 'compensationDiscountForMissedLessons',
                '.maxSalaryLessonPriceCount@value': 'maxSalaryLessonPriceCount',
                '.sessionDuration@value' : 'sessionDuration'
            }).render(data.settings);

            $('#backupSettings').directives({
                '.backupPeriodicallyFilesCount@value': 'backupPeriodicallyFilesCount',
                '.backupPeriodically@checked': function (context) {
                    return context.context.backupPeriodically ? 'checked' : ''
                },
                '.backupPeriodicallyPeriod@value': 'backupPeriod'
            }).render(data.settings);

            if (data.settings.passwordRequired) {
                $('#passwordsRequired').attr('checked', 'checked');
            }

            clientPrinting = false;
            if (data.settings.clientPrinting) {
                $('#clientPrinting').attr('checked', 'checked');
                clientPrinting = true;
            }

            if (data.settings.csvReport) {
                $('#csvReport').attr('checked', 'checked');
            }

            if (data.settings.autoContractId) {
                $('#autoContractId').attr('checked', 'checked');
            }

            $('#appversion').html(data.settings.appVersion);
            $('#yearFormat').val(data.settings.yearDateFormat);
            $('#compensationLimitDays').val(data.settings.compensationLimitDays);
            if (data.settings.generateBirthDate) {
                $('#generateBirthDate').attr('checked', 'checked');
            }

            $('#companyInfo').find('.autoContractNextId').val(data.autoContractNextId);

            if(data.settings.marketingAutoTask){
                $('#marketingSettings').find('.marketingAutoTask').attr('checked', 'checked');
            }
            $('#marketingSettings').find('.marketingAutoTaskDays').val(data.settings.marketingAutoTaskDays);
            if (data.settings.subscriptionEditAutoNotifications) {
                $('#subscriptionEditAutoNotifications').attr('checked', 'checked');
            }
        });

        commonHelper.checkServerVersion(false);
    };

    this.saveSettings = function () {
        var yearFormat = $('#yearFormat').children(null).filter(":selected").val();
        var subscriptionText = $('#subscriptionText').val();
        var subscriptionFooter = $('#subscriptionFooter').val();
        var companyPhone = $('#companyPhone').val();
        var subscriptionTitle = $('#subscriptionTitle').val();
        var companyName = $('#companyName').val();
        var organizationTitle = $('#organizationTitle').val();
        var clientTitle = $('#clientTitle').val();
        var teacherTitle = $('#teacherTitle').val();
        var moneyName = $('#moneyName').val();
        var desktopFilterWeeksFrom = $('#desktopFilterWeeksFrom').val();
        var desktopFilterWeeksTo = $('#desktopFilterWeeksTo').val();
        var maxSalaryLessonPriceCount = $('#maxSalaryLessonPriceCount').val();
        var printPriceAndPaid = $('#printPriceAndPaid:checked').val() ? true : false;
        var printVisitMark = $('#printVisitMark:checked').val() ? true : false;
        var printSimpleSubscriptionPack = $('#printSimpleSubscriptionPack:checked').val() ? true : false;
        var clientPrinting = $('#clientPrinting:checked').val() ? true : false;
        var csvReport = $('#csvReport:checked').val() ? true : false;

        var maxGroupElementsCount = $('#maxGroupElementsCount').val();
        var maxGroupElementsCountWithReservation = $('#maxGroupElementsCountWithReservation:checked').val() ? true : false;
        var compensationDiscountForMissedLessons = $('#compensationDiscountForMissedLessons').val();
        var compensationDiscountCountLessons = $('#compensationDiscountCountLessons').val();
        var compensationCountLessons = $('#compensationCountLessons').val();
        var sessionDuration = $('#sessionDuration').val();
        var autoContractId = $('#autoContractId:checked').val() ? true : false;
        var autoContractNextId = $('#autoContractNextId').val();
        var subscriptionEditAutoNotifications = $('#subscriptionEditAutoNotifications:checked').val() ? true : false;

        var compensationLimitDays = $('#compensationLimitDays').val();
        commonHelper.callAjaxMethod('settings.htm', 'saveSettings', {
            formatDate: yearFormat,
            compensationLimitDays: compensationLimitDays,
            subscriptionText: subscriptionText,
            subscriptionFooter : subscriptionFooter,
            companyPhone: companyPhone,
            subscriptionTitle: subscriptionTitle,
            companyName: companyName,
            organizationTitle: organizationTitle,
            teacherTitle: teacherTitle,
            clientTitle: clientTitle,
            printPriceAndPaid: printPriceAndPaid,
            printVisitMark: printVisitMark,
            printSimpleSubscriptionPack: printSimpleSubscriptionPack,
            maxGroupElementsCount: maxGroupElementsCount,
            maxGroupElementsCountWithReservation: maxGroupElementsCountWithReservation,
            desktopFilterWeeksFrom: desktopFilterWeeksFrom,
            desktopFilterWeeksTo: desktopFilterWeeksTo,
            moneyName: moneyName,
            compensationDiscountForMissedLessons: compensationDiscountForMissedLessons,
            compensationDiscountCountLessons: compensationDiscountCountLessons,
            compensationCountLessons: compensationCountLessons,
            clientPrinting: clientPrinting,
            csvReport: csvReport,
            maxSalaryLessonPriceCount: maxSalaryLessonPriceCount,
            sessionDuration: sessionDuration,
            autoContractId: autoContractId,
            autoContractNextId: autoContractNextId,
            subscriptionEditAutoNotifications: subscriptionEditAutoNotifications
        }, function (data) {
            DATE_FORMAT = yearFormat == 'yyyy' ? 'dd/mm/yy' : 'dd/mm/y'
        });
    };

    this.changePrinter = function () {
        commonHelper.callAjaxMethod('settings.htm', 'savePrinter', {selectedPrinter: $('#printersList').children(null).filter(':selected').val()}, function (data) {

        });
    };

    this.saveBackupSettings = function () {
        commonHelper.callAjaxMethod('settings.htm', 'saveBackupSettings', {
            backupPeriodically: $('[name=backupPeriodically]:checked').length > 0,
            backupPeriodicallyPeriod: $('[name=backupPeriodicallyPeriod]').val(),
            backupPeriodicallyFilesCount: $('[name=backupPeriodicallyFilesCount]').val()
        }, function (data) {

        });

    };

    this.restoreBackup = function () {
        var file = $('#backupFile').val();
        if (file == '') {
            commonHelper.showMessage(messages['settings.backup.file']);
        } else {
            $('#restoreForm').submit();
        }
    };

    this.makeBackup = function () {
        commonHelper.callAjaxMethod('settings.htm', 'makeBackup', {}, function (data) {
            if (data.result) {
                commonHelper.showMessage(messages['settings.backup.saved'] + ' ' + data.savedFile);
            } else {
                commonHelper.showMessage(messages['settings.backup.error']);
            }
        });
    };

    this.changeGenerateBirthDate = function () {
        if (!$('#generateBirthDate:checked').val()) {
            DIALOGS.askYesNoDialog(messages['settings.birthdate.confirm'], messages['settings.birthdate.switchoff'], function(){
                changeGeneratingBirthDateTasks(false, true);
            }, function(){
                changeGeneratingBirthDateTasks(false, false);
            }, messages['settings.birthdate.switchon']);
        } else {
            changeGeneratingBirthDateTasks(true, false);

        }
    };

    var changeGeneratingBirthDateTasks = function(state, deleteTasks){
        commonHelper.callAjaxMethod('settings.htm', 'saveGenerateBirthDate', {generateBirthDate: state, deleteTasks: deleteTasks}, function (data) {

        });
    };

    this.closeUpdateDialog = function () {
        $('#updatedialog').hide();
        $('#updatedialog-modal').hide();
        $('#updateResult').html('');
        $('#updateStatus').html('');

    };

    this.saveMobileSettings = function () {
        commonHelper.callAjaxMethod('settings.htm', 'saveMobileSettings', {
            mobileLogin: $('.mobileLogin').val(),
            mobilePassword: $('.mobilePassword').val()
        }, function (data) {

        });
    };

    this.restartApp = function () {
        $.ajax({
            url: '/updater/restart',
            type: 'get',
            async: false,
            data: {},
            dataType: 'json',
            success: function (result) {
                window.location = 'index.htm'
            },
            error: function (data) {
                $('#serverversiondescription').html(messages['settings.restart.error']);
            }
        });
    };

    this.updateApp = function () {
        var serverVersion = $('#serverversion').html();
        $.ajax({
            url: '/updater/update',
            type: 'get',
            async: true,
            data: {"requestedversion": serverVersion},
            dataType: 'json',
            success: function (result) {
                if (result.status == 'started') {
                    $('#closeUpdateDialogButton').attr('disabled', 'disabled');
                    var updatedialog = $('#updatedialog');
                    $('#updatedialog-modal').show();
                    moveDivToCenter(updatedialog);
                    updatedialog.show();

                    $(document).attr('hideAjaxProgress', true);
                    var intervalId = setInterval(function () {
                        refreshUpdateStatus(intervalId);
                    }, 1000);
                }

            },
            error: function (data) {
                $('#serverversiondescription').html(messages['settings.update.error']);
            }
        });
    };

    var refreshUpdateStatus = function (backgroundProcessId) {
        $.ajax({
            url: '/updater/status',
            type: 'get',
            async: true,
            data: {},
            dataType: 'json',
            success: function (result) {
                var description = result.description;
                var updateResult = result.result;
                var statusObject = $('#updateStatus');
                var updateResultObject = $('#updateResult');

                statusObject.html(description);
                if (updateResult) {
                    switch (updateResult.type) {
                        case 'SUCCESSFUL' :
                            statusObject.html(messages['settings.update.success']);

                            loadUpdateDescription();

                            $('#appversion').html(updateResult.newVersion);
                            $('#updatelink').hide();
                            break;
                        case 'UPDATE_IS_NOT_NECESSARY' :
                            statusObject.html(messages['settings.update.notnecessary']);
                            break;
                        case 'UPDATE_FAILED' :
                            statusObject.html(messages['settings.update.failed']);
                            updateResultObject.html(updateResult.message);
                            break;
                        case 'RESTORE_FAILED' :
                            statusObject.html(messages['settings.update.restorefailed']);
                            updateResultObject.html(updateResult.message);
                            break;

                        default:
                            statusObject.html(messages['settings.update.unknown']);
                    }

                    clearInterval(backgroundProcessId);
                    $('#closeUpdateDialogButton').removeAttr('disabled');
                    $(document).attr('hideAjaxProgress', false);
                }

            },
            error: function (data) {
                var statusObject = $('#updateStatus');
                clearInterval(backgroundProcessId);
                $(document).attr('hideAjaxProgress', false);
                statusObject.html(messages['settings.update.failedtitle']);
                $('#serverversiondescription').html(messages['settings.update.error']);
                $('#closeUpdateDialogButton').removeAttr('disabled');
            }
        });
    };

    var loadUpdateDescription = function () {
        commonHelper.callAjaxMethod('status.htm', 'loadUpdateDescription', {}, function (data) {
            var result = '<table width="100%">';
            $.each(data, function (index, element) {
                var version = element.appVersion.majorVersion + '.' + element.appVersion.minorVersion;
                var row = '<tr>';
                row += '<td style="width: 100px;font-size: 15px;">';
                row += version;
                row += '</td>';
                row += '<td>';

                var textRows = element.description.split('\n');
                $.each(textRows, function (index, textRow) {
                    row += textRow + '<br>';
                });

                row += '</td>';
                row += '</tr>';
                result += row;
            });
            result += '</table>';
            $('#updatesdescription').html(result);
        }, true, true, false, function () {
            return true;
        });
    };

    this.printTestPage = function () {
        if (!clientPrinting) {
            commonHelper.callAjaxMethod('settings.htm', 'printTestPage', {}, function (data) {
                if (!data) {
                    commonHelper.showMessage(messages['settings.print.testerror']);
                }
            });
        } else {
            commonHelper.openPdfPrintDialog('client.htm?method=printSubscriptionFromClient');
        }
    };

    this.saveMarketingSettings = function () {
        commonHelper.callAjaxMethod('settings.htm', 'saveMarketingSettings', {
            marketingAutoTask: $('[name=marketingAutoTask]:checked').length > 0,
            marketingAutoTaskDays: $('[name=marketingAutoTaskDays]').val()
        }, function (data) {

        });

    };

    return this;
}function statistic_helper() {
    var that = this;
    var tasksDataGrid = null;
    var membershipDataGrid = null;
    var teachersDataGrid = null;
    var selectedChild = {};
    var selectedScheduleId = '';
    var selectedChildrenGroupScheduleId = '';
    var TABLE_WIDTH = 0;
    var selectedFamilyId = null;
    var selectedChildId = null;
    var membershiptype = null;
    var plotInited = false;

    var kidStatisticSortField = 'kidName';
    var kidStatisticSortOrder = 'asc';
    this.pageReady = function () {

        $('#tabs-statistic').tabs();
        $('#tabs-statistic').tabs({
            select: function (event, ui) {
                $(ui.panel).show();
                switch (ui.index) {
                    case 0:
                        that.refreshChildrenLists(null);
                        break;
                    case 1:
                        if (!teachersDataGrid) {
                            that.refreshTeachersLists();
                        }
                        break;
                    case 2 :
                        if (!membershipDataGrid) {
                            that.refreshMembershipLists();
                        }

                        break;
                    case 3 :
                        if (!tasksDataGrid) {
                            that.refreshTasksLists();
                        }
                        break;
                    case 4 :

                        break;
                    case 5 :
                        if (!plotInited) {
                            plotInited = true;
                            that.selectPlot(null, 'visitsbyweektab');
                        }
                }
            }
        });

        var disabledTabs = [];
        commonHelper.checkPermission('plot', function () {
            initGraphicsTab();
        }, function () {
            disabledTabs.push(5);
        });

        commonHelper.checkPermission('finance', function () {
            $('.membershipTotalPrice').show();
        }, function () {
            disabledTabs.push(5);
            $('.membershipTotalPrice').hide();
        });

        commonHelper.checkPermission('excelpdfexport', function () {
            $('#childrenstatisticpdf').show();
            $('#childrenstatisticexcel').show();
            $('#downloadTeacherAsExcelLink').show();
            $('#downloadChildrenGroupAsExcelLink').show();
            $('#downloadMembershipAsExcelLink').show();
        }, function () {
            $('#childrenstatisticpdf').hide();
            $('#childrenstatisticexcel').hide();
            $('#downloadTeacherAsExcelLink').hide();
            $('#downloadChildrenGroupAsExcelLink').hide();
            $('#downloadMembershipAsExcelLink').hide();
        });

        commonHelper.checkFeature('RESERVE_COPY', function () {
            disabledTabs.push(5);
        }, function () {
        });

        $('#tabs-statistic').tabs("option", "disabled", disabledTabs);

        initReferences();
        initChildrenTab();
        initTeachersTab();
        initMembershipTab();
        initGroupsTab();
        initTasksTab();

        commonHelper.registerChangeOrganizationListener(function (organizationId) {
            initReferences();
            that.clearChildrenFilterParams();
            that.clearTeachersFilterParams();
            that.clearMembershipFilterParams();
            that.clearTasksFilterParams();

            that.refreshChildrenLists(null);
            that.refreshTasksLists();
            that.refreshTeachersLists();
            that.refreshMembershipLists();

            that.generateVisitsByWeeksPlot();
            that.generateIncreaseDecreaseByWeeksPlot();
            that.generateInfoSourcePlot();
            that.generateVisitsByWeeksPlot();
            that.generateLocationPlot();
            that.generateVisitAgePlot();
            that.generateTeacherDistrPlot();
            that.generateCourseDistrPlot();

        });

        TABLE_WIDTH = $('#tabs-statistic').parent(null).width() - 70;

        that.refreshChildrenLists(null);
        commonHelper.prepareViewer([
            {filter: '#createTaskButton', action: 'delete'}
        ]);
        $('body').find('button').button();
    };

    var initTeachersTab = function () {
        commonHelper.setDatePicker($('#filterteacherdatefrom'));
        commonHelper.setDatePicker($('#filterteacherdateto'));
    };

    var initMembershipTab = function () {
        commonHelper.setDatePicker($('#filtermembershipdatefrom'));
        commonHelper.setDatePicker($('#filtermembershipdateto'));

    };

    var initChildrenTab = function () {
        commonHelper.setDatePicker($('#subscriptionDateFrom'));
        commonHelper.setDatePicker($('#subscriptionDateTo'));
        commonHelper.setDatePicker($('#notVisitedDateFrom'));
        commonHelper.setDatePicker($('#notVisitedDateTo'));
        commonHelper.setDatePicker($('#agreementDateFrom'));
        commonHelper.setDatePicker($('#agreementDateTo'));
    };

    var initGroupsTab = function () {
        commonHelper.setDatePicker($('#childgroupChildGroupFrom'));
        commonHelper.setDatePicker($('#childgroupChildGroupTo'));
        commonHelper.setDatePicker($('#childgroupGroupDataFrom'));
        commonHelper.setDatePicker($('#childgroupGroupDataTo'));
        var firstDay = new Date();
        firstDay.setDate(1);

        var lastDay = new Date();
        lastDay.setMonth(lastDay.getMonth() + 1);
        lastDay.setDate(1);
        lastDay.setHours(0);
        lastDay.setMinutes(0);
        lastDay.setSeconds(0);
        lastDay.setMilliseconds(0);
        lastDay.setTime(lastDay.getTime() - 1000);
        $('#childgroupChildGroupFrom').val(commonHelper.formatDate(firstDay));
        $('#childgroupChildGroupTo').val(commonHelper.formatDate(lastDay));
        $('#childgroupGroupDataFrom').val(commonHelper.formatDate(firstDay));
        $('#childgroupGroupDataTo').val(commonHelper.formatDate(lastDay));

        var childautocompleteparams = {
            url: 'index.htm',
            method: 'autoCompleteSearchChild',
            defaultValue: messages['statistic.childfilternotset'],
            inputDataTitle: messages['statistic.childfilteraction'],
            objectNotFound: messages['statistic.childfilternotfound'],
            objectFound: messages['statistic.childfilterfound'],
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.firstName + ' ' + item.lastName;
            },
            generateLabel: function (item) {
                return item.firstName + ' ' + item.lastName + ';' + item.phone;
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('groupfilterchild', childautocompleteparams);


    };

    var initTasksTab = function () {
        commonHelper.setDatePicker($('#filterdatefrom'));
        commonHelper.setDatePicker($('#filterdateto'));

        var childautocompleteparams = {
            url: 'index.htm',
            method: 'autoCompleteSearchChild',
            defaultValue: messages['statistic.childfilternotset'],
            inputDataTitle: messages['statistic.childfilteraction'],
            objectNotFound: messages['statistic.childfilternotfound'],
            objectFound: messages['statistic.childfilterfound'],
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.firstName + ' ' + item.lastName;
            },
            generateLabel: function (item) {
                return item.firstName + ' ' + item.lastName + ';' + item.phone;
            }
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('filterchild', childautocompleteparams);

        var kidstatisticfilterchildparams = {
            selectCallback: function (objectId, selectedText, type) {
                if (objectId && objectId != '') {
                    if (type == 'family') {
                        selectedFamilyId = objectId;
                    } else {
                        selectedChildId = objectId;
                    }
                } else {
                    selectedFamilyId = null;
                    selectedChildId = null;
                }
            },
            generateId: function (item) {
                return item.id;
            },
            generateValue: function (item) {
                return item.value;
            },
            generateLabel: function (item) {
                return item.title;
            },
            generateType: function (item) {
                return item.objtype;
            },
            url: 'family.htm',
            method: 'autoCompleteSearchFamilyOrChild',
            defaultValue: messages['common.familyfilternotset'],
            inputDataTitle: messages['common.familyfiltertitle'],
            objectNotFound: messages['common.familyfilternotfound'],
            objectFound: messages['common.familyfilterfound']
        };
        AUTOCOMPLETE_SEARCH_FIELD.prepare('kidstatisticfilterchild', kidstatisticfilterchildparams);

    };

    var initGraphicsTab = function () {
        if ($('#tabs-plots').length == 1) {
            commonHelper.setDatePicker($('#visitsbyweeksfrom'));
            commonHelper.setDatePicker($('#visitsbyweeksto'));

            commonHelper.setDatePicker($('#increasedecreasebyweeksfrom'));
            commonHelper.setDatePicker($('#increasedecreasebyweeksto'));


            commonHelper.setDatePicker($('#infosourcefrom'));
            commonHelper.setDatePicker($('#infosourceto'));

            commonHelper.setDatePicker($('#locationfrom'));
            commonHelper.setDatePicker($('#locationto'));

            commonHelper.setDatePicker($('#visitagefrom'));
            commonHelper.setDatePicker($('#visitageto'));

            commonHelper.setDatePicker($('#teacherdistrto'));
            commonHelper.setDatePicker($('#teacherdistrfrom'));

            commonHelper.setDatePicker($('#coursedistrto'));
            commonHelper.setDatePicker($('#coursedistrfrom'));

            var initDateTo = new Date();
            var initDateFrom = new Date();

            initDateFrom.setDate(1);
            initDateFrom.setMonth(8);

            if (initDateTo.getMonth() >= 8) {
                initDateFrom.setYear(initDateTo.getFullYear());
            } else {
                initDateFrom.setYear(initDateTo.getFullYear() - 1);
            }


            $('#visitsbyweeksfrom').datepicker('setDate', initDateFrom);
            $('#visitsbyweeksto').datepicker('setDate', initDateTo);
            that.generateVisitsByWeeksPlot();

            $('#increasedecreasebyweeksfrom').datepicker('setDate', initDateFrom);
            $('#increasedecreasebyweeksto').datepicker('setDate', initDateTo);
            that.generateIncreaseDecreaseByWeeksPlot();

            $('#infosourcefrom').datepicker('setDate', initDateFrom);
            $('#infosourceto').datepicker('setDate', initDateTo);
            that.generateInfoSourcePlot();

            $('#locationfrom').datepicker('setDate', initDateFrom);
            $('#locationto').datepicker('setDate', initDateTo);
            that.generateLocationPlot();

            $('#visitagefrom').datepicker('setDate', initDateFrom);
            $('#visitageto').datepicker('setDate', initDateTo);
            that.generateVisitAgePlot();

            $('#teacherdistrfrom').datepicker('setDate', initDateFrom);
            $('#teacherdistrto').datepicker('setDate', initDateTo);
            that.generateTeacherDistrPlot();

            $('#coursedistrfrom').datepicker('setDate', initDateFrom);
            $('#coursedistrto').datepicker('setDate', initDateTo);
            that.generateCourseDistrPlot();
        }
    };

    this.openChildGroupScheduleMenu = function () {
        DIALOGS.scheduleDialogs.openSimpleSchedulesMenu('#childGroupScheduleMenu', function (id, options, menuElement) {
            selectedChildrenGroupScheduleId = id.split('-')[1];

            var teacherInfo;
            $.each(DIALOGS.scheduleDialogs.simpleScheduleCache, function (index, item) {
                if (item.id == selectedChildrenGroupScheduleId) {
                    teacherInfo = item.teacher;
                }
            });
            $('#scheduleSelectedTitle').html(teacherInfo.name + '<br>' + $(menuElement).html());
        });
    };

    this.downloadChildrenGroupAsExcel = function () {
        window.location.assign('statistic.htm?method=downloadChildrenGroupAsExcel&' + collectChildrenGroupParams());
    };

    this.downloadMembershipAsExcel = function () {
        window.location.assign('membershiphistory.htm?method=downloadMembershipAsExcel&' + collectMembershipSearchParams());
    };

    var collectChildrenGroupParams = function () {
        var params = {};
        params.childgroupChildGroupFrom = $('#childgroupChildGroupFrom').val();
        params.childgroupChildGroupTo = $('#childgroupChildGroupTo').val();
        params.childgroupGroupDataFrom = $('#childgroupGroupDataFrom').val();
        params.childgroupGroupDataTo = $('#childgroupGroupDataTo').val();
        params.childrenGroupTeacher = $('#childrenGroupTeacher').val();
        params.childrenGroupCourse = $('#childrenGroupCourse').val();
        params.scheduleId = selectedChildrenGroupScheduleId;
        params.childId = AUTOCOMPLETE_SEARCH_FIELD.getValue('groupfilterchild');

        var paramsString = '';
        for (var param in params) {
            paramsString += param + '=' + params[param] + '&';
        }
        return paramsString;
    };

    this.filterChildrenGroups = function () {
        var params = {};
        params.childgroupChildGroupFrom = $('#childgroupChildGroupFrom').val();
        params.childgroupChildGroupTo = $('#childgroupChildGroupTo').val();
        params.childgroupGroupDataFrom = $('#childgroupGroupDataFrom').val();
        params.childgroupGroupDataTo = $('#childgroupGroupDataTo').val();
        params.childrenGroupTeacher = $('#childrenGroupTeacher').val();
        params.childrenGroupCourse = $('#childrenGroupCourse').val();
        params.scheduleId = selectedChildrenGroupScheduleId;
        params.childId = AUTOCOMPLETE_SEARCH_FIELD.getValue('groupfilterchild');

        commonHelper.callAjaxMethod('statistic.htm', 'filterChildrenGroups',
            params, function (result) {
                var templateChildrenGroups = $('.filterResultChildrenGroups');
                $('#childrenGroupsContainer').children().remove();
                $.each(result, function (index, item) {
                    var colNames = ['', messages['statistic.child'], messages['statistic.parent'], messages['statistic.phone'], messages['statistic.dept']];

                    var colModels = [
                        {name: 'id', index: 'id', hidden: true},
                        {
                            name: 'name', index: 'name', formatter: function (context, opts) {
                            return '<a href="client.htm?childid=' + opts.rowId + '">' + context + '</a>';
                        }
                        },
                        {name: 'parentName', index: 'parentName', formatter: commonHelper.notNullFormatter},
                        {name: 'phone', index: 'phone', formatter: commonHelper.notNullFormatter},
                        {name: 'dept', index: 'dept', formatter: commonHelper.notNullFormatter}
                    ];

                    $.each(item.dates, function (index, date) {
                        colNames.push(date);
                        colModels.push({
                            name: date,
                            index: date,
                            width: 80,
                            formatter: function (context) {
                                if (context && context.startTime) {
                                    var visitColor;
                                    var visitTitle;
                                    switch (context.visit) {
                                        case '+':
                                            visitColor = 'green';
                                            visitTitle = messages['statistic.visit.ok'];
                                            break;
                                        case '~':
                                            visitColor = 'blue';
                                            visitTitle = messages['statistic.visit.goodreason'];
                                            break;
                                        case 'x':
                                            visitColor = 'red';
                                            visitTitle = messages['statistic.visit.no'];
                                            break;
                                        default:
                                            visitColor = 'black';
                                            visitTitle = '';
                                    }

                                    var title;

                                    switch (context.typeCode) {
                                        case 'subscription':
                                            title = messages['statistic.type.subscription'];
                                            break;
                                        case 'test':
                                            title = messages['statistic.type.test'];
                                            break;
                                        case 'compensation':
                                            title = messages['statistic.type.compensation'];
                                            break;
                                        case 'once':
                                            title = messages['statistic.type.once'];
                                            break;
                                        case 'reservation':
                                            title = messages['statistic.type.reservation'];
                                            break;
                                        default:
                                            title = '';
                                    }

                                    var startTime = '<span style="color: gray;">' + context.startTime + '</span>';
                                    var type = '<span style="font-weight: bold;">' + context.type + '</span>';
                                    var visit = '<span style="color: ' + visitColor + ';font-weight: bold;font-size: 15px;">' + context.visit + '</span>';
                                    var teacher = (context.actualTeacher ? '<span>' + '(' + context.actualTeacher + ')' + '</span>' : '');
                                    return '<div alt="' + title + ',' + visitTitle + '" title="' + title + ',' + visitTitle + '">' + startTime + ':' + type + '' + visit + '</div>' + '<div>' + teacher + '</div>';
                                } else {
                                    return '';
                                }
                            }
                        });
                    });
                    var childrenGroups = templateChildrenGroups.clone();
                    childrenGroups.removeClass('filterResultChildrenGroups');
                    childrenGroups.attr('id', index);
                    childrenGroups.show();
                    var scheduleTitle = $('<div>', {style: 'margin-top: 15px;'});

                    var scheduleInfo = item.schedule.teacherInfo + ' ';

                    $.each(item.schedule.elements, function (index, item) {
                        scheduleInfo += item.courseType.name + ', ' + item.day.title + ', ' + item.startTime + '-' + item.finishTime + '; ';
                    });


                    scheduleTitle.html(scheduleInfo);
                    scheduleTitle.appendTo($('#childrenGroupsContainer'));
                    childrenGroups.appendTo($('#childrenGroupsContainer'));

                    var addRecipientsLink = $('<a>', {
                        href: 'javascript:void(0)',
                        text: messages['statistic.addrecipient']
                    });
                    addRecipientsLink.appendTo(scheduleTitle);

                    addRecipientsLink.click(function () {
                        var datafromgrid = childrenGroups.jqGrid('getRowData');
                        var childIds = [];
                        $.each(datafromgrid, function (index, item) {
                            childIds.push(item.id);
                        });
                        commonHelper.callAjaxMethod('statistic.htm', 'addRecipient', {"objects": JSON.stringify({childId: childIds})}, function (data) {
                            $('#messageRecipientsCount').html(data.currentRecipientsCount);
                        });

                    });

                    childrenGroups.jqGrid('GridUnload');
                    var childrenGroupGrid = childrenGroups.jqGrid({
                        datatype: 'json',
                        colNames: colNames,
                        colModel: colModels,
                        height: "100%",
                        jsonReader: {repeatitems: false, id: "id"},
                        sortname: 'name',
                        viewrecords: true,
                        sortorder: "desc"
                    });

                    childrenGroupGrid[0].addJSONData(item.children);

                });

            });
    };

    this.clearChildrenGroupParams = function () {
        selectedChildrenGroupScheduleId = '';
        $('#childgroupChildGroupFrom').val('');
        $('#childgroupChildGroupTo').val('');
        $('#childgroupGroupDataFrom').val('');
        $('#childgroupGroupDataTo').val('');
        $('#childrenGroupTeacher').val('');
        $('#childrenGroupCourse').val('');
        $('#scheduleSelectedTitle').html('');
        AUTOCOMPLETE_SEARCH_FIELD.setValue('groupfilterchild', null, '');
    };

    this.unselectChildrenGroupSchedule = function () {
        selectedChildrenGroupScheduleId = '';
        $('#scheduleSelectedTitle').html('');
    };

    this.generateIncreaseDecreaseByWeeksPlot = function () {
        if ($('#increasedecreasebyweeksto').val() == '' || $('#increasedecreasebyweeksfrom').val() == '') {
            commonHelper.showMessage(messages['statistic.dateerror']);
        } else {
            $('#increasedecreasebyweekscontainer').children(null).remove();
            $('<img>', {
                width: '740px',
                height: '500px',
                src: 'plot.htm?method=increasedecreaseByWeeks&from=' +
                ($('#increasedecreasebyweeksfrom').val()) + '&' + 'to=' +
                ($('#increasedecreasebyweeksto').val()) + '&key=' +
                (new Date().getTime()) +
                '&teacher=' + ($('#increasedecreasebyweekteacher option:selected').val() ? $('#increasedecreasebyweekteacher option:selected').val() : '') +
                '&course=' + ($('#increasedecreasebyweekcourse option:selected').val() ? $('#increasedecreasebyweekcourse option:selected').val() : '')
            }).appendTo($('#increasedecreasebyweekscontainer'));
        }
    };

    this.generateVisitsByWeeksPlot = function () {
        if ($('#visitsbyweeksto').val() == '' || $('#visitsbyweeksfrom').val() == '') {
            commonHelper.showMessage(messages['statistic.dateerror']);
        } else {
            $('#visitsbyweekscontainer').children(null).remove();
            $('<img>', {
                width: '740px',
                height: '500px',
                src: 'plot.htm?method=visitsByWeeks&from=' +
                ($('#visitsbyweeksfrom').val()) + '&' + 'to=' +
                ($('#visitsbyweeksto').val()) + '&key=' +
                (new Date().getTime()) +
                '&teacher=' + ($('#visitsbyweekteacher option:selected').val() ? $('#visitsbyweekteacher option:selected').val() : '') +
                '&course=' + ($('#visitsbyweekcourse option:selected').val() ? $('#visitsbyweekcourse option:selected').val() : '')
            }).appendTo($('#visitsbyweekscontainer'));
        }
    };

    this.generateInfoSourcePlot = function () {
        if ($('#infosourceto').val() == '' || $('#infosourcefrom').val() == '') {
            commonHelper.showMessage(messages['statistic.dateerror']);
        } else {
            $('#infosourcecontainer').children(null).remove();
            $('<img>', {
                width: '740px',
                height: '500px',
                src: 'plot.htm?method=infoSource&from=' + ($('#infosourcefrom').val()) + '&' + 'to=' + ($('#infosourceto').val()) + '&key=' + (new Date().getTime())
            }).appendTo($('#infosourcecontainer'));
        }
    };

    this.generateLocationPlot = function () {
        if ($('#locationto').val() == '' || $('#locationfrom').val() == '') {
            commonHelper.showMessage(messages['statistic.dateerror']);
        } else {
            $('#locationcontainer').children(null).remove();
            $('<img>', {
                width: '740px',
                height: '500px',
                src: 'plot.htm?method=location&from=' + ($('#locationfrom').val()) + '&' + 'to=' + ($('#locationto').val()) + '&key=' + (new Date().getTime())
            }).appendTo($('#locationcontainer'));
        }
    };

    this.generateVisitAgePlot = function () {
        if ($('#visitageto').val() == '' || $('#visitagefrom').val() == '') {
            commonHelper.showMessage(messages['statistic.dateerror']);
        } else {
            $('#visitagecontainer').children(null).remove();
            $('<img>', {
                width: '740px',
                height: '500px',
                src: 'plot.htm?method=visitAge&from=' + ($('#visitagefrom').val()) + '&' + 'to=' + ($('#visitageto').val()) + '&key=' + (new Date().getTime())
            }).appendTo($('#visitagecontainer'));
        }
    };

    this.generateTeacherDistrPlot = function () {
        if ($('#teacherdistrto').val() == '' || $('#teacherdistrfrom').val() == '') {
            commonHelper.showMessage(messages['statistic.dateerror']);
        } else {
            $('#teacherdistrcontainer').children(null).remove();
            $('<img>', {
                width: '740px',
                height: '500px',
                src: 'plot.htm?method=teacherDistr&from=' + ($('#teacherdistrfrom').val()) + '&' + 'to=' + ($('#teacherdistrto').val()) + '&key=' + (new Date().getTime())
            }).appendTo($('#teacherdistrcontainer'));
        }
    };

    this.generateCourseDistrPlot = function () {
        if ($('#coursedistrto').val() == '' || $('#coursedistrfrom').val() == '') {
            commonHelper.showMessage(messages['statistic.dateerror']);
        } else {
            $('#coursedistrcontainer').children(null).remove();
            $('<img>', {
                width: '740px',
                height: '500px',
                src: 'plot.htm?method=courseDistr&from=' + ($('#coursedistrfrom').val()) + '&' + 'to=' + ($('#coursedistrto').val()) + '&key=' + (new Date().getTime())
            }).appendTo($('#coursedistrcontainer'));
        }
    };

    this.selectPlot = function (menuitem, plotdivid) {
        $('#plots-menu').children(null).removeClass('plotmenuitemselected');
        $(menuitem).addClass('plotmenuitemselected');
        $('#plots-list').children(null).hide();
        $('#' + plotdivid).show();
    };


    this.clearTeachersFilterParams = function () {
        $('#teacherTeacher').val('');
        $('#filterteacherdatefrom').val('');
        $('#filterteacherdateto').val('');
    };

    this.clearMembershipFilterParams = function () {
        $('#filtermembershipdatefrom').val('');
        $('#filtermembershipdateto').val('');
    };

    this.clearChildrenFilterParams = function () {
        $('#course').val('');
        $('#desiredCourse').val('');
        $('#teacher').val('');
        $('#additionalTeacher').val('');
        $('#sourceInfo').val('');
        $('#location').val('');
        $('#interest').val('');
        $('#includeMissedAll').removeAttr('checked');
        $('#removeVisitedAll').removeAttr('checked');
        $('#ageFrom').val('');
        $('#ageTo').val('');
        $('#subscriptionDateFrom').val('');
        $('#subscriptionDateTo').val('');
        $('#agreementDateFrom').val('');
        $('#agreementDateTo').val('');
        $('#notVisitedDateFrom').val('');
        $('#notVisitedDateTo').val('');
        $('#visitkindergarten').val('');
        $('#visitschool').val('');
        selectedScheduleId = '';
        $('#selectedSchedule').html('');
        $('#subscriptionType').val('');
        AUTOCOMPLETE_SEARCH_FIELD.setValue('kidstatisticfilterchild', null, '');
        selectedChildId = null;
        selectedFamilyId = null;
    };

    this.clearTasksFilterParams = function () {
        $('#filterdatefrom').val('');
        $('#filterdateto').val('');
        $('#filtersubject').val('');
        $('#filterchild').val('');
        $('#filterstatus').val('');
        $('#filtertype').val('');
        AUTOCOMPLETE_SEARCH_FIELD.setValue('filterchild', null, '');

    };

    this.refreshTeachersLists = function () {
        if (!teachersDataGrid) {
            var colNames = [
                messages['statistic.teacher.teacher'],
                messages['statistic.teacher.course'],
                messages['statistic.teacher.actualdate'],
                messages['statistic.teacher.actualtime'],
                messages['statistic.teacher.planneddate'],
                messages['statistic.teacher.childrencount'],
                messages['statistic.teacher.visitedcount'],
                messages['statistic.teacher.notvisitedgoodreason'],
                messages['statistic.teacher.notvisitednotgoodreason'],
                messages['statistic.teacher.compensation'],
                messages['statistic.teacher.subscriptions'],
                messages['statistic.teacher.defaultsubscriptions']
            ];

            var colModels = [
                {name: 'teacher', index: 'teacher', formatter: 'string'},
                {name: 'course', index: 'course', formatter: 'string'},
                {name: 'actualdate', index: 'actualdate', formatter: 'string'},
                {name: 'actualtime', index: 'actualtime', formatter: 'string'},
                {name: 'planneddate', index: 'planneddate', formatter: 'string'},
                {name: 'childrencount', index: 'childrencount', formatter: 'string'},
                {name: 'visitedcount', index: 'visitedcount', formatter: 'string'},

                {name: 'notvisitedwithreasoncount', index: 'notvisitedwithreasoncount', formatter: 'string'},
                {name: 'notvisitedwithoutreasoncount', index: 'notvisitedwithoutreasoncount', formatter: 'string'},
                {name: 'compensatedcount', index: 'compensatedcount', formatter: 'string'},

                {name: 'subscriptionscount', index: 'subscriptionscount', formatter: 'string'},
                {name: 'defaultsubscriptionscount', index: 'defaultsubscriptionscount', formatter: 'string'}
            ];

            $.each(membershiptype.rows, function (index, item) {
                colNames.push(item.name.replace(' ', '<br>'));
                colModels.push({
                    name: 'membershiptype_' + item.membershiptypeid,
                    index: 'membershiptype_' + item.membershiptypeid,
                    formatter: 'string'
                });
            });

            teachersDataGrid = $('#filterResultTeachers').jqGrid({
                datatype: loadTeachersLists,
                colNames: colNames,
                colModel: colModels,
                height: "100%",
                footerrow: true,
                jsonReader: {repeatitems: false, id: "teacherid"},
                rowNum: 25,
                pager: '#filterResultTeachersPager',
                sortname: 'teacherid',
                viewrecords: true,
                sortorder: "desc"
            });
            teachersDataGrid.jqGrid('setGridWidth', TABLE_WIDTH);
        } else {
            teachersDataGrid.setGridParam({
                page: 1
            });
            teachersDataGrid.trigger("reloadGrid");
        }
    };

    var loadTeachersLists = function (postdata) {
        postdata.teacherid = $('#teacherTeacher').val();
        postdata.filterteacherdateto = $('#filterteacherdateto').val();
        postdata.filterteacherdatefrom = $('#filterteacherdatefrom').val();

        commonHelper.callAjaxMethod('statistic.htm', 'filterTeachers',
            postdata, function (result) {
                teachersDataGrid.jqGrid("clearGridData");
                teachersDataGrid[0].addJSONData(result);

                var mainGrid = teachersDataGrid.parents().filter('.ui-jqgrid');
                var
                    sum = teachersDataGrid.jqGrid("getCol", "amount", false, "sum"),
                    $footerRow = mainGrid.find("tr.footrow"),
                    localData = teachersDataGrid.jqGrid("getGridParam", "data"),
                    totalRows = localData.length,
                    totalSum = 0,
                    $newFooterRow,
                    i;

                $newFooterRow = mainGrid.find("tr.myfootrow");
                if ($newFooterRow.length === 0) {
                    $newFooterRow = $footerRow.clone();
                    $newFooterRow.removeClass("footrow")
                        .addClass("myfootrow ui-widget-content");
                    $newFooterRow.children("td").each(function () {
                        this.style.width = ""; // remove width from inline CSS
                    });
                    $newFooterRow.insertAfter($footerRow);
                }

                var pageTotal = {};
                $newFooterRow.find(">td[aria-describedby=" + teachersDataGrid.attr('id') + "_planneddate]")
                    .text(messages['statistic.total']);
                var grandTotal = result.additionalAggregationList[0];
                $.each(grandTotal, function (index, item) {
                    $newFooterRow.find(">td[aria-describedby=" + teachersDataGrid.attr('id') + "_" + index + "]")
                        .text(item);
                    pageTotal[index] = 0;
                });

                $.each(result.rows, function (index, row) {
                    $.each(pageTotal, function (columnName, value) {
                        pageTotal[columnName] = pageTotal[columnName] + row[columnName];
                    });
                });

                pageTotal['planneddate'] = messages['statistic.onpage'];
                teachersDataGrid.jqGrid("footerData", "set", pageTotal);
            }, true);
    };

    this.downloadTeachersAsExcel = function () {
        window.location.assign('statistic.htm?method=downloadTeachersAsExcel&' + collectSearchTeacherParams());
    };

    var collectSearchTeacherParams = function () {
        var params = {
            teacherid: $('#teacherTeacher').val(),
            filterteacherdateto: $('#filterteacherdateto').val(),
            filterteacherdatefrom: $('#filterteacherdatefrom').val()
        };

        var paramsString = '';
        for (var param in params) {
            paramsString += param + '=' + params[param] + '&';
        }
        return paramsString;
    };


    this.sortKidsStatistic = function (sortField) {
        if (kidStatisticSortField == sortField) {
            kidStatisticSortOrder = kidStatisticSortOrder == 'asc' ? 'desc' : 'asc';
        } else {
            kidStatisticSortOrder = 'asc';
        }
        kidStatisticSortField = sortField;
        that.loadChildrenStatistic(null);
    };

    this.loadChildrenStatistic = function (selectPage) {
        $('.kidStatisticSortColumn').removeClass('switcherOn');
        $('.kidStatisticSortColumn.' + kidStatisticSortField).addClass('switcherOn');
        REFERENCE.fillReferenceList('childrenStatistic', 'statistic.htm', 'filterKids', {
            filterParams: collectSearchChildParams(),
            sortOrder: kidStatisticSortOrder,
            rowsOnPage: 15,
            sortName: kidStatisticSortField,
            selectedPage: selectPage ? selectPage : 1,
            fillCallback: function (list, template, data) {
                var row = template.clone();
                row.removeClass('childrenStatisticTemplate');
                row.show();
                row.appendTo(list);
                var result = list.directives({
                        '.childrenStatisticRow': {
                            'row <- rows': {
                                '.childrenStatisticChecked@name': 'checked_#{row.childid}',
                                '.childrenStatisticChecked@kidId': '#{row.childid}',
                                '.childrenStatisticId@value': 'row.childid',
                                '.kidName': 'row.kidname',
                                '.kidName@href': 'client.htm?childid=#{row.childid}',
                                '.parentname': 'row.parentname',
                                '.phone': 'row.phone',
                                '.birthdate': 'row.birthdate',
                                '.firstlessondate': 'row.firstlessondate',
                                '.lastlessondate': 'row.lastlessondate',
                                '.age': 'row.age',
                                '.infosource': 'row.infosource',
                                '.createdate': 'row.createdate',
                                '.contactauthor': 'row.contactauthor',
                                '.courses': 'row.courses',
                                '.desiredcourses': 'row.desiredcourses',
                                '.interest': 'row.interest',
                                '.agreementNumber': 'row.agreementnumber',
                                '.agreementDate': 'row.agreementdate',
                                '.comment': '#{row.comment}<br>------<br>#{row.familycomment}'
                            }
                        }
                    }
                ).render(data);
                $.each($('.childrenStatisticChecked'), function (index, _item) {
                    var item = $(_item);
                    var kidId = $(item).attr('kidId');
                    var selected = selectedChild[kidId] == null || selectedChild[kidId];
                    if (selected) {
                        item.attr('checked', 'checked');
                    } else {
                        item.removeAttr('checked');
                    }
                });
                return result;
            }
        });
    };


    this.refreshChildrenLists = function (selectPage) {
        that.loadChildrenStatistic(selectPage);
    };


    var currencyFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, "$1,") + ' ' + MONEY_NAME : '';
    };

    var notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    var booleanFormatter = function (cellvalue, options, rowObject) {
        return cellvalue ? messages['statistic.payed.yes'] : messages['statistic.payed.no'];
    };

    var collectSearchChildParams = function () {
        return {
            courseid: $('#course').val(),
            teacherid: $('#teacher').val(),
            additionalteacherid: $('#additionalTeacher').val(),
            agefrom: $('#ageFrom').val(),
            ageto: $('#ageTo').val(),
            subscriptiondatedrom: $('#subscriptionDateFrom').val(),
            subscriptiondatedto: $('#subscriptionDateTo').val(),
            agreementdatefrom: $('#agreementDateFrom').val(),
            agreementdateto: $('#agreementDateTo').val(),
            notvisiteddatefrom: $('#notVisitedDateFrom').val(),
            notvisiteddateto: $('#notVisitedDateTo').val(),
            includemissedall: $('#includeMissedAll:checked').length > 0 ? 'Y' : null,
            removevisitedall: $('#removeVisitedAll:checked').length > 0 ? 'Y' : null,
            scheduleid: selectedScheduleId,
            sourceinfoid: $('#sourceInfo').val(),
            locationid: $('#location').val(),
            interest: $('#interest').val(),
            desiredcourseid: $('#desiredCourse').val(),
            visitkindergarten: $('#visitkindergarten').val(),
            visitschool: $('#visitschool').val(),
            selectedfamilyid: selectedFamilyId ? selectedFamilyId : '',
            selectedchildid: selectedChildId ? selectedChildId : '',
            subscriptionType: $('#subscriptionType').val()
        };

    };

    this.addRecipients = function () {
        var addRecipientsParams = {};
        addRecipientsParams.searchParams = collectSearchChildParams();
        addRecipientsParams.selectedChildren = selectedChild;
        commonHelper.callAjaxMethod('statistic.htm', 'addRecipients', {"objects": JSON.stringify(addRecipientsParams)}, function (data) {
            $('#messageRecipientsCount').html(data.currentRecipientsCount);
        });
    };

    this.createTasks = function () {
        var params = {};
        params.hideChild = true;
        params.enableType = true;
        DIALOGS.taskEditDialog(null, null, null, null, true, true, null, null, function (data) {
            var createTaskParams = {};
            createTaskParams.searchParams = collectSearchChildParams();
            createTaskParams.taskParams = data;
            createTaskParams.selectedChildren = selectedChild;
            commonHelper.callAjaxMethod('statistic.htm', 'createTasks', {"objects": JSON.stringify(createTaskParams)}, function (data) {

            });
        });
    };

    this.selectChild = function (checked, name) {
        selectedChild[name.split('_')[1]] = checked;
    };

    this.openFamilyChildDialog = function (childid) {
        DIALOGS.familyDialogs.editFamilyDialog(null, childid, updateGridAfterFamilyUpdate, null, updateGridAfterFamilyUpdate);
    };

    var updateGridAfterFamilyUpdate = function () {
        var currentPage = $('#filterResultChildren').getGridParam('page');
        that.refreshChildrenLists(currentPage);
    };

    this.openFamilyDialog = function (familyid) {
        DIALOGS.familyDialogs.editFamilyDialog(familyid, null, updateGridAfterFamilyUpdate, null, updateGridAfterFamilyUpdate);
        $('body').find('button').button();
    };

    var clickChildFormatter = function (cellvalue, options, rowObject) {
        return '<a href="client.htm?childid=' + rowObject.childid + '">' + cellvalue + '</a>'
    };

    var clickFamilyChildFormatter = function (cellvalue, options, rowObject) {
        return '<a href="javascript:void(0)" onclick="' + options.colModel.formatoptions.clickmethod + '(' + rowObject.familyid + ')' + '; return false;">' + (cellvalue != '' ? cellvalue : messages['statistic.nofamily']) + '</a>'
    };

    this.refreshMembershipLists = function () {
        if (!membershipDataGrid) {

            var colNames = [];
            colNames.push(messages['statistic.membership.type']);
            colNames.push(messages['statistic.child']);
            colNames.push(messages['statistic.membership.course']);
            if (ORGS_COUNT > 0) {
                colNames.push(messages['statistic.membership.organization']);
            }
            colNames.push(messages['statistic.membership.teacher']);
            colNames.push(messages['statistic.membership.fromdate']);
            colNames.push(messages['statistic.membership.todate']);
            colNames.push(messages['statistic.membership.modifier']);
            colNames.push(messages['statistic.membership.createdate']);
            colNames.push(messages['statistic.membership.modifydate']);
            colNames.push(messages['statistic.membership.price']);
            colNames.push(messages['statistic.membership.paid']);
            colNames.push(messages['statistic.membership.customernumber']);

            var colModel = [];

            colModel.push({name: 'type', index: 'type', formatter: notNullFormatter});
            colModel.push({name: 'kid', index: 'kid', formatter: clickChildFormatter});
            colModel.push({name: 'course', index: 'course', formatter: notNullFormatter});
            if (ORGS_COUNT > 0) {
                colModel.push({name: 'organizationname', index: 'organizationname', formatter: notNullFormatter});
            }
            colModel.push({name: 'teacher', index: 'teacher', formatter: notNullFormatter});
            colModel.push({name: 'fromdate', index: 'fromdate', formatter: notNullFormatter});
            colModel.push({name: 'todate', index: 'todate', formatter: notNullFormatter});
            colModel.push({name: 'modifer', index: 'modifer', formatter: notNullFormatter});
            colModel.push({name: 'createdate', index: 'createdate', formatter: notNullFormatter});
            colModel.push({name: 'modifydate', index: 'modifydate', formatter: notNullFormatter});
            colModel.push({name: 'fullprice', index: 'fullprice', formatter: currencyFormatter});
            colModel.push({name: 'paid', index: 'paid', formatter: booleanFormatter});
            colModel.push({name: 'customnumber', index: 'customnumber', formatter: notNullFormatter});

            membershipDataGrid = $('#filterResultMemberships').jqGrid({
                datatype: loadMembershipLists,
                colNames: colNames,
                colModel: colModel,
                height: "100%",
                rowNum: 25,
                jsonReader: {repeatitems: false, id: "bmid"},
                pager: '#filterResultMembershipsPager', sortname: 'createdate', viewrecords: true, sortorder: "desc",
                afterInsertRow: function (rowid, aData, rowelem) {
                    if (rowelem.removed) {
                        membershipDataGrid.jqGrid('setRowData', rowid, false, {color: 'gray', background: '#DAC7C7'});
                    }
                }
            });
            membershipDataGrid.jqGrid('setGridWidth', TABLE_WIDTH);
        } else {
            membershipDataGrid.setGridParam({
                page: 1
            });
            membershipDataGrid.trigger("reloadGrid");
        }
    };

    var collectMembershipSearchParams = function () {
        var params = {
            filtermembershipdatefrom: $('#filtermembershipdatefrom').val(),
            filtermembershipdateto: $('#filtermembershipdateto').val(),
            user: $('#membershipuser').val(),
            membershiptype: $('#membershiptype').val()
        };

        var paramsString = '';
        for (var param in params) {
            paramsString += param + '=' + params[param] + '&';
        }
        return paramsString;
    };

    var loadMembershipLists = function (postdata) {
        postdata.filtermembershipdatefrom = $('#filtermembershipdatefrom').val();
        postdata.filtermembershipdateto = $('#filtermembershipdateto').val();
        postdata.user = $('#membershipuser').val();
        postdata.membershiptype = $('#membershiptype').val();
        commonHelper.callAjaxMethod('membershiphistory.htm', 'filterMemberships',
            postdata, function (result) {
                membershipDataGrid.jqGrid("clearGridData");
                membershipDataGrid[0].addJSONData(result);

                $('#totalPrice').html(result.additionalAggregationList[0].totalprice);
                $('#paidSum').html(result.additionalAggregationList[0].paidsum);
            }, true);
    };

    this.refreshTasksLists = function () {
        if (!tasksDataGrid) {

            var colNames = [];

            colNames.push(messages['statistic.tasks.subject']);
            colNames.push(messages['statistic.tasks.status']);
            colNames.push(messages['statistic.tasks.type']);
            if (ORGS_COUNT > 0) {
                colNames.push(messages['statistic.tasks.organization']);
            }
            colNames.push(messages['statistic.tasks.date']);
            if(studyClubMode){
                colNames.push(messages['statistic.tasks.clientname']);
            }
            else {
                colNames.push(messages['statistic.tasks.firstname']);
                colNames.push(messages['statistic.tasks.familyname']);
            }
            colNames.push(messages['statistic.tasks.comment']);

            var colModel = [];
            colModel.push({
                name: 'subject',
                index: 'subject',
                formatter: taskSubjectFormatter,
                formatoptions: {clickmethod: 'DIALOGS.taskEditDialog'}
            });
            colModel.push({name: 'status', index: 'status', formatter: taskStatusFormatter});
            colModel.push({name: 'type', index: 'type', formatter: taskTypeFormatter});
            if (ORGS_COUNT > 0) {
                colModel.push({name: 'organizationName', index: 'organizationName', formatter: notNullFormatter});
            }
            colModel.push({name: 'date', index: 'date', formatter: notNullFormatter});
            if(studyClubMode) {
                colModel.push({name: 'firstName', index: 'firstName', formatter: clickClientTasksFormatter});
            }
            else {
                colModel.push({name: 'firstName', index: 'firstName', formatter: clickChildTasksFormatter});
                colModel.push({
                    name: 'familyName',
                    index: 'familyName',
                    formatter: clickFamilyTasksFormatter,
                    formatoptions: {clickmethod: 'currentPage.openFamilyDialog'}
                });
            }
            colModel.push({name: 'comment', index: 'comment', formatter: 'string', sortable: false});

            tasksDataGrid = $('#filterResultTasks').jqGrid({
                datatype: loadTasksStatisticLists,
                colNames: colNames,
                colModel: colModel,
                height: "100%",
                jsonReader: {repeatitems: false, id: "taskid"},
                rowNum: 25,
                pager: '#filterResultTasksPager',
                sortname: 'taskid',
                viewrecords: true,
                sortorder: "desc"

            });
            tasksDataGrid.jqGrid('setGridWidth', TABLE_WIDTH);
        } else {
            tasksDataGrid.setGridParam({
                page: 1
            });
            tasksDataGrid.trigger("reloadGrid");
        }

    };

    var loadTasksStatisticLists = function (postdata) {
        postdata.filtersubject = $('#filtersubject').val() ? $('#filtersubject').val() : '';
        postdata.filterstatus = $('#filterstatus').val() ? $('#filterstatus').val() : '';
        postdata.filtertype = $('#filtertype').val() ? $('#filtertype').val() : '';
        postdata.filterdateto = $('#filterdateto').val() ? $('#filterdateto').val() : '';
        postdata.filterdatefrom = $('#filterdatefrom').val() ? $('#filterdatefrom').val() : '';
        postdata.filterrequestid = $('#filterrequestid').val() ? $('#filterrequestid').val() : '';
        postdata.filterchild = $('#filterchild').val() ? $('#filterchild').val() : '';

        commonHelper.callAjaxMethod('taskhistory.htm', 'filterTasks',
            postdata, function (result) {
                tasksDataGrid.clearGridData(true);
                tasksDataGrid[0].addJSONData(result);
            }, true);
    };

    var taskSubjectFormatter = function (cellvalue, options, rowObject) {
        return '<a href="javascript:void(0)" onclick="' + options.colModel.formatoptions.clickmethod + '(' + rowObject.taskid + ')' + '; return false;">' + cellvalue + '</a>'
    };

    var clickChildTasksFormatter = function (cellvalue, options, rowObject) {
        return rowObject.childId ? '<a href="client.htm?childid=' + rowObject.childId + '" >' + cellvalue + '</a>' : '';
    };

    var clickClientTasksFormatter = function (cellvalue, options, rowObject) {
        return rowObject.childId ? '<a href="client.htm?childid=' + rowObject.childId + '" >' + cellvalue + ' ' + rowObject.familyName + '</a>' : '';
    };

    var clickFamilyTasksFormatter = function (cellvalue, options, rowObject) {
        return '<a href="javascript:void(0)" onclick="' + options.colModel.formatoptions.clickmethod + '(' + rowObject.familyId + ')' + '; return false;">' + cellvalue + '</a>'
    };

    var taskTypeFormatter = function (cellvalue, options, rowObject) {
        return cellvalue.title;
    };

    var taskStatusFormatter = function (cellvalue, options, rowObject) {
        return cellvalue.title;
    };

    var initReferences = function () {
        commonHelper.callAjaxMethod('statistic.htm', 'loadReferences', {}, function (result) {
            var references = {};
            references.courses = [
                {name: '', courseid: ''}
            ].concat(result.courses.rows);
            references.teachers = [
                {name: '', teacherid: ''}
            ].concat(result.teachers.rows);
            references.schedules = [
                {id: '-1'}
            ].concat(result.schedules.rows);

            references.sourceInfos = [
                {name: '', infosourceid: ''}
            ].concat(result.sourceInfos.rows);
            references.locations = [
                {name: '', locationid: ''}
            ].concat(result.locations.rows);

            references.membershiptypes = [
                {name: '', membershiptypeid: ''}
            ].concat(result.membershiptype.rows);
            references.membershipusers = [
                {name: '', userid: ''}
            ].concat(result.users);

            membershiptype = result.membershiptype;


            var sourceInfoSelect = $('#sourceInfo');
            var teacherSelect = $('#teacher');
            var additionalTeacherSelect = $('#additionalTeacher');
            var childrenGroupTeacherSelect = $('#childrenGroupTeacher');

            var visitsByWeekTeacher = $('#visitsbyweekteacher');
            var visitsByWeekCourse = $('#visitsbyweekcourse');

            var increasedecreaseByWeekTeacher = $('#increasedecreasebyweekteacher');
            var increasedecreaseByWeekCourse = $('#increasedecreasebyweekcourse');

            var teacherTeacherSelect = $('#teacherTeacher');
            var locationSelect = $('#location');

            var membershipTypesSelect = $('.membershiptype');
            initReferenceSelect(membershipTypesSelect, references, 'membershiptype', 'membershiptypeid');
            $('<option>', {text: messages['statistic.subscription'], value: 'subscription'}).appendTo($('#subscriptionType'));
            $('<option>', {text: messages['statistic.reservation'], value: 'reservation'}).appendTo($('#subscriptionType'));

            var membershipUserSelect = $('#membershipuser');
            initReferenceSelect(membershipUserSelect, references, 'membershipuser', 'id');

            initReferenceSelect(teacherSelect, references, 'teacher', 'teacherid');
            initReferenceSelect(additionalTeacherSelect, references, 'teacher', 'teacherid');
            initReferenceSelect(teacherTeacherSelect, references, 'teacher', 'teacherid');
            initReferenceSelect(childrenGroupTeacherSelect, references, 'teacher', 'teacherid');

            if (visitsByWeekTeacher.length == 1) {
                initReferenceSelect(visitsByWeekTeacher, references, 'teacher', 'teacherid');
            }

            initReferenceSelect(increasedecreaseByWeekTeacher, references, 'teacher', 'teacherid');

            var courseSelect = $('#course');
            var childrenGroupCourseSelect = $('#childrenGroupCourse');
            initReferenceSelect(courseSelect, references, 'course', 'coursetypeid');
            initReferenceSelect(childrenGroupCourseSelect, references, 'course', 'coursetypeid');

            if (visitsByWeekCourse.length == 1) {
                initReferenceSelect(visitsByWeekCourse, references, 'course', 'coursetypeid');
            }

            initReferenceSelect(increasedecreaseByWeekCourse, references, 'course', 'coursetypeid');


            var desiredCourseSelect = $('#desiredCourse');
            initReferenceSelect(desiredCourseSelect, references, 'course', 'coursetypeid');

            initReferenceSelect(sourceInfoSelect, references, 'sourceInfo', 'infosourceid');
            initReferenceSelect(locationSelect, references, 'location', 'locationid');

            $.each(result.compositeSchedules.rows, function (index, item) {
                references.schedules.push({teacher: {name: item.scheduleDetails}, id: item.id});
            });

            $('.scheduleMenuUl').children(null).remove();
            var newRow = $('.menuScheduleItemTemplate').clone();
            newRow.show();
            newRow.appendTo($('.scheduleMenuUl'));
            $('#menuScheduleDiv .scheduleMenuUl').directives({
                '.menuScheduleItem': {
                    'schedule <- schedules': {
                        'span.teacher': generateTeachers,
                        'span.courseType': '#{schedule.courseType.name}',
                        'span.dates': '#{schedule.startDate} - #{schedule.finishDate}',
                        'span.scheduleElements': generateScheduleTitle,
                        '@value': 'schedule.id'
                    }
                }
            }).render(references);

            var menuContainer = $('#menuScheduleDiv ul');
            menuContainer.menu({
                    selected: selectSchedule
                }
            );

        });

        var initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename) {
            referenceSelect.children(null).remove();
            $('<option>', {
                value: ''
            }).appendTo(referenceSelect);

            var optionParams = {};
            optionParams[referencename + ' <- ' + referencename + 's'] = {
                '.': referencename + '.name',
                '@value': referencename + '.' + referencevaluename
            };

            referenceSelect.directives({
                'option': optionParams
            }).render(references);
        };

        var selectSchedule = function (event, ui) {
            selectedScheduleId = ui.item.attr('value');
            if (selectedScheduleId == -1) {
                selectedScheduleId = '';
                $('#selectedSchedule').html('');
            } else {
                var scheduleTitle = $(ui.item.children(null)[0]).html();
                $('#selectedSchedule').html(scheduleTitle);
            }
        };

        var generateTeachers = function (arg) {
            var teacherName = '';
            if(arg.item.teacher) {
                teacherName += arg.item.teacher.name;
            }
            if(arg.item.additionalTeacher){
                teacherName += ', ' + arg.item.additionalTeacher.name;
            }
            return teacherName;
        }

        var generateScheduleTitle = function (arg) {
            var context = arg.context;
            var item = arg.item;
            var result = '';
            if (item.id) {
                if (item.elements) {

                    for (var i = 0; i < item.elements.length; i++) {
                        var element = item.elements[i];
                        result += element.day.shortTitle + ' [' + element.startTime + '-' + element.finishTime + '] ; ';
                    }
                }
            }

            result += (item.comment ? ' ' + item.comment : '') + '';

            return result;
        }
    };

    this.openScheduleMenu = function () {
        var buttonOffset = $('#menubutton').offset();
        $('#menuScheduleDiv').css('left', (buttonOffset.left) + 'px');
        $('#menuScheduleDiv').css('top', (buttonOffset.top + $('#menubutton').height() + 3) + 'px');
        $('#menuScheduleDiv').show(10, 'linear', function () {
            $('html').one('click', function () {
                $('#menuScheduleDiv').hide();
            });
        });
    };

    this.openScheduleVisitsExcel = function () {
        if (selectedScheduleId) {
            var params = collectSearchChildParams();
            params.selectedChild = selectedChild;

            commonHelper.callAjaxMethod('statistic.htm', 'downloadChildrenVisitsAsExcel',
                {"objects": JSON.stringify(params)}, function (result) {
                    window.location.assign("files.htm?method=downloadFile&fileId=" + result.fileId);
                }, true);
        } else {
            commonHelper.showMessage(messages['statistic.noschedule']);
        }

    };

    this.openPrintVersion = function () {
        var params = collectSearchChildParams();

        //selectedChild
        var paramsString = 'sidx=' + kidStatisticSortField + '&sord' + '=' + kidStatisticSortOrder + '&';
        var existNotEmptyParam = false;
        for (var param in params) {
            var paramValue = params[param];
            existNotEmptyParam |= paramValue ? true : false;
            paramsString += param + '=' + paramValue + '&';
        }

        var left = (screen.width - 900) / 2;
        var top = (screen.height - 600) / 4;

        var printFunction = function () {
            window.open("statistic.htm?method=printKids" + (paramsString ? '&' + paramsString : ''), '_blank', 'status=0,toolbar=0,location=0,menubar=1,resizable=1,scrollbars=1, width=900px, height=600px, ' + 'top=' + top + ', left=' + left)
        };
        if (!existNotEmptyParam) {
            DIALOGS.askYesNoDialog(messages['statistic.printnoparam'], messages['common.yes'], printFunction);
        } else {
            printFunction();
        }

    };

    this.openExcelVersion = function () {
        var params = collectSearchChildParams();

        var paramsString = 'sidx=' + kidStatisticSortField + '&sord' + '=' + kidStatisticSortOrder + '&';
        var existNotEmptyParam = false;
        for (var param in params) {
            var paramValue = params[param];
            existNotEmptyParam |= paramValue ? true : false;
            paramsString += param + '=' + paramValue + '&';
        }

        var excelFunction = function () {
            window.location.assign("statistic.htm?method=downloadChildrenAsExcel" + (paramsString ? '&' + paramsString : ''));
        };
        if (!existNotEmptyParam) {
            DIALOGS.askYesNoDialog(messages['common.filternoparam'], messages['common.yes'], excelFunction);
        } else {
            excelFunction();
        }
    };

    this.openByClientExcel = function () {
        var params = {
            subscriptiondatedrom: $('#subscriptionDateFrom').val(),
            subscriptiondatedto: $('#subscriptionDateTo').val()
        };
        if(params.subscriptiondatedrom.length == 0 || params.subscriptiondatedto.length == 0){
            commonHelper.showMessage(messages['statistic.noperiod']);
        }
        else {
            commonHelper.callAjaxMethod('statistic.htm', 'downloadChildrenByClientAsExcel',
                {"objects": JSON.stringify(params)}, function (result) {
                    window.location.assign("files.htm?method=downloadFile&fileId=" + result.fileId);
                }, true);
        }
    };


}function visits_helper() {
    var that = this;
    var dayInfoDialog = null;
    var selectedDate = null;
    this.pageReady = function () {

        commonHelper.setDatePicker($('#lessonsdate'), function (_selectedDate) {
            selectedDate = _selectedDate;
            loadLessons(selectedDate);
        });

        commonHelper.registerChangeOrganizationListener(function (organizationId) {
            loadLessons(selectedDate);
        });

        var now = new Date();
        selectedDate = commonHelper.formatDate(now);
        loadLessons(selectedDate);
        $('body').find('button').button();
    };

    var loadLessons = function (selectedDate, scheduleId) {
        var subscriptionList = $('#subscriptionList');
        commonHelper.callAjaxMethod('visits.htm', 'loadDayLessons', {visitsdate: selectedDate, scheduleId: scheduleId}, function (data) {
            if (!scheduleId) {
                subscriptionList.parent(null).hide();
                subscriptionList.children(null).remove();
            }
            var template = $('#subscriptionInfoRow');

            $.each(data.elements, function (index, item) {
                var newRow = template.clone();

                if (scheduleId) {
                    var oldRow = $('#subscriptionInfoRow-' + scheduleId);
                    oldRow.after(newRow);
                    oldRow.remove();
                } else {
                    newRow.appendTo(subscriptionList);
                }

                newRow.directives({
                    '@id': 'subscriptionInfoRow-#{scheduleId}',
                    '.scheduleId@value': 'scheduleId',
                    '.sadId@value': 'sadId',
                    '.elementstarttime': 'startTime',
                    '.elementfinishtime': 'finishTime',
                    '.organization': 'organization.name',
                    '.teacher': generateTeacher,
                    '.actualTeacher': generateActualTeacher,
                    '.course': 'courseType.name',
                    '.plannedDate@value': 'plannedDate',
                    '.plannedStartTime@value': 'plannedStartTime',
                    '.changedPlannedDate': generateChangedPlannedDate,
                    '.changedPlannedDateTitle@style': generateChangedPlannedDateStyle,
                    '.room': 'room.title',
                    '.comment': 'comment',
                    '.subscriptiondiv@style': subcsriptionsdivstyle,
                    '.reservationdiv@style': reservationdivstyle,
                    '.schedulemessagediv@style+': schedulemessagestyle,
                    '.messageText': schedulemessage,
                    '.infoblock@style': infoblockstyle,
                    '.schedulerowinfo@style': schedulerowinfostyle,
                    '.kidRow': {
                        'kid <- kids': {
                            '.membershipId@value': 'kid.membershipId',
                            '.membershipType@value': 'kid.type',
                            '.scheduleId@value': 'kid.scheduleId',
                            '.kidindex' : 'kid.kidindex',
                            '.childid@value': 'kid.childId',
                            '.familyid@value': 'kid.familyId',
                            '.kidage': kidage,
                            '.kidphone': 'kid.familyPhone',
                            '.kidparent' : 'kid.parentName',
                            '.childsubscriptions@href': generateChildSubscriptions,
                            '.childsubscriptions': '#{kid.firstName} #{kid.lastName}',
                            '.visitedlink@id': 'kid.subscriptionElementId',
                            '.visitedlinkreason_a@id': 'kid.subscriptionElementId',
                            '.cancelvisitedlinkreason_a@id': 'kid.subscriptionElementId',
                            '.compensationlink@id': 'kid.subscriptionElementId',
                            '.compensationlink@compensationId': 'kid.compensationId',
                            '.compensationlink': compensationlinkvalue,
                            '.compensationlink@compensatedtype': 'kid.membershiptypecode',
                            '.cancelvisited@id': 'kid.subscriptionElementId',
                            '.membershiptitle': getMembershipTitle,
                            '.membershiptitle@style': membershiptitlestyle,
                            '.visitedtext@style': visitedtextstyle,
                            '.notvisitedtext@style': notvisitedtextstyle,
                            '.visitedlink@style': visitedlinkstyle,
                            '.lastCompensationDate': function (context) {
                                return context.item.lastCompensationDate ? 'до ' + context.item.lastCompensationDate : ''
                            },
                            '.compensationlinkContainer@style': compensationlinkstyle,
                            '.cancelvisited@style': cancelvisitedstyle,
                            '.visitedlinkreason@style': visitedlinkreasonstyle,
                            '.cancelvisitedlinkreason@style': cancelvisitedlinkreasonstyle,
                            '.notvisitedwithreasontext@style': notvisitedwithreasontextstyle,
                            '.notvisitedwithoutreasontext@style': notvisitedwithoutreasontextstyle,
                            '.deleted@style': deletedstyle,
                            '.lastLessonMark': lastlessonmark
                        }
                    },
                    '.reservationRow': {
                        'kid <- reservation': {
                            '.membershipId@value': 'kid.membershipId',
                            '.membershipType@value': 'kid.type',
                            '.scheduleId@value': 'kid.scheduleId',
                            '.childid@value': 'kid.childId',
                            '.kidindex' : 'kid.kidindex',
                            '.childreservations@href': generateChildSubscriptions,
                            '.childreservations': '#{kid.firstName} #{kid.lastName}',
                            '.kidage': kidage
                        }
                    }

                }).render(item);


            });

            subscriptionList = $('#subscriptionList');

            if (subscriptionList.children(null).length > 0) {
                $('#emptyList').hide();

                var kidRow = $('.kidRow');
                kidRow.removeClass('evenRow2');
                kidRow.removeClass('oddRow2');

                var reservationRow = $('.reservationRow');
                reservationRow.removeClass('evenRow2');
                reservationRow.removeClass('oddRow2');

                subscriptionList.children(null).filter(':even').addClass('evenRow');
                subscriptionList.children(null).filter(':odd').addClass('oddRow');

                var kidTableList = $('.kidsTableList');
                kidTableList.children(null).filter(':even').addClass('evenRow2');
                kidTableList.children(null).filter(':odd').addClass('oddRow2');

                var reservationTableList = $('.reservationTableList');

                reservationTableList.children(null).filter(':even').addClass('evenRow2');
                reservationTableList.children(null).filter(':odd').addClass('oddRow2');

                subscriptionList.parent().show();
                subscriptionList.children(null).show();
            } else {
                $('#emptyList').show();
            }

            commonHelper.prepareViewer([
                {filter: '.visitedlink', action: 'hide'},
                {filter: '.createsubscription', action: 'hide'},
                {filter: '.cancelvisited', action: 'hide'},
                {filter: '.addRecipientsLink', action: 'hide'}
            ]);

        });
    };

    that.openDayInfo = function (uiElement) {
        ACTUAL_DAY_INFO_INSTANCE = ACTUAL_DAY_INFO(function () {
            return dayInfoDialog;
        }, function () {

        }, function () {

        }, function (data) {
            var actualDateDiv = $('#subscriptiondays').find('[value="' + data.actualDay.plannedDate + '"]').find('.actualDate');
            actualDateDiv.show();
            actualDateDiv.find('.actualDateTitle').html(data.actualDay.actualDate);

        }, function (data) {
            var actualDateDiv = $('#subscriptiondays').find('[value="' + data.actualDay.plannedDate + '"]').find('.actualDate');
            actualDateDiv.find('.actualDateTitle').html('');
            actualDateDiv.hide();
        });

        var row = $(uiElement).parents().filter('.subscriptionRow');
        var scheduleId = row.find('.scheduleId').val();
        var plannedDate = row.find('.plannedDate').val();
        var plannedStartTime = row.find('.plannedStartTime').val();
        DIALOGS.openDayInfo(dayInfoDialog, plannedDate, plannedStartTime, scheduleId, true);
    };

    that.createReservation = function (scheduleId) {
        DIALOGS.subscriptionDialogs.openSubscriptionDialogForScheduleActualDay({
            subscriptionType: 'reservation',
            scheduleId: scheduleId,
            plannedDate: selectedDate,
            callbackFunction: function () {
                loadLessons(selectedDate, scheduleId);
            }
        });
    };

    that.createOnceLesson = function (scheduleId, sadId) {
        DIALOGS.subscriptionDialogs.openSubscriptionDialogForScheduleActualDay({
            subscriptionType: 'onceLesson',
            scheduleId: scheduleId,
            sadId: sadId,
            plannedDate: selectedDate,
            callbackFunction: function () {
                loadLessons(selectedDate, scheduleId);
            }
        });
    };

    that.createSubscription = function (scheduleId) {
        DIALOGS.subscriptionDialogs.openSubscriptionDialogForScheduleActualDay({
            subscriptionType: 'subscription',
            scheduleId: scheduleId,
            plannedDate: selectedDate,
            callbackFunction: function () {
                loadLessons(selectedDate, scheduleId);
            }
        });
    };

    that.editSubscriptionDialog = function (scheduleId, kidTitle, kidId, membershipId, membershipType) {
        DIALOGS.subscriptionDialogs.openSubscriptionDialogForChild({
            childId: kidId,
            childFamilyTitle: kidTitle,
            subscriptionId: membershipId,
            subscriptionType: membershipType,
            action: 'edit',
            callbackFunction: function () {
                loadLessons(selectedDate, scheduleId);
            },
            deleteCallbackFunction: function () {
                loadLessons(selectedDate, scheduleId);
            }
        });
    };

    var generateChangedPlannedDateStyle = function (context) {
        if (context.context.changedPlannedDate && context.context.changedPlannedDate != '') {
            return '';
        } else {
            return 'display : none;';
        }
    };

    var generateChangedPlannedDate = function (context) {
        if (context.context.changedPlannedDate != '') {
            return context.context.changedPlannedDate;
        } else {
            return '';
        }
    };

    var generateTeacher = function (context) {
        return context.context.teacher.name + (context.context.additionalTeacher ? (', ' + context.context.additionalTeacher.name) : '');
    };
    
    var generateActualTeacher = function (context) {
        var replace = false;
        var teacherName = '';
        if(context.context.actualTeacher && context.context.teacher.id != context.context.actualTeacher.id){
            replace = true;
            teacherName += context.context.actualTeacher.name;
        }
        else {
            teacherName += context.context.teacher.name;
        }
        if(context.context.actualAdditionalTeacher && (!context.context.additionalTeacher || context.context.additionalTeacher.id != context.context.actualAdditionalTeacher.id)){
            replace = true;
            teacherName += ',' + context.context.actualAdditionalTeacher.name;
        }
        else if(context.context.additionalTeacher){
            teacherName += ',' + context.context.additionalTeacher.name;
        }
        return replace ? '<span style="color: red;font-size: 12px;padding-left: 3px;">' + messages['visits.replacement'] + ' </span>' + teacherName : '';
    };

    var generateChildSubscriptions = function (context) {
        return 'client.htm?childid=' + context.item.childId;
    };

    var compensationlinkvalue = function (context) {
        return context.item.compensationId ? messages['visits.compensation.complete'] : messages['visits.compensation.inprogress'];
    };

    var membershiptitlestyle = function (context) {
        return context.item.type == 'onceLesson' ? 'color: #FF395A' : 'color: blue';
    };

    var getMembershipTitle = function (context) {
        var defaultTitle = context.item.type == 'onceLesson' ? messages['visits.onelesson.yes'] : messages['visits.onelesson.no'];
        return context.item.membershiptype ? '' + context.item.membershiptype : defaultTitle;
    };

    var schedulerowinfostyle = function (context) {
        return context.context.emptyschedule ? 'display: none' : '';
    };

    var infoblockstyle = function (context) {
        if (context.context.canceled || context.context.emptyschedule) {
            return 'vertical-align: middle;';
        }
        return '';
    };

    var schedulemessage = function (context) {
        if (context.context.canceled) {
            return messages['visits.lesson.canceled'];
        } else if (context.context.emptyschedule) {
            if (context.context.movedtype == 'movedfrom') {
                return messages['visits.lesson.moved'] + ' ' + context.context.actualDate;
            } else {
                return messages['visits.lesson.norecord'];
            }
        }
        return '';
    };

    var schedulemessagestyle = function (context) {
        if (context.context.canceled || context.context.emptyschedule) {
            if (context.context.canceled) {
                return 'background-color: #FFEAA0';
            } else if (context.context.emptyschedule) {
                if (context.context.movedtype == 'movedfrom') {
                    return 'background-color: #FFFBAB';
                } else {
                    return 'background-color: #E5FFA3';
                }
            } else {
                return '';
            }
        } else {
            return 'display : none;';
        }
    };

    var subcsriptionsdivstyle = function (context) {
        return context.context.kids && context.context.kids.length > 0 ? '' : 'display : none;';
    };

    var reservationdivstyle = function (context) {
        return context.context.reservation && context.context.reservation.length > 0 ? '' : 'display : none;';
    };

    var kidage = function (context) {
        return context.item.age ? context.item.age : '&nbsp;';
    };


    var visitedtextstyle = function (context) {
        return calculateLessonState(context.item) == 'visited' ? 'font-weight: bold' : 'display : none;';
    };

    var notvisitedtextstyle = function (context) {
        var state = calculateLessonState(context.item);
        switch (state) {
            case 'not-visited' :
                return 'color: green';
            case 'not-visited-with-reason' :
                return 'color: blue';
            case 'not-visited-without-reason' :
                return 'color: red';
            default :
                return 'display : none;';
        }
    };

    var visitedlinkstyle = function (context) {
        var state = calculateLessonState(context.item);
        return state == 'not-visited' || state == 'not-marked' || state == 'not-visited-with-reason' || state == 'not-visited-without-reason' ? '' : 'display : none;';
    };

    var compensationlinkstyle = function (context) {
        var state = calculateLessonState(context.item);
        return state == 'not-visited-with-reason' ? '' : 'display : none;';
    };

    var visitedlinkreasonstyle = function (context) {
        var state = calculateLessonState(context.item);
        return state == 'not-visited' || state == 'not-marked' || state == 'not-visited-without-reason' ? '' : 'display : none;';
    };

    var cancelvisitedlinkreasonstyle = function (context) {
        var state = calculateLessonState(context.item);
        return state == 'not-marked' || state == 'not-visited-with-reason' ? '' : 'display : none;';
    };

    var cancelvisitedstyle = function (context) {
        var state = calculateLessonState(context.item);
        return state == 'visited' ? '' : 'display : none;';
    };

    var notvisitedwithreasontextstyle = function (context) {
        var state = calculateLessonState(context.item);
        return state == 'not-visited-with-reason' ? '' : 'display : none;';
    };

    var notvisitedwithoutreasontextstyle = function (context) {
        var state = calculateLessonState(context.item);
        return state == 'not-visited-without-reason' ? '' : 'display : none;';
    };

    var calculateLessonState = function (item) {
        if (item.visited === '') {
            return 'not-marked';
        }

        if (item.visited === true) {
            return 'visited';
        }

        if ((item.visited === '' || item.visited === false) && item.notVisitedGoodReason === true) {
            return 'not-visited-with-reason';
        }

        if ((item.visited === '' || item.visited === false) && (item.notVisitedGoodReason === false || item.notVisitedGoodReason === '')) {
            return 'not-visited-without-reason';
        }

        if (item.visited === false) {
            return 'not-visited';
        }

        return 'invalid-type';
    };


    var lastlessonmark = function (context) {
        if (context.item.lastLesson) {
            switch (context.item.otherMsPaid) {
                case 'notPaid' :
                    return '<span style="color: blue" title="' + messages['visits.mark.notpaid'] + '" alt="' + messages['visits.mark.notpaid'] + '">!</span>';
                case 'last' :
                    return '<span style="color: red" title="' + messages['visits.mark.last'] + '" alt="' + messages['visits.mark.last'] + '">!</span>';
                case 'paid' :
                    return '<span style="color: green" title="' + messages['visits.mark.paid'] + '" alt="' + messages['visits.mark.paid'] + '">!</span>';
                case 'partlyPaid' :
                    return '<span style="color: #ffa252" title="' + messages['visits.mark.partlypaid'] + '"  alt="' + messages['visits.mark.partlypaid'] + '">!</span>';
            }
        }
        return '';
    };

    var deletedstyle = function (context) {
        return context.item.removed ? '' : 'display : none;';
    };

    that.openPrintVersion = function () {
        var left = (screen.width - 900) / 2;
        var top = (screen.height - 600) / 4;

        window.open("visits.htm?method=printVisits&selectedDate=" + selectedDate, '_blank', 'status=0,toolbar=0,location=0,menubar=1,resizable=1,scrollbars=1, width=900px, height=600px, ' + 'top=' + top + ', left=' + left);
    };

    that.createOrEditCompensation = function (subscriptionElementId, compensationId, compensatedtype, childId, childFamilyTitle) {
        if (compensationId) {
            DIALOGS.subscriptionDialogs.editCompensation({
                childId: childId,
                childFamilyTitle: childFamilyTitle,
                subscriptionId: compensationId,
                callbackFunction: function () {
                    loadLessons(selectedDate);
                },
                deleteCallbackFunction: function () {
                    loadLessons(selectedDate);
                }
            });
        } else {
            if (compensatedtype == 'compensation') {
                commonHelper.showMessage(messages['visits.compensation.error']);
            } else {
                DIALOGS.subscriptionDialogs.openSubscriptionDialogForCompensation({
                        childId: childId,
                        membershipElementId: subscriptionElementId,
                        childFamilyTitle: childFamilyTitle,
                        callbackFunction: function () {
                            loadLessons(selectedDate);
                        },
                        deleteCallbackFunction: function () {
                            loadLessons(selectedDate);
                        }
                    }
                )
            }
        }
    };

    that.markAsVisited = function (subscriptionElementId, container) {
        commonHelper.callAjaxMethod('visits.htm', 'markAsVisited', {subscriptionElementId: subscriptionElementId}, function (data) {
            if (data) {
                $(container).find('.visitedtext').show();
                $(container).find('.notvisitedtext').hide();
                $(container).find('.notvisitedwithreasontext').hide();
                $(container).find('.notvisitedwithoutreasontext').hide();
                $(container).find('.visitedlinkreason').hide();
                $(container).find('.cancelvisitedlinkreason').hide();
                $(container).find('.cancelvisited').show();
                $(container).find('.visitedlink').hide();
                $(container).find('.compensationlinkContainer').hide();

            }
        });
    };

    that.markAsNotVisitedWithReason = function (subscriptionElementId, container) {
        commonHelper.callAjaxMethod('visits.htm', 'markAsNotVisitedWithReason', {subscriptionElementId: subscriptionElementId}, function (data) {
            if (data) {
                $(container).find('.visitedtext').hide();

                $(container).find('.notvisitedtext').show();
                $(container).find('.notvisitedtext').css('color', 'blue');

                $(container).find('.notvisitedwithreasontext').show();
                $(container).find('.notvisitedwithoutreasontext').hide();
                $(container).find('.visitedlinkreason').hide();
                $(container).find('.cancelvisitedlinkreason').show();
                $(container).find('.cancelvisited').hide();
                $(container).find('.visitedlink').show();
                $(container).find('.compensationlinkContainer').show();

            }
        });
    };

    that.cancelNotVisitedWithReason = function (subscriptionElementId, container) {
        commonHelper.callAjaxMethod('visits.htm', 'cancelNotVisitedWithReason', {subscriptionElementId: subscriptionElementId}, function (data) {
            if (data) {
                $(container).find('.visitedtext').hide();

                $(container).find('.notvisitedtext').show();
                $(container).find('.notvisitedtext').css('color', 'red');

                $(container).find('.notvisitedwithreasontext').hide();
                $(container).find('.notvisitedwithoutreasontext').show();
                $(container).find('.visitedlinkreason').show();
                $(container).find('.cancelvisitedlinkreason').hide();
                $(container).find('.cancelvisited').hide();
                $(container).find('.visitedlink').show();
                $(container).find('.compensationlinkContainer').hide();
            }
        });
    };


    that.cancelAsVisited = function (subscriptionElementId, container) {
        commonHelper.callAjaxMethod('visits.htm', 'cancelAsVisited', {subscriptionElementId: subscriptionElementId}, function (data) {
            if (data) {
                $(container).find('.visitedtext').hide();
                $(container).find('.notvisitedtext').css('color', 'green');
                $(container).find('.notvisitedtext').show();
                $(container).find('.notvisitedwithreasontext').hide();
                $(container).find('.notvisitedwithoutreasontext').hide();
                $(container).find('.visitedlinkreason').show();
                $(container).find('.cancelvisitedlinkreason').hide();
                $(container).find('.cancelvisited').hide();
                $(container).find('.visitedlink').show();
                $(container).find('.compensationlinkContainer').hide();
            }
        });
    };

    that.addRecipients = function(container){
        var childIdsContainers = container.find('.childid');
        var childIds = [];
        $.each(childIdsContainers, function(index, item){
            childIds.push(item.value);
        });
        commonHelper.callAjaxMethod('statistic.htm', 'addRecipient', {"objects": JSON.stringify({childId: childIds})}, function (data) {
            $('#messageRecipientsCount').html(data.currentRecipientsCount);
        });
    };

    return this;
}(function(a,b){if(typeof define==="function"&&define.amd){define(b)
}else{if(typeof exports!=="undefined"){module.exports=b()
}else{a.atmosphere=b()
}}}(this,function(){var a={},d,c=false,g=[],f=[],e=0,b=Object.prototype.hasOwnProperty;
a={version:"2.3.2-javascript",onError:function(h){},onClose:function(h){},onOpen:function(h){},onReopen:function(h){},onMessage:function(h){},onReconnect:function(i,h){},onMessagePublished:function(h){},onTransportFailure:function(i,h){},onLocalMessage:function(h){},onFailureToReconnect:function(i,h){},onClientTimeout:function(h){},onOpenAfterResume:function(h){},WebsocketApiAdapter:function(i){var h,j;
i.onMessage=function(k){j.onmessage({data:k.responseBody})
};
i.onMessagePublished=function(k){j.onmessage({data:k.responseBody})
};
i.onOpen=function(k){j.onopen(k)
};
j={close:function(){h.close()
},send:function(k){h.push(k)
},onmessage:function(k){},onopen:function(k){},onclose:function(k){},onerror:function(k){}};
h=new a.subscribe(i);
return j
},AtmosphereRequest:function(ad){var p={timeout:300000,method:"GET",headers:{},contentType:"",callback:null,url:"",data:"",suspend:true,maxRequest:-1,reconnect:true,maxStreamingLength:10000000,lastIndex:0,logLevel:"info",requestCount:0,fallbackMethod:"GET",fallbackTransport:"streaming",transport:"long-polling",webSocketImpl:null,webSocketBinaryType:null,dispatchUrl:null,webSocketPathDelimiter:"@@",enableXDR:false,rewriteURL:false,attachHeadersAsQueryString:true,executeCallbackBeforeReconnect:false,readyState:0,withCredentials:false,trackMessageLength:false,messageDelimiter:"|",connectTimeout:-1,reconnectInterval:0,dropHeaders:true,uuid:0,async:true,shared:false,readResponsesHeaders:false,maxReconnectOnClose:5,enableProtocol:true,disableDisconnect:false,pollingInterval:0,heartbeat:{client:null,server:null},ackInterval:0,closeAsync:false,reconnectOnServerError:true,handleOnlineOffline:true,onError:function(aI){},onClose:function(aI){},onOpen:function(aI){},onMessage:function(aI){},onReopen:function(aJ,aI){},onReconnect:function(aJ,aI){},onMessagePublished:function(aI){},onTransportFailure:function(aJ,aI){},onLocalMessage:function(aI){},onFailureToReconnect:function(aJ,aI){},onClientTimeout:function(aI){},onOpenAfterResume:function(aI){}};
var ar={status:200,reasonPhrase:"OK",responseBody:"",messages:[],headers:[],state:"messageReceived",transport:"polling",error:null,request:null,partialMessage:"",errorHandled:false,closedByClientTimeout:false,ffTryingReconnect:false};
var aw=null;
var ag=null;
var z=null;
var n=null;
var X=null;
var u=true;
var ay=0;
var J=0;
var ak="X";
var aG=false;
var Q=null;
var h;
var ax=null;
var R=a.util.now();
var y;
var aF;
var Y=false;
ao(ad);
function aj(){u=true;
aG=false;
ay=0;
aw=null;
ag=null;
z=null;
n=null
}function U(){l();
aj()
}function w(aI){if(aI=="debug"){return p.logLevel==="debug"
}else{if(aI=="info"){return p.logLevel==="info"||p.logLevel==="debug"
}else{if(aI=="warn"){return p.logLevel==="warn"||p.logLevel==="info"||p.logLevel==="debug"
}else{if(aI=="error"){return p.logLevel==="error"||p.logLevel==="warn"||p.logLevel==="info"||p.logLevel==="debug"
}else{return false
}}}}}function aH(aI){if(w("debug")){a.util.debug(new Date()+" Atmosphere: "+aI)
}}function I(aJ,aI){if(ar.partialMessage===""&&(aI.transport==="streaming")&&(aJ.responseText.length>aI.maxStreamingLength)){return true
}return false
}function D(){if(p.enableProtocol&&!p.disableDisconnect&&!p.firstMessage){var aK="X-Atmosphere-Transport=close&X-Atmosphere-tracking-id="+p.uuid;
a.util.each(p.headers,function(aM,aO){var aN=a.util.isFunction(aO)?aO.call(this,p,p,ar):aO;
if(aN!=null){aK+="&"+encodeURIComponent(aM)+"="+encodeURIComponent(aN)
}});
var aI=p.url.replace(/([?&])_=[^&]*/,aK);
aI=aI+(aI===p.url?(/\?/.test(p.url)?"&":"?")+aK:"");
var aJ={connected:false};
var aL=new a.AtmosphereRequest(aJ);
aL.connectTimeout=p.connectTimeout;
aL.attachHeadersAsQueryString=false;
aL.dropHeaders=true;
aL.url=aI;
aL.contentType="text/plain";
aL.transport="polling";
aL.method="GET";
aL.data="";
aL.heartbeat=null;
if(p.enableXDR){aL.enableXDR=p.enableXDR
}aL.async=p.closeAsync;
am("",aL)
}}function H(){aH("Closing (AtmosphereRequest._close() called)");
aG=true;
if(p.reconnectId){clearTimeout(p.reconnectId);
delete p.reconnectId
}if(p.heartbeatTimer){clearTimeout(p.heartbeatTimer)
}p.reconnect=false;
ar.request=p;
ar.state="unsubscribe";
ar.responseBody="";
ar.status=408;
ar.partialMessage="";
ai();
D();
l()
}function l(){ar.partialMessage="";
if(p.id){clearTimeout(p.id)
}if(p.heartbeatTimer){clearTimeout(p.heartbeatTimer)
}if(p.reconnectId){clearTimeout(p.reconnectId);
delete p.reconnectId
}if(n!=null){n.close();
n=null
}if(X!=null){X.abort();
X=null
}if(z!=null){z.abort();
z=null
}if(aw!=null){if(aw.canSendMessage){aH("invoking .close() on WebSocket object");
aw.close()
}aw=null
}if(ag!=null){ag.close();
ag=null
}ah()
}function ah(){if(h!=null){clearInterval(y);
document.cookie=aF+"=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
h.signal("close",{reason:"",heir:!aG?R:(h.get("children")||[])[0]});
h.close()
}if(ax!=null){ax.close()
}}function ao(aI){U();
p=a.util.extend(p,aI);
p.mrequest=p.reconnect;
if(!p.reconnect){p.reconnect=true
}}function au(){return p.webSocketImpl!=null||window.WebSocket||window.MozWebSocket
}function at(){var aJ=a.util.getAbsoluteURL(p.url.toLowerCase());
var aK=/^([\w\+\.\-]+:)(?:\/\/([^\/?#:]*)(?::(\d+))?)?/.exec(aJ);
var aI=!!(aK&&(aK[1]!=window.location.protocol||aK[2]!=window.location.hostname||(aK[3]||(aK[1]==="http:"?80:443))!=(window.location.port||(window.location.protocol==="http:"?80:443))));
return window.EventSource&&(!aI||!a.util.browser.safari||a.util.browser.vmajor>=7)
}function aa(){if(p.shared){ax=aD(p);
if(ax!=null){if(w("debug")){a.util.debug("Storage service available. All communication will be local")
}if(ax.open(p)){return
}}if(w("debug")){a.util.debug("No Storage service available.")
}ax=null
}p.firstMessage=e==0?true:false;
p.isOpen=false;
p.ctime=a.util.now();
if(p.uuid===0){p.uuid=e
}ar.closedByClientTimeout=false;
if(p.transport!=="websocket"&&p.transport!=="sse"){L(p)
}else{if(p.transport==="websocket"){if(!au()){az("Websocket is not supported, using request.fallbackTransport ("+p.fallbackTransport+")")
}else{af(false)
}}else{if(p.transport==="sse"){if(!at()){az("Server Side Events(SSE) is not supported, using request.fallbackTransport ("+p.fallbackTransport+")")
}else{C(false)
}}}}}function aD(aM){var aN,aL,aQ,aI="atmosphere-"+aM.url,aJ={storage:function(){function aR(aV){if(aV.key===aI&&aV.newValue){aK(aV.newValue)
}}if(!a.util.storage){return
}var aU=window.localStorage,aS=function(aV){return a.util.parseJSON(aU.getItem(aI+"-"+aV))
},aT=function(aV,aW){aU.setItem(aI+"-"+aV,a.util.stringifyJSON(aW))
};
return{init:function(){aT("children",aS("children").concat([R]));
a.util.on(window,"storage",aR);
return aS("opened")
},signal:function(aV,aW){aU.setItem(aI,a.util.stringifyJSON({target:"p",type:aV,data:aW}))
},close:function(){var aV=aS("children");
a.util.off(window,"storage",aR);
if(aV){if(aO(aV,aM.id)){aT("children",aV)
}}}}
},windowref:function(){var aR=window.open("",aI.replace(/\W/g,""));
if(!aR||aR.closed||!aR.callbacks){return
}return{init:function(){aR.callbacks.push(aK);
aR.children.push(R);
return aR.opened
},signal:function(aS,aT){if(!aR.closed&&aR.fire){aR.fire(a.util.stringifyJSON({target:"p",type:aS,data:aT}))
}},close:function(){if(!aQ){aO(aR.callbacks,aK);
aO(aR.children,R)
}}}
}};
function aO(aU,aT){var aR,aS=aU.length;
for(aR=0;
aR<aS;
aR++){if(aU[aR]===aT){aU.splice(aR,1)
}}return aS!==aU.length
}function aK(aR){var aT=a.util.parseJSON(aR),aS=aT.data;
if(aT.target==="c"){switch(aT.type){case"open":V("opening","local",p);
break;
case"close":if(!aQ){aQ=true;
if(aS.reason==="aborted"){H()
}else{if(aS.heir===R){aa()
}else{setTimeout(function(){aa()
},100)
}}}break;
case"message":k(aS,"messageReceived",200,aM.transport);
break;
case"localMessage":F(aS);
break
}}}function aP(){var aR=new RegExp("(?:^|; )("+encodeURIComponent(aI)+")=([^;]*)").exec(document.cookie);
if(aR){return a.util.parseJSON(decodeURIComponent(aR[2]))
}}aN=aP();
if(!aN||a.util.now()-aN.ts>1000){return
}aL=aJ.storage()||aJ.windowref();
if(!aL){return
}return{open:function(){var aR;
y=setInterval(function(){var aS=aN;
aN=aP();
if(!aN||aS.ts===aN.ts){aK(a.util.stringifyJSON({target:"c",type:"close",data:{reason:"error",heir:aS.heir}}))
}},1000);
aR=aL.init();
if(aR){setTimeout(function(){V("opening","local",aM)
},50)
}return aR
},send:function(aR){aL.signal("send",aR)
},localSend:function(aR){aL.signal("localSend",a.util.stringifyJSON({id:R,event:aR}))
},close:function(){if(!aG){clearInterval(y);
aL.signal("close");
aL.close()
}}}
}function aE(){var aJ,aI="atmosphere-"+p.url,aN={storage:function(){function aO(aQ){if(aQ.key===aI&&aQ.newValue){aK(aQ.newValue)
}}if(!a.util.storage){return
}var aP=window.localStorage;
return{init:function(){a.util.on(window,"storage",aO)
},signal:function(aQ,aR){aP.setItem(aI,a.util.stringifyJSON({target:"c",type:aQ,data:aR}))
},get:function(aQ){return a.util.parseJSON(aP.getItem(aI+"-"+aQ))
},set:function(aQ,aR){aP.setItem(aI+"-"+aQ,a.util.stringifyJSON(aR))
},close:function(){a.util.off(window,"storage",aO);
aP.removeItem(aI);
aP.removeItem(aI+"-opened");
aP.removeItem(aI+"-children")
}}
},windowref:function(){var aP=aI.replace(/\W/g,""),aO=document.getElementById(aP),aQ;
if(!aO){aO=document.createElement("div");
aO.id=aP;
aO.style.display="none";
aO.innerHTML='<iframe name="'+aP+'" />';
document.body.appendChild(aO)
}aQ=aO.firstChild.contentWindow;
return{init:function(){aQ.callbacks=[aK];
aQ.fire=function(aR){var aS;
for(aS=0;
aS<aQ.callbacks.length;
aS++){aQ.callbacks[aS](aR)
}}
},signal:function(aR,aS){if(!aQ.closed&&aQ.fire){aQ.fire(a.util.stringifyJSON({target:"c",type:aR,data:aS}))
}},get:function(aR){return !aQ.closed?aQ[aR]:null
},set:function(aR,aS){if(!aQ.closed){aQ[aR]=aS
}},close:function(){}}
}};
function aK(aO){var aQ=a.util.parseJSON(aO),aP=aQ.data;
if(aQ.target==="p"){switch(aQ.type){case"send":t(aP);
break;
case"localSend":F(aP);
break;
case"close":H();
break
}}}Q=function aM(aO){aJ.signal("message",aO)
};
function aL(){document.cookie=aF+"="+encodeURIComponent(a.util.stringifyJSON({ts:a.util.now()+1,heir:(aJ.get("children")||[])[0]}))+"; path=/"
}aJ=aN.storage()||aN.windowref();
aJ.init();
if(w("debug")){a.util.debug("Installed StorageService "+aJ)
}aJ.set("children",[]);
if(aJ.get("opened")!=null&&!aJ.get("opened")){aJ.set("opened",false)
}aF=encodeURIComponent(aI);
aL();
y=setInterval(aL,1000);
h=aJ
}function V(aK,aN,aJ){if(p.shared&&aN!=="local"){aE()
}if(h!=null){h.set("opened",true)
}aJ.close=function(){H()
};
if(ay>0&&aK==="re-connecting"){aJ.isReopen=true;
q(ar)
}else{if(ar.error==null){ar.request=aJ;
var aL=ar.state;
ar.state=aK;
var aI=ar.transport;
ar.transport=aN;
var aM=ar.responseBody;
ai();
ar.responseBody=aM;
ar.state=aL;
ar.transport=aI
}}}function aB(aK){aK.transport="jsonp";
var aJ=p,aI;
if((aK!=null)&&(typeof(aK)!=="undefined")){aJ=aK
}X={open:function(){var aN="atmosphere"+(++R);
function aL(){aJ.lastIndex=0;
if(aJ.openId){clearTimeout(aJ.openId)
}if(aJ.heartbeatTimer){clearTimeout(aJ.heartbeatTimer)
}if(aJ.reconnect&&ay++<aJ.maxReconnectOnClose){V("re-connecting",aJ.transport,aJ);
an(X,aJ,aK.reconnectInterval);
aJ.openId=setTimeout(function(){Z(aJ)
},aJ.reconnectInterval+1000)
}else{T(0,"maxReconnectOnClose reached")
}}function aM(){var aO=aJ.url;
if(aJ.dispatchUrl!=null){aO+=aJ.dispatchUrl
}var aQ=aJ.data;
if(aJ.attachHeadersAsQueryString){aO=o(aJ);
if(aQ!==""){aO+="&X-Atmosphere-Post-Body="+encodeURIComponent(aQ)
}aQ=""
}var aP=document.head||document.getElementsByTagName("head")[0]||document.documentElement;
aI=document.createElement("script");
aI.src=aO+"&jsonpTransport="+aN;
aI.clean=function(){aI.clean=aI.onerror=aI.onload=aI.onreadystatechange=null;
if(aI.parentNode){aI.parentNode.removeChild(aI)
}if(++aK.scriptCount===2){aK.scriptCount=1;
aL()
}};
aI.onload=aI.onreadystatechange=function(){aH("jsonp.onload");
if(!aI.readyState||/loaded|complete/.test(aI.readyState)){aI.clean()
}};
aI.onerror=function(){aH("jsonp.onerror");
aK.scriptCount=1;
aI.clean()
};
aP.insertBefore(aI,aP.firstChild)
}window[aN]=function(aQ){aH("jsonp.window");
aK.scriptCount=0;
if(aJ.reconnect&&aJ.maxRequest===-1||aJ.requestCount++<aJ.maxRequest){if(!aJ.executeCallbackBeforeReconnect){an(X,aJ,aJ.pollingInterval)
}if(aQ!=null&&typeof aQ!=="string"){try{aQ=aQ.message
}catch(aP){}}var aO=r(aQ,aJ,ar);
if(!aO){k(ar.responseBody,"messageReceived",200,aJ.transport)
}if(aJ.executeCallbackBeforeReconnect){an(X,aJ,aJ.pollingInterval)
}j(aJ)
}else{a.util.log(p.logLevel,["JSONP reconnect maximum try reached "+p.requestCount]);
T(0,"maxRequest reached")
}};
setTimeout(function(){aM()
},50)
},abort:function(){if(aI&&aI.clean){aI.clean()
}}};
X.open()
}function av(aI){if(p.webSocketImpl!=null){return p.webSocketImpl
}else{if(window.WebSocket){return new WebSocket(aI)
}else{return new MozWebSocket(aI)
}}}function v(){return o(p,a.util.getAbsoluteURL(p.webSocketUrl||p.url)).replace(/^http/,"ws")
}function S(){var aI=o(p);
return aI
}function C(aJ){ar.transport="sse";
var aI=S();
if(w("debug")){a.util.debug("Invoking executeSSE");
a.util.debug("Using URL: "+aI)
}if(aJ&&!p.reconnect){if(ag!=null){l()
}return
}try{ag=new EventSource(aI,{withCredentials:p.withCredentials})
}catch(aK){T(0,aK);
az("SSE failed. Downgrading to fallback transport and resending");
return
}if(p.connectTimeout>0){p.id=setTimeout(function(){if(!aJ){l()
}},p.connectTimeout)
}ag.onopen=function(aL){aH("sse.onopen");
j(p);
if(w("debug")){a.util.debug("SSE successfully opened")
}if(!p.enableProtocol){if(!aJ){V("opening","sse",p)
}else{V("re-opening","sse",p)
}}else{if(p.isReopen){p.isReopen=false;
V("re-opening",p.transport,p)
}}aJ=true;
if(p.method==="POST"){ar.state="messageReceived";
ag.send(p.data)
}};
ag.onmessage=function(aM){aH("sse.onmessage");
j(p);
if(!p.enableXDR&&window.location.host&&aM.origin&&aM.origin!==window.location.protocol+"//"+window.location.host){a.util.log(p.logLevel,["Origin was not "+window.location.protocol+"//"+window.location.host]);
return
}ar.state="messageReceived";
ar.status=200;
aM=aM.data;
var aL=r(aM,p,ar);
if(!aL){ai();
ar.responseBody="";
ar.messages=[]
}};
ag.onerror=function(aL){aH("sse.onerror");
clearTimeout(p.id);
if(p.heartbeatTimer){clearTimeout(p.heartbeatTimer)
}if(ar.closedByClientTimeout){return
}ae(aJ);
l();
if(aG){a.util.log(p.logLevel,["SSE closed normally"])
}else{if(!aJ){az("SSE failed. Downgrading to fallback transport and resending")
}else{if(p.reconnect&&(ar.transport==="sse")){if(ay++<p.maxReconnectOnClose){V("re-connecting",p.transport,p);
if(p.reconnectInterval>0){p.reconnectId=setTimeout(function(){C(true)
},p.reconnectInterval)
}else{C(true)
}ar.responseBody="";
ar.messages=[]
}else{a.util.log(p.logLevel,["SSE reconnect maximum try reached "+ay]);
T(0,"maxReconnectOnClose reached")
}}}}}
}function af(aJ){ar.transport="websocket";
var aI=v(p.url);
if(w("debug")){a.util.debug("Invoking executeWebSocket, using URL: "+aI)
}if(aJ&&!p.reconnect){if(aw!=null){l()
}return
}aw=av(aI);
if(p.webSocketBinaryType!=null){aw.binaryType=p.webSocketBinaryType
}if(p.connectTimeout>0){p.id=setTimeout(function(){if(!aJ){var aM={code:1002,reason:"",wasClean:false};
aw.onclose(aM);
try{l()
}catch(aN){}return
}},p.connectTimeout)
}aw.onopen=function(aN){aH("websocket.onopen");
j(p);
c=false;
if(w("debug")){a.util.debug("Websocket successfully opened")
}var aM=aJ;
if(aw!=null){aw.canSendMessage=true
}if(!p.enableProtocol){aJ=true;
if(aM){V("re-opening","websocket",p)
}else{V("opening","websocket",p)
}}if(aw!=null){if(p.method==="POST"){ar.state="messageReceived";
aw.send(p.data)
}}};
aw.onmessage=function(aO){aH("websocket.onmessage");
j(p);
if(p.enableProtocol){aJ=true
}ar.state="messageReceived";
ar.status=200;
aO=aO.data;
var aM=typeof(aO)==="string";
if(aM){var aN=r(aO,p,ar);
if(!aN){ai();
ar.responseBody="";
ar.messages=[]
}}else{aO=s(p,aO);
if(aO===""){return
}ar.responseBody=aO;
ai();
ar.responseBody=null
}};
aw.onerror=function(aM){aH("websocket.onerror");
clearTimeout(p.id);
if(p.heartbeatTimer){clearTimeout(p.heartbeatTimer)
}};
aw.onclose=function(aM){aH("websocket.onclose");
clearTimeout(p.id);
if(ar.state==="closed"){return
}var aN=aM.reason;
if(aN===""){switch(aM.code){case 1000:aN="Normal closure; the connection successfully completed whatever purpose for which it was created.";
break;
case 1001:aN="The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection.";
break;
case 1002:aN="The endpoint is terminating the connection due to a protocol error.";
break;
case 1003:aN="The connection is being terminated because the endpoint received data of a type it cannot accept (for example, a text-only endpoint received binary data).";
break;
case 1004:aN="The endpoint is terminating the connection because a data frame was received that is too large.";
break;
case 1005:aN="Unknown: no status code was provided even though one was expected.";
break;
case 1006:aN="Connection was closed abnormally (that is, with no close frame being sent).";
break
}}if(w("warn")){a.util.warn("Websocket closed, reason: "+aN+" - wasClean: "+aM.wasClean)
}if(ar.closedByClientTimeout||(p.handleOnlineOffline&&c)){if(p.reconnectId){clearTimeout(p.reconnectId);
delete p.reconnectId
}return
}ae(aJ);
ar.state="closed";
if(aG){a.util.log(p.logLevel,["Websocket closed normally"])
}else{if(!aJ){az("Websocket failed on first connection attempt. Downgrading to "+p.fallbackTransport+" and resending")
}else{if(p.reconnect&&ar.transport==="websocket"){l();
if(ay++<p.maxReconnectOnClose){V("re-connecting",p.transport,p);
if(p.reconnectInterval>0){p.reconnectId=setTimeout(function(){ar.responseBody="";
ar.messages=[];
af(true)
},p.reconnectInterval)
}else{ar.responseBody="";
ar.messages=[];
af(true)
}}else{a.util.log(p.logLevel,["Websocket reconnect maximum try reached "+ay]);
if(w("warn")){a.util.warn("Websocket error, reason: "+aM.reason)
}T(0,"maxReconnectOnClose reached")
}}}}};
var aK=navigator.userAgent.toLowerCase();
var aL=aK.indexOf("android")>-1;
if(aL&&aw.url===undefined){aw.onclose({reason:"Android 4.1 does not support websockets.",wasClean:false})
}}function s(aM,aL){var aK=aL;
if(aM.transport==="polling"){return aK
}if(aM.enableProtocol&&aM.firstMessage&&a.util.trim(aL).length!==0){var aN=aM.trackMessageLength?1:0;
var aJ=aL.split(aM.messageDelimiter);
if(aJ.length<=aN+1){return aK
}aM.firstMessage=false;
aM.uuid=a.util.trim(aJ[aN]);
if(aJ.length<=aN+2){a.util.log("error",["Protocol data not sent by the server. If you enable protocol on client side, be sure to install JavascriptProtocol interceptor on server side.Also note that atmosphere-runtime 2.2+ should be used."])
}J=parseInt(a.util.trim(aJ[aN+1]),10);
ak=aJ[aN+2];
if(aM.transport!=="long-polling"){Z(aM)
}e=aM.uuid;
aK="";
aN=aM.trackMessageLength?4:3;
if(aJ.length>aN+1){for(var aI=aN;
aI<aJ.length;
aI++){aK+=aJ[aI];
if(aI+1!==aJ.length){aK+=aM.messageDelimiter
}}}if(aM.ackInterval!==0){setTimeout(function(){t("...ACK...")
},aM.ackInterval)
}}else{if(aM.enableProtocol&&aM.firstMessage&&a.util.browser.msie&&+a.util.browser.version.split(".")[0]<10){a.util.log(p.logLevel,["Receiving unexpected data from IE"])
}else{Z(aM)
}}return aK
}function j(aI){clearTimeout(aI.id);
if(aI.timeout>0&&aI.transport!=="polling"){aI.id=setTimeout(function(){aC(aI);
D();
l()
},aI.timeout)
}}function aC(aI){ar.closedByClientTimeout=true;
ar.state="closedByClient";
ar.responseBody="";
ar.status=408;
ar.messages=[];
ai()
}function T(aI,aJ){l();
clearTimeout(p.id);
ar.state="error";
ar.reasonPhrase=aJ;
ar.responseBody="";
ar.status=aI;
ar.messages=[];
ai()
}function r(aM,aL,aI){aM=s(aL,aM);
if(aM.length===0){return true
}aI.responseBody=aM;
if(aL.trackMessageLength){aM=aI.partialMessage+aM;
var aK=[];
var aJ=aM.indexOf(aL.messageDelimiter);
if(aJ!=-1){while(aJ!==-1){var aO=aM.substring(0,aJ);
var aN=+aO;
if(isNaN(aN)){throw new Error('message length "'+aO+'" is not a number')
}aJ+=aL.messageDelimiter.length;
if(aJ+aN>aM.length){aJ=-1
}else{aK.push(aM.substring(aJ,aJ+aN));
aM=aM.substring(aJ+aN,aM.length);
aJ=aM.indexOf(aL.messageDelimiter)
}}aI.partialMessage=aM;
if(aK.length!==0){aI.responseBody=aK.join(aL.messageDelimiter);
aI.messages=aK;
return false
}else{aI.responseBody="";
aI.messages=[];
return true
}}}aI.responseBody=aM;
aI.messages=[aM];
return false
}function az(aI){a.util.log(p.logLevel,[aI]);
if(typeof(p.onTransportFailure)!=="undefined"){p.onTransportFailure(aI,p)
}else{if(typeof(a.util.onTransportFailure)!=="undefined"){a.util.onTransportFailure(aI,p)
}}p.transport=p.fallbackTransport;
var aJ=p.connectTimeout===-1?0:p.connectTimeout;
if(p.reconnect&&p.transport!=="none"||p.transport==null){p.method=p.fallbackMethod;
ar.transport=p.fallbackTransport;
p.fallbackTransport="none";
if(aJ>0){p.reconnectId=setTimeout(function(){aa()
},aJ)
}else{aa()
}}else{T(500,"Unable to reconnect with fallback transport")
}}function o(aK,aI){var aJ=p;
if((aK!=null)&&(typeof(aK)!=="undefined")){aJ=aK
}if(aI==null){aI=aJ.url
}if(!aJ.attachHeadersAsQueryString){return aI
}if(aI.indexOf("X-Atmosphere-Framework")!==-1){return aI
}aI+=(aI.indexOf("?")!==-1)?"&":"?";
aI+="X-Atmosphere-tracking-id="+aJ.uuid;
aI+="&X-Atmosphere-Framework="+a.version;
aI+="&X-Atmosphere-Transport="+aJ.transport;
if(aJ.trackMessageLength){aI+="&X-Atmosphere-TrackMessageSize=true"
}if(aJ.heartbeat!==null&&aJ.heartbeat.server!==null){aI+="&X-Heartbeat-Server="+aJ.heartbeat.server
}if(aJ.contentType!==""){aI+="&Content-Type="+(aJ.transport==="websocket"?aJ.contentType:encodeURIComponent(aJ.contentType))
}if(aJ.enableProtocol){aI+="&X-atmo-protocol=true"
}a.util.each(aJ.headers,function(aL,aN){var aM=a.util.isFunction(aN)?aN.call(this,aJ,aK,ar):aN;
if(aM!=null){aI+="&"+encodeURIComponent(aL)+"="+encodeURIComponent(aM)
}});
return aI
}function Z(aI){if(!aI.isOpen){aI.isOpen=true;
V("opening",aI.transport,aI)
}else{if(aI.isReopen){aI.isReopen=false;
V("re-opening",aI.transport,aI)
}else{if(ar.state==="messageReceived"&&(aI.transport==="jsonp"||aI.transport==="long-polling")){ap(ar)
}else{return
}}}B(aI)
}function B(aJ){if(aJ.heartbeatTimer!=null){clearTimeout(aJ.heartbeatTimer)
}if(!isNaN(J)&&J>0){var aI=function(){if(w("debug")){a.util.debug("Sending heartbeat")
}t(ak);
aJ.heartbeatTimer=setTimeout(aI,J)
};
aJ.heartbeatTimer=setTimeout(aI,J)
}}function L(aM){var aJ=p;
if((aM!=null)||(typeof(aM)!=="undefined")){aJ=aM
}aJ.lastIndex=0;
aJ.readyState=0;
if((aJ.transport==="jsonp")||((aJ.enableXDR)&&(a.util.checkCORSSupport()))){aB(aJ);
return
}if(a.util.browser.msie&&+a.util.browser.version.split(".")[0]<10){if((aJ.transport==="streaming")){if(aJ.enableXDR&&window.XDomainRequest){P(aJ)
}else{aA(aJ)
}return
}if((aJ.enableXDR)&&(window.XDomainRequest)){P(aJ);
return
}}var aL=function(aQ){aJ.lastIndex=0;
ay++;
if(aQ||(aJ.reconnect&&ay<=aJ.maxReconnectOnClose)){var aP=aQ?0:aM.reconnectInterval;
ar.ffTryingReconnect=true;
V("re-connecting",aM.transport,aM);
an(aK,aJ,aP)
}else{T(0,"maxReconnectOnClose reached")
}};
var aN=function(aP){if(a._beforeUnloadState){a.util.debug(new Date()+" Atmosphere: reconnectF: execution delayed due to _beforeUnloadState flag");
setTimeout(function(){aL(aP)
},5000)
}else{aL(aP)
}};
var aI=function(){ar.errorHandled=true;
l();
aN(false)
};
if(aJ.force||(aJ.reconnect&&(aJ.maxRequest===-1||aJ.requestCount++<aJ.maxRequest))){aJ.force=false;
var aK=a.util.xhr();
aK.hasData=false;
M(aK,aJ,true);
if(aJ.suspend){z=aK
}if(aJ.transport!=="polling"){ar.transport=aJ.transport;
aK.onabort=function(){aH("ajaxrequest.onabort");
ae(true)
};
aK.onerror=function(){aH("ajaxrequest.onerror");
ar.error=true;
ar.ffTryingReconnect=true;
try{ar.status=XMLHttpRequest.status
}catch(aP){ar.status=500
}if(!ar.status){ar.status=500
}if(!ar.errorHandled){l();
aN(false)
}}
}aK.onreadystatechange=function(){aH("ajaxRequest.onreadystatechange, new state: "+aK.readyState);
if(aG){aH("onreadystatechange has been ignored due to _abortingConnection flag");
return
}ar.error=null;
var aQ=false;
var aW=false;
if(aJ.transport==="streaming"&&aJ.readyState>2&&aK.readyState===4){l();
aN(false);
return
}aJ.readyState=aK.readyState;
if(aJ.transport==="streaming"&&aK.readyState>=3){aW=true
}else{if(aJ.transport==="long-polling"&&aK.readyState===4){aW=true
}}j(p);
if(aJ.transport!=="polling"){var aP=200;
if(aK.readyState===4){aP=aK.status>1000?0:aK.status
}if(!aJ.reconnectOnServerError&&(aP>=300&&aP<600)){T(aP,aK.statusText);
return
}if(aP>=300||aP===0){aI();
return
}if((!aJ.enableProtocol||!aM.firstMessage)&&aK.readyState===2){if(a.util.browser.mozilla&&ar.ffTryingReconnect){ar.ffTryingReconnect=false;
setTimeout(function(){if(!ar.ffTryingReconnect){Z(aJ)
}},500)
}else{Z(aJ)
}}}else{if(aK.readyState===4){aW=true
}}if(aW){var aT=aK.responseText;
ar.errorHandled=false;
if(aJ.transport==="long-polling"&&a.util.trim(aT).length===0){if(!aK.hasData){aN(true)
}else{aK.hasData=false
}return
}aK.hasData=true;
G(aK,p);
if(aJ.transport==="streaming"){if(!a.util.browser.opera){var aS=aT.substring(aJ.lastIndex,aT.length);
aQ=r(aS,aJ,ar);
aJ.lastIndex=aT.length;
if(aQ){return
}}else{a.util.iterate(function(){if(ar.status!==500&&aK.responseText.length>aJ.lastIndex){try{ar.status=aK.status;
ar.headers=a.util.parseHeaders(aK.getAllResponseHeaders());
G(aK,p)
}catch(aY){ar.status=404
}j(p);
ar.state="messageReceived";
var aX=aK.responseText.substring(aJ.lastIndex);
aJ.lastIndex=aK.responseText.length;
aQ=r(aX,aJ,ar);
if(!aQ){ai()
}if(I(aK,aJ)){K(aK,aJ);
return
}}else{if(ar.status>400){aJ.lastIndex=aK.responseText.length;
return false
}}},0)
}}else{aQ=r(aT,aJ,ar)
}var aV=I(aK,aJ);
try{ar.status=aK.status;
ar.headers=a.util.parseHeaders(aK.getAllResponseHeaders());
G(aK,aJ)
}catch(aU){ar.status=404
}if(aJ.suspend){ar.state=ar.status===0?"closed":"messageReceived"
}else{ar.state="messagePublished"
}var aR=!aV&&aM.transport!=="streaming"&&aM.transport!=="polling";
if(aR&&!aJ.executeCallbackBeforeReconnect){an(aK,aJ,aJ.pollingInterval)
}if(ar.responseBody.length!==0&&!aQ){ai()
}if(aR&&aJ.executeCallbackBeforeReconnect){an(aK,aJ,aJ.pollingInterval)
}if(aV){K(aK,aJ)
}}};
try{aK.send(aJ.data);
u=true
}catch(aO){a.util.log(aJ.logLevel,["Unable to connect to "+aJ.url]);
T(0,aO)
}}else{if(aJ.logLevel==="debug"){a.util.log(aJ.logLevel,["Max re-connection reached."])
}T(0,"maxRequest reached")
}}function K(aJ,aI){ar.messages=[];
aI.isReopen=true;
H();
aG=false;
an(aJ,aI,500)
}function M(aK,aL,aJ){var aI=aL.url;
if(aL.dispatchUrl!=null&&aL.method==="POST"){aI+=aL.dispatchUrl
}aI=o(aL,aI);
aI=a.util.prepareURL(aI);
if(aJ){aK.open(aL.method,aI,aL.async);
if(aL.connectTimeout>0){aL.id=setTimeout(function(){if(aL.requestCount===0){l();
k("Connect timeout","closed",200,aL.transport)
}},aL.connectTimeout)
}}if(p.withCredentials&&p.transport!=="websocket"){if("withCredentials" in aK){aK.withCredentials=true
}}if(!p.dropHeaders){aK.setRequestHeader("X-Atmosphere-Framework",a.version);
aK.setRequestHeader("X-Atmosphere-Transport",aL.transport);
if(aL.heartbeat!==null&&aL.heartbeat.server!==null){aK.setRequestHeader("X-Heartbeat-Server",aK.heartbeat.server)
}if(aL.trackMessageLength){aK.setRequestHeader("X-Atmosphere-TrackMessageSize","true")
}aK.setRequestHeader("X-Atmosphere-tracking-id",aL.uuid);
a.util.each(aL.headers,function(aM,aO){var aN=a.util.isFunction(aO)?aO.call(this,aK,aL,aJ,ar):aO;
if(aN!=null){aK.setRequestHeader(aM,aN)
}})
}if(aL.contentType!==""){aK.setRequestHeader("Content-Type",aL.contentType)
}}function an(aK,aL,aJ){if(ar.closedByClientTimeout){return
}if(aL.reconnect||(aL.suspend&&u)){var aI=0;
if(aK&&aK.readyState>1){aI=aK.status>1000?0:aK.status
}ar.status=aI===0?204:aI;
ar.reason=aI===0?"Server resumed the connection or down.":"OK";
clearTimeout(aL.id);
if(aL.reconnectId){clearTimeout(aL.reconnectId);
delete aL.reconnectId
}if(aJ>0){p.reconnectId=setTimeout(function(){L(aL)
},aJ)
}else{L(aL)
}}}function q(aI){aI.state="re-connecting";
al(aI)
}function ap(aI){aI.state="openAfterResume";
al(aI);
aI.state="messageReceived"
}function P(aI){if(aI.transport!=="polling"){n=ac(aI);
n.open()
}else{ac(aI).open()
}}function ac(aK){var aJ=p;
if((aK!=null)&&(typeof(aK)!=="undefined")){aJ=aK
}var aP=aJ.transport;
var aO=0;
var aI=new window.XDomainRequest();
var aM=function(){if(aJ.transport==="long-polling"&&(aJ.reconnect&&(aJ.maxRequest===-1||aJ.requestCount++<aJ.maxRequest))){aI.status=200;
P(aJ)
}};
var aN=aJ.rewriteURL||function(aR){var aQ=/(?:^|;\s*)(JSESSIONID|PHPSESSID)=([^;]*)/.exec(document.cookie);
switch(aQ&&aQ[1]){case"JSESSIONID":return aR.replace(/;jsessionid=[^\?]*|(\?)|$/,";jsessionid="+aQ[2]+"$1");
case"PHPSESSID":return aR.replace(/\?PHPSESSID=[^&]*&?|\?|$/,"?PHPSESSID="+aQ[2]+"&").replace(/&$/,"")
}return aR
};
aI.onprogress=function(){aL(aI)
};
aI.onerror=function(){if(aJ.transport!=="polling"){l();
if(ay++<aJ.maxReconnectOnClose){if(aJ.reconnectInterval>0){aJ.reconnectId=setTimeout(function(){V("re-connecting",aK.transport,aK);
P(aJ)
},aJ.reconnectInterval)
}else{V("re-connecting",aK.transport,aK);
P(aJ)
}}else{T(0,"maxReconnectOnClose reached")
}}};
aI.onload=function(){};
var aL=function(aQ){clearTimeout(aJ.id);
var aS=aQ.responseText;
aS=aS.substring(aO);
aO+=aS.length;
if(aP!=="polling"){j(aJ);
var aR=r(aS,aJ,ar);
if(aP==="long-polling"&&a.util.trim(aS).length===0){return
}if(aJ.executeCallbackBeforeReconnect){aM()
}if(!aR){k(ar.responseBody,"messageReceived",200,aP)
}if(!aJ.executeCallbackBeforeReconnect){aM()
}}};
return{open:function(){var aQ=aJ.url;
if(aJ.dispatchUrl!=null){aQ+=aJ.dispatchUrl
}aQ=o(aJ,aQ);
aI.open(aJ.method,aN(aQ));
if(aJ.method==="GET"){aI.send()
}else{aI.send(aJ.data)
}if(aJ.connectTimeout>0){aJ.id=setTimeout(function(){if(aJ.requestCount===0){l();
k("Connect timeout","closed",200,aJ.transport)
}},aJ.connectTimeout)
}},close:function(){aI.abort()
}}
}function aA(aI){n=ab(aI);
n.open()
}function ab(aL){var aK=p;
if((aL!=null)&&(typeof(aL)!=="undefined")){aK=aL
}var aJ;
var aM=new window.ActiveXObject("htmlfile");
aM.open();
aM.close();
var aI=aK.url;
if(aK.dispatchUrl!=null){aI+=aK.dispatchUrl
}if(aK.transport!=="polling"){ar.transport=aK.transport
}return{open:function(){var aN=aM.createElement("iframe");
aI=o(aK);
if(aK.data!==""){aI+="&X-Atmosphere-Post-Body="+encodeURIComponent(aK.data)
}aI=a.util.prepareURL(aI);
aN.src=aI;
aM.body.appendChild(aN);
var aO=aN.contentDocument||aN.contentWindow.document;
aJ=a.util.iterate(function(){try{if(!aO.firstChild){return
}var aR=aO.body?aO.body.lastChild:aO;
var aT=function(){var aV=aR.cloneNode(true);
aV.appendChild(aO.createTextNode("."));
var aU=aV.innerText;
aU=aU.substring(0,aU.length-1);
return aU
};
if(!aO.body||!aO.body.firstChild||aO.body.firstChild.nodeName.toLowerCase()!=="pre"){var aQ=aO.head||aO.getElementsByTagName("head")[0]||aO.documentElement||aO;
var aP=aO.createElement("script");
aP.text="document.write('<plaintext>')";
aQ.insertBefore(aP,aQ.firstChild);
aQ.removeChild(aP);
aR=aO.body.lastChild
}if(aK.closed){aK.isReopen=true
}aJ=a.util.iterate(function(){var aV=aT();
if(aV.length>aK.lastIndex){j(p);
ar.status=200;
ar.error=null;
aR.innerText="";
var aU=r(aV,aK,ar);
if(aU){return""
}k(ar.responseBody,"messageReceived",200,aK.transport)
}aK.lastIndex=0;
if(aO.readyState==="complete"){ae(true);
V("re-connecting",aK.transport,aK);
if(aK.reconnectInterval>0){aK.reconnectId=setTimeout(function(){aA(aK)
},aK.reconnectInterval)
}else{aA(aK)
}return false
}},null);
return false
}catch(aS){ar.error=true;
V("re-connecting",aK.transport,aK);
if(ay++<aK.maxReconnectOnClose){if(aK.reconnectInterval>0){aK.reconnectId=setTimeout(function(){aA(aK)
},aK.reconnectInterval)
}else{aA(aK)
}}else{T(0,"maxReconnectOnClose reached")
}aM.execCommand("Stop");
aM.close();
return false
}})
},close:function(){if(aJ){aJ()
}aM.execCommand("Stop");
ae(true)
}}
}function t(aI){if(ax!=null){E(aI)
}else{if(z!=null||ag!=null){O(aI)
}else{if(n!=null){i(aI)
}else{if(X!=null){A(aI)
}else{if(aw!=null){W(aI)
}else{T(0,"No suspended connection available");
a.util.error("No suspended connection available. Make sure atmosphere.subscribe has been called and request.onOpen invoked before trying to push data")
}}}}}}function am(aJ,aI){if(!aI){aI=x(aJ)
}aI.transport="polling";
aI.method="GET";
aI.withCredentials=false;
aI.reconnect=false;
aI.force=true;
aI.suspend=false;
aI.timeout=1000;
L(aI)
}function E(aI){ax.send(aI)
}function aq(aJ){if(aJ.length===0){return
}try{if(ax){ax.localSend(aJ)
}else{if(h){h.signal("localMessage",a.util.stringifyJSON({id:R,event:aJ}))
}}}catch(aI){a.util.error(aI)
}}function O(aJ){var aI=x(aJ);
L(aI)
}function i(aJ){if(p.enableXDR&&a.util.checkCORSSupport()){var aI=x(aJ);
aI.reconnect=false;
aB(aI)
}else{O(aJ)
}}function A(aI){O(aI)
}function N(aI){var aJ=aI;
if(typeof(aJ)==="object"){aJ=aI.data
}return aJ
}function x(aJ){var aK=N(aJ);
var aI={connected:false,timeout:60000,method:"POST",url:p.url,contentType:p.contentType,headers:p.headers,reconnect:true,callback:null,data:aK,suspend:false,maxRequest:-1,logLevel:"info",requestCount:0,withCredentials:p.withCredentials,async:p.async,transport:"polling",isOpen:true,attachHeadersAsQueryString:true,enableXDR:p.enableXDR,uuid:p.uuid,dispatchUrl:p.dispatchUrl,enableProtocol:false,messageDelimiter:"|",trackMessageLength:p.trackMessageLength,maxReconnectOnClose:p.maxReconnectOnClose,heartbeatTimer:p.heartbeatTimer,heartbeat:p.heartbeat};
if(typeof(aJ)==="object"){aI=a.util.extend(aI,aJ)
}return aI
}function W(aI){var aL=a.util.isBinary(aI)?aI:N(aI);
var aJ;
try{if(p.dispatchUrl!=null){aJ=p.webSocketPathDelimiter+p.dispatchUrl+p.webSocketPathDelimiter+aL
}else{aJ=aL
}if(!aw.canSendMessage){a.util.error("WebSocket not connected.");
return
}aw.send(aJ)
}catch(aK){aw.onclose=function(aM){};
l();
az("Websocket failed. Downgrading to "+p.fallbackTransport+" and resending "+aI);
O(aI)
}}function F(aJ){var aI=a.util.parseJSON(aJ);
if(aI.id!==R){if(typeof(p.onLocalMessage)!=="undefined"){p.onLocalMessage(aI.event)
}else{if(typeof(a.util.onLocalMessage)!=="undefined"){a.util.onLocalMessage(aI.event)
}}}}function k(aL,aI,aJ,aK){ar.responseBody=aL;
ar.transport=aK;
ar.status=aJ;
ar.state=aI;
ai()
}function G(aI,aK){if(!aK.readResponsesHeaders){if(!aK.enableProtocol){aK.uuid=R
}}else{try{var aJ=aI.getResponseHeader("X-Atmosphere-tracking-id");
if(aJ&&aJ!=null){aK.uuid=aJ.split(" ").pop()
}}catch(aL){}}}function al(aI){m(aI,p);
m(aI,a.util)
}function m(aJ,aK){switch(aJ.state){case"messageReceived":aH("Firing onMessage");
ay=0;
if(typeof(aK.onMessage)!=="undefined"){aK.onMessage(aJ)
}if(typeof(aK.onmessage)!=="undefined"){aK.onmessage(aJ)
}break;
case"error":var aL=(typeof(aJ.reasonPhrase)!="undefined")?aJ.reasonPhrase:"n/a";
aH("Firing onError, reasonPhrase: "+aL);
if(typeof(aK.onError)!=="undefined"){aK.onError(aJ)
}if(typeof(aK.onerror)!=="undefined"){aK.onerror(aJ)
}break;
case"opening":delete p.closed;
aH("Firing onOpen");
if(typeof(aK.onOpen)!=="undefined"){aK.onOpen(aJ)
}if(typeof(aK.onopen)!=="undefined"){aK.onopen(aJ)
}break;
case"messagePublished":aH("Firing messagePublished");
if(typeof(aK.onMessagePublished)!=="undefined"){aK.onMessagePublished(aJ)
}break;
case"re-connecting":aH("Firing onReconnect");
if(typeof(aK.onReconnect)!=="undefined"){aK.onReconnect(p,aJ)
}break;
case"closedByClient":aH("Firing closedByClient");
if(typeof(aK.onClientTimeout)!=="undefined"){aK.onClientTimeout(p)
}break;
case"re-opening":delete p.closed;
aH("Firing onReopen");
if(typeof(aK.onReopen)!=="undefined"){aK.onReopen(p,aJ)
}break;
case"fail-to-reconnect":aH("Firing onFailureToReconnect");
if(typeof(aK.onFailureToReconnect)!=="undefined"){aK.onFailureToReconnect(p,aJ)
}break;
case"unsubscribe":case"closed":var aI=typeof(p.closed)!=="undefined"?p.closed:false;
if(!aI){aH("Firing onClose ("+aJ.state+" case)");
if(typeof(aK.onClose)!=="undefined"){aK.onClose(aJ)
}if(typeof(aK.onclose)!=="undefined"){aK.onclose(aJ)
}}else{aH("Request already closed, not firing onClose ("+aJ.state+" case)")
}p.closed=true;
break;
case"openAfterResume":if(typeof(aK.onOpenAfterResume)!=="undefined"){aK.onOpenAfterResume(p)
}break
}}function ae(aI){if(ar.state!=="closed"){ar.state="closed";
ar.responseBody="";
ar.messages=[];
ar.status=!aI?501:200;
ai()
}}function ai(){var aK=function(aN,aO){aO(ar)
};
if(ax==null&&Q!=null){Q(ar.responseBody)
}p.reconnect=p.mrequest;
var aI=typeof(ar.responseBody)==="string";
var aL=(aI&&p.trackMessageLength)?(ar.messages.length>0?ar.messages:[""]):new Array(ar.responseBody);
for(var aJ=0;
aJ<aL.length;
aJ++){if(aL.length>1&&aL[aJ].length===0){continue
}ar.responseBody=(aI)?a.util.trim(aL[aJ]):aL[aJ];
if(ax==null&&Q!=null){Q(ar.responseBody)
}if((ar.responseBody.length===0||(aI&&ak===ar.responseBody))&&ar.state==="messageReceived"){continue
}al(ar);
if(f.length>0){if(w("debug")){a.util.debug("Invoking "+f.length+" global callbacks: "+ar.state)
}try{a.util.each(f,aK)
}catch(aM){a.util.log(p.logLevel,["Callback exception"+aM])
}}if(typeof(p.callback)==="function"){if(w("debug")){a.util.debug("Invoking request callbacks")
}try{p.callback(ar)
}catch(aM){a.util.log(p.logLevel,["Callback exception"+aM])
}}}}this.subscribe=function(aI){ao(aI);
aa()
};
this.execute=function(){aa()
};
this.close=function(){H()
};
this.disconnect=function(){D()
};
this.getUrl=function(){return p.url
};
this.push=function(aK,aJ){if(aJ!=null){var aI=p.dispatchUrl;
p.dispatchUrl=aJ;
t(aK);
p.dispatchUrl=aI
}else{t(aK)
}};
this.getUUID=function(){return p.uuid
};
this.pushLocal=function(aI){aq(aI)
};
this.enableProtocol=function(aI){return p.enableProtocol
};
this.init=function(){aj()
};
this.request=p;
this.response=ar
}};
a.subscribe=function(h,k,j){if(typeof(k)==="function"){a.addCallback(k)
}if(typeof(h)!=="string"){j=h
}else{j.url=h
}e=((typeof(j)!=="undefined")&&typeof(j.uuid)!=="undefined")?j.uuid:0;
var i=new a.AtmosphereRequest(j);
i.execute();
g[g.length]=i;
return i
};
a.unsubscribe=function(){if(g.length>0){var h=[].concat(g);
for(var k=0;
k<h.length;
k++){var j=h[k];
j.close();
clearTimeout(j.response.request.id);
if(j.heartbeatTimer){clearTimeout(j.heartbeatTimer)
}}}g=[];
f=[]
};
a.unsubscribeUrl=function(j){var h=-1;
if(g.length>0){for(var l=0;
l<g.length;
l++){var k=g[l];
if(k.getUrl()===j){k.close();
clearTimeout(k.response.request.id);
if(k.heartbeatTimer){clearTimeout(k.heartbeatTimer)
}h=l;
break
}}}if(h>=0){g.splice(h,1)
}};
a.addCallback=function(h){if(a.util.inArray(h,f)===-1){f.push(h)
}};
a.removeCallback=function(i){var h=a.util.inArray(i,f);
if(h!==-1){f.splice(h,1)
}};
a.util={browser:{},parseHeaders:function(i){var h,k=/^(.*?):[ \t]*([^\r\n]*)\r?$/mg,j={};
while(h=k.exec(i)){j[h[1]]=h[2]
}return j
},now:function(){return new Date().getTime()
},isArray:function(h){return Object.prototype.toString.call(h)==="[object Array]"
},inArray:function(k,l){if(!Array.prototype.indexOf){var h=l.length;
for(var j=0;
j<h;
++j){if(l[j]===k){return j
}}return -1
}return l.indexOf(k)
},isBinary:function(h){return/^\[object\s(?:Blob|ArrayBuffer|.+Array)\]$/.test(Object.prototype.toString.call(h))
},isFunction:function(h){return Object.prototype.toString.call(h)==="[object Function]"
},getAbsoluteURL:function(h){if(typeof(document.createElement)==="undefined"){return h
}var i=document.createElement("div");
i.innerHTML='<a href="'+h+'"/>';
return encodeURI(decodeURI(i.firstChild.href))
},prepareURL:function(i){var j=a.util.now();
var h=i.replace(/([?&])_=[^&]*/,"$1_="+j);
return h+(h===i?(/\?/.test(i)?"&":"?")+"_="+j:"")
},trim:function(h){if(!String.prototype.trim){return h.toString().replace(/(?:(?:^|\n)\s+|\s+(?:$|\n))/g,"").replace(/\s+/g," ")
}else{return h.toString().trim()
}},param:function(l){var j,h=[];
function k(m,n){n=a.util.isFunction(n)?n():(n==null?"":n);
h.push(encodeURIComponent(m)+"="+encodeURIComponent(n))
}function i(n,o){var m;
if(a.util.isArray(o)){a.util.each(o,function(q,p){if(/\[\]$/.test(n)){k(n,p)
}else{i(n+"["+(typeof p==="object"?q:"")+"]",p)
}})
}else{if(Object.prototype.toString.call(o)==="[object Object]"){for(m in o){i(n+"["+m+"]",o[m])
}}else{k(n,o)
}}}for(j in l){i(j,l[j])
}return h.join("&").replace(/%20/g,"+")
},storage:function(){try{return !!(window.localStorage&&window.StorageEvent)
}catch(h){return false
}},iterate:function(j,i){var k;
i=i||0;
(function h(){k=setTimeout(function(){if(j()===false){return
}h()
},i)
})();
return function(){clearTimeout(k)
}
},each:function(n,o,j){if(!n){return
}var m,k=0,l=n.length,h=a.util.isArray(n);
if(j){if(h){for(;
k<l;
k++){m=o.apply(n[k],j);
if(m===false){break
}}}else{for(k in n){m=o.apply(n[k],j);
if(m===false){break
}}}}else{if(h){for(;
k<l;
k++){m=o.call(n[k],k,n[k]);
if(m===false){break
}}}else{for(k in n){m=o.call(n[k],k,n[k]);
if(m===false){break
}}}}return n
},extend:function(l){var k,j,h;
for(k=1;
k<arguments.length;
k++){if((j=arguments[k])!=null){for(h in j){l[h]=j[h]
}}}return l
},on:function(j,i,h){if(j.addEventListener){j.addEventListener(i,h,false)
}else{if(j.attachEvent){j.attachEvent("on"+i,h)
}}},off:function(j,i,h){if(j.removeEventListener){j.removeEventListener(i,h,false)
}else{if(j.detachEvent){j.detachEvent("on"+i,h)
}}},log:function(j,i){if(window.console){var h=window.console[j];
if(typeof h==="function"){h.apply(window.console,i)
}}},warn:function(){a.util.log("warn",arguments)
},info:function(){a.util.log("info",arguments)
},debug:function(){a.util.log("debug",arguments)
},error:function(){a.util.log("error",arguments)
},xhr:function(){try{return new window.XMLHttpRequest()
}catch(i){try{return new window.ActiveXObject("Microsoft.XMLHTTP")
}catch(h){}}},parseJSON:function(h){return !h?null:window.JSON&&window.JSON.parse?window.JSON.parse(h):new Function("return "+h)()
},stringifyJSON:function(j){var m=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,k={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"};
function h(n){return'"'+n.replace(m,function(o){var p=k[o];
return typeof p==="string"?p:"\\u"+("0000"+o.charCodeAt(0).toString(16)).slice(-4)
})+'"'
}function i(o){return o<10?"0"+o:o
}return window.JSON&&window.JSON.stringify?window.JSON.stringify(j):(function l(s,r){var q,p,n,o,u=r[s],t=typeof u;
if(u&&typeof u==="object"&&typeof u.toJSON==="function"){u=u.toJSON(s);
t=typeof u
}switch(t){case"string":return h(u);
case"number":return isFinite(u)?String(u):"null";
case"boolean":return String(u);
case"object":if(!u){return"null"
}switch(Object.prototype.toString.call(u)){case"[object Date]":return isFinite(u.valueOf())?'"'+u.getUTCFullYear()+"-"+i(u.getUTCMonth()+1)+"-"+i(u.getUTCDate())+"T"+i(u.getUTCHours())+":"+i(u.getUTCMinutes())+":"+i(u.getUTCSeconds())+'Z"':"null";
case"[object Array]":n=u.length;
o=[];
for(q=0;
q<n;
q++){o.push(l(q,u)||"null")
}return"["+o.join(",")+"]";
default:o=[];
for(q in u){if(b.call(u,q)){p=l(q,u);
if(p){o.push(h(q)+":"+p)
}}}return"{"+o.join(",")+"}"
}}})("",{"":j})
},checkCORSSupport:function(){if(a.util.browser.msie&&!window.XDomainRequest&&+a.util.browser.version.split(".")[0]<11){return true
}else{if(a.util.browser.opera&&+a.util.browser.version.split(".")<12){return true
}else{if(a.util.trim(navigator.userAgent).slice(0,16)==="KreaTVWebKit/531"){return true
}else{if(a.util.trim(navigator.userAgent).slice(-7).toLowerCase()==="kreatel"){return true
}}}}var i=navigator.userAgent.toLowerCase();
var j=i.match(/.+android ([0-9]{1,2})/i),h=parseInt((j&&j[0])||-1,10);
if(!isNaN(h)&&h>-1&&h<3){return true
}return false
}};
d=a.util.now();
(function(){var i=navigator.userAgent.toLowerCase(),h=/(chrome)[ \/]([\w.]+)/.exec(i)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(i)||/(msie) ([\w.]+)/.exec(i)||/(trident)(?:.*? rv:([\w.]+)|)/.exec(i)||i.indexOf("android")<0&&/version\/(.+) (safari)/.exec(i)||i.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(i)||[];
if(h[2]==="safari"){h[2]=h[1];
h[1]="safari"
}a.util.browser[h[1]||""]=true;
a.util.browser.version=h[2]||"0";
a.util.browser.vmajor=a.util.browser.version.split(".")[0];
if(a.util.browser.trident){a.util.browser.msie=true
}if(a.util.browser.msie||(a.util.browser.mozilla&&+a.util.browser.version.split(".")[0]===1)){a.util.storage=false
}})();
a.util.on(window,"unload",function(h){a.util.debug(new Date()+" Atmosphere: unload event");
a.unsubscribe()
});
a.util.on(window,"beforeunload",function(h){a.util.debug(new Date()+" Atmosphere: beforeunload event");
a._beforeUnloadState=true;
setTimeout(function(){a.util.debug(new Date()+" Atmosphere: beforeunload event timeout reached. Reset _beforeUnloadState flag");
a._beforeUnloadState=false
},5000)
});
a.util.on(window,"keypress",function(h){if(h.charCode===27||h.keyCode===27){if(h.preventDefault){h.preventDefault()
}}});
a.util.on(window,"offline",function(){a.util.debug(new Date()+" Atmosphere: offline event");
c=true;
if(g.length>0){var h=[].concat(g);
for(var k=0;
k<h.length;
k++){var j=h[k];
if(j.request.handleOnlineOffline){j.close();
clearTimeout(j.response.request.id);
if(j.heartbeatTimer){clearTimeout(j.heartbeatTimer)
}}}}});
a.util.on(window,"online",function(){a.util.debug(new Date()+" Atmosphere: online event");
if(g.length>0){for(var h=0;
h<g.length;
h++){if(g[h].request.handleOnlineOffline){g[h].init();
g[h].execute()
}}}c=false
});
return a
}));var AUTOCOMPLETE_SEARCH_FIELD = new function () {
    var that = this;

    this.disable = function (childTextSelectId) {
        var childTextUi = $('#' + childTextSelectId + '_field');
        childTextUi.attr('disabled', 'disabled');
    };

    this.enable = function (childTextSelectId) {
        var childTextUi = $('#' + childTextSelectId + '_field');
        childTextUi.removeAttr('disabled');
    };

    this.hide = function (childTextSelectId) {
        var childTextUi = $('#' + childTextSelectId + '_field');
        var childTextStatusUi = $('#' + childTextSelectId + '_status');
        childTextUi.hide();
        childTextStatusUi.hide();
    };

    this.show = function (childTextSelectId) {
        var childTextUi = $('#' + childTextSelectId + '_field');
        var childTextStatusUi = $('#' + childTextSelectId + '_status');
        childTextUi.show();
        childTextStatusUi.show();
    };

    this.clear = function (childTextSelectId) {
        var childTextUi = $('#' + childTextSelectId + '_field');
        var childValueElement = $('#' + childTextSelectId);
        var childTextStatusUi = $('#' + childTextSelectId + '_status');

        var params = childTextUi.data('params');

        childValueElement.val('');
        childTextUi.val(commonHelper.decodeHtmlString(params ? params.defaultValue : ''));
        childTextStatusUi.html(params ? params.inputDataTitle : '');

        childTextUi.removeClass('filledAutoComplete');
        childTextUi.removeClass('updatedAutoComplete');
        childTextUi.addClass('emptyAutoComplete');
    };

    this.setTitle = function (childTextSelectId, title) {
        var childTextUi = $('#' + childTextSelectId + '_field');
        var childTextStatusUi = $('#' + childTextSelectId + '_status');

        var params = childTextUi.data('params');

        childTextUi.removeClass('emptyAutoComplete');
        childTextUi.removeClass('updatedAutoComplete');
        childTextUi.addClass('filledAutoComplete');

        childTextUi.val(commonHelper.decodeHtmlString(title));
        childTextStatusUi.html(params.objectFound);
    };

    this.getTitle = function (childTextSelectId) {
        var childTextUi = $('#' + childTextSelectId + '_field');
        return childTextUi.val();
    };

    this.getValue = function (childTextSelectId) {
        var childValueElement = $('#' + childTextSelectId);
        return childValueElement.val();
    };

    this.setValue = function (childTextSelectId, value, title) {
        var childValueElement = $('#' + childTextSelectId);
        var childTextUi = $('#' + childTextSelectId + '_field');
        var childTextStatusUi = $('#' + childTextSelectId + '_status');

        var params = childTextUi.data('params');

        childValueElement.val(value != null ? value : '');
        childTextUi.val(commonHelper.decodeHtmlString(title));

        if (value) {
            childTextUi.removeClass('emptyAutoComplete');
            childTextUi.removeClass('updatedAutoComplete');
            childTextUi.addClass('filledAutoComplete');

            if (params.selectCallback) {
                params.selectCallback(value, title, '');
            }

            if (params.foundStatusClick) {
                childTextStatusUi.bind('click', params.foundStatusClick);
                childTextStatusUi.addClass('filledAutoCompleteWithLink');
            }

            childTextStatusUi.html(params.objectFound);
        } else {
            childTextUi.addClass('emptyAutoComplete');
            childTextUi.removeClass('updatedAutoComplete');
            childTextUi.removeClass('filledAutoComplete');
            childTextStatusUi.unbind('click');
            childTextStatusUi.removeClass('filledAutoCompleteWithLink');
            childTextUi.val(params.defaultValue);
            $(childTextStatusUi).html(params.inputDataTitle);
        }
    };

    this.prepare = function (fieldTextSelectId, params) {
        var childValueElement = $('#' + fieldTextSelectId);
        var childTextUi = $('#' + fieldTextSelectId + '_field');
        childTextUi.data('params', params);
        var childTextStatusUi = $('#' + fieldTextSelectId + '_status');
        $(childTextStatusUi).html(params.inputDataTitle);
        DEFAULT_INPUT_VALUE.prepare(childTextUi, params.defaultValue, function () {
            childTextUi.removeClass('emptyAutoComplete');
            childTextUi.removeClass('filledAutoComplete');
            childTextUi.addClass('updatedAutoComplete');

            $(childTextStatusUi).html(params.inputDataTitle);
        }, function () {
            childTextUi.addClass('emptyAutoComplete');
            childTextUi.removeClass('updatedAutoComplete');
            childTextUi.removeClass('filledAutoComplete');

            $(childValueElement).val('');
            if (params.selectCallback) {
                params.selectCallback('');
            }
            $(childTextStatusUi).html(params.inputDataTitle);
        }, function () {
            if (childValueElement.val() == '') {

                childTextUi.addClass('emptyAutoComplete');
                childTextUi.removeClass('updatedAutoComplete');
                childTextUi.removeClass('filledAutoComplete');

                return params.defaultValue;
            } else {
                childTextStatusUi.html(params.objectFound);
            }
        });

        childTextUi.autocomplete({
            source:function (request, response) {
                childValueElement.val('');
                childTextStatusUi.html(params.objectNotFound);
                commonHelper.callAjaxMethod(params.url, params.method, {term:request.term}, function (data) {
                    childTextUi.removeClass('emptyAutoComplete');
                    childTextUi.addClass('updatedAutoComplete');
                    childTextUi.removeClass('filledAutoComplete');

                    if (params.selectCallback) {
                        params.selectCallback('');
                    }

                    childTextStatusUi.unbind('click');
                    childTextStatusUi.removeClass('filledAutoCompleteWithLink');

                    response($.map(data, function (item, index) {
                        return {
                            label:params.generateLabel(item),
                            value:params.generateValue(item),
                            id:params.generateId(item),
                            type:params.generateType ? params.generateType(item) : '',
                            data: {
                                deposit: item.deposit,
                                discount: item.discount,
                                multisubscriptions: item.multisubscriptions

                            }
                        }
                    }));
                    childTextUi.removeClass("ui-autocomplete-loading");
                });
            },
            dataType:"jsonp",
            minLength:2,

            select:function (event, ui) {
                if (ui.item.id && ui.item.id != '') {
                    childValueElement.val(ui.item.id);
                    $(childTextStatusUi).html(params.objectFound);
                    if (params.selectCallback) {
                        params.selectCallback(ui.item.id, ui.item.value, ui.item.type, ui.item.data);
                    }

                    if (params.foundStatusClick) {
                        childTextStatusUi.bind('click', params.foundStatusClick);
                        childTextStatusUi.addClass('filledAutoCompleteWithLink');
                    }
                }
                childTextUi.removeClass('emptyAutoComplete');
                childTextUi.removeClass('updatedAutoComplete');
                childTextUi.addClass('filledAutoComplete');
            },
            open:function () {
                $(this).removeClass("ui-corner-all").addClass("ui-corner-top");

                childTextUi.removeClass('emptyAutoComplete');
                childTextUi.addClass('updatedAutoComplete');
                childTextUi.removeClass('filledAutoComplete');

                childTextUi.addClass('emptyAutoComplete');
            },
            close:function () {
                $(this).removeClass("ui-corner-top").addClass("ui-corner-all");
            }
        });
    };
    return that;
}();var BUBBLE_DIALOG = new function () {
    var that = this;
    var currentDialog;
    that.show = function (object, content) {

        if (currentDialog){
            currentDialog.dialog('destroy');
        }

        content.dialog({
            modal: false,
            width: 500,
            position: {my: 'left top', at: 'right top', of: object, collision: 'flipfit flipfit'},
            zIndex: 1400,
            buttons: [
                {

                    text: messages['common.close'],
                    click: function () {
                        content.dialog('destroy');
                    }
                }
            ]
        }).show();

        currentDialog = content;

        content.dialog().bind('clickoutside', function () {
            content.dialog('destroy');
        });


        content.parent().find(".ui-dialog-titlebar").hide();
        return content;
    };

    that.close = function (object) {
        if (object && object.dialog){
            object.dialog('destroy');
        }
    };

    return that;
}();



function PageHelper() {
    var that = this;
    var PAGE_LIST_ITEMS_COUNT = 7;
    var changeOrganizationCallbacks = [];

    this.closeDialog = function (dialogName, event) {
        var dialogObject = $('#' + dialogName);
        var closeFunc = dialogObject.dialog('option', 'beforeClose');
        if (closeFunc instanceof Function) {
            closeFunc.call(null, event);
        }
        dialogObject.dialog('destroy');
    };

    this.hideDialog = function (dialogName, event) {
        var dialogObject = $('#' + dialogName);
        var closeFunc = dialogObject.dialog('option', 'beforeClose');
        if (closeFunc instanceof Function) {
            closeFunc.call(null, event);
        }
        dialogObject.dialog('close');
    };

    this.getMaxZIndex = function () {
        return Math.max(0, Math.max.apply(null, $.map((true) ? $.makeArray(document.getElementsByTagName("*")) : $(selector),
            function (v) {
                return parseFloat($(v).css("z-index")) || null;
            })));
    };

    this.fillWithInputs = function (data, container, paramNames) {
        for (var i = 0; i < paramNames.length; i++) {
            var paramName = paramNames[i];
            var paramValue = container.find('[name="' + paramName + '"]').val();
            data[paramName] = paramValue ? paramValue : '';
        }
    };

    this.fillArrayWithInputs = function (data, objects, arrayName, paramNames) {
        var res = [];
        data[arrayName] = res;
        $.each(objects, function (index, element) {
            var newobject = {};
            if (element.id.indexOf('template') == -1) {
                res[res.length] = newobject;
                that.fillWithInputs(newobject, $(element), paramNames);
            }
        });
    };

    this.callSecureAjaxMethod = function (url, method, params, success, async, hideprogress, fake, errorCallback) {
        baseCallAjaxMethod('https://' + window.location.hostname + ':' + HTTPS_PORT + CONTEXT_PATH + '/' + url, method, params, success, async, hideprogress, fake, errorCallback, 'jsonp');
    };

    this.callAjaxMethod = function (url, method, params, success, async, hideprogress, fake, errorCallback) {
        baseCallAjaxMethod(url, method, params, success, async, hideprogress, fake, errorCallback, 'json');
    };

    this.callPageByAjaxMethod = function (url, method, params, success, async, hideprogress, fake, errorCallback) {
        baseCallAjaxMethod(url, method, params, success, async, hideprogress, fake, errorCallback, 'html');
    };

    var baseCallAjaxMethod = function (url, method, params, success, async, hideprogress, fake, errorCallback, datatype) {
        params.method = method;
        $(document).attr('hideAjaxProgress', '' + (hideprogress ? 'true' : 'false'));
        if (!fake) {
            $.ajax({
                url: url,
                type: 'post',
                async: async,
                data: params,
                dataType: datatype,
                success: function (result) {
                    if (result && result.type == 'error') {
                        var generatedMessage = result.message;
                        var details = '';
                        if (result.details) {
                            generatedMessage += '<br>';
                            $.each(result.details, function (index, item) {
                                details += item;
                                details += '<br>';
                            });
                        }
                        if (errorCallback) {
                            errorCallback();
                        }
                        that.showError(generatedMessage, details);
                    } else {
                        if (success) {
                            success.call(null, result);
                        }
                    }
                },
                error: function (data) {
                    if (data && data.responseText == 'NOT_AUTH') {
                        that.showError(messages['commonjs.sessionexpired'], null, function () {
                            window.location = 'login';
                        });
                    } else {
                        var errorProcessed = false;
                        if (errorCallback) {
                            errorProcessed = errorCallback();
                        }
                        if (!errorProcessed) {
                            console.log("data: " + JSON.stringify(data));
                            that.showError(messages['commonjs.loaderror'] + ' ' + data.statusText);
                        }
                    }
                }
            });
        } else {
            success(null);
        }
    };

    this.showError = function (message, details, onClick) {
        var alertDialog = $('#dialogalertmessage');
        if (alertDialog.length == 0) {
            alertDialog = $('<div id="dialogalertmessage">');
        }

        alertDialog.children(null).remove();

        $('<h4>', {
            style: 'color : red'
        }).html(message).appendTo(alertDialog);
        if (details) {
            $('<p>', {
                style: 'color : black'
            }).html(details).appendTo(alertDialog);
        }
        alertDialog.dialog({
            title: messages['commonjs.error'],
            modal: true,
            height: 300,
            width: 450,
            zIndex: (commonHelper.getMaxZIndex() + 1),
            buttons: [
                {

                    text: messages['common.close'],
                    click: function () {
                        if (onClick) {
                            onClick();
                        }
                        commonHelper.closeDialog('dialogalertmessage');
                    }
                }
            ]
        });

        alertDialog.dialog('moveToTop');
    };

    this.showBigMessage = function (message) {
        showMessage(message, 650, 400);
    };

    this.showMessage = function (message) {
        showMessage(message, 450, 200);
    };

    var showMessage = function (message, width, height) {
        var dialogDiv = $('#messageDialog');
        if (dialogDiv.length == 0) {
            dialogDiv = $('<div id="messageDialog">' + message + '</div>');
        } else {
            dialogDiv.html(message);
        }
        dialogDiv.dialog({
            title: messages['commonjs.message'],
            modal: true,
            height: height,
            width: width,
            zIndex: (commonHelper.getMaxZIndex() + 1),
            buttons: [
                {
                    text: messages['common.close'],
                    click: function () {
                        commonHelper.closeDialog('messageDialog');
                    }
                }
            ]
        });
        dialogDiv.dialog('moveToTop');
    };

    this.setDateTimePicker = function (dateHolder, value) {
        dateHolder.datetimepicker({format: 'd/m/Y H:i', value: value, lang: messages['common.datetimepicker'], dayOfWeekStart: 1});
    };

    this.setDatePicker = function (dateHolder, onSelect) {
        $.datepicker.setDefaults($.datepicker.regional[messages['common.datetimepicker']]);
        dateHolder.datepicker('destroy');
        dateHolder.removeClass('hasDatepicker');
        dateHolder.datepicker(
            {
                firstDay: 1, changeYear: true, changeMonth: true, dateFormat: DATE_FORMAT, onSelect: onSelect
            });
        dateHolder.datepicker('enable');
        return dateHolder;
    };


    this.setTimePicker = function (dateHolder) {
        dateHolder.removeClass('hasTimepicker');
        dateHolder.timepicker({
            showLeadingZero: true,
            separator: ':',
            step: 5});
    };


    this.validateForm = function (form, validateMessage, rules) {
        $.validator.addMethod("date", function (value, element) {
            return commonHelper.parseDate(value);
        });


        validateMessage.html('');
        var errorMessages = {};
        for (var rule in rules) {
            errorMessages[rule] = '';
        }
        return form.validate({
            invalidHandler: function (e, validator) {
                if (validator.numberOfInvalids() > 0) {
                    validateMessage.html(messages['commonjs.valueserror']);
                }
            },
            rules: rules,
            messages: errorMessages
        }).form();
    };

    this.clearBeforeValidation = function (formselect, messages) {
        $(formselect).find('input,textarea').removeClass('error');
        $(formselect).find('.date').datepicker('destroy');
        $(messages).html('');
    };

    this.generateTimepickers = function (starttime, endtime, doNotCheckStartTime) {
        $(starttime).timepicker({
            showLeadingZero: true,
            onHourShow: function (hour) {
                return hour >= 8 && hour <= 21;
            },
            onMinuteShow: function (minute) {
                return true;
            },
            separator: ':',
            step: 5});

        $(endtime).timepicker({
            showLeadingZero: true,
            onHourShow: function (hour) {
                return hour >= 8 && hour <= 21 && (doNotCheckStartTime || $(starttime).timepicker('getHour') < 0 || $(starttime).timepicker('getHour') <= hour);
            },
            onMinuteShow: function (hour, minute) {
                return doNotCheckStartTime || parseInt($(starttime).timepicker('getHour'), 10) < parseInt(hour, 10) || parseInt($(starttime).timepicker('getMinute'), 10) < parseInt(minute, 10);
            },
            separator: ':',
            step: 5});

    };

    this.generatePaginator = function (_listid, selectedPage, pageCount, onLoad) {
        var paginator = $("#paginator_" + _listid);
        paginator.show();
        paginator.paginate({
            customParentWidth: 80,
            customElementWidth: 25,
            customElementLeft: 60,
            count: pageCount,
            start: selectedPage,
            display: PAGE_LIST_ITEMS_COUNT,
            border: true,
            border_color: '#000',
            text_color: '#fff',
            background_color: 'gray',
            border_hover_color: '#ccc',
            text_hover_color: '#000',
            background_hover_color: '#fff',
            images: false,
            mouse: 'press',
            onChange: function (page) {
                onLoad(page);
            }
        });
    };

    this.showEmptyList = function (_listid) {
        var emptyElement = $('#empty_' + _listid);
        emptyElement.show();
    };

    this.hidePaginator = function (_listid) {
        $("#paginator_" + _listid).hide();
    };

    this.hideEmptyList = function (_listid) {
        var emptyElement = $('#empty_' + _listid);
        emptyElement.hide();
    };

    this.formatDateWithCustomFormat = function (format, date) {
        return $.datepicker.formatDate(format, date);
    };

    this.formatDate = function (date) {
        return $.datepicker.formatDate(DATE_FORMAT, date);
    };

    this.formatDateTime = function (date) {
        return $.datepicker.formatDate(DATE_FORMAT + ' ' + this.formatTime(date), date);
    };

    this.formatTime = function (date) {
        return (date.getHours() < 10 ? '0' + date.getHours() : date.getHours()) + ':' + (date.getMinutes() < 10 ? '0' + date.getMinutes() : date.getMinutes());
    };

    this.parseDate = function (date) {
        return $.datepicker.parseDate(DATE_FORMAT, date);

    };

    this.parseDateWithFormat = function (date, format) {
        return $.datepicker.parseDate(format, date);

    };

    this.parseDateTime = function (date, time) {
        var _date = $.datepicker.parseDate(DATE_FORMAT, date);
        var _time = time.split(':');
        _date.setHours(parseInt(_time[0], 10));
        _date.setMinutes(parseInt(_time[1], 10));
        return _date;
    };

    var showUpdateInformer = function () {
        $('#updateInformer').show();
    };

    this.checkServerVersion = function (hideAjaxProgress) {
        var currentVersion = $('#applicationVersion').val();
        var newVersion = $('#updateExists').val();
        if (newVersion === '') {
            if (currentVersion && currentVersion != '') {
                var currentMajorVersion = currentVersion.split('.')[0];
                var currentMinorVersion = currentVersion.split('.')[1];
                $.ajax({
                    url: '/updater/check',
                    type: 'get',
                    async: true,
                    global: hideAjaxProgress ? false : true,
                    data: {'majorversion': currentMajorVersion},
                    dataType: 'json',
                    success: function (result) {
                        if (result.versionInfo) {
                            $('#agreementNumber').html(result.versionInfo.agreementNumber);
                            var majorVersion = result.versionInfo.majorversion.version;
                            var minorVersion = result.versionInfo.minorversion.version;
                            $('#serverversiondescription').html('');
                            $('#serverversion').html(minorVersion);

                            var serverMinorVersion = minorVersion.split('.')[1];
                            if (parseInt(serverMinorVersion) > parseInt(currentMinorVersion)) {
                                commonHelper.callAjaxMethod('settings.htm', 'updateExists', {version: minorVersion}, function () {
                                    showUpdateInformer();
                                }, true);
                                $('#updatelink').show();
                            }
                        } else {
                            $('#updatelink').hide();
                            $('#serverversiondescription').html(messages['commonjs.versionerror']);
                        }

                    },
                    error: function (data) {
                        $(document).attr('hideAjaxProgress', false);
                        $('#updatelink').hide();
                        $('#serverversiondescription').html(messages['commonjs.versionerror']);
                    }
                });
            }
        } else {
            $('#updatelink').show();
            $('#serverversion').html(newVersion);

        }
    };

    this.prepareViewer = function (objects, container) {
        if (VIEWER) {
            $.each(objects, function (index, item) {
                var filteredObjects;

                if (container) {
                    filteredObjects = container.find(item.filter);
                } else {
                    filteredObjects = $(item.filter);
                }
                if (item.action == 'delete') {
                    filteredObjects.remove();
                } else if (item.action == 'disable') {
                    filteredObjects.attr('disabled', 'disabled');
                } else if (item.action == 'disabledatepicker') {
                    filteredObjects.datepicker('disable');
                } else if (item.action == 'hide') {
                    filteredObjects.hide();
                } else if (item.action == 'disableautocomplete') {
                    AUTOCOMPLETE_SEARCH_FIELD.disable(item.filter);
                }
            });
        }
    };

    this.checkPermission = function (authorityName, onGrant, onDeny) {
        var userAuthorized = !AUTHORITIES || AUTHORITIES[authorityName];
        if (userAuthorized) {
            if (onGrant) {
                onGrant();
            }
        } else {
            if (onDeny) {
                onDeny();
            }
        }
    };

    this.checkFeature = function (authorityName, onGrant, onDeny) {
        var userAuthorized = !FEATURES || FEATURES[authorityName];
        if (userAuthorized) {
            if (onGrant) {
                onGrant();
            }
        } else {
            if (onDeny) {
                onDeny();
            }
        }
    };

    this.selectLanguage = function (userLanguage) {
        this.callAjaxMethod('users.htm', 'saveUserLanguage', {userLanguage: userLanguage}, function () {
            location.reload();
        });
    };

    this.selectOrganization = function (organizationId) {
        this.callAjaxMethod('organizations.htm', 'selectCurrentOrganization', {organizationId: organizationId}, function (useCallbacks) {
            CURRENT_ORG = organizationId;
            if(useCallbacks){
                $.each(changeOrganizationCallbacks, function (index, item) {
                        item(organizationId);
                    }
                )
            }
            else {
                window.location = 'index.htm';
            }
        });
    };

    this.registerChangeOrganizationListener = function (callback) {
        changeOrganizationCallbacks.push(callback);
    };

    var decodeDiv = $('<div>');
    this.decodeHtmlString = function (str) {
        return str ? decodeDiv.html(str).text() : '';
    };

    that.currencyFormatter = function (cellvalue, options, rowObject) {
        try {
            return cellvalue != null ? cellvalue.toFixed(2).replace(/(\d)(?=(\d{3})+\.)/g, "$1,") + ' ' + MONEY_NAME : '';
        } catch (e) {
            return cellvalue;
        }
    };


    that.notNullFormatter = function (cellvalue, options, rowObject) {
        return cellvalue != null ? cellvalue : '';
    };

    that.timeToMinutes = function (time) {
        return time.hours * 60 + time.minutes;
    };

    that.timeObjectToString = function (timeObject) {
        if (typeof(timeObject) == 'string') {
            return timeObject;
        } else {
            return (timeObject.hours <= 9 ? '0' + timeObject.hours : timeObject.hours) + ':' + (timeObject.minutes <= 9 ? '0' + timeObject.minutes : timeObject.minutes);
        }
    };

    that.stringToTimeObject = function (timeString) {
        var startRowTime = timeString.split(':');
        return {hours: parseInt(startRowTime[0]), minutes: parseInt(startRowTime[1])};
    }

    that.openPdfPrintDialog = function (url) {
        $('#pdfPrintingDialog').show();
        $('#pdfPrintingDialog').overlay({
            oneInstance: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5,
                zIndex: 100
            },
            fixed: false
        });
        $('#pdfObject').attr('data', url);
        $('#pdfPrintingDialog').overlay().load();
        $('#pdfPrintingDialog').css('z-index', (commonHelper.getMaxZIndex() + 1));
    }
    
    this.initReferenceSelect = function (referenceSelect, references, referencename, referencevaluename, titlename) {
        referenceSelect.children(null).remove();
        $('<option>', {
            value: ''
        }).appendTo(referenceSelect);

        var optionParams = {};
        optionParams[referencename + ' <- ' + referencename + 's'] = {
            '.': referencename + '.' + titlename,
            '@value': referencename + '.' + referencevaluename
        };

        referenceSelect.directives({
            'option': optionParams
        }).render(references);
    };
}

function initPage() {
    $(document).ready(function () {

        if ($.jgrid.hasOwnProperty("regional") && $.jgrid.regional.hasOwnProperty(messages['common.lang'])) {
            $.extend($.jgrid,$.jgrid.regional[messages['common.lang']]);
        }

        $(document).ajaxStart(
            function () {
                var hideAjaxProgress = $(document).attr('hideAjaxProgress');
                if (hideAjaxProgress == 'false') {
                    openProgressImage();
                }

            }).ajaxStop(function () {
                closeProgressImage();
            });

        if (currentPage.pageReady) {
            currentPage.pageReady();
        }

        $('.moneyName').html(MONEY_NAME);

    });
    initPushListener();
}

function initPushListener() {
    atmosphere.subscribe({
        "url": "push.htm",
        "transport": "long-polling",
        "fallbackTransport": "long-polling",
        "onMessage": function (response) {
            if(response.status == 200){
                var eventInfo = JSON.parse(response.responseBody);
                if(eventInfo.action == 'incomingCall'){
                    startTitleAlert(messages['commonjs.incomecallalert']);
                    DIALOGS.askYesNoDialog(messages['commonjs.incomecall'], messages['commonjs.open'], function () {
                        if(eventInfo.childId && eventInfo.phone){
                            window.open('client.htm?action=openChild&actionParameters=' + JSON.stringify({
                                    childId: eventInfo.childId,
                                    scriptType: 'CLIENT'
                                }), '_blank');
                        }
                        else if(eventInfo.requestId && eventInfo.phone){
                            window.open('marketing.htm?action=openDialog&actionParameters=' + JSON.stringify({
                                    requestid: eventInfo.requestId,
                                    scriptType: 'REQUEST' 
                                }), '_blank');
                        }
                        else {
                            var defaultParameters = {};
                            defaultParameters['callId'] = eventInfo.callId;
                            defaultParameters['infoSourceId'] = eventInfo.infoSourceId;
                            defaultParameters['adCompanyId'] = eventInfo.adCompanyId;
                            defaultParameters['organizationId'] = eventInfo.organizationId;
                            if(eventInfo.phone){
                                defaultParameters['phone'] = eventInfo.phone;
                            }
                            if(eventInfo.marketing){
                                defaultParameters['scriptType'] = 'NEW_REQUEST';
                                window.open('marketing.htm?action=openDialog&actionParameters=' + JSON.stringify(defaultParameters), '_blank');
                            }
                            else {
                                defaultParameters['scriptType'] = 'NEW_CLIENT';
                                window.open('client.htm?action=openDialog&actionParameters=' + JSON.stringify(defaultParameters), '_blank');
                            }
                        }
                        stopTitleAlert();
                    }, function () {
                        if(eventInfo.childId && eventInfo.phone){
                            DIALOGS.openScriptDialog(null, 'CLIENT');
                        }
                        else if(eventInfo.requestId && eventInfo.phone){
                            DIALOGS.openScriptDialog(null, 'REQUEST');
                        }
                        else {
                            if(eventInfo.marketing){
                                DIALOGS.openScriptDialog(null, 'NEW_REQUEST');
                            }
                            else {
                                DIALOGS.openScriptDialog(null, 'NEW_CLIENT');
                            }
                        }
                        stopTitleAlert();
                    });
                }
                else if(eventInfo.action == 'incomingCallEnd'){
                    $('.autoclose').dialog('close');
                    stopTitleAlert();
                }
            }
        }
    });
}

function disableForDemo() {
    if (DEMO) {
        $('button').attr('disabled', 'disabled');
        $('input').attr('disabled', 'disabled');
        $('select').attr('disabled', 'disabled');
        $('[rel="control"]').remove();
    }
}

function openProgressImage() {
    var ajaxBusy = $('#ajaxBusy');
    moveDivToCenter(ajaxBusy);
    ajaxBusy.show();
}

function closeProgressImage() {
    $('#ajaxBusy').hide();
}

function moveDivToCenter(div) {
    div.css("position", "absolute");
    div.css("top", (($(window).height() - div.outerHeight()) / 2) + $(window).scrollTop() + "px");
    div.css("left", (($(window).width() - div.outerWidth()) / 2) + $(window).scrollLeft() + "px");

}

var titleAlertInterval = null;

function startTitleAlert(text){
    stopTitleAlert();
    titleAlertInterval = setInterval(function(){
        var r = text;
        var t = document.title;

        if(!$("div").is("#saved-title")) {
            $("body").append('<div id="saved-title">' + t + '</div>');
        }
        var st = $("#saved-title").text();

        if(t != r) {
            document.title = r;
        }
        else {
            document.title = st;
        }
    }, 1000);
}

function stopTitleAlert(){
    if(titleAlertInterval){
        clearInterval(titleAlertInterval);
        document.title = $("#saved-title").text();
        titleAlertInterval = null;
    }
}

if (typeof String.prototype.startsWith != 'function') {
    // see below for better implementation!
    String.prototype.startsWith = function (str) {
        return this.indexOf(str) == 0;
    };
}


var commonHelper = new PageHelper();
var currentPage = null;
var DATE_FORMAT = null;
var SERVER_DATE_FORMAT = null;
var DEMO = null;
var VIEWER = null;
var ORGS_COUNT = 0;
var CURRENT_ORG = null;
var FEATURES = null;
var MONEY_NAME = messages['commonjs.moneyname'];
var DEFAULT_INPUT_VALUE = new function () {
    var that = this;

    that.prepare = function (element, defaultValue, onFocusEmpty, onBlurEmpty, onBlurFilled) {
        if (element.val() == '') {
            element.val(defaultValue);
        }
        element.focus(function () {
            if (this.value == defaultValue) {
                if (onFocusEmpty) {
                    onFocusEmpty();
                }
                this.value = '';
            }
        });
        element.blur(function () {
            if (this.value == '') {
                if (onBlurEmpty) {
                    onBlurEmpty();
                }
                this.value = defaultValue;
            } else {
                var res;
                if (onBlurFilled) {
                    if (res = onBlurFilled()) {
                        this.value = res;
                    }
                }
            }
        });
    };

}();/*!
 * FullCalendar v3.3.1
 * Docs & License: https://fullcalendar.io/
 * (c) 2017 Adam Shaw
 */

(function(factory) {
	if (typeof define === 'function' && define.amd) {
		define([ 'jquery', 'moment' ], factory);
	}
	else if (typeof exports === 'object') { // Node/CommonJS
		module.exports = factory(require('jquery'), require('moment'));
	}
	else {
		factory(jQuery, moment);
	}
})(function($, moment) {

;;

var FC = $.fullCalendar = {
	version: "3.3.1",
	// When introducing internal API incompatibilities (where fullcalendar plugins would break),
	// the minor version of the calendar should be upped (ex: 2.7.2 -> 2.8.0)
	// and the below integer should be incremented.
	internalApiVersion: 9
};
var fcViews = FC.views = {};


$.fn.fullCalendar = function(options) {
	var args = Array.prototype.slice.call(arguments, 1); // for a possible method call
	var res = this; // what this function will return (this jQuery object by default)

	this.each(function(i, _element) { // loop each DOM element involved
		var element = $(_element);
		var calendar = element.data('fullCalendar'); // get the existing calendar object (if any)
		var singleRes; // the returned value of this single method call

		// a method call
		if (typeof options === 'string') {
			if (calendar && $.isFunction(calendar[options])) {
				singleRes = calendar[options].apply(calendar, args);
				if (!i) {
					res = singleRes; // record the first method call result
				}
				if (options === 'destroy') { // for the destroy method, must remove Calendar object data
					element.removeData('fullCalendar');
				}
			}
		}
		// a new calendar initialization
		else if (!calendar) { // don't initialize twice
			calendar = new Calendar(element, options);
			element.data('fullCalendar', calendar);
			calendar.render();
		}
	});

	return res;
};


var complexOptions = [ // names of options that are objects whose properties should be combined
	'header',
	'footer',
	'buttonText',
	'buttonIcons',
	'themeButtonIcons'
];


// Merges an array of option objects into a single object
function mergeOptions(optionObjs) {
	return mergeProps(optionObjs, complexOptions);
}

;;

// exports
FC.intersectRanges = intersectRanges;
FC.applyAll = applyAll;
FC.debounce = debounce;
FC.isInt = isInt;
FC.htmlEscape = htmlEscape;
FC.cssToStr = cssToStr;
FC.proxy = proxy;
FC.capitaliseFirstLetter = capitaliseFirstLetter;


/* FullCalendar-specific DOM Utilities
----------------------------------------------------------------------------------------------------------------------*/


// Given the scrollbar widths of some other container, create borders/margins on rowEls in order to match the left
// and right space that was offset by the scrollbars. A 1-pixel border first, then margin beyond that.
function compensateScroll(rowEls, scrollbarWidths) {
	if (scrollbarWidths.left) {
		rowEls.css({
			'border-left-width': 1,
			'margin-left': scrollbarWidths.left - 1
		});
	}
	if (scrollbarWidths.right) {
		rowEls.css({
			'border-right-width': 1,
			'margin-right': scrollbarWidths.right - 1
		});
	}
}


// Undoes compensateScroll and restores all borders/margins
function uncompensateScroll(rowEls) {
	rowEls.css({
		'margin-left': '',
		'margin-right': '',
		'border-left-width': '',
		'border-right-width': ''
	});
}


// Make the mouse cursor express that an event is not allowed in the current area
function disableCursor() {
	$('body').addClass('fc-not-allowed');
}


// Returns the mouse cursor to its original look
function enableCursor() {
	$('body').removeClass('fc-not-allowed');
}


// Given a total available height to fill, have `els` (essentially child rows) expand to accomodate.
// By default, all elements that are shorter than the recommended height are expanded uniformly, not considering
// any other els that are already too tall. if `shouldRedistribute` is on, it considers these tall rows and 
// reduces the available height.
function distributeHeight(els, availableHeight, shouldRedistribute) {

	// *FLOORING NOTE*: we floor in certain places because zoom can give inaccurate floating-point dimensions,
	// and it is better to be shorter than taller, to avoid creating unnecessary scrollbars.

	var minOffset1 = Math.floor(availableHeight / els.length); // for non-last element
	var minOffset2 = Math.floor(availableHeight - minOffset1 * (els.length - 1)); // for last element *FLOORING NOTE*
	var flexEls = []; // elements that are allowed to expand. array of DOM nodes
	var flexOffsets = []; // amount of vertical space it takes up
	var flexHeights = []; // actual css height
	var usedHeight = 0;

	undistributeHeight(els); // give all elements their natural height

	// find elements that are below the recommended height (expandable).
	// important to query for heights in a single first pass (to avoid reflow oscillation).
	els.each(function(i, el) {
		var minOffset = i === els.length - 1 ? minOffset2 : minOffset1;
		var naturalOffset = $(el).outerHeight(true);

		if (naturalOffset < minOffset) {
			flexEls.push(el);
			flexOffsets.push(naturalOffset);
			flexHeights.push($(el).height());
		}
		else {
			// this element stretches past recommended height (non-expandable). mark the space as occupied.
			usedHeight += naturalOffset;
		}
	});

	// readjust the recommended height to only consider the height available to non-maxed-out rows.
	if (shouldRedistribute) {
		availableHeight -= usedHeight;
		minOffset1 = Math.floor(availableHeight / flexEls.length);
		minOffset2 = Math.floor(availableHeight - minOffset1 * (flexEls.length - 1)); // *FLOORING NOTE*
	}

	// assign heights to all expandable elements
	$(flexEls).each(function(i, el) {
		var minOffset = i === flexEls.length - 1 ? minOffset2 : minOffset1;
		var naturalOffset = flexOffsets[i];
		var naturalHeight = flexHeights[i];
		var newHeight = minOffset - (naturalOffset - naturalHeight); // subtract the margin/padding

		if (naturalOffset < minOffset) { // we check this again because redistribution might have changed things
			$(el).height(newHeight);
		}
	});
}


// Undoes distrubuteHeight, restoring all els to their natural height
function undistributeHeight(els) {
	els.height('');
}


// Given `els`, a jQuery set of <td> cells, find the cell with the largest natural width and set the widths of all the
// cells to be that width.
// PREREQUISITE: if you want a cell to take up width, it needs to have a single inner element w/ display:inline
function matchCellWidths(els) {
	var maxInnerWidth = 0;

	els.find('> *').each(function(i, innerEl) {
		var innerWidth = $(innerEl).outerWidth();
		if (innerWidth > maxInnerWidth) {
			maxInnerWidth = innerWidth;
		}
	});

	maxInnerWidth++; // sometimes not accurate of width the text needs to stay on one line. insurance

	els.width(maxInnerWidth);

	return maxInnerWidth;
}


// Given one element that resides inside another,
// Subtracts the height of the inner element from the outer element.
function subtractInnerElHeight(outerEl, innerEl) {
	var both = outerEl.add(innerEl);
	var diff;

	// effin' IE8/9/10/11 sometimes returns 0 for dimensions. this weird hack was the only thing that worked
	both.css({
		position: 'relative', // cause a reflow, which will force fresh dimension recalculation
		left: -1 // ensure reflow in case the el was already relative. negative is less likely to cause new scroll
	});
	diff = outerEl.outerHeight() - innerEl.outerHeight(); // grab the dimensions
	both.css({ position: '', left: '' }); // undo hack

	return diff;
}


/* Element Geom Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.getOuterRect = getOuterRect;
FC.getClientRect = getClientRect;
FC.getContentRect = getContentRect;
FC.getScrollbarWidths = getScrollbarWidths;


// borrowed from https://github.com/jquery/jquery-ui/blob/1.11.0/ui/core.js#L51
function getScrollParent(el) {
	var position = el.css('position'),
		scrollParent = el.parents().filter(function() {
			var parent = $(this);
			return (/(auto|scroll)/).test(
				parent.css('overflow') + parent.css('overflow-y') + parent.css('overflow-x')
			);
		}).eq(0);

	return position === 'fixed' || !scrollParent.length ? $(el[0].ownerDocument || document) : scrollParent;
}


// Queries the outer bounding area of a jQuery element.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getOuterRect(el, origin) {
	var offset = el.offset();
	var left = offset.left - (origin ? origin.left : 0);
	var top = offset.top - (origin ? origin.top : 0);

	return {
		left: left,
		right: left + el.outerWidth(),
		top: top,
		bottom: top + el.outerHeight()
	};
}


// Queries the area within the margin/border/scrollbars of a jQuery element. Does not go within the padding.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
// WARNING: given element can't have borders
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getClientRect(el, origin) {
	var offset = el.offset();
	var scrollbarWidths = getScrollbarWidths(el);
	var left = offset.left + getCssFloat(el, 'border-left-width') + scrollbarWidths.left - (origin ? origin.left : 0);
	var top = offset.top + getCssFloat(el, 'border-top-width') + scrollbarWidths.top - (origin ? origin.top : 0);

	return {
		left: left,
		right: left + el[0].clientWidth, // clientWidth includes padding but NOT scrollbars
		top: top,
		bottom: top + el[0].clientHeight // clientHeight includes padding but NOT scrollbars
	};
}


// Queries the area within the margin/border/padding of a jQuery element. Assumed not to have scrollbars.
// Returns a rectangle with absolute coordinates: left, right (exclusive), top, bottom (exclusive).
// Origin is optional.
function getContentRect(el, origin) {
	var offset = el.offset(); // just outside of border, margin not included
	var left = offset.left + getCssFloat(el, 'border-left-width') + getCssFloat(el, 'padding-left') -
		(origin ? origin.left : 0);
	var top = offset.top + getCssFloat(el, 'border-top-width') + getCssFloat(el, 'padding-top') -
		(origin ? origin.top : 0);

	return {
		left: left,
		right: left + el.width(),
		top: top,
		bottom: top + el.height()
	};
}


// Returns the computed left/right/top/bottom scrollbar widths for the given jQuery element.
// WARNING: given element can't have borders (which will cause offsetWidth/offsetHeight to be larger).
// NOTE: should use clientLeft/clientTop, but very unreliable cross-browser.
function getScrollbarWidths(el) {
	var leftRightWidth = el[0].offsetWidth - el[0].clientWidth;
	var bottomWidth = el[0].offsetHeight - el[0].clientHeight;
	var widths;

	leftRightWidth = sanitizeScrollbarWidth(leftRightWidth);
	bottomWidth = sanitizeScrollbarWidth(bottomWidth);

	widths = { left: 0, right: 0, top: 0, bottom: bottomWidth };

	if (getIsLeftRtlScrollbars() && el.css('direction') == 'rtl') { // is the scrollbar on the left side?
		widths.left = leftRightWidth;
	}
	else {
		widths.right = leftRightWidth;
	}

	return widths;
}


// The scrollbar width computations in getScrollbarWidths are sometimes flawed when it comes to
// retina displays, rounding, and IE11. Massage them into a usable value.
function sanitizeScrollbarWidth(width) {
	width = Math.max(0, width); // no negatives
	width = Math.round(width);
	return width;
}


// Logic for determining if, when the element is right-to-left, the scrollbar appears on the left side

var _isLeftRtlScrollbars = null;

function getIsLeftRtlScrollbars() { // responsible for caching the computation
	if (_isLeftRtlScrollbars === null) {
		_isLeftRtlScrollbars = computeIsLeftRtlScrollbars();
	}
	return _isLeftRtlScrollbars;
}

function computeIsLeftRtlScrollbars() { // creates an offscreen test element, then removes it
	var el = $('<div><div/></div>')
		.css({
			position: 'absolute',
			top: -1000,
			left: 0,
			border: 0,
			padding: 0,
			overflow: 'scroll',
			direction: 'rtl'
		})
		.appendTo('body');
	var innerEl = el.children();
	var res = innerEl.offset().left > el.offset().left; // is the inner div shifted to accommodate a left scrollbar?
	el.remove();
	return res;
}


// Retrieves a jQuery element's computed CSS value as a floating-point number.
// If the queried value is non-numeric (ex: IE can return "medium" for border width), will just return zero.
function getCssFloat(el, prop) {
	return parseFloat(el.css(prop)) || 0;
}


/* Mouse / Touch Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.preventDefault = preventDefault;


// Returns a boolean whether this was a left mouse click and no ctrl key (which means right click on Mac)
function isPrimaryMouseButton(ev) {
	return ev.which == 1 && !ev.ctrlKey;
}


function getEvX(ev) {
	var touches = ev.originalEvent.touches;

	// on mobile FF, pageX for touch events is present, but incorrect,
	// so, look at touch coordinates first.
	if (touches && touches.length) {
		return touches[0].pageX;
	}

	return ev.pageX;
}


function getEvY(ev) {
	var touches = ev.originalEvent.touches;

	// on mobile FF, pageX for touch events is present, but incorrect,
	// so, look at touch coordinates first.
	if (touches && touches.length) {
		return touches[0].pageY;
	}

	return ev.pageY;
}


function getEvIsTouch(ev) {
	return /^touch/.test(ev.type);
}


function preventSelection(el) {
	el.addClass('fc-unselectable')
		.on('selectstart', preventDefault);
}


function allowSelection(el) {
	el.removeClass('fc-unselectable')
		.off('selectstart', preventDefault);
}


// Stops a mouse/touch event from doing it's native browser action
function preventDefault(ev) {
	ev.preventDefault();
}


/* General Geometry Utils
----------------------------------------------------------------------------------------------------------------------*/

FC.intersectRects = intersectRects;

// Returns a new rectangle that is the intersection of the two rectangles. If they don't intersect, returns false
function intersectRects(rect1, rect2) {
	var res = {
		left: Math.max(rect1.left, rect2.left),
		right: Math.min(rect1.right, rect2.right),
		top: Math.max(rect1.top, rect2.top),
		bottom: Math.min(rect1.bottom, rect2.bottom)
	};

	if (res.left < res.right && res.top < res.bottom) {
		return res;
	}
	return false;
}


// Returns a new point that will have been moved to reside within the given rectangle
function constrainPoint(point, rect) {
	return {
		left: Math.min(Math.max(point.left, rect.left), rect.right),
		top: Math.min(Math.max(point.top, rect.top), rect.bottom)
	};
}


// Returns a point that is the center of the given rectangle
function getRectCenter(rect) {
	return {
		left: (rect.left + rect.right) / 2,
		top: (rect.top + rect.bottom) / 2
	};
}


// Subtracts point2's coordinates from point1's coordinates, returning a delta
function diffPoints(point1, point2) {
	return {
		left: point1.left - point2.left,
		top: point1.top - point2.top
	};
}


/* Object Ordering by Field
----------------------------------------------------------------------------------------------------------------------*/

FC.parseFieldSpecs = parseFieldSpecs;
FC.compareByFieldSpecs = compareByFieldSpecs;
FC.compareByFieldSpec = compareByFieldSpec;
FC.flexibleCompare = flexibleCompare;


function parseFieldSpecs(input) {
	var specs = [];
	var tokens = [];
	var i, token;

	if (typeof input === 'string') {
		tokens = input.split(/\s*,\s*/);
	}
	else if (typeof input === 'function') {
		tokens = [ input ];
	}
	else if ($.isArray(input)) {
		tokens = input;
	}

	for (i = 0; i < tokens.length; i++) {
		token = tokens[i];

		if (typeof token === 'string') {
			specs.push(
				token.charAt(0) == '-' ?
					{ field: token.substring(1), order: -1 } :
					{ field: token, order: 1 }
			);
		}
		else if (typeof token === 'function') {
			specs.push({ func: token });
		}
	}

	return specs;
}


function compareByFieldSpecs(obj1, obj2, fieldSpecs) {
	var i;
	var cmp;

	for (i = 0; i < fieldSpecs.length; i++) {
		cmp = compareByFieldSpec(obj1, obj2, fieldSpecs[i]);
		if (cmp) {
			return cmp;
		}
	}

	return 0;
}


function compareByFieldSpec(obj1, obj2, fieldSpec) {
	if (fieldSpec.func) {
		return fieldSpec.func(obj1, obj2);
	}
	return flexibleCompare(obj1[fieldSpec.field], obj2[fieldSpec.field]) *
		(fieldSpec.order || 1);
}


function flexibleCompare(a, b) {
	if (!a && !b) {
		return 0;
	}
	if (b == null) {
		return -1;
	}
	if (a == null) {
		return 1;
	}
	if ($.type(a) === 'string' || $.type(b) === 'string') {
		return String(a).localeCompare(String(b));
	}
	return a - b;
}


/* FullCalendar-specific Misc Utilities
----------------------------------------------------------------------------------------------------------------------*/


// Computes the intersection of the two ranges. Will return fresh date clones in a range.
// Returns undefined if no intersection.
// Expects all dates to be normalized to the same timezone beforehand.
// TODO: move to date section?
function intersectRanges(subjectRange, constraintRange) {
	var subjectStart = subjectRange.start;
	var subjectEnd = subjectRange.end;
	var constraintStart = constraintRange.start;
	var constraintEnd = constraintRange.end;
	var segStart, segEnd;
	var isStart, isEnd;

	if (subjectEnd > constraintStart && subjectStart < constraintEnd) { // in bounds at all?

		if (subjectStart >= constraintStart) {
			segStart = subjectStart.clone();
			isStart = true;
		}
		else {
			segStart = constraintStart.clone();
			isStart =  false;
		}

		if (subjectEnd <= constraintEnd) {
			segEnd = subjectEnd.clone();
			isEnd = true;
		}
		else {
			segEnd = constraintEnd.clone();
			isEnd = false;
		}

		return {
			start: segStart,
			end: segEnd,
			isStart: isStart,
			isEnd: isEnd
		};
	}
}


/* Date Utilities
----------------------------------------------------------------------------------------------------------------------*/

FC.computeGreatestUnit = computeGreatestUnit;
FC.divideRangeByDuration = divideRangeByDuration;
FC.divideDurationByDuration = divideDurationByDuration;
FC.multiplyDuration = multiplyDuration;
FC.durationHasTime = durationHasTime;

var dayIDs = [ 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat' ];
var unitsDesc = [ 'year', 'month', 'week', 'day', 'hour', 'minute', 'second', 'millisecond' ]; // descending


// Diffs the two moments into a Duration where full-days are recorded first, then the remaining time.
// Moments will have their timezones normalized.
function diffDayTime(a, b) {
	return moment.duration({
		days: a.clone().stripTime().diff(b.clone().stripTime(), 'days'),
		ms: a.time() - b.time() // time-of-day from day start. disregards timezone
	});
}


// Diffs the two moments via their start-of-day (regardless of timezone). Produces whole-day durations.
function diffDay(a, b) {
	return moment.duration({
		days: a.clone().stripTime().diff(b.clone().stripTime(), 'days')
	});
}


// Diffs two moments, producing a duration, made of a whole-unit-increment of the given unit. Uses rounding.
function diffByUnit(a, b, unit) {
	return moment.duration(
		Math.round(a.diff(b, unit, true)), // returnFloat=true
		unit
	);
}


// Computes the unit name of the largest whole-unit period of time.
// For example, 48 hours will be "days" whereas 49 hours will be "hours".
// Accepts start/end, a range object, or an original duration object.
function computeGreatestUnit(start, end) {
	var i, unit;
	var val;

	for (i = 0; i < unitsDesc.length; i++) {
		unit = unitsDesc[i];
		val = computeRangeAs(unit, start, end);

		if (val >= 1 && isInt(val)) {
			break;
		}
	}

	return unit; // will be "milliseconds" if nothing else matches
}


// like computeGreatestUnit, but has special abilities to interpret the source input for clues
function computeDurationGreatestUnit(duration, durationInput) {
	var unit = computeGreatestUnit(duration);

	// prevent days:7 from being interpreted as a week
	if (unit === 'week' && typeof durationInput === 'object' && durationInput.days) {
		unit = 'day';
	}

	return unit;
}


// Computes the number of units (like "hours") in the given range.
// Range can be a {start,end} object, separate start/end args, or a Duration.
// Results are based on Moment's .as() and .diff() methods, so results can depend on internal handling
// of month-diffing logic (which tends to vary from version to version).
function computeRangeAs(unit, start, end) {

	if (end != null) { // given start, end
		return end.diff(start, unit, true);
	}
	else if (moment.isDuration(start)) { // given duration
		return start.as(unit);
	}
	else { // given { start, end } range object
		return start.end.diff(start.start, unit, true);
	}
}


// Intelligently divides a range (specified by a start/end params) by a duration
function divideRangeByDuration(start, end, dur) {
	var months;

	if (durationHasTime(dur)) {
		return (end - start) / dur;
	}
	months = dur.asMonths();
	if (Math.abs(months) >= 1 && isInt(months)) {
		return end.diff(start, 'months', true) / months;
	}
	return end.diff(start, 'days', true) / dur.asDays();
}


// Intelligently divides one duration by another
function divideDurationByDuration(dur1, dur2) {
	var months1, months2;

	if (durationHasTime(dur1) || durationHasTime(dur2)) {
		return dur1 / dur2;
	}
	months1 = dur1.asMonths();
	months2 = dur2.asMonths();
	if (
		Math.abs(months1) >= 1 && isInt(months1) &&
		Math.abs(months2) >= 1 && isInt(months2)
	) {
		return months1 / months2;
	}
	return dur1.asDays() / dur2.asDays();
}


// Intelligently multiplies a duration by a number
function multiplyDuration(dur, n) {
	var months;

	if (durationHasTime(dur)) {
		return moment.duration(dur * n);
	}
	months = dur.asMonths();
	if (Math.abs(months) >= 1 && isInt(months)) {
		return moment.duration({ months: months * n });
	}
	return moment.duration({ days: dur.asDays() * n });
}


function cloneRange(range) {
	return {
		start: range.start.clone(),
		end: range.end.clone()
	};
}


// Trims the beginning and end of inner range to be completely within outerRange.
// Returns a new range object.
function constrainRange(innerRange, outerRange) {
	innerRange = cloneRange(innerRange);

	if (outerRange.start) {
		// needs to be inclusively before outerRange's end
		innerRange.start = constrainDate(innerRange.start, outerRange);
	}

	if (outerRange.end) {
		innerRange.end = minMoment(innerRange.end, outerRange.end);
	}

	return innerRange;
}


// If the given date is not within the given range, move it inside.
// (If it's past the end, make it one millisecond before the end).
// Always returns a new moment.
function constrainDate(date, range) {
	date = date.clone();

	if (range.start) {
		date = maxMoment(date, range.start);
	}

	if (range.end && date >= range.end) {
		date = range.end.clone().subtract(1);
	}

	return date;
}


function isDateWithinRange(date, range) {
	return (!range.start || date >= range.start) &&
		(!range.end || date < range.end);
}


// TODO: deal with repeat code in intersectRanges
// constraintRange can have unspecified start/end, an open-ended range.
function doRangesIntersect(subjectRange, constraintRange) {
	return (!constraintRange.start || subjectRange.end >= constraintRange.start) &&
		(!constraintRange.end || subjectRange.start < constraintRange.end);
}


function isRangeWithinRange(innerRange, outerRange) {
	return (!outerRange.start || innerRange.start >= outerRange.start) &&
		(!outerRange.end || innerRange.end <= outerRange.end);
}


function isRangesEqual(range0, range1) {
	return ((range0.start && range1.start && range0.start.isSame(range1.start)) || (!range0.start && !range1.start)) &&
		((range0.end && range1.end && range0.end.isSame(range1.end)) || (!range0.end && !range1.end));
}


// Returns the moment that's earlier in time. Always a copy.
function minMoment(mom1, mom2) {
	return (mom1.isBefore(mom2) ? mom1 : mom2).clone();
}


// Returns the moment that's later in time. Always a copy.
function maxMoment(mom1, mom2) {
	return (mom1.isAfter(mom2) ? mom1 : mom2).clone();
}


// Returns a boolean about whether the given duration has any time parts (hours/minutes/seconds/ms)
function durationHasTime(dur) {
	return Boolean(dur.hours() || dur.minutes() || dur.seconds() || dur.milliseconds());
}


function isNativeDate(input) {
	return  Object.prototype.toString.call(input) === '[object Date]' || input instanceof Date;
}


// Returns a boolean about whether the given input is a time string, like "06:40:00" or "06:00"
function isTimeString(str) {
	return /^\d+\:\d+(?:\:\d+\.?(?:\d{3})?)?$/.test(str);
}


/* Logging and Debug
----------------------------------------------------------------------------------------------------------------------*/

FC.log = function() {
	var console = window.console;

	if (console && console.log) {
		return console.log.apply(console, arguments);
	}
};

FC.warn = function() {
	var console = window.console;

	if (console && console.warn) {
		return console.warn.apply(console, arguments);
	}
	else {
		return FC.log.apply(FC, arguments);
	}
};


/* General Utilities
----------------------------------------------------------------------------------------------------------------------*/

var hasOwnPropMethod = {}.hasOwnProperty;


// Merges an array of objects into a single object.
// The second argument allows for an array of property names who's object values will be merged together.
function mergeProps(propObjs, complexProps) {
	var dest = {};
	var i, name;
	var complexObjs;
	var j, val;
	var props;

	if (complexProps) {
		for (i = 0; i < complexProps.length; i++) {
			name = complexProps[i];
			complexObjs = [];

			// collect the trailing object values, stopping when a non-object is discovered
			for (j = propObjs.length - 1; j >= 0; j--) {
				val = propObjs[j][name];

				if (typeof val === 'object') {
					complexObjs.unshift(val);
				}
				else if (val !== undefined) {
					dest[name] = val; // if there were no objects, this value will be used
					break;
				}
			}

			// if the trailing values were objects, use the merged value
			if (complexObjs.length) {
				dest[name] = mergeProps(complexObjs);
			}
		}
	}

	// copy values into the destination, going from last to first
	for (i = propObjs.length - 1; i >= 0; i--) {
		props = propObjs[i];

		for (name in props) {
			if (!(name in dest)) { // if already assigned by previous props or complex props, don't reassign
				dest[name] = props[name];
			}
		}
	}

	return dest;
}


// Create an object that has the given prototype. Just like Object.create
function createObject(proto) {
	var f = function() {};
	f.prototype = proto;
	return new f();
}
FC.createObject = createObject;


function copyOwnProps(src, dest) {
	for (var name in src) {
		if (hasOwnProp(src, name)) {
			dest[name] = src[name];
		}
	}
}


function hasOwnProp(obj, name) {
	return hasOwnPropMethod.call(obj, name);
}


// Is the given value a non-object non-function value?
function isAtomic(val) {
	return /undefined|null|boolean|number|string/.test($.type(val));
}


function applyAll(functions, thisObj, args) {
	if ($.isFunction(functions)) {
		functions = [ functions ];
	}
	if (functions) {
		var i;
		var ret;
		for (i=0; i<functions.length; i++) {
			ret = functions[i].apply(thisObj, args) || ret;
		}
		return ret;
	}
}


function firstDefined() {
	for (var i=0; i<arguments.length; i++) {
		if (arguments[i] !== undefined) {
			return arguments[i];
		}
	}
}


function htmlEscape(s) {
	return (s + '').replace(/&/g, '&amp;')
		.replace(/</g, '&lt;')
		.replace(/>/g, '&gt;')
		.replace(/'/g, '&#039;')
		.replace(/"/g, '&quot;')
		.replace(/\n/g, '<br />');
}

function stripHtmlEntities(text) {
	return text.replace(/&.*?;/g, '');
}


// Given a hash of CSS properties, returns a string of CSS.
// Uses property names as-is (no camel-case conversion). Will not make statements for null/undefined values.
function cssToStr(cssProps) {
	var statements = [];

	$.each(cssProps, function(name, val) {
		if (val != null) {
			statements.push(name + ':' + val);
		}
	});

	return statements.join(';');
}


// Given an object hash of HTML attribute names to values,
// generates a string that can be injected between < > in HTML
function attrsToStr(attrs) {
	var parts = [];

	$.each(attrs, function(name, val) {
		if (val != null) {
			parts.push(name + '="' + htmlEscape(val) + '"');
		}
	});

	return parts.join(' ');
}


function capitaliseFirstLetter(str) {
	return str.charAt(0).toUpperCase() + str.slice(1);
}


function compareNumbers(a, b) { // for .sort()
	return a - b;
}


function isInt(n) {
	return n % 1 === 0;
}


// Returns a method bound to the given object context.
// Just like one of the jQuery.proxy signatures, but without the undesired behavior of treating the same method with
// different contexts as identical when binding/unbinding events.
function proxy(obj, methodName) {
	var method = obj[methodName];

	return function() {
		return method.apply(obj, arguments);
	};
}


// Returns a function, that, as long as it continues to be invoked, will not
// be triggered. The function will be called after it stops being called for
// N milliseconds. If `immediate` is passed, trigger the function on the
// leading edge, instead of the trailing.
// https://github.com/jashkenas/underscore/blob/1.6.0/underscore.js#L714
function debounce(func, wait, immediate) {
	var timeout, args, context, timestamp, result;

	var later = function() {
		var last = +new Date() - timestamp;
		if (last < wait) {
			timeout = setTimeout(later, wait - last);
		}
		else {
			timeout = null;
			if (!immediate) {
				result = func.apply(context, args);
				context = args = null;
			}
		}
	};

	return function() {
		context = this;
		args = arguments;
		timestamp = +new Date();
		var callNow = immediate && !timeout;
		if (!timeout) {
			timeout = setTimeout(later, wait);
		}
		if (callNow) {
			result = func.apply(context, args);
			context = args = null;
		}
		return result;
	};
}

;;

/*
GENERAL NOTE on moments throughout the *entire rest* of the codebase:
All moments are assumed to be ambiguously-zoned unless otherwise noted,
with the NOTABLE EXCEOPTION of start/end dates that live on *Event Objects*.
Ambiguously-TIMED moments are assumed to be ambiguously-zoned by nature.
*/

var ambigDateOfMonthRegex = /^\s*\d{4}-\d\d$/;
var ambigTimeOrZoneRegex =
	/^\s*\d{4}-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?)?$/;
var newMomentProto = moment.fn; // where we will attach our new methods
var oldMomentProto = $.extend({}, newMomentProto); // copy of original moment methods

// tell momentjs to transfer these properties upon clone
var momentProperties = moment.momentProperties;
momentProperties.push('_fullCalendar');
momentProperties.push('_ambigTime');
momentProperties.push('_ambigZone');


// Creating
// -------------------------------------------------------------------------------------------------

// Creates a new moment, similar to the vanilla moment(...) constructor, but with
// extra features (ambiguous time, enhanced formatting). When given an existing moment,
// it will function as a clone (and retain the zone of the moment). Anything else will
// result in a moment in the local zone.
FC.moment = function() {
	return makeMoment(arguments);
};

// Sames as FC.moment, but forces the resulting moment to be in the UTC timezone.
FC.moment.utc = function() {
	var mom = makeMoment(arguments, true);

	// Force it into UTC because makeMoment doesn't guarantee it
	// (if given a pre-existing moment for example)
	if (mom.hasTime()) { // don't give ambiguously-timed moments a UTC zone
		mom.utc();
	}

	return mom;
};

// Same as FC.moment, but when given an ISO8601 string, the timezone offset is preserved.
// ISO8601 strings with no timezone offset will become ambiguously zoned.
FC.moment.parseZone = function() {
	return makeMoment(arguments, true, true);
};

// Builds an enhanced moment from args. When given an existing moment, it clones. When given a
// native Date, or called with no arguments (the current time), the resulting moment will be local.
// Anything else needs to be "parsed" (a string or an array), and will be affected by:
//    parseAsUTC - if there is no zone information, should we parse the input in UTC?
//    parseZone - if there is zone information, should we force the zone of the moment?
function makeMoment(args, parseAsUTC, parseZone) {
	var input = args[0];
	var isSingleString = args.length == 1 && typeof input === 'string';
	var isAmbigTime;
	var isAmbigZone;
	var ambigMatch;
	var mom;

	if (moment.isMoment(input) || isNativeDate(input) || input === undefined) {
		mom = moment.apply(null, args);
	}
	else { // "parsing" is required
		isAmbigTime = false;
		isAmbigZone = false;

		if (isSingleString) {
			if (ambigDateOfMonthRegex.test(input)) {
				// accept strings like '2014-05', but convert to the first of the month
				input += '-01';
				args = [ input ]; // for when we pass it on to moment's constructor
				isAmbigTime = true;
				isAmbigZone = true;
			}
			else if ((ambigMatch = ambigTimeOrZoneRegex.exec(input))) {
				isAmbigTime = !ambigMatch[5]; // no time part?
				isAmbigZone = true;
			}
		}
		else if ($.isArray(input)) {
			// arrays have no timezone information, so assume ambiguous zone
			isAmbigZone = true;
		}
		// otherwise, probably a string with a format

		if (parseAsUTC || isAmbigTime) {
			mom = moment.utc.apply(moment, args);
		}
		else {
			mom = moment.apply(null, args);
		}

		if (isAmbigTime) {
			mom._ambigTime = true;
			mom._ambigZone = true; // ambiguous time always means ambiguous zone
		}
		else if (parseZone) { // let's record the inputted zone somehow
			if (isAmbigZone) {
				mom._ambigZone = true;
			}
			else if (isSingleString) {
				mom.utcOffset(input); // if not a valid zone, will assign UTC
			}
		}
	}

	mom._fullCalendar = true; // flag for extended functionality

	return mom;
}


// Week Number
// -------------------------------------------------------------------------------------------------


// Returns the week number, considering the locale's custom week number calcuation
// `weeks` is an alias for `week`
newMomentProto.week = newMomentProto.weeks = function(input) {
	var weekCalc = this._locale._fullCalendar_weekCalc;

	if (input == null && typeof weekCalc === 'function') { // custom function only works for getter
		return weekCalc(this);
	}
	else if (weekCalc === 'ISO') {
		return oldMomentProto.isoWeek.apply(this, arguments); // ISO getter/setter
	}

	return oldMomentProto.week.apply(this, arguments); // local getter/setter
};


// Time-of-day
// -------------------------------------------------------------------------------------------------

// GETTER
// Returns a Duration with the hours/minutes/seconds/ms values of the moment.
// If the moment has an ambiguous time, a duration of 00:00 will be returned.
//
// SETTER
// You can supply a Duration, a Moment, or a Duration-like argument.
// When setting the time, and the moment has an ambiguous time, it then becomes unambiguous.
newMomentProto.time = function(time) {

	// Fallback to the original method (if there is one) if this moment wasn't created via FullCalendar.
	// `time` is a generic enough method name where this precaution is necessary to avoid collisions w/ other plugins.
	if (!this._fullCalendar) {
		return oldMomentProto.time.apply(this, arguments);
	}

	if (time == null) { // getter
		return moment.duration({
			hours: this.hours(),
			minutes: this.minutes(),
			seconds: this.seconds(),
			milliseconds: this.milliseconds()
		});
	}
	else { // setter

		this._ambigTime = false; // mark that the moment now has a time

		if (!moment.isDuration(time) && !moment.isMoment(time)) {
			time = moment.duration(time);
		}

		// The day value should cause overflow (so 24 hours becomes 00:00:00 of next day).
		// Only for Duration times, not Moment times.
		var dayHours = 0;
		if (moment.isDuration(time)) {
			dayHours = Math.floor(time.asDays()) * 24;
		}

		// We need to set the individual fields.
		// Can't use startOf('day') then add duration. In case of DST at start of day.
		return this.hours(dayHours + time.hours())
			.minutes(time.minutes())
			.seconds(time.seconds())
			.milliseconds(time.milliseconds());
	}
};

// Converts the moment to UTC, stripping out its time-of-day and timezone offset,
// but preserving its YMD. A moment with a stripped time will display no time
// nor timezone offset when .format() is called.
newMomentProto.stripTime = function() {

	if (!this._ambigTime) {

		this.utc(true); // keepLocalTime=true (for keeping *date* value)

		// set time to zero
		this.set({
			hours: 0,
			minutes: 0,
			seconds: 0,
			ms: 0
		});

		// Mark the time as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
		// which clears all ambig flags.
		this._ambigTime = true;
		this._ambigZone = true; // if ambiguous time, also ambiguous timezone offset
	}

	return this; // for chaining
};

// Returns if the moment has a non-ambiguous time (boolean)
newMomentProto.hasTime = function() {
	return !this._ambigTime;
};


// Timezone
// -------------------------------------------------------------------------------------------------

// Converts the moment to UTC, stripping out its timezone offset, but preserving its
// YMD and time-of-day. A moment with a stripped timezone offset will display no
// timezone offset when .format() is called.
newMomentProto.stripZone = function() {
	var wasAmbigTime;

	if (!this._ambigZone) {

		wasAmbigTime = this._ambigTime;

		this.utc(true); // keepLocalTime=true (for keeping date and time values)

		// the above call to .utc()/.utcOffset() unfortunately might clear the ambig flags, so restore
		this._ambigTime = wasAmbigTime || false;

		// Mark the zone as ambiguous. This needs to happen after the .utc() call, which might call .utcOffset(),
		// which clears the ambig flags.
		this._ambigZone = true;
	}

	return this; // for chaining
};

// Returns of the moment has a non-ambiguous timezone offset (boolean)
newMomentProto.hasZone = function() {
	return !this._ambigZone;
};


// implicitly marks a zone
newMomentProto.local = function(keepLocalTime) {

	// for when converting from ambiguously-zoned to local,
	// keep the time values when converting from UTC -> local
	oldMomentProto.local.call(this, this._ambigZone || keepLocalTime);

	// ensure non-ambiguous
	// this probably already happened via local() -> utcOffset(), but don't rely on Moment's internals
	this._ambigTime = false;
	this._ambigZone = false;

	return this; // for chaining
};


// implicitly marks a zone
newMomentProto.utc = function(keepLocalTime) {

	oldMomentProto.utc.call(this, keepLocalTime);

	// ensure non-ambiguous
	// this probably already happened via utc() -> utcOffset(), but don't rely on Moment's internals
	this._ambigTime = false;
	this._ambigZone = false;

	return this;
};


// implicitly marks a zone (will probably get called upon .utc() and .local())
newMomentProto.utcOffset = function(tzo) {

	if (tzo != null) { // setter
		// these assignments needs to happen before the original zone method is called.
		// I forget why, something to do with a browser crash.
		this._ambigTime = false;
		this._ambigZone = false;
	}

	return oldMomentProto.utcOffset.apply(this, arguments);
};


// Formatting
// -------------------------------------------------------------------------------------------------

newMomentProto.format = function() {
	if (this._fullCalendar && arguments[0]) { // an enhanced moment? and a format string provided?
		return formatDate(this, arguments[0]); // our extended formatting
	}
	if (this._ambigTime) {
		return oldMomentFormat(this, 'YYYY-MM-DD');
	}
	if (this._ambigZone) {
		return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
	}
	return oldMomentProto.format.apply(this, arguments);
};

newMomentProto.toISOString = function() {
	if (this._ambigTime) {
		return oldMomentFormat(this, 'YYYY-MM-DD');
	}
	if (this._ambigZone) {
		return oldMomentFormat(this, 'YYYY-MM-DD[T]HH:mm:ss');
	}
	return oldMomentProto.toISOString.apply(this, arguments);
};

;;
(function() {

// exports
FC.formatDate = formatDate;
FC.formatRange = formatRange;
FC.oldMomentFormat = oldMomentFormat;
FC.queryMostGranularFormatUnit = queryMostGranularFormatUnit;


// Config
// ---------------------------------------------------------------------------------------------------------------------

/*
Inserted between chunks in the fake ("intermediate") formatting string.
Important that it passes as whitespace (\s) because moment often identifies non-standalone months
via a regexp with an \s.
*/
var PART_SEPARATOR = '\u000b'; // vertical tab

/*
Inserted as the first character of a literal-text chunk to indicate that the literal text is not actually literal text,
but rather, a "special" token that has custom rendering (see specialTokens map).
*/
var SPECIAL_TOKEN_MARKER = '\u001f'; // information separator 1

/*
Inserted at the beginning and end of a span of text that must have non-zero numeric characters.
Handling of these markers is done in a post-processing step at the very end of text rendering.
*/
var MAYBE_MARKER = '\u001e'; // information separator 2
var MAYBE_REGEXP = new RegExp(MAYBE_MARKER + '([^' + MAYBE_MARKER + ']*)' + MAYBE_MARKER, 'g'); // must be global

/*
Addition formatting tokens we want recognized
*/
var specialTokens = {
	t: function(date) { // "a" or "p"
		return oldMomentFormat(date, 'a').charAt(0);
	},
	T: function(date) { // "A" or "P"
		return oldMomentFormat(date, 'A').charAt(0);
	}
};

/*
The first characters of formatting tokens for units that are 1 day or larger.
`value` is for ranking relative size (lower means bigger).
`unit` is a normalized unit, used for comparing moments.
*/
var largeTokenMap = {
	Y: { value: 1, unit: 'year' },
	M: { value: 2, unit: 'month' },
	W: { value: 3, unit: 'week' }, // ISO week
	w: { value: 3, unit: 'week' }, // local week
	D: { value: 4, unit: 'day' }, // day of month
	d: { value: 4, unit: 'day' } // day of week
};


// Single Date Formatting
// ---------------------------------------------------------------------------------------------------------------------

/*
Formats `date` with a Moment formatting string, but allow our non-zero areas and special token
*/
function formatDate(date, formatStr) {
	return renderFakeFormatString(
		getParsedFormatString(formatStr).fakeFormatString,
		date
	);
}

/*
Call this if you want Moment's original format method to be used
*/
function oldMomentFormat(mom, formatStr) {
	return oldMomentProto.format.call(mom, formatStr); // oldMomentProto defined in moment-ext.js
}


// Date Range Formatting
// -------------------------------------------------------------------------------------------------
// TODO: make it work with timezone offset

/*
Using a formatting string meant for a single date, generate a range string, like
"Sep 2 - 9 2013", that intelligently inserts a separator where the dates differ.
If the dates are the same as far as the format string is concerned, just return a single
rendering of one date, without any separator.
*/
function formatRange(date1, date2, formatStr, separator, isRTL) {
	var localeData;

	date1 = FC.moment.parseZone(date1);
	date2 = FC.moment.parseZone(date2);

	localeData = date1.localeData();

	// Expand localized format strings, like "LL" -> "MMMM D YYYY".
	// BTW, this is not important for `formatDate` because it is impossible to put custom tokens
	// or non-zero areas in Moment's localized format strings.
	formatStr = localeData.longDateFormat(formatStr) || formatStr;

	return renderParsedFormat(
		getParsedFormatString(formatStr),
		date1,
		date2,
		separator || ' - ',
		isRTL
	);
}

/*
Renders a range with an already-parsed format string.
*/
function renderParsedFormat(parsedFormat, date1, date2, separator, isRTL) {
	var sameUnits = parsedFormat.sameUnits;
	var unzonedDate1 = date1.clone().stripZone(); // for same-unit comparisons
	var unzonedDate2 = date2.clone().stripZone(); // "

	var renderedParts1 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date1);
	var renderedParts2 = renderFakeFormatStringParts(parsedFormat.fakeFormatString, date2);

	var leftI;
	var leftStr = '';
	var rightI;
	var rightStr = '';
	var middleI;
	var middleStr1 = '';
	var middleStr2 = '';
	var middleStr = '';

	// Start at the leftmost side of the formatting string and continue until you hit a token
	// that is not the same between dates.
	for (
		leftI = 0;
		leftI < sameUnits.length && (!sameUnits[leftI] || unzonedDate1.isSame(unzonedDate2, sameUnits[leftI]));
		leftI++
	) {
		leftStr += renderedParts1[leftI];
	}

	// Similarly, start at the rightmost side of the formatting string and move left
	for (
		rightI = sameUnits.length - 1;
		rightI > leftI && (!sameUnits[rightI] || unzonedDate1.isSame(unzonedDate2, sameUnits[rightI]));
		rightI--
	) {
		// If current chunk is on the boundary of unique date-content, and is a special-case
		// date-formatting postfix character, then don't consume it. Consider it unique date-content.
		// TODO: make configurable
		if (rightI - 1 === leftI && renderedParts1[rightI] === '.') {
			break;
		}

		rightStr = renderedParts1[rightI] + rightStr;
	}

	// The area in the middle is different for both of the dates.
	// Collect them distinctly so we can jam them together later.
	for (middleI = leftI; middleI <= rightI; middleI++) {
		middleStr1 += renderedParts1[middleI];
		middleStr2 += renderedParts2[middleI];
	}

	if (middleStr1 || middleStr2) {
		if (isRTL) {
			middleStr = middleStr2 + separator + middleStr1;
		}
		else {
			middleStr = middleStr1 + separator + middleStr2;
		}
	}

	return processMaybeMarkers(
		leftStr + middleStr + rightStr
	);
}


// Format String Parsing
// ---------------------------------------------------------------------------------------------------------------------

var parsedFormatStrCache = {};

/*
Returns a parsed format string, leveraging a cache.
*/
function getParsedFormatString(formatStr) {
	return parsedFormatStrCache[formatStr] ||
		(parsedFormatStrCache[formatStr] = parseFormatString(formatStr));
}

/*
Parses a format string into the following:
- fakeFormatString: a momentJS formatting string, littered with special control characters that get post-processed.
- sameUnits: for every part in fakeFormatString, if the part is a token, the value will be a unit string (like "day"),
  that indicates how similar a range's start & end must be in order to share the same formatted text.
  If not a token, then the value is null.
  Always a flat array (not nested liked "chunks").
*/
function parseFormatString(formatStr) {
	var chunks = chunkFormatString(formatStr);
	
	return {
		fakeFormatString: buildFakeFormatString(chunks),
		sameUnits: buildSameUnits(chunks)
	};
}

/*
Break the formatting string into an array of chunks.
A 'maybe' chunk will have nested chunks.
*/
function chunkFormatString(formatStr) {
	var chunks = [];
	var match;

	// TODO: more descrimination
	// \4 is a backreference to the first character of a multi-character set.
	var chunker = /\[([^\]]*)\]|\(([^\)]*)\)|(LTS|LT|(\w)\4*o?)|([^\w\[\(]+)/g;

	while ((match = chunker.exec(formatStr))) {
		if (match[1]) { // a literal string inside [ ... ]
			chunks.push.apply(chunks, // append
				splitStringLiteral(match[1])
			);
		}
		else if (match[2]) { // non-zero formatting inside ( ... )
			chunks.push({ maybe: chunkFormatString(match[2]) });
		}
		else if (match[3]) { // a formatting token
			chunks.push({ token: match[3] });
		}
		else if (match[5]) { // an unenclosed literal string
			chunks.push.apply(chunks, // append
				splitStringLiteral(match[5])
			);
		}
	}

	return chunks;
}

/*
Potentially splits a literal-text string into multiple parts. For special cases.
*/
function splitStringLiteral(s) {
	if (s === '. ') {
		return [ '.', ' ' ]; // for locales with periods bound to the end of each year/month/date
	}
	else {
		return [ s ];
	}
}

/*
Given chunks parsed from a real format string, generate a fake (aka "intermediate") format string with special control
characters that will eventually be given to moment for formatting, and then post-processed.
*/
function buildFakeFormatString(chunks) {
	var parts = [];
	var i, chunk;

	for (i = 0; i < chunks.length; i++) {
		chunk = chunks[i];

		if (typeof chunk === 'string') {
			parts.push('[' + chunk + ']');
		}
		else if (chunk.token) {
			if (chunk.token in specialTokens) {
				parts.push(
					SPECIAL_TOKEN_MARKER + // useful during post-processing
					'[' + chunk.token + ']' // preserve as literal text
				);
			}
			else {
				parts.push(chunk.token); // unprotected text implies a format string
			}
		}
		else if (chunk.maybe) {
			parts.push(
				MAYBE_MARKER + // useful during post-processing
				buildFakeFormatString(chunk.maybe) +
				MAYBE_MARKER
			);
		}
	}

	return parts.join(PART_SEPARATOR);
}

/*
Given parsed chunks from a real formatting string, generates an array of unit strings (like "day") that indicate
in which regard two dates must be similar in order to share range formatting text.
The `chunks` can be nested (because of "maybe" chunks), however, the returned array will be flat.
*/
function buildSameUnits(chunks) {
	var units = [];
	var i, chunk;
	var tokenInfo;

	for (i = 0; i < chunks.length; i++) {
		chunk = chunks[i];

		if (chunk.token) {
			tokenInfo = largeTokenMap[chunk.token.charAt(0)];
			units.push(tokenInfo ? tokenInfo.unit : 'second'); // default to a very strict same-second
		}
		else if (chunk.maybe) {
			units.push.apply(units, // append
				buildSameUnits(chunk.maybe)
			);
		}
		else {
			units.push(null);
		}
	}

	return units;
}


// Rendering to text
// ---------------------------------------------------------------------------------------------------------------------

/*
Formats a date with a fake format string, post-processes the control characters, then returns.
*/
function renderFakeFormatString(fakeFormatString, date) {
	return processMaybeMarkers(
		renderFakeFormatStringParts(fakeFormatString, date).join('')
	);
}

/*
Formats a date into parts that will have been post-processed, EXCEPT for the "maybe" markers.
*/
function renderFakeFormatStringParts(fakeFormatString, date) {
	var parts = [];
	var fakeRender = oldMomentFormat(date, fakeFormatString);
	var fakeParts = fakeRender.split(PART_SEPARATOR);
	var i, fakePart;

	for (i = 0; i < fakeParts.length; i++) {
		fakePart = fakeParts[i];

		if (fakePart.charAt(0) === SPECIAL_TOKEN_MARKER) {
			parts.push(
				// the literal string IS the token's name.
				// call special token's registered function.
				specialTokens[fakePart.substring(1)](date)
			);
		}
		else {
			parts.push(fakePart);
		}
	}

	return parts;
}

/*
Accepts an almost-finally-formatted string and processes the "maybe" control characters, returning a new string.
*/
function processMaybeMarkers(s) {
	return s.replace(MAYBE_REGEXP, function(m0, m1) { // regex assumed to have 'g' flag
		if (m1.match(/[1-9]/)) { // any non-zero numeric characters?
			return m1;
		}
		else {
			return '';
		}
	});
}


// Misc Utils
// -------------------------------------------------------------------------------------------------

/*
Returns a unit string, either 'year', 'month', 'day', or null for the most granular formatting token in the string.
*/
function queryMostGranularFormatUnit(formatStr) {
	var chunks = chunkFormatString(formatStr);
	var i, chunk;
	var candidate;
	var best;

	for (i = 0; i < chunks.length; i++) {
		chunk = chunks[i];

		if (chunk.token) {
			candidate = largeTokenMap[chunk.token.charAt(0)];
			if (candidate) {
				if (!best || candidate.value > best.value) {
					best = candidate;
				}
			}
		}
	}

	if (best) {
		return best.unit;
	}

	return null;
};

})();

// quick local references
var formatDate = FC.formatDate;
var formatRange = FC.formatRange;
var oldMomentFormat = FC.oldMomentFormat;

;;

FC.Class = Class; // export

// Class that all other classes will inherit from
function Class() { }


// Called on a class to create a subclass.
// Last argument contains instance methods. Any argument before the last are considered mixins.
Class.extend = function() {
	var len = arguments.length;
	var i;
	var members;

	for (i = 0; i < len; i++) {
		members = arguments[i];
		if (i < len - 1) { // not the last argument?
			mixIntoClass(this, members);
		}
	}

	return extendClass(this, members || {}); // members will be undefined if no arguments
};


// Adds new member variables/methods to the class's prototype.
// Can be called with another class, or a plain object hash containing new members.
Class.mixin = function(members) {
	mixIntoClass(this, members);
};


function extendClass(superClass, members) {
	var subClass;

	// ensure a constructor for the subclass, forwarding all arguments to the super-constructor if it doesn't exist
	if (hasOwnProp(members, 'constructor')) {
		subClass = members.constructor;
	}
	if (typeof subClass !== 'function') {
		subClass = members.constructor = function() {
			superClass.apply(this, arguments);
		};
	}

	// build the base prototype for the subclass, which is an new object chained to the superclass's prototype
	subClass.prototype = createObject(superClass.prototype);

	// copy each member variable/method onto the the subclass's prototype
	copyOwnProps(members, subClass.prototype);

	// copy over all class variables/methods to the subclass, such as `extend` and `mixin`
	copyOwnProps(superClass, subClass);

	return subClass;
}


function mixIntoClass(theClass, members) {
	copyOwnProps(members, theClass.prototype);
}
;;

/*
Wrap jQuery's Deferred Promise object to be slightly more Promise/A+ compliant.
With the added non-standard feature of synchronously executing handlers on resolved promises,
which doesn't always happen otherwise (esp with nested .then handlers!?),
so, this makes things a lot easier, esp because jQuery 3 changed the synchronicity for Deferred objects.

TODO: write tests and more comments
*/

function Promise(executor) {
	var deferred = $.Deferred();
	var promise = deferred.promise();

	if (typeof executor === 'function') {
		executor(
			function(value) { // resolve
				if (Promise.immediate) {
					promise._value = value;
				}
				deferred.resolve(value);
			},
			function() { // reject
				deferred.reject();
			}
		);
	}
	
	if (Promise.immediate) {
		var origThen = promise.then;

		promise.then = function(onFulfilled, onRejected) {
			var state = promise.state();
			
			if (state === 'resolved') {
				if (typeof onFulfilled === 'function') {
					return Promise.resolve(onFulfilled(promise._value));
				}
			}
			else if (state === 'rejected') {
				if (typeof onRejected === 'function') {
					onRejected();
					return promise; // already rejected
				}
			}

			return origThen.call(promise, onFulfilled, onRejected);
		};
	}

	return promise; // instanceof Promise will break :( TODO: make Promise a real class
}

FC.Promise = Promise;

Promise.immediate = true;


Promise.resolve = function(value) {
	if (value && typeof value.resolve === 'function') {
		return value.promise();
	}
	if (value && typeof value.then === 'function') {
		return value;
	}
	else {
		var deferred = $.Deferred().resolve(value);
		var promise = deferred.promise();

		if (Promise.immediate) {
			var origThen = promise.then;

			promise._value = value;

			promise.then = function(onFulfilled, onRejected) {
				if (typeof onFulfilled === 'function') {
					return Promise.resolve(onFulfilled(value));
				}
				return origThen.call(promise, onFulfilled, onRejected);
			};
		}

		return promise;
	}
};


Promise.reject = function() {
	return $.Deferred().reject().promise();
};


Promise.all = function(inputs) {
	var hasAllValues = false;
	var values;
	var i, input;

	if (Promise.immediate) {
		hasAllValues = true;
		values = [];

		for (i = 0; i < inputs.length; i++) {
			input = inputs[i];

			if (input && typeof input.state === 'function' && input.state() === 'resolved' && ('_value' in input)) {
				values.push(input._value);
			}
			else if (input && typeof input.then === 'function') {
				hasAllValues = false;
				break;
			}
			else {
				values.push(input);
			}
		}
	}

	if (hasAllValues) {
		return Promise.resolve(values);
	}
	else {
		return $.when.apply($.when, inputs).then(function() {
			return $.when($.makeArray(arguments));
		});
	}
};

;;

// TODO: write tests and clean up code

function TaskQueue(debounceWait) {
	var q = []; // array of runFuncs

	function addTask(taskFunc) {
		return new Promise(function(resolve) {

			// should run this function when it's taskFunc's turn to run.
			// responsible for popping itself off the queue.
			var runFunc = function() {
				Promise.resolve(taskFunc()) // result might be async, coerce to promise
					.then(resolve) // resolve TaskQueue::push's promise, for the caller. will receive result of taskFunc.
					.then(function() {
						q.shift(); // pop itself off

						// run the next task, if any
						if (q.length) {
							q[0]();
						}
					});
			};

			// always put the task at the end of the queue, BEFORE running the task
			q.push(runFunc);

			// if it's the only task in the queue, run immediately
			if (q.length === 1) {
				runFunc();
			}
		});
	}

	this.add = // potentially debounce, for the public method
		typeof debounceWait === 'number' ?
			debounce(addTask, debounceWait) :
			addTask; // if not a number (null/undefined/false), no debounce at all

	this.addQuickly = addTask; // guaranteed no debounce
}

FC.TaskQueue = TaskQueue;

/*
q = new TaskQueue();

function work(i) {
	return q.push(function() {
		trigger();
		console.log('work' + i);
	});
}

var cnt = 0;

function trigger() {
	if (cnt < 5) {
		cnt++;
		work(cnt);
	}
}

work(9);
*/

;;

var EmitterMixin = FC.EmitterMixin = {

	// jQuery-ification via $(this) allows a non-DOM object to have
	// the same event handling capabilities (including namespaces).


	on: function(types, handler) {
		$(this).on(types, this._prepareIntercept(handler));
		return this; // for chaining
	},


	one: function(types, handler) {
		$(this).one(types, this._prepareIntercept(handler));
		return this; // for chaining
	},


	_prepareIntercept: function(handler) {
		// handlers are always called with an "event" object as their first param.
		// sneak the `this` context and arguments into the extra parameter object
		// and forward them on to the original handler.
		var intercept = function(ev, extra) {
			return handler.apply(
				extra.context || this,
				extra.args || []
			);
		};

		// mimick jQuery's internal "proxy" system (risky, I know)
		// causing all functions with the same .guid to appear to be the same.
		// https://github.com/jquery/jquery/blob/2.2.4/src/core.js#L448
		// this is needed for calling .off with the original non-intercept handler.
		if (!handler.guid) {
			handler.guid = $.guid++;
		}
		intercept.guid = handler.guid;

		return intercept;
	},


	off: function(types, handler) {
		$(this).off(types, handler);

		return this; // for chaining
	},


	trigger: function(types) {
		var args = Array.prototype.slice.call(arguments, 1); // arguments after the first

		// pass in "extra" info to the intercept
		$(this).triggerHandler(types, { args: args });

		return this; // for chaining
	},


	triggerWith: function(types, context, args) {

		// `triggerHandler` is less reliant on the DOM compared to `trigger`.
		// pass in "extra" info to the intercept.
		$(this).triggerHandler(types, { context: context, args: args });

		return this; // for chaining
	}

};

;;

/*
Utility methods for easily listening to events on another object,
and more importantly, easily unlistening from them.
*/
var ListenerMixin = FC.ListenerMixin = (function() {
	var guid = 0;
	var ListenerMixin = {

		listenerId: null,

		/*
		Given an `other` object that has on/off methods, bind the given `callback` to an event by the given name.
		The `callback` will be called with the `this` context of the object that .listenTo is being called on.
		Can be called:
			.listenTo(other, eventName, callback)
		OR
			.listenTo(other, {
				eventName1: callback1,
				eventName2: callback2
			})
		*/
		listenTo: function(other, arg, callback) {
			if (typeof arg === 'object') { // given dictionary of callbacks
				for (var eventName in arg) {
					if (arg.hasOwnProperty(eventName)) {
						this.listenTo(other, eventName, arg[eventName]);
					}
				}
			}
			else if (typeof arg === 'string') {
				other.on(
					arg + '.' + this.getListenerNamespace(), // use event namespacing to identify this object
					$.proxy(callback, this) // always use `this` context
						// the usually-undesired jQuery guid behavior doesn't matter,
						// because we always unbind via namespace
				);
			}
		},

		/*
		Causes the current object to stop listening to events on the `other` object.
		`eventName` is optional. If omitted, will stop listening to ALL events on `other`.
		*/
		stopListeningTo: function(other, eventName) {
			other.off((eventName || '') + '.' + this.getListenerNamespace());
		},

		/*
		Returns a string, unique to this object, to be used for event namespacing
		*/
		getListenerNamespace: function() {
			if (this.listenerId == null) {
				this.listenerId = guid++;
			}
			return '_listener' + this.listenerId;
		}

	};
	return ListenerMixin;
})();
;;

/* A rectangular panel that is absolutely positioned over other content
------------------------------------------------------------------------------------------------------------------------
Options:
	- className (string)
	- content (HTML string or jQuery element set)
	- parentEl
	- top
	- left
	- right (the x coord of where the right edge should be. not a "CSS" right)
	- autoHide (boolean)
	- show (callback)
	- hide (callback)
*/

var Popover = Class.extend(ListenerMixin, {

	isHidden: true,
	options: null,
	el: null, // the container element for the popover. generated by this object
	margin: 10, // the space required between the popover and the edges of the scroll container


	constructor: function(options) {
		this.options = options || {};
	},


	// Shows the popover on the specified position. Renders it if not already
	show: function() {
		if (this.isHidden) {
			if (!this.el) {
				this.render();
			}
			this.el.show();
			this.position();
			this.isHidden = false;
			this.trigger('show');
		}
	},


	// Hides the popover, through CSS, but does not remove it from the DOM
	hide: function() {
		if (!this.isHidden) {
			this.el.hide();
			this.isHidden = true;
			this.trigger('hide');
		}
	},


	// Creates `this.el` and renders content inside of it
	render: function() {
		var _this = this;
		var options = this.options;

		this.el = $('<div class="fc-popover"/>')
			.addClass(options.className || '')
			.css({
				// position initially to the top left to avoid creating scrollbars
				top: 0,
				left: 0
			})
			.append(options.content)
			.appendTo(options.parentEl);

		// when a click happens on anything inside with a 'fc-close' className, hide the popover
		this.el.on('click', '.fc-close', function() {
			_this.hide();
		});

		if (options.autoHide) {
			this.listenTo($(document), 'mousedown', this.documentMousedown);
		}
	},


	// Triggered when the user clicks *anywhere* in the document, for the autoHide feature
	documentMousedown: function(ev) {
		// only hide the popover if the click happened outside the popover
		if (this.el && !$(ev.target).closest(this.el).length) {
			this.hide();
		}
	},


	// Hides and unregisters any handlers
	removeElement: function() {
		this.hide();

		if (this.el) {
			this.el.remove();
			this.el = null;
		}

		this.stopListeningTo($(document), 'mousedown');
	},


	// Positions the popover optimally, using the top/left/right options
	position: function() {
		var options = this.options;
		var origin = this.el.offsetParent().offset();
		var width = this.el.outerWidth();
		var height = this.el.outerHeight();
		var windowEl = $(window);
		var viewportEl = getScrollParent(this.el);
		var viewportTop;
		var viewportLeft;
		var viewportOffset;
		var top; // the "position" (not "offset") values for the popover
		var left; //

		// compute top and left
		top = options.top || 0;
		if (options.left !== undefined) {
			left = options.left;
		}
		else if (options.right !== undefined) {
			left = options.right - width; // derive the left value from the right value
		}
		else {
			left = 0;
		}

		if (viewportEl.is(window) || viewportEl.is(document)) { // normalize getScrollParent's result
			viewportEl = windowEl;
			viewportTop = 0; // the window is always at the top left
			viewportLeft = 0; // (and .offset() won't work if called here)
		}
		else {
			viewportOffset = viewportEl.offset();
			viewportTop = viewportOffset.top;
			viewportLeft = viewportOffset.left;
		}

		// if the window is scrolled, it causes the visible area to be further down
		viewportTop += windowEl.scrollTop();
		viewportLeft += windowEl.scrollLeft();

		// constrain to the view port. if constrained by two edges, give precedence to top/left
		if (options.viewportConstrain !== false) {
			top = Math.min(top, viewportTop + viewportEl.outerHeight() - height - this.margin);
			top = Math.max(top, viewportTop + this.margin);
			left = Math.min(left, viewportLeft + viewportEl.outerWidth() - width - this.margin);
			left = Math.max(left, viewportLeft + this.margin);
		}

		this.el.css({
			top: top - origin.top,
			left: left - origin.left
		});
	},


	// Triggers a callback. Calls a function in the option hash of the same name.
	// Arguments beyond the first `name` are forwarded on.
	// TODO: better code reuse for this. Repeat code
	trigger: function(name) {
		if (this.options[name]) {
			this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
	}

});

;;

/*
A cache for the left/right/top/bottom/width/height values for one or more elements.
Works with both offset (from topleft document) and position (from offsetParent).

options:
- els
- isHorizontal
- isVertical
*/
var CoordCache = FC.CoordCache = Class.extend({

	els: null, // jQuery set (assumed to be siblings)
	forcedOffsetParentEl: null, // options can override the natural offsetParent
	origin: null, // {left,top} position of offsetParent of els
	boundingRect: null, // constrain cordinates to this rectangle. {left,right,top,bottom} or null
	isHorizontal: false, // whether to query for left/right/width
	isVertical: false, // whether to query for top/bottom/height

	// arrays of coordinates (offsets from topleft of document)
	lefts: null,
	rights: null,
	tops: null,
	bottoms: null,


	constructor: function(options) {
		this.els = $(options.els);
		this.isHorizontal = options.isHorizontal;
		this.isVertical = options.isVertical;
		this.forcedOffsetParentEl = options.offsetParent ? $(options.offsetParent) : null;
	},


	// Queries the els for coordinates and stores them.
	// Call this method before using and of the get* methods below.
	build: function() {
		var offsetParentEl = this.forcedOffsetParentEl;
		if (!offsetParentEl && this.els.length > 0) {
			offsetParentEl = this.els.eq(0).offsetParent();
		}

		this.origin = offsetParentEl ?
			offsetParentEl.offset() :
			null;

		this.boundingRect = this.queryBoundingRect();

		if (this.isHorizontal) {
			this.buildElHorizontals();
		}
		if (this.isVertical) {
			this.buildElVerticals();
		}
	},


	// Destroys all internal data about coordinates, freeing memory
	clear: function() {
		this.origin = null;
		this.boundingRect = null;
		this.lefts = null;
		this.rights = null;
		this.tops = null;
		this.bottoms = null;
	},


	// When called, if coord caches aren't built, builds them
	ensureBuilt: function() {
		if (!this.origin) {
			this.build();
		}
	},


	// Populates the left/right internal coordinate arrays
	buildElHorizontals: function() {
		var lefts = [];
		var rights = [];

		this.els.each(function(i, node) {
			var el = $(node);
			var left = el.offset().left;
			var width = el.outerWidth();

			lefts.push(left);
			rights.push(left + width);
		});

		this.lefts = lefts;
		this.rights = rights;
	},


	// Populates the top/bottom internal coordinate arrays
	buildElVerticals: function() {
		var tops = [];
		var bottoms = [];

		this.els.each(function(i, node) {
			var el = $(node);
			var top = el.offset().top;
			var height = el.outerHeight();

			tops.push(top);
			bottoms.push(top + height);
		});

		this.tops = tops;
		this.bottoms = bottoms;
	},


	// Given a left offset (from document left), returns the index of the el that it horizontally intersects.
	// If no intersection is made, returns undefined.
	getHorizontalIndex: function(leftOffset) {
		this.ensureBuilt();

		var lefts = this.lefts;
		var rights = this.rights;
		var len = lefts.length;
		var i;

		for (i = 0; i < len; i++) {
			if (leftOffset >= lefts[i] && leftOffset < rights[i]) {
				return i;
			}
		}
	},


	// Given a top offset (from document top), returns the index of the el that it vertically intersects.
	// If no intersection is made, returns undefined.
	getVerticalIndex: function(topOffset) {
		this.ensureBuilt();

		var tops = this.tops;
		var bottoms = this.bottoms;
		var len = tops.length;
		var i;

		for (i = 0; i < len; i++) {
			if (topOffset >= tops[i] && topOffset < bottoms[i]) {
				return i;
			}
		}
	},


	// Gets the left offset (from document left) of the element at the given index
	getLeftOffset: function(leftIndex) {
		this.ensureBuilt();
		return this.lefts[leftIndex];
	},


	// Gets the left position (from offsetParent left) of the element at the given index
	getLeftPosition: function(leftIndex) {
		this.ensureBuilt();
		return this.lefts[leftIndex] - this.origin.left;
	},


	// Gets the right offset (from document left) of the element at the given index.
	// This value is NOT relative to the document's right edge, like the CSS concept of "right" would be.
	getRightOffset: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex];
	},


	// Gets the right position (from offsetParent left) of the element at the given index.
	// This value is NOT relative to the offsetParent's right edge, like the CSS concept of "right" would be.
	getRightPosition: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex] - this.origin.left;
	},


	// Gets the width of the element at the given index
	getWidth: function(leftIndex) {
		this.ensureBuilt();
		return this.rights[leftIndex] - this.lefts[leftIndex];
	},


	// Gets the top offset (from document top) of the element at the given index
	getTopOffset: function(topIndex) {
		this.ensureBuilt();
		return this.tops[topIndex];
	},


	// Gets the top position (from offsetParent top) of the element at the given position
	getTopPosition: function(topIndex) {
		this.ensureBuilt();
		return this.tops[topIndex] - this.origin.top;
	},

	// Gets the bottom offset (from the document top) of the element at the given index.
	// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
	getBottomOffset: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex];
	},


	// Gets the bottom position (from the offsetParent top) of the element at the given index.
	// This value is NOT relative to the offsetParent's bottom edge, like the CSS concept of "bottom" would be.
	getBottomPosition: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex] - this.origin.top;
	},


	// Gets the height of the element at the given index
	getHeight: function(topIndex) {
		this.ensureBuilt();
		return this.bottoms[topIndex] - this.tops[topIndex];
	},


	// Bounding Rect
	// TODO: decouple this from CoordCache

	// Compute and return what the elements' bounding rectangle is, from the user's perspective.
	// Right now, only returns a rectangle if constrained by an overflow:scroll element.
	// Returns null if there are no elements
	queryBoundingRect: function() {
		var scrollParentEl;

		if (this.els.length > 0) {
			scrollParentEl = getScrollParent(this.els.eq(0));

			if (!scrollParentEl.is(document)) {
				return getClientRect(scrollParentEl);
			}
		}

		return null;
	},

	isPointInBounds: function(leftOffset, topOffset) {
		return this.isLeftInBounds(leftOffset) && this.isTopInBounds(topOffset);
	},

	isLeftInBounds: function(leftOffset) {
		return !this.boundingRect || (leftOffset >= this.boundingRect.left && leftOffset < this.boundingRect.right);
	},

	isTopInBounds: function(topOffset) {
		return !this.boundingRect || (topOffset >= this.boundingRect.top && topOffset < this.boundingRect.bottom);
	}

});

;;

/* Tracks a drag's mouse movement, firing various handlers
----------------------------------------------------------------------------------------------------------------------*/
// TODO: use Emitter

var DragListener = FC.DragListener = Class.extend(ListenerMixin, {

	options: null,
	subjectEl: null,

	// coordinates of the initial mousedown
	originX: null,
	originY: null,

	// the wrapping element that scrolls, or MIGHT scroll if there's overflow.
	// TODO: do this for wrappers that have overflow:hidden as well.
	scrollEl: null,

	isInteracting: false,
	isDistanceSurpassed: false,
	isDelayEnded: false,
	isDragging: false,
	isTouch: false,
	isGeneric: false, // initiated by 'dragstart' (jqui)

	delay: null,
	delayTimeoutId: null,
	minDistance: null,

	shouldCancelTouchScroll: true,
	scrollAlwaysKills: false,


	constructor: function(options) {
		this.options = options || {};
	},


	// Interaction (high-level)
	// -----------------------------------------------------------------------------------------------------------------


	startInteraction: function(ev, extraOptions) {

		if (ev.type === 'mousedown') {
			if (GlobalEmitter.get().shouldIgnoreMouse()) {
				return;
			}
			else if (!isPrimaryMouseButton(ev)) {
				return;
			}
			else {
				ev.preventDefault(); // prevents native selection in most browsers
			}
		}

		if (!this.isInteracting) {

			// process options
			extraOptions = extraOptions || {};
			this.delay = firstDefined(extraOptions.delay, this.options.delay, 0);
			this.minDistance = firstDefined(extraOptions.distance, this.options.distance, 0);
			this.subjectEl = this.options.subjectEl;

			preventSelection($('body'));

			this.isInteracting = true;
			this.isTouch = getEvIsTouch(ev);
			this.isGeneric = ev.type === 'dragstart';
			this.isDelayEnded = false;
			this.isDistanceSurpassed = false;

			this.originX = getEvX(ev);
			this.originY = getEvY(ev);
			this.scrollEl = getScrollParent($(ev.target));

			this.bindHandlers();
			this.initAutoScroll();
			this.handleInteractionStart(ev);
			this.startDelay(ev);

			if (!this.minDistance) {
				this.handleDistanceSurpassed(ev);
			}
		}
	},


	handleInteractionStart: function(ev) {
		this.trigger('interactionStart', ev);
	},


	endInteraction: function(ev, isCancelled) {
		if (this.isInteracting) {
			this.endDrag(ev);

			if (this.delayTimeoutId) {
				clearTimeout(this.delayTimeoutId);
				this.delayTimeoutId = null;
			}

			this.destroyAutoScroll();
			this.unbindHandlers();

			this.isInteracting = false;
			this.handleInteractionEnd(ev, isCancelled);

			allowSelection($('body'));
		}
	},


	handleInteractionEnd: function(ev, isCancelled) {
		this.trigger('interactionEnd', ev, isCancelled || false);
	},


	// Binding To DOM
	// -----------------------------------------------------------------------------------------------------------------


	bindHandlers: function() {
		// some browsers (Safari in iOS 10) don't allow preventDefault on touch events that are bound after touchstart,
		// so listen to the GlobalEmitter singleton, which is always bound, instead of the document directly.
		var globalEmitter = GlobalEmitter.get();

		if (this.isGeneric) {
			this.listenTo($(document), { // might only work on iOS because of GlobalEmitter's bind :(
				drag: this.handleMove,
				dragstop: this.endInteraction
			});
		}
		else if (this.isTouch) {
			this.listenTo(globalEmitter, {
				touchmove: this.handleTouchMove,
				touchend: this.endInteraction,
				scroll: this.handleTouchScroll
			});
		}
		else {
			this.listenTo(globalEmitter, {
				mousemove: this.handleMouseMove,
				mouseup: this.endInteraction
			});
		}

		this.listenTo(globalEmitter, {
			selectstart: preventDefault, // don't allow selection while dragging
			contextmenu: preventDefault // long taps would open menu on Chrome dev tools
		});
	},


	unbindHandlers: function() {
		this.stopListeningTo(GlobalEmitter.get());
		this.stopListeningTo($(document)); // for isGeneric
	},


	// Drag (high-level)
	// -----------------------------------------------------------------------------------------------------------------


	// extraOptions ignored if drag already started
	startDrag: function(ev, extraOptions) {
		this.startInteraction(ev, extraOptions); // ensure interaction began

		if (!this.isDragging) {
			this.isDragging = true;
			this.handleDragStart(ev);
		}
	},


	handleDragStart: function(ev) {
		this.trigger('dragStart', ev);
	},


	handleMove: function(ev) {
		var dx = getEvX(ev) - this.originX;
		var dy = getEvY(ev) - this.originY;
		var minDistance = this.minDistance;
		var distanceSq; // current distance from the origin, squared

		if (!this.isDistanceSurpassed) {
			distanceSq = dx * dx + dy * dy;
			if (distanceSq >= minDistance * minDistance) { // use pythagorean theorem
				this.handleDistanceSurpassed(ev);
			}
		}

		if (this.isDragging) {
			this.handleDrag(dx, dy, ev);
		}
	},


	// Called while the mouse is being moved and when we know a legitimate drag is taking place
	handleDrag: function(dx, dy, ev) {
		this.trigger('drag', dx, dy, ev);
		this.updateAutoScroll(ev); // will possibly cause scrolling
	},


	endDrag: function(ev) {
		if (this.isDragging) {
			this.isDragging = false;
			this.handleDragEnd(ev);
		}
	},


	handleDragEnd: function(ev) {
		this.trigger('dragEnd', ev);
	},


	// Delay
	// -----------------------------------------------------------------------------------------------------------------


	startDelay: function(initialEv) {
		var _this = this;

		if (this.delay) {
			this.delayTimeoutId = setTimeout(function() {
				_this.handleDelayEnd(initialEv);
			}, this.delay);
		}
		else {
			this.handleDelayEnd(initialEv);
		}
	},


	handleDelayEnd: function(initialEv) {
		this.isDelayEnded = true;

		if (this.isDistanceSurpassed) {
			this.startDrag(initialEv);
		}
	},


	// Distance
	// -----------------------------------------------------------------------------------------------------------------


	handleDistanceSurpassed: function(ev) {
		this.isDistanceSurpassed = true;

		if (this.isDelayEnded) {
			this.startDrag(ev);
		}
	},


	// Mouse / Touch
	// -----------------------------------------------------------------------------------------------------------------


	handleTouchMove: function(ev) {

		// prevent inertia and touchmove-scrolling while dragging
		if (this.isDragging && this.shouldCancelTouchScroll) {
			ev.preventDefault();
		}

		this.handleMove(ev);
	},


	handleMouseMove: function(ev) {
		this.handleMove(ev);
	},


	// Scrolling (unrelated to auto-scroll)
	// -----------------------------------------------------------------------------------------------------------------


	handleTouchScroll: function(ev) {
		// if the drag is being initiated by touch, but a scroll happens before
		// the drag-initiating delay is over, cancel the drag
		if (!this.isDragging || this.scrollAlwaysKills) {
			this.endInteraction(ev, true); // isCancelled=true
		}
	},


	// Utils
	// -----------------------------------------------------------------------------------------------------------------


	// Triggers a callback. Calls a function in the option hash of the same name.
	// Arguments beyond the first `name` are forwarded on.
	trigger: function(name) {
		if (this.options[name]) {
			this.options[name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
		// makes _methods callable by event name. TODO: kill this
		if (this['_' + name]) {
			this['_' + name].apply(this, Array.prototype.slice.call(arguments, 1));
		}
	}


});

;;
/*
this.scrollEl is set in DragListener
*/
DragListener.mixin({

	isAutoScroll: false,

	scrollBounds: null, // { top, bottom, left, right }
	scrollTopVel: null, // pixels per second
	scrollLeftVel: null, // pixels per second
	scrollIntervalId: null, // ID of setTimeout for scrolling animation loop

	// defaults
	scrollSensitivity: 30, // pixels from edge for scrolling to start
	scrollSpeed: 200, // pixels per second, at maximum speed
	scrollIntervalMs: 50, // millisecond wait between scroll increment


	initAutoScroll: function() {
		var scrollEl = this.scrollEl;

		this.isAutoScroll =
			this.options.scroll &&
			scrollEl &&
			!scrollEl.is(window) &&
			!scrollEl.is(document);

		if (this.isAutoScroll) {
			// debounce makes sure rapid calls don't happen
			this.listenTo(scrollEl, 'scroll', debounce(this.handleDebouncedScroll, 100));
		}
	},


	destroyAutoScroll: function() {
		this.endAutoScroll(); // kill any animation loop

		// remove the scroll handler if there is a scrollEl
		if (this.isAutoScroll) {
			this.stopListeningTo(this.scrollEl, 'scroll'); // will probably get removed by unbindHandlers too :(
		}
	},


	// Computes and stores the bounding rectangle of scrollEl
	computeScrollBounds: function() {
		if (this.isAutoScroll) {
			this.scrollBounds = getOuterRect(this.scrollEl);
			// TODO: use getClientRect in future. but prevents auto scrolling when on top of scrollbars
		}
	},


	// Called when the dragging is in progress and scrolling should be updated
	updateAutoScroll: function(ev) {
		var sensitivity = this.scrollSensitivity;
		var bounds = this.scrollBounds;
		var topCloseness, bottomCloseness;
		var leftCloseness, rightCloseness;
		var topVel = 0;
		var leftVel = 0;

		if (bounds) { // only scroll if scrollEl exists

			// compute closeness to edges. valid range is from 0.0 - 1.0
			topCloseness = (sensitivity - (getEvY(ev) - bounds.top)) / sensitivity;
			bottomCloseness = (sensitivity - (bounds.bottom - getEvY(ev))) / sensitivity;
			leftCloseness = (sensitivity - (getEvX(ev) - bounds.left)) / sensitivity;
			rightCloseness = (sensitivity - (bounds.right - getEvX(ev))) / sensitivity;

			// translate vertical closeness into velocity.
			// mouse must be completely in bounds for velocity to happen.
			if (topCloseness >= 0 && topCloseness <= 1) {
				topVel = topCloseness * this.scrollSpeed * -1; // negative. for scrolling up
			}
			else if (bottomCloseness >= 0 && bottomCloseness <= 1) {
				topVel = bottomCloseness * this.scrollSpeed;
			}

			// translate horizontal closeness into velocity
			if (leftCloseness >= 0 && leftCloseness <= 1) {
				leftVel = leftCloseness * this.scrollSpeed * -1; // negative. for scrolling left
			}
			else if (rightCloseness >= 0 && rightCloseness <= 1) {
				leftVel = rightCloseness * this.scrollSpeed;
			}
		}

		this.setScrollVel(topVel, leftVel);
	},


	// Sets the speed-of-scrolling for the scrollEl
	setScrollVel: function(topVel, leftVel) {

		this.scrollTopVel = topVel;
		this.scrollLeftVel = leftVel;

		this.constrainScrollVel(); // massages into realistic values

		// if there is non-zero velocity, and an animation loop hasn't already started, then START
		if ((this.scrollTopVel || this.scrollLeftVel) && !this.scrollIntervalId) {
			this.scrollIntervalId = setInterval(
				proxy(this, 'scrollIntervalFunc'), // scope to `this`
				this.scrollIntervalMs
			);
		}
	},


	// Forces scrollTopVel and scrollLeftVel to be zero if scrolling has already gone all the way
	constrainScrollVel: function() {
		var el = this.scrollEl;

		if (this.scrollTopVel < 0) { // scrolling up?
			if (el.scrollTop() <= 0) { // already scrolled all the way up?
				this.scrollTopVel = 0;
			}
		}
		else if (this.scrollTopVel > 0) { // scrolling down?
			if (el.scrollTop() + el[0].clientHeight >= el[0].scrollHeight) { // already scrolled all the way down?
				this.scrollTopVel = 0;
			}
		}

		if (this.scrollLeftVel < 0) { // scrolling left?
			if (el.scrollLeft() <= 0) { // already scrolled all the left?
				this.scrollLeftVel = 0;
			}
		}
		else if (this.scrollLeftVel > 0) { // scrolling right?
			if (el.scrollLeft() + el[0].clientWidth >= el[0].scrollWidth) { // already scrolled all the way right?
				this.scrollLeftVel = 0;
			}
		}
	},


	// This function gets called during every iteration of the scrolling animation loop
	scrollIntervalFunc: function() {
		var el = this.scrollEl;
		var frac = this.scrollIntervalMs / 1000; // considering animation frequency, what the vel should be mult'd by

		// change the value of scrollEl's scroll
		if (this.scrollTopVel) {
			el.scrollTop(el.scrollTop() + this.scrollTopVel * frac);
		}
		if (this.scrollLeftVel) {
			el.scrollLeft(el.scrollLeft() + this.scrollLeftVel * frac);
		}

		this.constrainScrollVel(); // since the scroll values changed, recompute the velocities

		// if scrolled all the way, which causes the vels to be zero, stop the animation loop
		if (!this.scrollTopVel && !this.scrollLeftVel) {
			this.endAutoScroll();
		}
	},


	// Kills any existing scrolling animation loop
	endAutoScroll: function() {
		if (this.scrollIntervalId) {
			clearInterval(this.scrollIntervalId);
			this.scrollIntervalId = null;

			this.handleScrollEnd();
		}
	},


	// Get called when the scrollEl is scrolled (NOTE: this is delayed via debounce)
	handleDebouncedScroll: function() {
		// recompute all coordinates, but *only* if this is *not* part of our scrolling animation
		if (!this.scrollIntervalId) {
			this.handleScrollEnd();
		}
	},


	// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
	handleScrollEnd: function() {
	}

});
;;

/* Tracks mouse movements over a component and raises events about which hit the mouse is over.
------------------------------------------------------------------------------------------------------------------------
options:
- subjectEl
- subjectCenter
*/

var HitDragListener = DragListener.extend({

	component: null, // converts coordinates to hits
		// methods: hitsNeeded, hitsNotNeeded, queryHit

	origHit: null, // the hit the mouse was over when listening started
	hit: null, // the hit the mouse is over
	coordAdjust: null, // delta that will be added to the mouse coordinates when computing collisions


	constructor: function(component, options) {
		DragListener.call(this, options); // call the super-constructor

		this.component = component;
	},


	// Called when drag listening starts (but a real drag has not necessarily began).
	// ev might be undefined if dragging was started manually.
	handleInteractionStart: function(ev) {
		var subjectEl = this.subjectEl;
		var subjectRect;
		var origPoint;
		var point;

		this.component.hitsNeeded();
		this.computeScrollBounds(); // for autoscroll

		if (ev) {
			origPoint = { left: getEvX(ev), top: getEvY(ev) };
			point = origPoint;

			// constrain the point to bounds of the element being dragged
			if (subjectEl) {
				subjectRect = getOuterRect(subjectEl); // used for centering as well
				point = constrainPoint(point, subjectRect);
			}

			this.origHit = this.queryHit(point.left, point.top);

			// treat the center of the subject as the collision point?
			if (subjectEl && this.options.subjectCenter) {

				// only consider the area the subject overlaps the hit. best for large subjects.
				// TODO: skip this if hit didn't supply left/right/top/bottom
				if (this.origHit) {
					subjectRect = intersectRects(this.origHit, subjectRect) ||
						subjectRect; // in case there is no intersection
				}

				point = getRectCenter(subjectRect);
			}

			this.coordAdjust = diffPoints(point, origPoint); // point - origPoint
		}
		else {
			this.origHit = null;
			this.coordAdjust = null;
		}

		// call the super-method. do it after origHit has been computed
		DragListener.prototype.handleInteractionStart.apply(this, arguments);
	},


	// Called when the actual drag has started
	handleDragStart: function(ev) {
		var hit;

		DragListener.prototype.handleDragStart.apply(this, arguments); // call the super-method

		// might be different from this.origHit if the min-distance is large
		hit = this.queryHit(getEvX(ev), getEvY(ev));

		// report the initial hit the mouse is over
		// especially important if no min-distance and drag starts immediately
		if (hit) {
			this.handleHitOver(hit);
		}
	},


	// Called when the drag moves
	handleDrag: function(dx, dy, ev) {
		var hit;

		DragListener.prototype.handleDrag.apply(this, arguments); // call the super-method

		hit = this.queryHit(getEvX(ev), getEvY(ev));

		if (!isHitsEqual(hit, this.hit)) { // a different hit than before?
			if (this.hit) {
				this.handleHitOut();
			}
			if (hit) {
				this.handleHitOver(hit);
			}
		}
	},


	// Called when dragging has been stopped
	handleDragEnd: function() {
		this.handleHitDone();
		DragListener.prototype.handleDragEnd.apply(this, arguments); // call the super-method
	},


	// Called when a the mouse has just moved over a new hit
	handleHitOver: function(hit) {
		var isOrig = isHitsEqual(hit, this.origHit);

		this.hit = hit;

		this.trigger('hitOver', this.hit, isOrig, this.origHit);
	},


	// Called when the mouse has just moved out of a hit
	handleHitOut: function() {
		if (this.hit) {
			this.trigger('hitOut', this.hit);
			this.handleHitDone();
			this.hit = null;
		}
	},


	// Called after a hitOut. Also called before a dragStop
	handleHitDone: function() {
		if (this.hit) {
			this.trigger('hitDone', this.hit);
		}
	},


	// Called when the interaction ends, whether there was a real drag or not
	handleInteractionEnd: function() {
		DragListener.prototype.handleInteractionEnd.apply(this, arguments); // call the super-method

		this.origHit = null;
		this.hit = null;

		this.component.hitsNotNeeded();
	},


	// Called when scrolling has stopped, whether through auto scroll, or the user scrolling
	handleScrollEnd: function() {
		DragListener.prototype.handleScrollEnd.apply(this, arguments); // call the super-method

		// hits' absolute positions will be in new places after a user's scroll.
		// HACK for recomputing.
		if (this.isDragging) {
			this.component.releaseHits();
			this.component.prepareHits();
		}
	},


	// Gets the hit underneath the coordinates for the given mouse event
	queryHit: function(left, top) {

		if (this.coordAdjust) {
			left += this.coordAdjust.left;
			top += this.coordAdjust.top;
		}

		return this.component.queryHit(left, top);
	}

});


// Returns `true` if the hits are identically equal. `false` otherwise. Must be from the same component.
// Two null values will be considered equal, as two "out of the component" states are the same.
function isHitsEqual(hit0, hit1) {

	if (!hit0 && !hit1) {
		return true;
	}

	if (hit0 && hit1) {
		return hit0.component === hit1.component &&
			isHitPropsWithin(hit0, hit1) &&
			isHitPropsWithin(hit1, hit0); // ensures all props are identical
	}

	return false;
}


// Returns true if all of subHit's non-standard properties are within superHit
function isHitPropsWithin(subHit, superHit) {
	for (var propName in subHit) {
		if (!/^(component|left|right|top|bottom)$/.test(propName)) {
			if (subHit[propName] !== superHit[propName]) {
				return false;
			}
		}
	}
	return true;
}

;;

/*
Listens to document and window-level user-interaction events, like touch events and mouse events,
and fires these events as-is to whoever is observing a GlobalEmitter.
Best when used as a singleton via GlobalEmitter.get()

Normalizes mouse/touch events. For examples:
- ignores the the simulated mouse events that happen after a quick tap: mousemove+mousedown+mouseup+click
- compensates for various buggy scenarios where a touchend does not fire
*/

FC.touchMouseIgnoreWait = 500;

var GlobalEmitter = Class.extend(ListenerMixin, EmitterMixin, {

	isTouching: false,
	mouseIgnoreDepth: 0,
	handleScrollProxy: null,


	bind: function() {
		var _this = this;

		this.listenTo($(document), {
			touchstart: this.handleTouchStart,
			touchcancel: this.handleTouchCancel,
			touchend: this.handleTouchEnd,
			mousedown: this.handleMouseDown,
			mousemove: this.handleMouseMove,
			mouseup: this.handleMouseUp,
			click: this.handleClick,
			selectstart: this.handleSelectStart,
			contextmenu: this.handleContextMenu
		});

		// because we need to call preventDefault
		// because https://www.chromestatus.com/features/5093566007214080
		// TODO: investigate performance because this is a global handler
		window.addEventListener(
			'touchmove',
			this.handleTouchMoveProxy = function(ev) {
				_this.handleTouchMove($.Event(ev));
			},
			{ passive: false } // allows preventDefault()
		);

		// attach a handler to get called when ANY scroll action happens on the page.
		// this was impossible to do with normal on/off because 'scroll' doesn't bubble.
		// http://stackoverflow.com/a/32954565/96342
		window.addEventListener(
			'scroll',
			this.handleScrollProxy = function(ev) {
				_this.handleScroll($.Event(ev));
			},
			true // useCapture
		);
	},

	unbind: function() {
		this.stopListeningTo($(document));

		window.removeEventListener(
			'touchmove',
			this.handleTouchMoveProxy
		);

		window.removeEventListener(
			'scroll',
			this.handleScrollProxy,
			true // useCapture
		);
	},


	// Touch Handlers
	// -----------------------------------------------------------------------------------------------------------------

	handleTouchStart: function(ev) {

		// if a previous touch interaction never ended with a touchend, then implicitly end it,
		// but since a new touch interaction is about to begin, don't start the mouse ignore period.
		this.stopTouch(ev, true); // skipMouseIgnore=true

		this.isTouching = true;
		this.trigger('touchstart', ev);
	},

	handleTouchMove: function(ev) {
		if (this.isTouching) {
			this.trigger('touchmove', ev);
		}
	},

	handleTouchCancel: function(ev) {
		if (this.isTouching) {
			this.trigger('touchcancel', ev);

			// Have touchcancel fire an artificial touchend. That way, handlers won't need to listen to both.
			// If touchend fires later, it won't have any effect b/c isTouching will be false.
			this.stopTouch(ev);
		}
	},

	handleTouchEnd: function(ev) {
		this.stopTouch(ev);
	},


	// Mouse Handlers
	// -----------------------------------------------------------------------------------------------------------------

	handleMouseDown: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('mousedown', ev);
		}
	},

	handleMouseMove: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('mousemove', ev);
		}
	},

	handleMouseUp: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('mouseup', ev);
		}
	},

	handleClick: function(ev) {
		if (!this.shouldIgnoreMouse()) {
			this.trigger('click', ev);
		}
	},


	// Misc Handlers
	// -----------------------------------------------------------------------------------------------------------------

	handleSelectStart: function(ev) {
		this.trigger('selectstart', ev);
	},

	handleContextMenu: function(ev) {
		this.trigger('contextmenu', ev);
	},

	handleScroll: function(ev) {
		this.trigger('scroll', ev);
	},


	// Utils
	// -----------------------------------------------------------------------------------------------------------------

	stopTouch: function(ev, skipMouseIgnore) {
		if (this.isTouching) {
			this.isTouching = false;
			this.trigger('touchend', ev);

			if (!skipMouseIgnore) {
				this.startTouchMouseIgnore();
			}
		}
	},

	startTouchMouseIgnore: function() {
		var _this = this;
		var wait = FC.touchMouseIgnoreWait;

		if (wait) {
			this.mouseIgnoreDepth++;
			setTimeout(function() {
				_this.mouseIgnoreDepth--;
			}, wait);
		}
	},

	shouldIgnoreMouse: function() {
		return this.isTouching || Boolean(this.mouseIgnoreDepth);
	}

});


// Singleton
// ---------------------------------------------------------------------------------------------------------------------

(function() {
	var globalEmitter = null;
	var neededCount = 0;


	// gets the singleton
	GlobalEmitter.get = function() {

		if (!globalEmitter) {
			globalEmitter = new GlobalEmitter();
			globalEmitter.bind();
		}

		return globalEmitter;
	};


	// called when an object knows it will need a GlobalEmitter in the near future.
	GlobalEmitter.needed = function() {
		GlobalEmitter.get(); // ensures globalEmitter
		neededCount++;
	};


	// called when the object that originally called needed() doesn't need a GlobalEmitter anymore.
	GlobalEmitter.unneeded = function() {
		neededCount--;

		if (!neededCount) { // nobody else needs it
			globalEmitter.unbind();
			globalEmitter = null;
		}
	};

})();

;;

/* Creates a clone of an element and lets it track the mouse as it moves
----------------------------------------------------------------------------------------------------------------------*/

var MouseFollower = Class.extend(ListenerMixin, {

	options: null,

	sourceEl: null, // the element that will be cloned and made to look like it is dragging
	el: null, // the clone of `sourceEl` that will track the mouse
	parentEl: null, // the element that `el` (the clone) will be attached to

	// the initial position of el, relative to the offset parent. made to match the initial offset of sourceEl
	top0: null,
	left0: null,

	// the absolute coordinates of the initiating touch/mouse action
	y0: null,
	x0: null,

	// the number of pixels the mouse has moved from its initial position
	topDelta: null,
	leftDelta: null,

	isFollowing: false,
	isHidden: false,
	isAnimating: false, // doing the revert animation?

	constructor: function(sourceEl, options) {
		this.options = options = options || {};
		this.sourceEl = sourceEl;
		this.parentEl = options.parentEl ? $(options.parentEl) : sourceEl.parent(); // default to sourceEl's parent
	},


	// Causes the element to start following the mouse
	start: function(ev) {
		if (!this.isFollowing) {
			this.isFollowing = true;

			this.y0 = getEvY(ev);
			this.x0 = getEvX(ev);
			this.topDelta = 0;
			this.leftDelta = 0;

			if (!this.isHidden) {
				this.updatePosition();
			}

			if (getEvIsTouch(ev)) {
				this.listenTo($(document), 'touchmove', this.handleMove);
			}
			else {
				this.listenTo($(document), 'mousemove', this.handleMove);
			}
		}
	},


	// Causes the element to stop following the mouse. If shouldRevert is true, will animate back to original position.
	// `callback` gets invoked when the animation is complete. If no animation, it is invoked immediately.
	stop: function(shouldRevert, callback) {
		var _this = this;
		var revertDuration = this.options.revertDuration;

		function complete() { // might be called by .animate(), which might change `this` context
			_this.isAnimating = false;
			_this.removeElement();

			_this.top0 = _this.left0 = null; // reset state for future updatePosition calls

			if (callback) {
				callback();
			}
		}

		if (this.isFollowing && !this.isAnimating) { // disallow more than one stop animation at a time
			this.isFollowing = false;

			this.stopListeningTo($(document));

			if (shouldRevert && revertDuration && !this.isHidden) { // do a revert animation?
				this.isAnimating = true;
				this.el.animate({
					top: this.top0,
					left: this.left0
				}, {
					duration: revertDuration,
					complete: complete
				});
			}
			else {
				complete();
			}
		}
	},


	// Gets the tracking element. Create it if necessary
	getEl: function() {
		var el = this.el;

		if (!el) {
			el = this.el = this.sourceEl.clone()
				.addClass(this.options.additionalClass || '')
				.css({
					position: 'absolute',
					visibility: '', // in case original element was hidden (commonly through hideEvents())
					display: this.isHidden ? 'none' : '', // for when initially hidden
					margin: 0,
					right: 'auto', // erase and set width instead
					bottom: 'auto', // erase and set height instead
					width: this.sourceEl.width(), // explicit height in case there was a 'right' value
					height: this.sourceEl.height(), // explicit width in case there was a 'bottom' value
					opacity: this.options.opacity || '',
					zIndex: this.options.zIndex
				});

			// we don't want long taps or any mouse interaction causing selection/menus.
			// would use preventSelection(), but that prevents selectstart, causing problems.
			el.addClass('fc-unselectable');

			el.appendTo(this.parentEl);
		}

		return el;
	},


	// Removes the tracking element if it has already been created
	removeElement: function() {
		if (this.el) {
			this.el.remove();
			this.el = null;
		}
	},


	// Update the CSS position of the tracking element
	updatePosition: function() {
		var sourceOffset;
		var origin;

		this.getEl(); // ensure this.el

		// make sure origin info was computed
		if (this.top0 === null) {
			sourceOffset = this.sourceEl.offset();
			origin = this.el.offsetParent().offset();
			this.top0 = sourceOffset.top - origin.top;
			this.left0 = sourceOffset.left - origin.left;
		}

		this.el.css({
			top: this.top0 + this.topDelta,
			left: this.left0 + this.leftDelta
		});
	},


	// Gets called when the user moves the mouse
	handleMove: function(ev) {
		this.topDelta = getEvY(ev) - this.y0;
		this.leftDelta = getEvX(ev) - this.x0;

		if (!this.isHidden) {
			this.updatePosition();
		}
	},


	// Temporarily makes the tracking element invisible. Can be called before following starts
	hide: function() {
		if (!this.isHidden) {
			this.isHidden = true;
			if (this.el) {
				this.el.hide();
			}
		}
	},


	// Show the tracking element after it has been temporarily hidden
	show: function() {
		if (this.isHidden) {
			this.isHidden = false;
			this.updatePosition();
			this.getEl().show();
		}
	}

});

;;

/* An abstract class comprised of a "grid" of areas that each represent a specific datetime
----------------------------------------------------------------------------------------------------------------------*/

var Grid = FC.Grid = Class.extend(ListenerMixin, {

	// self-config, overridable by subclasses
	hasDayInteractions: true, // can user click/select ranges of time?

	view: null, // a View object
	isRTL: null, // shortcut to the view's isRTL option

	start: null,
	end: null,

	el: null, // the containing element
	elsByFill: null, // a hash of jQuery element sets used for rendering each fill. Keyed by fill name.

	// derived from options
	eventTimeFormat: null,
	displayEventTime: null,
	displayEventEnd: null,

	minResizeDuration: null, // TODO: hack. set by subclasses. minumum event resize duration

	// if defined, holds the unit identified (ex: "year" or "month") that determines the level of granularity
	// of the date areas. if not defined, assumes to be day and time granularity.
	// TODO: port isTimeScale into same system?
	largeUnit: null,

	dayClickListener: null,
	daySelectListener: null,
	segDragListener: null,
	segResizeListener: null,
	externalDragListener: null,


	constructor: function(view) {
		this.view = view;
		this.isRTL = view.opt('isRTL');
		this.elsByFill = {};

		this.dayClickListener = this.buildDayClickListener();
		this.daySelectListener = this.buildDaySelectListener();
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Generates the format string used for event time text, if not explicitly defined by 'timeFormat'
	computeEventTimeFormat: function() {
		return this.view.opt('smallTimeFormat');
	},


	// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventTime'.
	// Only applies to non-all-day events.
	computeDisplayEventTime: function() {
		return true;
	},


	// Determines whether events should have their end times displayed, if not explicitly defined by 'displayEventEnd'
	computeDisplayEventEnd: function() {
		return true;
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	// Tells the grid about what period of time to display.
	// Any date-related internal data should be generated.
	setRange: function(range) {
		this.start = range.start.clone();
		this.end = range.end.clone();

		this.rangeUpdated();
		this.processRangeOptions();
	},


	// Called when internal variables that rely on the range should be updated
	rangeUpdated: function() {
	},


	// Updates values that rely on options and also relate to range
	processRangeOptions: function() {
		var view = this.view;
		var displayEventTime;
		var displayEventEnd;

		this.eventTimeFormat =
			view.opt('eventTimeFormat') ||
			view.opt('timeFormat') || // deprecated
			this.computeEventTimeFormat();

		displayEventTime = view.opt('displayEventTime');
		if (displayEventTime == null) {
			displayEventTime = this.computeDisplayEventTime(); // might be based off of range
		}

		displayEventEnd = view.opt('displayEventEnd');
		if (displayEventEnd == null) {
			displayEventEnd = this.computeDisplayEventEnd(); // might be based off of range
		}

		this.displayEventTime = displayEventTime;
		this.displayEventEnd = displayEventEnd;
	},


	// Converts a span (has unzoned start/end and any other grid-specific location information)
	// into an array of segments (pieces of events whose format is decided by the grid).
	spanToSegs: function(span) {
		// subclasses must implement
	},


	// Diffs the two dates, returning a duration, based on granularity of the grid
	// TODO: port isTimeScale into this system?
	diffDates: function(a, b) {
		if (this.largeUnit) {
			return diffByUnit(a, b, this.largeUnit);
		}
		else {
			return diffDayTime(a, b);
		}
	},


	/* Hit Area
	------------------------------------------------------------------------------------------------------------------*/

	hitsNeededDepth: 0, // necessary because multiple callers might need the same hits

	hitsNeeded: function() {
		if (!(this.hitsNeededDepth++)) {
			this.prepareHits();
		}
	},

	hitsNotNeeded: function() {
		if (this.hitsNeededDepth && !(--this.hitsNeededDepth)) {
			this.releaseHits();
		}
	},


	// Called before one or more queryHit calls might happen. Should prepare any cached coordinates for queryHit
	prepareHits: function() {
	},


	// Called when queryHit calls have subsided. Good place to clear any coordinate caches.
	releaseHits: function() {
	},


	// Given coordinates from the topleft of the document, return data about the date-related area underneath.
	// Can return an object with arbitrary properties (although top/right/left/bottom are encouraged).
	// Must have a `grid` property, a reference to this current grid. TODO: avoid this
	// The returned object will be processed by getHitSpan and getHitEl.
	queryHit: function(leftOffset, topOffset) {
	},


	// like getHitSpan, but returns null if the resulting span's range is invalid
	getSafeHitSpan: function(hit) {
		var hitSpan = this.getHitSpan(hit);

		if (!isRangeWithinRange(hitSpan, this.view.activeRange)) {
			return null;
		}

		return hitSpan;
	},


	// Given position-level information about a date-related area within the grid,
	// should return an object with at least a start/end date. Can provide other information as well.
	getHitSpan: function(hit) {
	},


	// Given position-level information about a date-related area within the grid,
	// should return a jQuery element that best represents it. passed to dayClick callback.
	getHitEl: function(hit) {
	},


	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Sets the container element that the grid should render inside of.
	// Does other DOM-related initializations.
	setElement: function(el) {
		this.el = el;

		if (this.hasDayInteractions) {
			preventSelection(el);

			this.bindDayHandler('touchstart', this.dayTouchStart);
			this.bindDayHandler('mousedown', this.dayMousedown);
		}

		// attach event-element-related handlers. in Grid.events
		// same garbage collection note as above.
		this.bindSegHandlers();

		this.bindGlobalHandlers();
	},


	bindDayHandler: function(name, handler) {
		var _this = this;

		// attach a handler to the grid's root element.
		// jQuery will take care of unregistering them when removeElement gets called.
		this.el.on(name, function(ev) {
			if (
				!$(ev.target).is(
					_this.segSelector + ',' + // directly on an event element
					_this.segSelector + ' *,' + // within an event element
					'.fc-more,' + // a "more.." link
					'a[data-goto]' // a clickable nav link
				)
			) {
				return handler.call(_this, ev);
			}
		});
	},


	// Removes the grid's container element from the DOM. Undoes any other DOM-related attachments.
	// DOES NOT remove any content beforehand (doesn't clear events or call unrenderDates), unlike View
	removeElement: function() {
		this.unbindGlobalHandlers();
		this.clearDragListeners();

		this.el.remove();

		// NOTE: we don't null-out this.el for the same reasons we don't do it within View::removeElement
	},


	// Renders the basic structure of grid view before any content is rendered
	renderSkeleton: function() {
		// subclasses should implement
	},


	// Renders the grid's date-related content (like areas that represent days/times).
	// Assumes setRange has already been called and the skeleton has already been rendered.
	renderDates: function() {
		// subclasses should implement
	},


	// Unrenders the grid's date-related content
	unrenderDates: function() {
		// subclasses should implement
	},


	/* Handlers
	------------------------------------------------------------------------------------------------------------------*/


	// Binds DOM handlers to elements that reside outside the grid, such as the document
	bindGlobalHandlers: function() {
		this.listenTo($(document), {
			dragstart: this.externalDragStart, // jqui
			sortstart: this.externalDragStart // jqui
		});
	},


	// Unbinds DOM handlers from elements that reside outside the grid
	unbindGlobalHandlers: function() {
		this.stopListeningTo($(document));
	},


	// Process a mousedown on an element that represents a day. For day clicking and selecting.
	dayMousedown: function(ev) {
		var view = this.view;

		// HACK
		// This will still work even though bindDayHandler doesn't use GlobalEmitter.
		if (GlobalEmitter.get().shouldIgnoreMouse()) {
			return;
		}

		this.dayClickListener.startInteraction(ev);

		if (view.opt('selectable')) {
			this.daySelectListener.startInteraction(ev, {
				distance: view.opt('selectMinDistance')
			});
		}
	},


	dayTouchStart: function(ev) {
		var view = this.view;
		var selectLongPressDelay;

		// On iOS (and Android?) when a new selection is initiated overtop another selection,
		// the touchend never fires because the elements gets removed mid-touch-interaction (my theory).
		// HACK: simply don't allow this to happen.
		// ALSO: prevent selection when an *event* is already raised.
		if (view.isSelected || view.selectedEvent) {
			return;
		}

		selectLongPressDelay = view.opt('selectLongPressDelay');
		if (selectLongPressDelay == null) {
			selectLongPressDelay = view.opt('longPressDelay'); // fallback
		}

		this.dayClickListener.startInteraction(ev);

		if (view.opt('selectable')) {
			this.daySelectListener.startInteraction(ev, {
				delay: selectLongPressDelay
			});
		}
	},


	// Creates a listener that tracks the user's drag across day elements, for day clicking.
	buildDayClickListener: function() {
		var _this = this;
		var view = this.view;
		var dayClickHit; // null if invalid dayClick

		var dragListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			interactionStart: function() {
				dayClickHit = dragListener.origHit;
			},
			hitOver: function(hit, isOrig, origHit) {
				// if user dragged to another cell at any point, it can no longer be a dayClick
				if (!isOrig) {
					dayClickHit = null;
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				dayClickHit = null;
			},
			interactionEnd: function(ev, isCancelled) {
				var hitSpan;

				if (!isCancelled && dayClickHit) {
					hitSpan = _this.getSafeHitSpan(dayClickHit);

					if (hitSpan) {
						view.triggerDayClick(hitSpan, _this.getHitEl(dayClickHit), ev);
					}
				}
			}
		});

		// because dayClickListener won't be called with any time delay, "dragging" will begin immediately,
		// which will kill any touchmoving/scrolling. Prevent this.
		dragListener.shouldCancelTouchScroll = false;

		dragListener.scrollAlwaysKills = true;

		return dragListener;
	},


	// Creates a listener that tracks the user's drag across day elements, for day selecting.
	buildDaySelectListener: function() {
		var _this = this;
		var view = this.view;
		var selectionSpan; // null if invalid selection

		var dragListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			interactionStart: function() {
				selectionSpan = null;
			},
			dragStart: function() {
				view.unselect(); // since we could be rendering a new selection, we want to clear any old one
			},
			hitOver: function(hit, isOrig, origHit) {
				var origHitSpan;
				var hitSpan;

				if (origHit) { // click needs to have started on a hit

					origHitSpan = _this.getSafeHitSpan(origHit);
					hitSpan = _this.getSafeHitSpan(hit);

					if (origHitSpan && hitSpan) {
						selectionSpan = _this.computeSelection(origHitSpan, hitSpan);
					}
					else {
						selectionSpan = null;
					}

					if (selectionSpan) {
						_this.renderSelection(selectionSpan);
					}
					else if (selectionSpan === false) {
						disableCursor();
					}
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				selectionSpan = null;
				_this.unrenderSelection();
			},
			hitDone: function() { // called after a hitOut OR before a dragEnd
				enableCursor();
			},
			interactionEnd: function(ev, isCancelled) {
				if (!isCancelled && selectionSpan) {
					// the selection will already have been rendered. just report it
					view.reportSelection(selectionSpan, ev);
				}
			}
		});

		return dragListener;
	},


	// Kills all in-progress dragging.
	// Useful for when public API methods that result in re-rendering are invoked during a drag.
	// Also useful for when touch devices misbehave and don't fire their touchend.
	clearDragListeners: function() {
		this.dayClickListener.endInteraction();
		this.daySelectListener.endInteraction();

		if (this.segDragListener) {
			this.segDragListener.endInteraction(); // will clear this.segDragListener
		}
		if (this.segResizeListener) {
			this.segResizeListener.endInteraction(); // will clear this.segResizeListener
		}
		if (this.externalDragListener) {
			this.externalDragListener.endInteraction(); // will clear this.externalDragListener
		}
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: should probably move this to Grid.events, like we did event dragging / resizing


	// Renders a mock event at the given event location, which contains zoned start/end properties.
	// Returns all mock event elements.
	renderEventLocationHelper: function(eventLocation, sourceSeg) {
		var fakeEvent = this.fabricateHelperEvent(eventLocation, sourceSeg);

		return this.renderHelper(fakeEvent, sourceSeg); // do the actual rendering
	},


	// Builds a fake event given zoned event date properties and a segment is should be inspired from.
	// The range's end can be null, in which case the mock event that is rendered will have a null end time.
	// `sourceSeg` is the internal segment object involved in the drag. If null, something external is dragging.
	fabricateHelperEvent: function(eventLocation, sourceSeg) {
		var fakeEvent = sourceSeg ? createObject(sourceSeg.event) : {}; // mask the original event object if possible

		fakeEvent.start = eventLocation.start.clone();
		fakeEvent.end = eventLocation.end ? eventLocation.end.clone() : null;
		fakeEvent.allDay = null; // force it to be freshly computed by normalizeEventDates
		this.view.calendar.normalizeEventDates(fakeEvent);

		// this extra className will be useful for differentiating real events from mock events in CSS
		fakeEvent.className = (fakeEvent.className || []).concat('fc-helper');

		// if something external is being dragged in, don't render a resizer
		if (!sourceSeg) {
			fakeEvent.editable = false;
		}

		return fakeEvent;
	},


	// Renders a mock event. Given zoned event date properties.
	// Must return all mock event elements.
	renderHelper: function(eventLocation, sourceSeg) {
		// subclasses must implement
	},


	// Unrenders a mock event
	unrenderHelper: function() {
		// subclasses must implement
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection. Will highlight by default but can be overridden by subclasses.
	// Given a span (unzoned start/end and other misc data)
	renderSelection: function(span) {
		this.renderHighlight(span);
	},


	// Unrenders any visual indications of a selection. Will unrender a highlight by default.
	unrenderSelection: function() {
		this.unrenderHighlight();
	},


	// Given the first and last date-spans of a selection, returns another date-span object.
	// Subclasses can override and provide additional data in the span object. Will be passed to renderSelection().
	// Will return false if the selection is invalid and this should be indicated to the user.
	// Will return null/undefined if a selection invalid but no error should be reported.
	computeSelection: function(span0, span1) {
		var span = this.computeSelectionSpan(span0, span1);

		if (span && !this.view.calendar.isSelectionSpanAllowed(span)) {
			return false;
		}

		return span;
	},


	// Given two spans, must return the combination of the two.
	// TODO: do this separation of concerns (combining VS validation) for event dnd/resize too.
	computeSelectionSpan: function(span0, span1) {
		var dates = [ span0.start, span0.end, span1.start, span1.end ];

		dates.sort(compareNumbers); // sorts chronologically. works with Moments

		return { start: dates[0].clone(), end: dates[3].clone() };
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	// Renders an emphasis on the given date range. Given a span (unzoned start/end and other misc data)
	renderHighlight: function(span) {
		this.renderFill('highlight', this.spanToSegs(span));
	},


	// Unrenders the emphasis on a date range
	unrenderHighlight: function() {
		this.unrenderFill('highlight');
	},


	// Generates an array of classNames for rendering the highlight. Used by the fill system.
	highlightSegClasses: function() {
		return [ 'fc-highlight' ];
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
	},


	unrenderBusinessHours: function() {
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
	},


	renderNowIndicator: function(date) {
	},


	unrenderNowIndicator: function() {
	},


	/* Fill System (highlight, background events, business hours)
	--------------------------------------------------------------------------------------------------------------------
	TODO: remove this system. like we did in TimeGrid
	*/


	// Renders a set of rectangles over the given segments of time.
	// MUST RETURN a subset of segs, the segs that were actually rendered.
	// Responsible for populating this.elsByFill. TODO: better API for expressing this requirement
	renderFill: function(type, segs) {
		// subclasses must implement
	},


	// Unrenders a specific type of fill that is currently rendered on the grid
	unrenderFill: function(type) {
		var el = this.elsByFill[type];

		if (el) {
			el.remove();
			delete this.elsByFill[type];
		}
	},


	// Renders and assigns an `el` property for each fill segment. Generic enough to work with different types.
	// Only returns segments that successfully rendered.
	// To be harnessed by renderFill (implemented by subclasses).
	// Analagous to renderFgSegEls.
	renderFillSegEls: function(type, segs) {
		var _this = this;
		var segElMethod = this[type + 'SegEl'];
		var html = '';
		var renderedSegs = [];
		var i;

		if (segs.length) {

			// build a large concatenation of segment HTML
			for (i = 0; i < segs.length; i++) {
				html += this.fillSegHtml(type, segs[i]);
			}

			// Grab individual elements from the combined HTML string. Use each as the default rendering.
			// Then, compute the 'el' for each segment.
			$(html).each(function(i, node) {
				var seg = segs[i];
				var el = $(node);

				// allow custom filter methods per-type
				if (segElMethod) {
					el = segElMethod.call(_this, seg, el);
				}

				if (el) { // custom filters did not cancel the render
					el = $(el); // allow custom filter to return raw DOM node

					// correct element type? (would be bad if a non-TD were inserted into a table for example)
					if (el.is(_this.fillSegTag)) {
						seg.el = el;
						renderedSegs.push(seg);
					}
				}
			});
		}

		return renderedSegs;
	},


	fillSegTag: 'div', // subclasses can override


	// Builds the HTML needed for one fill segment. Generic enough to work with different types.
	fillSegHtml: function(type, seg) {

		// custom hooks per-type
		var classesMethod = this[type + 'SegClasses'];
		var cssMethod = this[type + 'SegCss'];

		var classes = classesMethod ? classesMethod.call(this, seg) : [];
		var css = cssToStr(cssMethod ? cssMethod.call(this, seg) : {});

		return '<' + this.fillSegTag +
			(classes.length ? ' class="' + classes.join(' ') + '"' : '') +
			(css ? ' style="' + css + '"' : '') +
			' />';
	},



	/* Generic rendering utilities for subclasses
	------------------------------------------------------------------------------------------------------------------*/


	// Computes HTML classNames for a single-day element
	getDayClasses: function(date, noThemeHighlight) {
		var view = this.view;
		var classes = [];
		var today;

		if (!isDateWithinRange(date, view.activeRange)) {
			classes.push('fc-disabled-day'); // TODO: jQuery UI theme?
		}
		else {
			classes.push('fc-' + dayIDs[date.day()]);

			if (
				view.currentRangeAs('months') == 1 && // TODO: somehow get into MonthView
				date.month() != view.currentRange.start.month()
			) {
				classes.push('fc-other-month');
			}

			today = view.calendar.getNow();

			if (date.isSame(today, 'day')) {
				classes.push('fc-today');

				if (noThemeHighlight !== true) {
					classes.push(view.highlightStateClass);
				}
			}
			else if (date < today) {
				classes.push('fc-past');
			}
			else {
				classes.push('fc-future');
			}
		}

		return classes;
	}

});

;;

/* Event-rendering and event-interaction methods for the abstract Grid class
----------------------------------------------------------------------------------------------------------------------

Data Types:
	event - { title, id, start, (end), whatever }
	location - { start, (end), allDay }
	rawEventRange - { start, end }
	eventRange - { start, end, isStart, isEnd }
	eventSpan - { start, end, isStart, isEnd, whatever }
	eventSeg - { event, whatever }
	seg - { whatever }
*/

Grid.mixin({

	// self-config, overridable by subclasses
	segSelector: '.fc-event-container > *', // what constitutes an event element?

	mousedOverSeg: null, // the segment object the user's mouse is over. null if over nothing
	isDraggingSeg: false, // is a segment being dragged? boolean
	isResizingSeg: false, // is a segment being resized? boolean
	isDraggingExternal: false, // jqui-dragging an external element? boolean
	segs: null, // the *event* segments currently rendered in the grid. TODO: rename to `eventSegs`


	// Renders the given events onto the grid
	renderEvents: function(events) {
		var bgEvents = [];
		var fgEvents = [];
		var i;

		for (i = 0; i < events.length; i++) {
			(isBgEvent(events[i]) ? bgEvents : fgEvents).push(events[i]);
		}

		this.segs = [].concat( // record all segs
			this.renderBgEvents(bgEvents),
			this.renderFgEvents(fgEvents)
		);
	},


	renderBgEvents: function(events) {
		var segs = this.eventsToSegs(events);

		// renderBgSegs might return a subset of segs, segs that were actually rendered
		return this.renderBgSegs(segs) || segs;
	},


	renderFgEvents: function(events) {
		var segs = this.eventsToSegs(events);

		// renderFgSegs might return a subset of segs, segs that were actually rendered
		return this.renderFgSegs(segs) || segs;
	},


	// Unrenders all events currently rendered on the grid
	unrenderEvents: function() {
		this.handleSegMouseout(); // trigger an eventMouseout if user's mouse is over an event
		this.clearDragListeners();

		this.unrenderFgSegs();
		this.unrenderBgSegs();

		this.segs = null;
	},


	// Retrieves all rendered segment objects currently rendered on the grid
	getEventSegs: function() {
		return this.segs || [];
	},


	/* Foreground Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders foreground event segments onto the grid. May return a subset of segs that were rendered.
	renderFgSegs: function(segs) {
		// subclasses must implement
	},


	// Unrenders all currently rendered foreground segments
	unrenderFgSegs: function() {
		// subclasses must implement
	},


	// Renders and assigns an `el` property for each foreground event segment.
	// Only returns segments that successfully rendered.
	// A utility that subclasses may use.
	renderFgSegEls: function(segs, disableResizing) {
        var view = this.view;
		var html = '';
		var renderedSegs = [];
		var i;

		if (segs.length) { // don't build an empty html string

			// build a large concatenation of event segment HTML
			for (i = 0; i < segs.length; i++) {
				html += this.fgSegHtml(segs[i], disableResizing);
			}

            // Grab individual elements from the combined HTML string. Use each as the default rendering.
			// Then, compute the 'el' for each segment. An el might be null if the eventRender callback returned false.
			$(html).each(function(i, node) {
            	var seg = segs[i];
                var el = view.resolveEventEl(seg.event, $(node));

                if (el) {
                    el.data('fc-seg', seg); // used by handlers
                    seg.el = el;
                    renderedSegs.push(seg);
                }
            });
		}

		return renderedSegs;
	},


	// Generates the HTML for the default rendering of a foreground event segment. Used by renderFgSegEls()
	fgSegHtml: function(seg, disableResizing) {
		// subclasses should implement
	},


	/* Background Segment Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the given background event segments onto the grid.
	// Returns a subset of the segs that were actually rendered.
	renderBgSegs: function(segs) {
		return this.renderFill('bgEvent', segs);
	},


	// Unrenders all the currently rendered background event segments
	unrenderBgSegs: function() {
		this.unrenderFill('bgEvent');
	},


	// Renders a background event element, given the default rendering. Called by the fill system.
	bgEventSegEl: function(seg, el) {
		return this.view.resolveEventEl(seg.event, el); // will filter through eventRender
	},


	// Generates an array of classNames to be used for the default rendering of a background event.
	// Called by fillSegHtml.
	bgEventSegClasses: function(seg) {
		var event = seg.event;
		var source = event.source || {};

		return [ 'fc-bgevent' ].concat(
			event.className,
			source.className || []
		);
	},


	// Generates a semicolon-separated CSS string to be used for the default rendering of a background event.
	// Called by fillSegHtml.
	bgEventSegCss: function(seg) {
		return {
			'background-color': this.getSegSkinCss(seg)['background-color']
		};
	},


	// Generates an array of classNames to be used for the rendering business hours overlay. Called by the fill system.
	// Called by fillSegHtml.
	businessHoursSegClasses: function(seg) {
		return [ 'fc-nonbusiness', 'fc-bgevent' ];
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	// Compute business hour segs for the grid's current date range.
	// Caller must ask if whole-day business hours are needed.
	// If no `businessHours` configuration value is specified, assumes the calendar default.
	buildBusinessHourSegs: function(wholeDay, businessHours) {
		return this.eventsToSegs(
			this.buildBusinessHourEvents(wholeDay, businessHours)
		);
	},


	// Compute business hour *events* for the grid's current date range.
	// Caller must ask if whole-day business hours are needed.
	// If no `businessHours` configuration value is specified, assumes the calendar default.
	buildBusinessHourEvents: function(wholeDay, businessHours) {
		var calendar = this.view.calendar;
		var events;

		if (businessHours == null) {
			// fallback
			// access from calendawr. don't access from view. doesn't update with dynamic options.
			businessHours = calendar.options.businessHours;
		}

		events = calendar.computeBusinessHourEvents(wholeDay, businessHours);

		// HACK. Eventually refactor business hours "events" system.
		// If no events are given, but businessHours is activated, this means the entire visible range should be
		// marked as *not* business-hours, via inverse-background rendering.
		if (!events.length && businessHours) {
			events = [
				$.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, {
					start: this.view.activeRange.end, // guaranteed out-of-range
					end: this.view.activeRange.end,   // "
					dow: null
				})
			];
		}

		return events;
	},


	/* Handlers
	------------------------------------------------------------------------------------------------------------------*/


	// Attaches event-element-related handlers for *all* rendered event segments of the view.
	bindSegHandlers: function() {
		this.bindSegHandlersToEl(this.el);
	},


	// Attaches event-element-related handlers to an arbitrary container element. leverages bubbling.
	bindSegHandlersToEl: function(el) {
		this.bindSegHandlerToEl(el, 'touchstart', this.handleSegTouchStart);
		this.bindSegHandlerToEl(el, 'mouseenter', this.handleSegMouseover);
		this.bindSegHandlerToEl(el, 'mouseleave', this.handleSegMouseout);
		this.bindSegHandlerToEl(el, 'mousedown', this.handleSegMousedown);
		this.bindSegHandlerToEl(el, 'click', this.handleSegClick);
	},


	// Executes a handler for any a user-interaction on a segment.
	// Handler gets called with (seg, ev), and with the `this` context of the Grid
	bindSegHandlerToEl: function(el, name, handler) {
		var _this = this;

		el.on(name, this.segSelector, function(ev) {
			var seg = $(this).data('fc-seg'); // grab segment data. put there by View::renderEvents

			// only call the handlers if there is not a drag/resize in progress
			if (seg && !_this.isDraggingSeg && !_this.isResizingSeg) {
				return handler.call(_this, seg, ev); // context will be the Grid
			}
		});
	},


	handleSegClick: function(seg, ev) {
		var res = this.view.publiclyTrigger('eventClick', seg.el[0], seg.event, ev); // can return `false` to cancel
		if (res === false) {
			ev.preventDefault();
		}
	},


	// Updates internal state and triggers handlers for when an event element is moused over
	handleSegMouseover: function(seg, ev) {
		if (
			!GlobalEmitter.get().shouldIgnoreMouse() &&
			!this.mousedOverSeg
		) {
			this.mousedOverSeg = seg;
			if (this.view.isEventResizable(seg.event)) {
				seg.el.addClass('fc-allow-mouse-resize');
			}
			this.view.publiclyTrigger('eventMouseover', seg.el[0], seg.event, ev);
		}
	},


	// Updates internal state and triggers handlers for when an event element is moused out.
	// Can be given no arguments, in which case it will mouseout the segment that was previously moused over.
	handleSegMouseout: function(seg, ev) {
		ev = ev || {}; // if given no args, make a mock mouse event

		if (this.mousedOverSeg) {
			seg = seg || this.mousedOverSeg; // if given no args, use the currently moused-over segment
			this.mousedOverSeg = null;
			if (this.view.isEventResizable(seg.event)) {
				seg.el.removeClass('fc-allow-mouse-resize');
			}
			this.view.publiclyTrigger('eventMouseout', seg.el[0], seg.event, ev);
		}
	},


	handleSegMousedown: function(seg, ev) {
		var isResizing = this.startSegResize(seg, ev, { distance: 5 });

		if (!isResizing && this.view.isEventDraggable(seg.event)) {
			this.buildSegDragListener(seg)
				.startInteraction(ev, {
					distance: 5
				});
		}
	},


	handleSegTouchStart: function(seg, ev) {
		var view = this.view;
		var event = seg.event;
		var isSelected = view.isEventSelected(event);
		var isDraggable = view.isEventDraggable(event);
		var isResizable = view.isEventResizable(event);
		var isResizing = false;
		var dragListener;
		var eventLongPressDelay;

		if (isSelected && isResizable) {
			// only allow resizing of the event is selected
			isResizing = this.startSegResize(seg, ev);
		}

		if (!isResizing && (isDraggable || isResizable)) { // allowed to be selected?

			eventLongPressDelay = view.opt('eventLongPressDelay');
			if (eventLongPressDelay == null) {
				eventLongPressDelay = view.opt('longPressDelay'); // fallback
			}

			dragListener = isDraggable ?
				this.buildSegDragListener(seg) :
				this.buildSegSelectListener(seg); // seg isn't draggable, but still needs to be selected

			dragListener.startInteraction(ev, { // won't start if already started
				delay: isSelected ? 0 : eventLongPressDelay // do delay if not already selected
			});
		}
	},


	// returns boolean whether resizing actually started or not.
	// assumes the seg allows resizing.
	// `dragOptions` are optional.
	startSegResize: function(seg, ev, dragOptions) {
		if ($(ev.target).is('.fc-resizer')) {
			this.buildSegResizeListener(seg, $(ev.target).is('.fc-start-resizer'))
				.startInteraction(ev, dragOptions);
			return true;
		}
		return false;
	},



	/* Event Dragging
	------------------------------------------------------------------------------------------------------------------*/


	// Builds a listener that will track user-dragging on an event segment.
	// Generic enough to work with any type of Grid.
	// Has side effect of setting/unsetting `segDragListener`
	buildSegDragListener: function(seg) {
		var _this = this;
		var view = this.view;
		var el = seg.el;
		var event = seg.event;
		var isDragging;
		var mouseFollower; // A clone of the original element that will move with the mouse
		var dropLocation; // zoned event date properties

		if (this.segDragListener) {
			return this.segDragListener;
		}

		// Tracks mouse movement over the *view's* coordinate map. Allows dragging and dropping between subcomponents
		// of the view.
		var dragListener = this.segDragListener = new HitDragListener(view, {
			scroll: view.opt('dragScroll'),
			subjectEl: el,
			subjectCenter: true,
			interactionStart: function(ev) {
				seg.component = _this; // for renderDrag
				isDragging = false;
				mouseFollower = new MouseFollower(seg.el, {
					additionalClass: 'fc-dragging',
					parentEl: view.el,
					opacity: dragListener.isTouch ? null : view.opt('dragOpacity'),
					revertDuration: view.opt('dragRevertDuration'),
					zIndex: 2 // one above the .fc-view
				});
				mouseFollower.hide(); // don't show until we know this is a real drag
				mouseFollower.start(ev);
			},
			dragStart: function(ev) {
				if (dragListener.isTouch && !view.isEventSelected(event)) {
					// if not previously selected, will fire after a delay. then, select the event
					view.selectEvent(event);
				}
				isDragging = true;
				_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
				_this.segDragStart(seg, ev);
				view.hideEvent(event); // hide all event segments. our mouseFollower will take over
			},
			hitOver: function(hit, isOrig, origHit) {
				var isAllowed = true;
				var origHitSpan;
				var hitSpan;
				var dragHelperEls;

				// starting hit could be forced (DayGrid.limit)
				if (seg.hit) {
					origHit = seg.hit;
				}

				// hit might not belong to this grid, so query origin grid
				origHitSpan = origHit.component.getSafeHitSpan(origHit);
				hitSpan = hit.component.getSafeHitSpan(hit);

				if (origHitSpan && hitSpan) {
					dropLocation = _this.computeEventDrop(origHitSpan, hitSpan, event);
					isAllowed = dropLocation && _this.isEventLocationAllowed(dropLocation, event);
				}
				else {
					isAllowed = false;
				}

				if (!isAllowed) {
					dropLocation = null;
					disableCursor();
				}

				// if a valid drop location, have the subclass render a visual indication
				if (dropLocation && (dragHelperEls = view.renderDrag(dropLocation, seg))) {

					dragHelperEls.addClass('fc-dragging');
					if (!dragListener.isTouch) {
						_this.applyDragOpacity(dragHelperEls);
					}

					mouseFollower.hide(); // if the subclass is already using a mock event "helper", hide our own
				}
				else {
					mouseFollower.show(); // otherwise, have the helper follow the mouse (no snapping)
				}

				if (isOrig) {
					dropLocation = null; // needs to have moved hits to be a valid drop
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				view.unrenderDrag(); // unrender whatever was done in renderDrag
				mouseFollower.show(); // show in case we are moving out of all hits
				dropLocation = null;
			},
			hitDone: function() { // Called after a hitOut OR before a dragEnd
				enableCursor();
			},
			interactionEnd: function(ev) {
				delete seg.component; // prevent side effects

				// do revert animation if hasn't changed. calls a callback when finished (whether animation or not)
				mouseFollower.stop(!dropLocation, function() {
					if (isDragging) {
						view.unrenderDrag();
						_this.segDragStop(seg, ev);
					}

					if (dropLocation) {
						// no need to re-show original, will rerender all anyways. esp important if eventRenderWait
						view.reportSegDrop(seg, dropLocation, _this.largeUnit, el, ev);
					}
					else {
						view.showEvent(event);
					}
				});
				_this.segDragListener = null;
			}
		});

		return dragListener;
	},


	// seg isn't draggable, but let's use a generic DragListener
	// simply for the delay, so it can be selected.
	// Has side effect of setting/unsetting `segDragListener`
	buildSegSelectListener: function(seg) {
		var _this = this;
		var view = this.view;
		var event = seg.event;

		if (this.segDragListener) {
			return this.segDragListener;
		}

		var dragListener = this.segDragListener = new DragListener({
			dragStart: function(ev) {
				if (dragListener.isTouch && !view.isEventSelected(event)) {
					// if not previously selected, will fire after a delay. then, select the event
					view.selectEvent(event);
				}
			},
			interactionEnd: function(ev) {
				_this.segDragListener = null;
			}
		});

		return dragListener;
	},


	// Called before event segment dragging starts
	segDragStart: function(seg, ev) {
		this.isDraggingSeg = true;
		this.view.publiclyTrigger('eventDragStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Called after event segment dragging stops
	segDragStop: function(seg, ev) {
		this.isDraggingSeg = false;
		this.view.publiclyTrigger('eventDragStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Given the spans an event drag began, and the span event was dropped, calculates the new zoned start/end/allDay
	// values for the event. Subclasses may override and set additional properties to be used by renderDrag.
	// A falsy returned value indicates an invalid drop.
	// DOES NOT consider overlap/constraint.
	computeEventDrop: function(startSpan, endSpan, event) {
		var calendar = this.view.calendar;
		var dragStart = startSpan.start;
		var dragEnd = endSpan.start;
		var delta;
		var dropLocation; // zoned event date properties

		if (dragStart.hasTime() === dragEnd.hasTime()) {
			delta = this.diffDates(dragEnd, dragStart);

			// if an all-day event was in a timed area and it was dragged to a different time,
			// guarantee an end and adjust start/end to have times
			if (event.allDay && durationHasTime(delta)) {
				dropLocation = {
					start: event.start.clone(),
					end: calendar.getEventEnd(event), // will be an ambig day
					allDay: false // for normalizeEventTimes
				};
				calendar.normalizeEventTimes(dropLocation);
			}
			// othewise, work off existing values
			else {
				dropLocation = pluckEventDateProps(event);
			}

			dropLocation.start.add(delta);
			if (dropLocation.end) {
				dropLocation.end.add(delta);
			}
		}
		else {
			// if switching from day <-> timed, start should be reset to the dropped date, and the end cleared
			dropLocation = {
				start: dragEnd.clone(),
				end: null, // end should be cleared
				allDay: !dragEnd.hasTime()
			};
		}

		return dropLocation;
	},


	// Utility for apply dragOpacity to a jQuery set
	applyDragOpacity: function(els) {
		var opacity = this.view.opt('dragOpacity');

		if (opacity != null) {
			els.css('opacity', opacity);
		}
	},


	/* External Element Dragging
	------------------------------------------------------------------------------------------------------------------*/


	// Called when a jQuery UI drag is initiated anywhere in the DOM
	externalDragStart: function(ev, ui) {
		var view = this.view;
		var el;
		var accept;

		if (view.opt('droppable')) { // only listen if this setting is on
			el = $((ui ? ui.item : null) || ev.target);

			// Test that the dragged element passes the dropAccept selector or filter function.
			// FYI, the default is "*" (matches all)
			accept = view.opt('dropAccept');
			if ($.isFunction(accept) ? accept.call(el[0], el) : el.is(accept)) {
				if (!this.isDraggingExternal) { // prevent double-listening if fired twice
					this.listenToExternalDrag(el, ev, ui);
				}
			}
		}
	},


	// Called when a jQuery UI drag starts and it needs to be monitored for dropping
	listenToExternalDrag: function(el, ev, ui) {
		var _this = this;
		var view = this.view;
		var meta = getDraggedElMeta(el); // extra data about event drop, including possible event to create
		var dropLocation; // a null value signals an unsuccessful drag

		// listener that tracks mouse movement over date-associated pixel regions
		var dragListener = _this.externalDragListener = new HitDragListener(this, {
			interactionStart: function() {
				_this.isDraggingExternal = true;
			},
			hitOver: function(hit) {
				var isAllowed = true;
				var hitSpan = hit.component.getSafeHitSpan(hit); // hit might not belong to this grid

				if (hitSpan) {
					dropLocation = _this.computeExternalDrop(hitSpan, meta);
					isAllowed = dropLocation && _this.isExternalLocationAllowed(dropLocation, meta.eventProps);
				}
				else {
					isAllowed = false;
				}

				if (!isAllowed) {
					dropLocation = null;
					disableCursor();
				}

				if (dropLocation) {
					_this.renderDrag(dropLocation); // called without a seg parameter
				}
			},
			hitOut: function() {
				dropLocation = null; // signal unsuccessful
			},
			hitDone: function() { // Called after a hitOut OR before a dragEnd
				enableCursor();
				_this.unrenderDrag();
			},
			interactionEnd: function(ev) {
				if (dropLocation) { // element was dropped on a valid hit
					view.reportExternalDrop(meta, dropLocation, el, ev, ui);
				}
				_this.isDraggingExternal = false;
				_this.externalDragListener = null;
			}
		});

		dragListener.startDrag(ev); // start listening immediately
	},


	// Given a hit to be dropped upon, and misc data associated with the jqui drag (guaranteed to be a plain object),
	// returns the zoned start/end dates for the event that would result from the hypothetical drop. end might be null.
	// Returning a null value signals an invalid drop hit.
	// DOES NOT consider overlap/constraint.
	computeExternalDrop: function(span, meta) {
		var calendar = this.view.calendar;
		var dropLocation = {
			start: calendar.applyTimezone(span.start), // simulate a zoned event start date
			end: null
		};

		// if dropped on an all-day span, and element's metadata specified a time, set it
		if (meta.startTime && !dropLocation.start.hasTime()) {
			dropLocation.start.time(meta.startTime);
		}

		if (meta.duration) {
			dropLocation.end = dropLocation.start.clone().add(meta.duration);
		}

		return dropLocation;
	},



	/* Drag Rendering (for both events and an external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event or external element being dragged.
	// `dropLocation` contains hypothetical start/end/allDay values the event would have if dropped. end can be null.
	// `seg` is the internal segment object that is being dragged. If dragging an external element, `seg` is null.
	// A truthy returned value indicates this method has rendered a helper element.
	// Must return elements used for any mock events.
	renderDrag: function(dropLocation, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event or external element being dragged
	unrenderDrag: function() {
		// subclasses must implement
	},


	/* Resizing
	------------------------------------------------------------------------------------------------------------------*/


	// Creates a listener that tracks the user as they resize an event segment.
	// Generic enough to work with any type of Grid.
	buildSegResizeListener: function(seg, isStart) {
		var _this = this;
		var view = this.view;
		var calendar = view.calendar;
		var el = seg.el;
		var event = seg.event;
		var eventEnd = calendar.getEventEnd(event);
		var isDragging;
		var resizeLocation; // zoned event date properties. falsy if invalid resize

		// Tracks mouse movement over the *grid's* coordinate map
		var dragListener = this.segResizeListener = new HitDragListener(this, {
			scroll: view.opt('dragScroll'),
			subjectEl: el,
			interactionStart: function() {
				isDragging = false;
			},
			dragStart: function(ev) {
				isDragging = true;
				_this.handleSegMouseout(seg, ev); // ensure a mouseout on the manipulated event has been reported
				_this.segResizeStart(seg, ev);
			},
			hitOver: function(hit, isOrig, origHit) {
				var isAllowed = true;
				var origHitSpan = _this.getSafeHitSpan(origHit);
				var hitSpan = _this.getSafeHitSpan(hit);

				if (origHitSpan && hitSpan) {
					resizeLocation = isStart ?
						_this.computeEventStartResize(origHitSpan, hitSpan, event) :
						_this.computeEventEndResize(origHitSpan, hitSpan, event);

					isAllowed = resizeLocation && _this.isEventLocationAllowed(resizeLocation, event);
				}
				else {
					isAllowed = false;
				}

				if (!isAllowed) {
					resizeLocation = null;
					disableCursor();
				}
				else {
					if (
						resizeLocation.start.isSame(event.start.clone().stripZone()) &&
						resizeLocation.end.isSame(eventEnd.clone().stripZone())
					) {
						// no change. (FYI, event dates might have zones)
						resizeLocation = null;
					}
				}

				if (resizeLocation) {
					view.hideEvent(event);
					_this.renderEventResize(resizeLocation, seg);
				}
			},
			hitOut: function() { // called before mouse moves to a different hit OR moved out of all hits
				resizeLocation = null;
				view.showEvent(event); // for when out-of-bounds. show original
			},
			hitDone: function() { // resets the rendering to show the original event
				_this.unrenderEventResize();
				enableCursor();
			},
			interactionEnd: function(ev) {
				if (isDragging) {
					_this.segResizeStop(seg, ev);
				}

				if (resizeLocation) { // valid date to resize to?
					// no need to re-show original, will rerender all anyways. esp important if eventRenderWait
					view.reportSegResize(seg, resizeLocation, _this.largeUnit, el, ev);
				}
				else {
					view.showEvent(event);
				}
				_this.segResizeListener = null;
			}
		});

		return dragListener;
	},


	// Called before event segment resizing starts
	segResizeStart: function(seg, ev) {
		this.isResizingSeg = true;
		this.view.publiclyTrigger('eventResizeStart', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Called after event segment resizing stops
	segResizeStop: function(seg, ev) {
		this.isResizingSeg = false;
		this.view.publiclyTrigger('eventResizeStop', seg.el[0], seg.event, ev, {}); // last argument is jqui dummy
	},


	// Returns new date-information for an event segment being resized from its start
	computeEventStartResize: function(startSpan, endSpan, event) {
		return this.computeEventResize('start', startSpan, endSpan, event);
	},


	// Returns new date-information for an event segment being resized from its end
	computeEventEndResize: function(startSpan, endSpan, event) {
		return this.computeEventResize('end', startSpan, endSpan, event);
	},


	// Returns new zoned date information for an event segment being resized from its start OR end
	// `type` is either 'start' or 'end'.
	// DOES NOT consider overlap/constraint.
	computeEventResize: function(type, startSpan, endSpan, event) {
		var calendar = this.view.calendar;
		var delta = this.diffDates(endSpan[type], startSpan[type]);
		var resizeLocation; // zoned event date properties
		var defaultDuration;

		// build original values to work from, guaranteeing a start and end
		resizeLocation = {
			start: event.start.clone(),
			end: calendar.getEventEnd(event),
			allDay: event.allDay
		};

		// if an all-day event was in a timed area and was resized to a time, adjust start/end to have times
		if (resizeLocation.allDay && durationHasTime(delta)) {
			resizeLocation.allDay = false;
			calendar.normalizeEventTimes(resizeLocation);
		}

		resizeLocation[type].add(delta); // apply delta to start or end

		// if the event was compressed too small, find a new reasonable duration for it
		if (!resizeLocation.start.isBefore(resizeLocation.end)) {

			defaultDuration =
				this.minResizeDuration || // TODO: hack
				(event.allDay ?
					calendar.defaultAllDayEventDuration :
					calendar.defaultTimedEventDuration);

			if (type == 'start') { // resizing the start?
				resizeLocation.start = resizeLocation.end.clone().subtract(defaultDuration);
			}
			else { // resizing the end?
				resizeLocation.end = resizeLocation.start.clone().add(defaultDuration);
			}
		}

		return resizeLocation;
	},


	// Renders a visual indication of an event being resized.
	// `range` has the updated dates of the event. `seg` is the original segment object involved in the drag.
	// Must return elements used for any mock events.
	renderEventResize: function(range, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event being resized.
	unrenderEventResize: function() {
		// subclasses must implement
	},


	/* Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Compute the text that should be displayed on an event's element.
	// `range` can be the Event object itself, or something range-like, with at least a `start`.
	// If event times are disabled, or the event has no time, will return a blank string.
	// If not specified, formatStr will default to the eventTimeFormat setting,
	// and displayEnd will default to the displayEventEnd setting.
	getEventTimeText: function(range, formatStr, displayEnd) {

		if (formatStr == null) {
			formatStr = this.eventTimeFormat;
		}

		if (displayEnd == null) {
			displayEnd = this.displayEventEnd;
		}

		if (this.displayEventTime && range.start.hasTime()) {
			if (displayEnd && range.end) {
				return this.view.formatRange(range, formatStr);
			}
			else {
				return range.start.format(formatStr);
			}
		}

		return '';
	},


	// Generic utility for generating the HTML classNames for an event segment's element
	getSegClasses: function(seg, isDraggable, isResizable) {
		var view = this.view;
		var classes = [
			'fc-event',
			seg.isStart ? 'fc-start' : 'fc-not-start',
			seg.isEnd ? 'fc-end' : 'fc-not-end'
		].concat(this.getSegCustomClasses(seg));

		if (isDraggable) {
			classes.push('fc-draggable');
		}
		if (isResizable) {
			classes.push('fc-resizable');
		}

		// event is currently selected? attach a className.
		if (view.isEventSelected(seg.event)) {
			classes.push('fc-selected');
		}

		return classes;
	},


	// List of classes that were defined by the caller of the API in some way
	getSegCustomClasses: function(seg) {
		var event = seg.event;

		return [].concat(
			event.className, // guaranteed to be an array
			event.source ? event.source.className : []
		);
	},


	// Utility for generating event skin-related CSS properties
	getSegSkinCss: function(seg) {
		return {
			'background-color': this.getSegBackgroundColor(seg),
			'border-color': this.getSegBorderColor(seg),
			color: this.getSegTextColor(seg)
		};
	},


	// Queries for caller-specified color, then falls back to default
	getSegBackgroundColor: function(seg) {
		return seg.event.backgroundColor ||
			seg.event.color ||
			this.getSegDefaultBackgroundColor(seg);
	},


	getSegDefaultBackgroundColor: function(seg) {
		var source = seg.event.source || {};

		return source.backgroundColor ||
			source.color ||
			this.view.opt('eventBackgroundColor') ||
			this.view.opt('eventColor');
	},


	// Queries for caller-specified color, then falls back to default
	getSegBorderColor: function(seg) {
		return seg.event.borderColor ||
			seg.event.color ||
			this.getSegDefaultBorderColor(seg);
	},


	getSegDefaultBorderColor: function(seg) {
		var source = seg.event.source || {};

		return source.borderColor ||
			source.color ||
			this.view.opt('eventBorderColor') ||
			this.view.opt('eventColor');
	},


	// Queries for caller-specified color, then falls back to default
	getSegTextColor: function(seg) {
		return seg.event.textColor ||
			this.getSegDefaultTextColor(seg);
	},


	getSegDefaultTextColor: function(seg) {
		var source = seg.event.source || {};

		return source.textColor ||
			this.view.opt('eventTextColor');
	},


	/* Event Location Validation
	------------------------------------------------------------------------------------------------------------------*/


	isEventLocationAllowed: function(eventLocation, event) {
		if (this.isEventLocationInRange(eventLocation)) {
			var calendar = this.view.calendar;
			var eventSpans = this.eventToSpans(eventLocation);
			var i;

			if (eventSpans.length) {
				for (i = 0; i < eventSpans.length; i++) {
					if (!calendar.isEventSpanAllowed(eventSpans[i], event)) {
						return false;
					}
				}

				return true;
			}
		}

		return false;
	},


	isExternalLocationAllowed: function(eventLocation, metaProps) { // FOR the external element
		if (this.isEventLocationInRange(eventLocation)) {
			var calendar = this.view.calendar;
			var eventSpans = this.eventToSpans(eventLocation);
			var i;

			if (eventSpans.length) {
				for (i = 0; i < eventSpans.length; i++) {
					if (!calendar.isExternalSpanAllowed(eventSpans[i], eventLocation, metaProps)) {
						return false;
					}
				}

				return true;
			}
		}

		return false;
	},


	isEventLocationInRange: function(eventLocation) {
		return isRangeWithinRange(
			this.eventToRawRange(eventLocation),
			this.view.validRange
		);
	},


	/* Converting events -> eventRange -> eventSpan -> eventSegs
	------------------------------------------------------------------------------------------------------------------*/


	// Generates an array of segments for the given single event
	// Can accept an event "location" as well (which only has start/end and no allDay)
	eventToSegs: function(event) {
		return this.eventsToSegs([ event ]);
	},


	// Generates spans (always unzoned) for the given event.
	// Does not do any inverting for inverse-background events.
	// Can accept an event "location" as well (which only has start/end and no allDay)
	eventToSpans: function(event) {
		var eventRange = this.eventToRange(event); // { start, end, isStart, isEnd }

		if (eventRange) {
			return this.eventRangeToSpans(eventRange, event);
		}
		else { // out of view's valid range
			return [];
		}
	},



	// Converts an array of event objects into an array of event segment objects.
	// A custom `segSliceFunc` may be given for arbitrarily slicing up events.
	// Doesn't guarantee an order for the resulting array.
	eventsToSegs: function(allEvents, segSliceFunc) {
		var _this = this;
		var eventsById = groupEventsById(allEvents);
		var segs = [];

		$.each(eventsById, function(id, events) {
			var visibleEvents = [];
			var eventRanges = [];
			var eventRange; // { start, end, isStart, isEnd }
			var i;

			for (i = 0; i < events.length; i++) {
				eventRange = _this.eventToRange(events[i]); // might be null if completely out of range

				if (eventRange) {
					eventRanges.push(eventRange);
					visibleEvents.push(events[i]);
				}
			}

			// inverse-background events (utilize only the first event in calculations)
			if (isInverseBgEvent(events[0])) {
				eventRanges = _this.invertRanges(eventRanges); // will lose isStart/isEnd

				for (i = 0; i < eventRanges.length; i++) {
					segs.push.apply(segs, // append to
						_this.eventRangeToSegs(eventRanges[i], events[0], segSliceFunc)
					);
				}
			}
			// normal event ranges
			else {
				for (i = 0; i < eventRanges.length; i++) {
					segs.push.apply(segs, // append to
						_this.eventRangeToSegs(eventRanges[i], visibleEvents[i], segSliceFunc)
					);
				}
			}
		});

		return segs;
	},


	// Generates the unzoned start/end dates an event appears to occupy
	// Can accept an event "location" as well (which only has start/end and no allDay)
	// returns { start, end, isStart, isEnd }
	// If the event is completely outside of the grid's valid range, will return undefined.
	eventToRange: function(event) {
		return this.refineRawEventRange(
			this.eventToRawRange(event)
		);
	},


	// Ensures the given range is within the view's activeRange and is correctly localized.
	// Always returns a result
	refineRawEventRange: function(rawRange) {
		var view = this.view;
		var calendar = view.calendar;
		var range = intersectRanges(rawRange, view.activeRange);

		if (range) { // otherwise, event doesn't have valid range

			// hack: dynamic locale change forgets to upate stored event localed
			calendar.localizeMoment(range.start);
			calendar.localizeMoment(range.end);

			return range;
		}
	},


	// not constrained to valid dates
	// not given localizeMoment hack
	eventToRawRange: function(event) {
		var calendar = this.view.calendar;
		var start = event.start.clone().stripZone();
		var end = (
				event.end ?
					event.end.clone() :
					// derive the end from the start and allDay. compute allDay if necessary
					calendar.getDefaultEventEnd(
						event.allDay != null ?
							event.allDay :
							!event.start.hasTime(),
						event.start
					)
			).stripZone();

		return { start: start, end: end };
	},


	// Given an event's range (unzoned start/end), and the event itself,
	// slice into segments (using the segSliceFunc function if specified)
	// eventRange - { start, end, isStart, isEnd }
	eventRangeToSegs: function(eventRange, event, segSliceFunc) {
		var eventSpans = this.eventRangeToSpans(eventRange, event);
		var segs = [];
		var i;

		for (i = 0; i < eventSpans.length; i++) {
			segs.push.apply(segs, // append to
				this.eventSpanToSegs(eventSpans[i], event, segSliceFunc)
			);
		}

		return segs;
	},


	// Given an event's unzoned date range, return an array of eventSpan objects.
	// eventSpan - { start, end, isStart, isEnd, otherthings... }
	// Subclasses can override.
	// Subclasses are obligated to forward eventRange.isStart/isEnd to the resulting spans.
	eventRangeToSpans: function(eventRange, event) {
		return [ $.extend({}, eventRange) ]; // copy into a single-item array
	},


	// Given an event's span (unzoned start/end and other misc data), and the event itself,
	// slices into segments and attaches event-derived properties to them.
	// eventSpan - { start, end, isStart, isEnd, otherthings... }
	eventSpanToSegs: function(eventSpan, event, segSliceFunc) {
		var segs = segSliceFunc ? segSliceFunc(eventSpan) : this.spanToSegs(eventSpan);
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];

			// the eventSpan's isStart/isEnd takes precedence over the seg's
			if (!eventSpan.isStart) {
				seg.isStart = false;
			}
			if (!eventSpan.isEnd) {
				seg.isEnd = false;
			}

			seg.event = event;
			seg.eventStartMS = +eventSpan.start; // TODO: not the best name after making spans unzoned
			seg.eventDurationMS = eventSpan.end - eventSpan.start;
		}

		return segs;
	},


	// Produces a new array of range objects that will cover all the time NOT covered by the given ranges.
	// SIDE EFFECT: will mutate the given array and will use its date references.
	invertRanges: function(ranges) {
		var view = this.view;
		var viewStart = view.activeRange.start.clone(); // need a copy
		var viewEnd = view.activeRange.end.clone(); // need a copy
		var inverseRanges = [];
		var start = viewStart; // the end of the previous range. the start of the new range
		var i, range;

		// ranges need to be in order. required for our date-walking algorithm
		ranges.sort(compareRanges);

		for (i = 0; i < ranges.length; i++) {
			range = ranges[i];

			// add the span of time before the event (if there is any)
			if (range.start > start) { // compare millisecond time (skip any ambig logic)
				inverseRanges.push({
					start: start,
					end: range.start
				});
			}

			start = range.end;
		}

		// add the span of time after the last event (if there is any)
		if (start < viewEnd) { // compare millisecond time (skip any ambig logic)
			inverseRanges.push({
				start: start,
				end: viewEnd
			});
		}

		return inverseRanges;
	},


	sortEventSegs: function(segs) {
		segs.sort(proxy(this, 'compareEventSegs'));
	},


	// A cmp function for determining which segments should take visual priority
	compareEventSegs: function(seg1, seg2) {
		return seg1.eventStartMS - seg2.eventStartMS || // earlier events go first
			seg2.eventDurationMS - seg1.eventDurationMS || // tie? longer events go first
			seg2.event.allDay - seg1.event.allDay || // tie? put all-day events first (booleans cast to 0/1)
			compareByFieldSpecs(seg1.event, seg2.event, this.view.eventOrderSpecs);
	}

});


/* Utilities
----------------------------------------------------------------------------------------------------------------------*/


function pluckEventDateProps(event) {
	return {
		start: event.start.clone(),
		end: event.end ? event.end.clone() : null,
		allDay: event.allDay // keep it the same
	};
}
FC.pluckEventDateProps = pluckEventDateProps;


function isBgEvent(event) { // returns true if background OR inverse-background
	var rendering = getEventRendering(event);
	return rendering === 'background' || rendering === 'inverse-background';
}
FC.isBgEvent = isBgEvent; // export


function isInverseBgEvent(event) {
	return getEventRendering(event) === 'inverse-background';
}


function getEventRendering(event) {
	return firstDefined((event.source || {}).rendering, event.rendering);
}


function groupEventsById(events) {
	var eventsById = {};
	var i, event;

	for (i = 0; i < events.length; i++) {
		event = events[i];
		(eventsById[event._id] || (eventsById[event._id] = [])).push(event);
	}

	return eventsById;
}


// A cmp function for determining which non-inverted "ranges" (see above) happen earlier
function compareRanges(range1, range2) {
	return range1.start - range2.start; // earlier ranges go first
}


/* External-Dragging-Element Data
----------------------------------------------------------------------------------------------------------------------*/

// Require all HTML5 data-* attributes used by FullCalendar to have this prefix.
// A value of '' will query attributes like data-event. A value of 'fc' will query attributes like data-fc-event.
FC.dataAttrPrefix = '';

// Given a jQuery element that might represent a dragged FullCalendar event, returns an intermediate data structure
// to be used for Event Object creation.
// A defined `.eventProps`, even when empty, indicates that an event should be created.
function getDraggedElMeta(el) {
	var prefix = FC.dataAttrPrefix;
	var eventProps; // properties for creating the event, not related to date/time
	var startTime; // a Duration
	var duration;
	var stick;

	if (prefix) { prefix += '-'; }
	eventProps = el.data(prefix + 'event') || null;

	if (eventProps) {
		if (typeof eventProps === 'object') {
			eventProps = $.extend({}, eventProps); // make a copy
		}
		else { // something like 1 or true. still signal event creation
			eventProps = {};
		}

		// pluck special-cased date/time properties
		startTime = eventProps.start;
		if (startTime == null) { startTime = eventProps.time; } // accept 'time' as well
		duration = eventProps.duration;
		stick = eventProps.stick;
		delete eventProps.start;
		delete eventProps.time;
		delete eventProps.duration;
		delete eventProps.stick;
	}

	// fallback to standalone attribute values for each of the date/time properties
	if (startTime == null) { startTime = el.data(prefix + 'start'); }
	if (startTime == null) { startTime = el.data(prefix + 'time'); } // accept 'time' as well
	if (duration == null) { duration = el.data(prefix + 'duration'); }
	if (stick == null) { stick = el.data(prefix + 'stick'); }

	// massage into correct data types
	startTime = startTime != null ? moment.duration(startTime) : null;
	duration = duration != null ? moment.duration(duration) : null;
	stick = Boolean(stick);

	return { eventProps: eventProps, startTime: startTime, duration: duration, stick: stick };
}


;;

/*
A set of rendering and date-related methods for a visual component comprised of one or more rows of day columns.
Prerequisite: the object being mixed into needs to be a *Grid*
*/
var DayTableMixin = FC.DayTableMixin = {

	breakOnWeeks: false, // should create a new row for each week?
	dayDates: null, // whole-day dates for each column. left to right
	dayIndices: null, // for each day from start, the offset
	daysPerRow: null,
	rowCnt: null,
	colCnt: null,
	colHeadFormat: null,


	// Populates internal variables used for date calculation and rendering
	updateDayTable: function() {
		var view = this.view;
		var date = this.start.clone();
		var dayIndex = -1;
		var dayIndices = [];
		var dayDates = [];
		var daysPerRow;
		var firstDay;
		var rowCnt;

		while (date.isBefore(this.end)) { // loop each day from start to end
			if (view.isHiddenDay(date)) {
				dayIndices.push(dayIndex + 0.5); // mark that it's between indices
			}
			else {
				dayIndex++;
				dayIndices.push(dayIndex);
				dayDates.push(date.clone());
			}
			date.add(1, 'days');
		}

		if (this.breakOnWeeks) {
			// count columns until the day-of-week repeats
			firstDay = dayDates[0].day();
			for (daysPerRow = 1; daysPerRow < dayDates.length; daysPerRow++) {
				if (dayDates[daysPerRow].day() == firstDay) {
					break;
				}
			}
			rowCnt = Math.ceil(dayDates.length / daysPerRow);
		}
		else {
			rowCnt = 1;
			daysPerRow = dayDates.length;
		}

		this.dayDates = dayDates;
		this.dayIndices = dayIndices;
		this.daysPerRow = daysPerRow;
		this.rowCnt = rowCnt;

		this.updateDayTableCols();
	},


	// Computes and assigned the colCnt property and updates any options that may be computed from it
	updateDayTableCols: function() {
		this.colCnt = this.computeColCnt();
		this.colHeadFormat = this.view.opt('columnFormat') || this.computeColHeadFormat();
	},


	// Determines how many columns there should be in the table
	computeColCnt: function() {
		return this.daysPerRow;
	},


	// Computes the ambiguously-timed moment for the given cell
	getCellDate: function(row, col) {
		return this.dayDates[
				this.getCellDayIndex(row, col)
			].clone();
	},


	// Computes the ambiguously-timed date range for the given cell
	getCellRange: function(row, col) {
		var start = this.getCellDate(row, col);
		var end = start.clone().add(1, 'days');

		return { start: start, end: end };
	},


	// Returns the number of day cells, chronologically, from the first of the grid (0-based)
	getCellDayIndex: function(row, col) {
		return row * this.daysPerRow + this.getColDayIndex(col);
	},


	// Returns the numner of day cells, chronologically, from the first cell in *any given row*
	getColDayIndex: function(col) {
		if (this.isRTL) {
			return this.colCnt - 1 - col;
		}
		else {
			return col;
		}
	},


	// Given a date, returns its chronolocial cell-index from the first cell of the grid.
	// If the date lies between cells (because of hiddenDays), returns a floating-point value between offsets.
	// If before the first offset, returns a negative number.
	// If after the last offset, returns an offset past the last cell offset.
	// Only works for *start* dates of cells. Will not work for exclusive end dates for cells.
	getDateDayIndex: function(date) {
		var dayIndices = this.dayIndices;
		var dayOffset = date.diff(this.start, 'days');

		if (dayOffset < 0) {
			return dayIndices[0] - 1;
		}
		else if (dayOffset >= dayIndices.length) {
			return dayIndices[dayIndices.length - 1] + 1;
		}
		else {
			return dayIndices[dayOffset];
		}
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Computes a default column header formatting string if `colFormat` is not explicitly defined
	computeColHeadFormat: function() {
		// if more than one week row, or if there are a lot of columns with not much space,
		// put just the day numbers will be in each cell
		if (this.rowCnt > 1 || this.colCnt > 10) {
			return 'ddd'; // "Sat"
		}
		// multiple days, so full single date string WON'T be in title text
		else if (this.colCnt > 1) {
			return this.view.opt('dayOfMonthFormat'); // "Sat 12/10"
		}
		// single day, so full single date string will probably be in title text
		else {
			return 'dddd'; // "Saturday"
		}
	},


	/* Slicing
	------------------------------------------------------------------------------------------------------------------*/


	// Slices up a date range into a segment for every week-row it intersects with
	sliceRangeByRow: function(range) {
		var daysPerRow = this.daysPerRow;
		var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
		var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
		var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
		var segs = [];
		var row;
		var rowFirst, rowLast; // inclusive day-index range for current row
		var segFirst, segLast; // inclusive day-index range for segment

		for (row = 0; row < this.rowCnt; row++) {
			rowFirst = row * daysPerRow;
			rowLast = rowFirst + daysPerRow - 1;

			// intersect segment's offset range with the row's
			segFirst = Math.max(rangeFirst, rowFirst);
			segLast = Math.min(rangeLast, rowLast);

			// deal with in-between indices
			segFirst = Math.ceil(segFirst); // in-between starts round to next cell
			segLast = Math.floor(segLast); // in-between ends round to prev cell

			if (segFirst <= segLast) { // was there any intersection with the current row?
				segs.push({
					row: row,

					// normalize to start of row
					firstRowDayIndex: segFirst - rowFirst,
					lastRowDayIndex: segLast - rowFirst,

					// must be matching integers to be the segment's start/end
					isStart: segFirst === rangeFirst,
					isEnd: segLast === rangeLast
				});
			}
		}

		return segs;
	},


	// Slices up a date range into a segment for every day-cell it intersects with.
	// TODO: make more DRY with sliceRangeByRow somehow.
	sliceRangeByDay: function(range) {
		var daysPerRow = this.daysPerRow;
		var normalRange = this.view.computeDayRange(range); // make whole-day range, considering nextDayThreshold
		var rangeFirst = this.getDateDayIndex(normalRange.start); // inclusive first index
		var rangeLast = this.getDateDayIndex(normalRange.end.clone().subtract(1, 'days')); // inclusive last index
		var segs = [];
		var row;
		var rowFirst, rowLast; // inclusive day-index range for current row
		var i;
		var segFirst, segLast; // inclusive day-index range for segment

		for (row = 0; row < this.rowCnt; row++) {
			rowFirst = row * daysPerRow;
			rowLast = rowFirst + daysPerRow - 1;

			for (i = rowFirst; i <= rowLast; i++) {

				// intersect segment's offset range with the row's
				segFirst = Math.max(rangeFirst, i);
				segLast = Math.min(rangeLast, i);

				// deal with in-between indices
				segFirst = Math.ceil(segFirst); // in-between starts round to next cell
				segLast = Math.floor(segLast); // in-between ends round to prev cell

				if (segFirst <= segLast) { // was there any intersection with the current row?
					segs.push({
						row: row,

						// normalize to start of row
						firstRowDayIndex: segFirst - rowFirst,
						lastRowDayIndex: segLast - rowFirst,

						// must be matching integers to be the segment's start/end
						isStart: segFirst === rangeFirst,
						isEnd: segLast === rangeLast
					});
				}
			}
		}

		return segs;
	},


	/* Header Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderHeadHtml: function() {
		var view = this.view;

		return '' +
			'<div class="fc-row ' + view.widgetHeaderClass + '">' +
				'<table>' +
					'<thead>' +
						this.renderHeadTrHtml() +
					'</thead>' +
				'</table>' +
			'</div>';
	},


	renderHeadIntroHtml: function() {
		return this.renderIntroHtml(); // fall back to generic
	},


	renderHeadTrHtml: function() {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderHeadIntroHtml()) +
				this.renderHeadDateCellsHtml() +
				(this.isRTL ? this.renderHeadIntroHtml() : '') +
			'</tr>';
	},


	renderHeadDateCellsHtml: function() {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(0, col);
			htmls.push(this.renderHeadDateCellHtml(date));
		}

		return htmls.join('');
	},


	// TODO: when internalApiVersion, accept an object for HTML attributes
	// (colspan should be no different)
	renderHeadDateCellHtml: function(date, colspan, otherAttrs) {
		var view = this.view;
		var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
		var classNames = [
			'fc-day-header',
			view.widgetHeaderClass
		];
		var innerHtml = htmlEscape(date.format(this.colHeadFormat));

		// if only one row of days, the classNames on the header can represent the specific days beneath
		if (this.rowCnt === 1) {
			classNames = classNames.concat(
				// includes the day-of-week class
				// noThemeHighlight=true (don't highlight the header)
				this.getDayClasses(date, true)
			);
		}
		else {
			classNames.push('fc-' + dayIDs[date.day()]); // only add the day-of-week class
		}

		return '' +
            '<th class="' + classNames.join(' ') + '"' +
				((isDateValid && this.rowCnt) === 1 ?
					' data-date="' + date.format('YYYY-MM-DD') + '"' :
					'') +
				(colspan > 1 ?
					' colspan="' + colspan + '"' :
					'') +
				(otherAttrs ?
					' ' + otherAttrs :
					'') +
				'>' +
				(isDateValid ?
					// don't make a link if the heading could represent multiple days, or if there's only one day (forceOff)
					view.buildGotoAnchorHtml(
						{ date: date, forceOff: this.rowCnt > 1 || this.colCnt === 1 },
						innerHtml
					) :
					// if not valid, display text, but no link
					innerHtml
				) +
			'</th>';
	},


	/* Background Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderBgTrHtml: function(row) {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderBgIntroHtml(row)) +
				this.renderBgCellsHtml(row) +
				(this.isRTL ? this.renderBgIntroHtml(row) : '') +
			'</tr>';
	},


	renderBgIntroHtml: function(row) {
		return this.renderIntroHtml(); // fall back to generic
	},


	renderBgCellsHtml: function(row) {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(row, col);
			htmls.push(this.renderBgCellHtml(date));
		}

		return htmls.join('');
	},


	renderBgCellHtml: function(date, otherAttrs) {
		var view = this.view;
		var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
		var classes = this.getDayClasses(date);

		classes.unshift('fc-day', view.widgetContentClass);

		return '<td class="' + classes.join(' ') + '"' +
			(isDateValid ?
				' data-date="' + date.format('YYYY-MM-DD') + '"' : // if date has a time, won't format it
				'') +
			(otherAttrs ?
				' ' + otherAttrs :
				'') +
			'></td>';
	},


	/* Generic
	------------------------------------------------------------------------------------------------------------------*/


	// Generates the default HTML intro for any row. User classes should override
	renderIntroHtml: function() {
	},


	// TODO: a generic method for dealing with <tr>, RTL, intro
	// when increment internalApiVersion
	// wrapTr (scheduler)


	/* Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Applies the generic "intro" and "outro" HTML to the given cells.
	// Intro means the leftmost cell when the calendar is LTR and the rightmost cell when RTL. Vice-versa for outro.
	bookendCells: function(trEl) {
		var introHtml = this.renderIntroHtml();

		if (introHtml) {
			if (this.isRTL) {
				trEl.append(introHtml);
			}
			else {
				trEl.prepend(introHtml);
			}
		}
	}

};

;;

/* A component that renders a grid of whole-days that runs horizontally. There can be multiple rows, one per week.
----------------------------------------------------------------------------------------------------------------------*/

var DayGrid = FC.DayGrid = Grid.extend(DayTableMixin, {

	numbersVisible: false, // should render a row for day/week numbers? set by outside view. TODO: make internal
	bottomCoordPadding: 0, // hack for extending the hit area for the last row of the coordinate grid

	rowEls: null, // set of fake row elements
	cellEls: null, // set of whole-day elements comprising the row's background
	helperEls: null, // set of cell skeleton elements for rendering the mock event "helper"

	rowCoordCache: null,
	colCoordCache: null,


	// Renders the rows and columns into the component's `this.el`, which should already be assigned.
	// isRigid determins whether the individual rows should ignore the contents and be a constant height.
	// Relies on the view's colCnt and rowCnt. In the future, this component should probably be self-sufficient.
	renderDates: function(isRigid) {
		var view = this.view;
		var rowCnt = this.rowCnt;
		var colCnt = this.colCnt;
		var html = '';
		var row;
		var col;

		for (row = 0; row < rowCnt; row++) {
			html += this.renderDayRowHtml(row, isRigid);
		}
		this.el.html(html);

		this.rowEls = this.el.find('.fc-row');
		this.cellEls = this.el.find('.fc-day, .fc-disabled-day');

		this.rowCoordCache = new CoordCache({
			els: this.rowEls,
			isVertical: true
		});
		this.colCoordCache = new CoordCache({
			els: this.cellEls.slice(0, this.colCnt), // only the first row
			isHorizontal: true
		});

		// trigger dayRender with each cell's element
		for (row = 0; row < rowCnt; row++) {
			for (col = 0; col < colCnt; col++) {
				view.publiclyTrigger(
					'dayRender',
					null,
					this.getCellDate(row, col),
					this.getCellEl(row, col)
				);
			}
		}
	},


	unrenderDates: function() {
		this.removeSegPopover();
	},


	renderBusinessHours: function() {
		var segs = this.buildBusinessHourSegs(true); // wholeDay=true
		this.renderFill('businessHours', segs, 'bgevent');
	},


	unrenderBusinessHours: function() {
		this.unrenderFill('businessHours');
	},


	// Generates the HTML for a single row, which is a div that wraps a table.
	// `row` is the row number.
	renderDayRowHtml: function(row, isRigid) {
		var view = this.view;
		var classes = [ 'fc-row', 'fc-week', view.widgetContentClass ];

		if (isRigid) {
			classes.push('fc-rigid');
		}

		return '' +
			'<div class="' + classes.join(' ') + '">' +
				'<div class="fc-bg">' +
					'<table>' +
						this.renderBgTrHtml(row) +
					'</table>' +
				'</div>' +
				'<div class="fc-content-skeleton">' +
					'<table>' +
						(this.numbersVisible ?
							'<thead>' +
								this.renderNumberTrHtml(row) +
							'</thead>' :
							''
							) +
					'</table>' +
				'</div>' +
			'</div>';
	},


	/* Grid Number Rendering
	------------------------------------------------------------------------------------------------------------------*/


	renderNumberTrHtml: function(row) {
		return '' +
			'<tr>' +
				(this.isRTL ? '' : this.renderNumberIntroHtml(row)) +
				this.renderNumberCellsHtml(row) +
				(this.isRTL ? this.renderNumberIntroHtml(row) : '') +
			'</tr>';
	},


	renderNumberIntroHtml: function(row) {
		return this.renderIntroHtml();
	},


	renderNumberCellsHtml: function(row) {
		var htmls = [];
		var col, date;

		for (col = 0; col < this.colCnt; col++) {
			date = this.getCellDate(row, col);
			htmls.push(this.renderNumberCellHtml(date));
		}

		return htmls.join('');
	},


	// Generates the HTML for the <td>s of the "number" row in the DayGrid's content skeleton.
	// The number row will only exist if either day numbers or week numbers are turned on.
	renderNumberCellHtml: function(date) {
		var view = this.view;
		var html = '';
		var isDateValid = isDateWithinRange(date, view.activeRange); // TODO: called too frequently. cache somehow.
		var isDayNumberVisible = view.dayNumbersVisible && isDateValid;
		var classes;
		var weekCalcFirstDoW;

		if (!isDayNumberVisible && !view.cellWeekNumbersVisible) {
			// no numbers in day cell (week number must be along the side)
			return '<td/>'; //  will create an empty space above events :(
		}

		classes = this.getDayClasses(date);
		classes.unshift('fc-day-top');

		if (view.cellWeekNumbersVisible) {
			// To determine the day of week number change under ISO, we cannot
			// rely on moment.js methods such as firstDayOfWeek() or weekday(),
			// because they rely on the locale's dow (possibly overridden by
			// our firstDay option), which may not be Monday. We cannot change
			// dow, because that would affect the calendar start day as well.
			if (date._locale._fullCalendar_weekCalc === 'ISO') {
				weekCalcFirstDoW = 1;  // Monday by ISO 8601 definition
			}
			else {
				weekCalcFirstDoW = date._locale.firstDayOfWeek();
			}
		}

		html += '<td class="' + classes.join(' ') + '"' +
			(isDateValid ?
				' data-date="' + date.format() + '"' :
				''
				) +
			'>';

		if (view.cellWeekNumbersVisible && (date.day() == weekCalcFirstDoW)) {
			html += view.buildGotoAnchorHtml(
				{ date: date, type: 'week' },
				{ 'class': 'fc-week-number' },
				date.format('w') // inner HTML
			);
		}

		if (isDayNumberVisible) {
			html += view.buildGotoAnchorHtml(
				date,
				{ 'class': 'fc-day-number' },
				date.date() // inner HTML
			);
		}

		html += '</td>';

		return html;
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Computes a default event time formatting string if `timeFormat` is not explicitly defined
	computeEventTimeFormat: function() {
		return this.view.opt('extraSmallTimeFormat'); // like "6p" or "6:30p"
	},


	// Computes a default `displayEventEnd` value if one is not expliclty defined
	computeDisplayEventEnd: function() {
		return this.colCnt == 1; // we'll likely have space if there's only one day
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	rangeUpdated: function() {
		this.updateDayTable();
	},


	// Slices up the given span (unzoned start/end with other misc data) into an array of segments
	spanToSegs: function(span) {
		var segs = this.sliceRangeByRow(span);
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			if (this.isRTL) {
				seg.leftCol = this.daysPerRow - 1 - seg.lastRowDayIndex;
				seg.rightCol = this.daysPerRow - 1 - seg.firstRowDayIndex;
			}
			else {
				seg.leftCol = seg.firstRowDayIndex;
				seg.rightCol = seg.lastRowDayIndex;
			}
		}

		return segs;
	},


	/* Hit System
	------------------------------------------------------------------------------------------------------------------*/


	prepareHits: function() {
		this.colCoordCache.build();
		this.rowCoordCache.build();
		this.rowCoordCache.bottoms[this.rowCnt - 1] += this.bottomCoordPadding; // hack
	},


	releaseHits: function() {
		this.colCoordCache.clear();
		this.rowCoordCache.clear();
	},


	queryHit: function(leftOffset, topOffset) {
		if (this.colCoordCache.isLeftInBounds(leftOffset) && this.rowCoordCache.isTopInBounds(topOffset)) {
			var col = this.colCoordCache.getHorizontalIndex(leftOffset);
			var row = this.rowCoordCache.getVerticalIndex(topOffset);

			if (row != null && col != null) {
				return this.getCellHit(row, col);
			}
		}
	},


	getHitSpan: function(hit) {
		return this.getCellRange(hit.row, hit.col);
	},


	getHitEl: function(hit) {
		return this.getCellEl(hit.row, hit.col);
	},


	/* Cell System
	------------------------------------------------------------------------------------------------------------------*/
	// FYI: the first column is the leftmost column, regardless of date


	getCellHit: function(row, col) {
		return {
			row: row,
			col: col,
			component: this, // needed unfortunately :(
			left: this.colCoordCache.getLeftOffset(col),
			right: this.colCoordCache.getRightOffset(col),
			top: this.rowCoordCache.getTopOffset(row),
			bottom: this.rowCoordCache.getBottomOffset(row)
		};
	},


	getCellEl: function(row, col) {
		return this.cellEls.eq(row * this.colCnt + col);
	},


	/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: move to DayGrid.event, similar to what we did with Grid's drag methods


	// Renders a visual indication of an event or external element being dragged.
	// `eventLocation` has zoned start and end (optional)
	renderDrag: function(eventLocation, seg) {
		var eventSpans = this.eventToSpans(eventLocation);
		var i;

		// always render a highlight underneath
		for (i = 0; i < eventSpans.length; i++) {
			this.renderHighlight(eventSpans[i]);
		}

		// if a segment from the same calendar but another component is being dragged, render a helper event
		if (seg && seg.component !== this) {
			return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
		}
	},


	// Unrenders any visual indication of a hovering event
	unrenderDrag: function() {
		this.unrenderHighlight();
		this.unrenderHelper();
	},


	/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being resized
	renderEventResize: function(eventLocation, seg) {
		var eventSpans = this.eventToSpans(eventLocation);
		var i;

		for (i = 0; i < eventSpans.length; i++) {
			this.renderHighlight(eventSpans[i]);
		}

		return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
	},


	// Unrenders a visual indication of an event being resized
	unrenderEventResize: function() {
		this.unrenderHighlight();
		this.unrenderHelper();
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a mock "helper" event. `sourceSeg` is the associated internal segment object. It can be null.
	renderHelper: function(event, sourceSeg) {
		var helperNodes = [];
		var segs = this.eventToSegs(event);
		var rowStructs;

		segs = this.renderFgSegEls(segs); // assigns each seg's el and returns a subset of segs that were rendered
		rowStructs = this.renderSegRows(segs);

		// inject each new event skeleton into each associated row
		this.rowEls.each(function(row, rowNode) {
			var rowEl = $(rowNode); // the .fc-row
			var skeletonEl = $('<div class="fc-helper-skeleton"><table/></div>'); // will be absolutely positioned
			var skeletonTop;

			// If there is an original segment, match the top position. Otherwise, put it at the row's top level
			if (sourceSeg && sourceSeg.row === row) {
				skeletonTop = sourceSeg.el.position().top;
			}
			else {
				skeletonTop = rowEl.find('.fc-content-skeleton tbody').position().top;
			}

			skeletonEl.css('top', skeletonTop)
				.find('table')
					.append(rowStructs[row].tbodyEl);

			rowEl.append(skeletonEl);
			helperNodes.push(skeletonEl[0]);
		});

		return ( // must return the elements rendered
			this.helperEls = $(helperNodes) // array -> jQuery set
		);
	},


	// Unrenders any visual indication of a mock helper event
	unrenderHelper: function() {
		if (this.helperEls) {
			this.helperEls.remove();
			this.helperEls = null;
		}
	},


	/* Fill System (highlight, background events, business hours)
	------------------------------------------------------------------------------------------------------------------*/


	fillSegTag: 'td', // override the default tag name


	// Renders a set of rectangles over the given segments of days.
	// Only returns segments that successfully rendered.
	renderFill: function(type, segs, className) {
		var nodes = [];
		var i, seg;
		var skeletonEl;

		segs = this.renderFillSegEls(type, segs); // assignes `.el` to each seg. returns successfully rendered segs

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			skeletonEl = this.renderFillRow(type, seg, className);
			this.rowEls.eq(seg.row).append(skeletonEl);
			nodes.push(skeletonEl[0]);
		}

		this.elsByFill[type] = $(nodes);

		return segs;
	},


	// Generates the HTML needed for one row of a fill. Requires the seg's el to be rendered.
	renderFillRow: function(type, seg, className) {
		var colCnt = this.colCnt;
		var startCol = seg.leftCol;
		var endCol = seg.rightCol + 1;
		var skeletonEl;
		var trEl;

		className = className || type.toLowerCase();

		skeletonEl = $(
			'<div class="fc-' + className + '-skeleton">' +
				'<table><tr/></table>' +
			'</div>'
		);
		trEl = skeletonEl.find('tr');

		if (startCol > 0) {
			trEl.append('<td colspan="' + startCol + '"/>');
		}

		trEl.append(
			seg.el.attr('colspan', endCol - startCol)
		);

		if (endCol < colCnt) {
			trEl.append('<td colspan="' + (colCnt - endCol) + '"/>');
		}

		this.bookendCells(trEl);

		return skeletonEl;
	}

});

;;

/* Event-rendering methods for the DayGrid class
----------------------------------------------------------------------------------------------------------------------*/

DayGrid.mixin({

	rowStructs: null, // an array of objects, each holding information about a row's foreground event-rendering


	// Unrenders all events currently rendered on the grid
	unrenderEvents: function() {
		this.removeSegPopover(); // removes the "more.." events popover
		Grid.prototype.unrenderEvents.apply(this, arguments); // calls the super-method
	},


	// Retrieves all rendered segment objects currently rendered on the grid
	getEventSegs: function() {
		return Grid.prototype.getEventSegs.call(this) // get the segments from the super-method
			.concat(this.popoverSegs || []); // append the segments from the "more..." popover
	},


	// Renders the given background event segments onto the grid
	renderBgSegs: function(segs) {

		// don't render timed background events
		var allDaySegs = $.grep(segs, function(seg) {
			return seg.event.allDay;
		});

		return Grid.prototype.renderBgSegs.call(this, allDaySegs); // call the super-method
	},


	// Renders the given foreground event segments onto the grid
	renderFgSegs: function(segs) {
		var rowStructs;

		// render an `.el` on each seg
		// returns a subset of the segs. segs that were actually rendered
		segs = this.renderFgSegEls(segs);

		rowStructs = this.rowStructs = this.renderSegRows(segs);

		// append to each row's content skeleton
		this.rowEls.each(function(i, rowNode) {
			$(rowNode).find('.fc-content-skeleton > table').append(
				rowStructs[i].tbodyEl
			);
		});

		return segs; // return only the segs that were actually rendered
	},


	// Unrenders all currently rendered foreground event segments
	unrenderFgSegs: function() {
		var rowStructs = this.rowStructs || [];
		var rowStruct;

		while ((rowStruct = rowStructs.pop())) {
			rowStruct.tbodyEl.remove();
		}

		this.rowStructs = null;
	},


	// Uses the given events array to generate <tbody> elements that should be appended to each row's content skeleton.
	// Returns an array of rowStruct objects (see the bottom of `renderSegRow`).
	// PRECONDITION: each segment shoud already have a rendered and assigned `.el`
	renderSegRows: function(segs) {
		var rowStructs = [];
		var segRows;
		var row;

		segRows = this.groupSegRows(segs); // group into nested arrays

		// iterate each row of segment groupings
		for (row = 0; row < segRows.length; row++) {
			rowStructs.push(
				this.renderSegRow(row, segRows[row])
			);
		}

		return rowStructs;
	},


	// Builds the HTML to be used for the default element for an individual segment
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing && event.allDay &&
			seg.isStart && view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing && event.allDay &&
			seg.isEnd && view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		var skinCss = cssToStr(this.getSegSkinCss(seg));
		var timeHtml = '';
		var timeText;
		var titleHtml;

		classes.unshift('fc-day-grid-event', 'fc-h-event');

		// Only display a timed events time if it is the starting segment
		if (seg.isStart) {
			timeText = this.getEventTimeText(event);
			if (timeText) {
				timeHtml = '<span class="fc-time">' + htmlEscape(timeText) + '</span>';
			}
		}

		titleHtml =
			'<span class="fc-title">' +
				(htmlEscape(event.title || '') || '&nbsp;') + // we always want one line of height
			'</span>';
		
		return '<a class="' + classes.join(' ') + '"' +
				(event.url ?
					' href="' + htmlEscape(event.url) + '"' :
					''
					) +
				(skinCss ?
					' style="' + skinCss + '"' :
					''
					) +
			'>' +
				'<div class="fc-content">' +
					(this.isRTL ?
						titleHtml + ' ' + timeHtml : // put a natural space in between
						timeHtml + ' ' + titleHtml   //
						) +
				'</div>' +
				(isResizableFromStart ?
					'<div class="fc-resizer fc-start-resizer" />' :
					''
					) +
				(isResizableFromEnd ?
					'<div class="fc-resizer fc-end-resizer" />' :
					''
					) +
			'</a>';
	},


	// Given a row # and an array of segments all in the same row, render a <tbody> element, a skeleton that contains
	// the segments. Returns object with a bunch of internal data about how the render was calculated.
	// NOTE: modifies rowSegs
	renderSegRow: function(row, rowSegs) {
		var colCnt = this.colCnt;
		var segLevels = this.buildSegLevels(rowSegs); // group into sub-arrays of levels
		var levelCnt = Math.max(1, segLevels.length); // ensure at least one level
		var tbody = $('<tbody/>');
		var segMatrix = []; // lookup for which segments are rendered into which level+col cells
		var cellMatrix = []; // lookup for all <td> elements of the level+col matrix
		var loneCellMatrix = []; // lookup for <td> elements that only take up a single column
		var i, levelSegs;
		var col;
		var tr;
		var j, seg;
		var td;

		// populates empty cells from the current column (`col`) to `endCol`
		function emptyCellsUntil(endCol) {
			while (col < endCol) {
				// try to grab a cell from the level above and extend its rowspan. otherwise, create a fresh cell
				td = (loneCellMatrix[i - 1] || [])[col];
				if (td) {
					td.attr(
						'rowspan',
						parseInt(td.attr('rowspan') || 1, 10) + 1
					);
				}
				else {
					td = $('<td/>');
					tr.append(td);
				}
				cellMatrix[i][col] = td;
				loneCellMatrix[i][col] = td;
				col++;
			}
		}

		for (i = 0; i < levelCnt; i++) { // iterate through all levels
			levelSegs = segLevels[i];
			col = 0;
			tr = $('<tr/>');

			segMatrix.push([]);
			cellMatrix.push([]);
			loneCellMatrix.push([]);

			// levelCnt might be 1 even though there are no actual levels. protect against this.
			// this single empty row is useful for styling.
			if (levelSegs) {
				for (j = 0; j < levelSegs.length; j++) { // iterate through segments in level
					seg = levelSegs[j];

					emptyCellsUntil(seg.leftCol);

					// create a container that occupies or more columns. append the event element.
					td = $('<td class="fc-event-container"/>').append(seg.el);
					if (seg.leftCol != seg.rightCol) {
						td.attr('colspan', seg.rightCol - seg.leftCol + 1);
					}
					else { // a single-column segment
						loneCellMatrix[i][col] = td;
					}

					while (col <= seg.rightCol) {
						cellMatrix[i][col] = td;
						segMatrix[i][col] = seg;
						col++;
					}

					tr.append(td);
				}
			}

			emptyCellsUntil(colCnt); // finish off the row
			this.bookendCells(tr);
			tbody.append(tr);
		}

		return { // a "rowStruct"
			row: row, // the row number
			tbodyEl: tbody,
			cellMatrix: cellMatrix,
			segMatrix: segMatrix,
			segLevels: segLevels,
			segs: rowSegs
		};
	},


	// Stacks a flat array of segments, which are all assumed to be in the same row, into subarrays of vertical levels.
	// NOTE: modifies segs
	buildSegLevels: function(segs) {
		var levels = [];
		var i, seg;
		var j;

		// Give preference to elements with certain criteria, so they have
		// a chance to be closer to the top.
		this.sortEventSegs(segs);
		
		for (i = 0; i < segs.length; i++) {
			seg = segs[i];

			// loop through levels, starting with the topmost, until the segment doesn't collide with other segments
			for (j = 0; j < levels.length; j++) {
				if (!isDaySegCollision(seg, levels[j])) {
					break;
				}
			}
			// `j` now holds the desired subrow index
			seg.level = j;

			// create new level array if needed and append segment
			(levels[j] || (levels[j] = [])).push(seg);
		}

		// order segments left-to-right. very important if calendar is RTL
		for (j = 0; j < levels.length; j++) {
			levels[j].sort(compareDaySegCols);
		}

		return levels;
	},


	// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's row
	groupSegRows: function(segs) {
		var segRows = [];
		var i;

		for (i = 0; i < this.rowCnt; i++) {
			segRows.push([]);
		}

		for (i = 0; i < segs.length; i++) {
			segRows[segs[i].row].push(segs[i]);
		}

		return segRows;
	}

});


// Computes whether two segments' columns collide. They are assumed to be in the same row.
function isDaySegCollision(seg, otherSegs) {
	var i, otherSeg;

	for (i = 0; i < otherSegs.length; i++) {
		otherSeg = otherSegs[i];

		if (
			otherSeg.leftCol <= seg.rightCol &&
			otherSeg.rightCol >= seg.leftCol
		) {
			return true;
		}
	}

	return false;
}


// A cmp function for determining the leftmost event
function compareDaySegCols(a, b) {
	return a.leftCol - b.leftCol;
}

;;

/* Methods relate to limiting the number events for a given day on a DayGrid
----------------------------------------------------------------------------------------------------------------------*/
// NOTE: all the segs being passed around in here are foreground segs

DayGrid.mixin({

	segPopover: null, // the Popover that holds events that can't fit in a cell. null when not visible
	popoverSegs: null, // an array of segment objects that the segPopover holds. null when not visible


	removeSegPopover: function() {
		if (this.segPopover) {
			this.segPopover.hide(); // in handler, will call segPopover's removeElement
		}
	},


	// Limits the number of "levels" (vertically stacking layers of events) for each row of the grid.
	// `levelLimit` can be false (don't limit), a number, or true (should be computed).
	limitRows: function(levelLimit) {
		var rowStructs = this.rowStructs || [];
		var row; // row #
		var rowLevelLimit;

		for (row = 0; row < rowStructs.length; row++) {
			this.unlimitRow(row);

			if (!levelLimit) {
				rowLevelLimit = false;
			}
			else if (typeof levelLimit === 'number') {
				rowLevelLimit = levelLimit;
			}
			else {
				rowLevelLimit = this.computeRowLevelLimit(row);
			}

			if (rowLevelLimit !== false) {
				this.limitRow(row, rowLevelLimit);
			}
		}
	},


	// Computes the number of levels a row will accomodate without going outside its bounds.
	// Assumes the row is "rigid" (maintains a constant height regardless of what is inside).
	// `row` is the row number.
	computeRowLevelLimit: function(row) {
		var rowEl = this.rowEls.eq(row); // the containing "fake" row div
		var rowHeight = rowEl.height(); // TODO: cache somehow?
		var trEls = this.rowStructs[row].tbodyEl.children();
		var i, trEl;
		var trHeight;

		function iterInnerHeights(i, childNode) {
			trHeight = Math.max(trHeight, $(childNode).outerHeight());
		}

		// Reveal one level <tr> at a time and stop when we find one out of bounds
		for (i = 0; i < trEls.length; i++) {
			trEl = trEls.eq(i).removeClass('fc-limited'); // reset to original state (reveal)

			// with rowspans>1 and IE8, trEl.outerHeight() would return the height of the largest cell,
			// so instead, find the tallest inner content element.
			trHeight = 0;
			trEl.find('> td > :first-child').each(iterInnerHeights);

			if (trEl.position().top + trHeight > rowHeight) {
				return i;
			}
		}

		return false; // should not limit at all
	},


	// Limits the given grid row to the maximum number of levels and injects "more" links if necessary.
	// `row` is the row number.
	// `levelLimit` is a number for the maximum (inclusive) number of levels allowed.
	limitRow: function(row, levelLimit) {
		var _this = this;
		var rowStruct = this.rowStructs[row];
		var moreNodes = []; // array of "more" <a> links and <td> DOM nodes
		var col = 0; // col #, left-to-right (not chronologically)
		var levelSegs; // array of segment objects in the last allowable level, ordered left-to-right
		var cellMatrix; // a matrix (by level, then column) of all <td> jQuery elements in the row
		var limitedNodes; // array of temporarily hidden level <tr> and segment <td> DOM nodes
		var i, seg;
		var segsBelow; // array of segment objects below `seg` in the current `col`
		var totalSegsBelow; // total number of segments below `seg` in any of the columns `seg` occupies
		var colSegsBelow; // array of segment arrays, below seg, one for each column (offset from segs's first column)
		var td, rowspan;
		var segMoreNodes; // array of "more" <td> cells that will stand-in for the current seg's cell
		var j;
		var moreTd, moreWrap, moreLink;

		// Iterates through empty level cells and places "more" links inside if need be
		function emptyCellsUntil(endCol) { // goes from current `col` to `endCol`
			while (col < endCol) {
				segsBelow = _this.getCellSegs(row, col, levelLimit);
				if (segsBelow.length) {
					td = cellMatrix[levelLimit - 1][col];
					moreLink = _this.renderMoreLink(row, col, segsBelow);
					moreWrap = $('<div/>').append(moreLink);
					td.append(moreWrap);
					moreNodes.push(moreWrap[0]);
				}
				col++;
			}
		}

		if (levelLimit && levelLimit < rowStruct.segLevels.length) { // is it actually over the limit?
			levelSegs = rowStruct.segLevels[levelLimit - 1];
			cellMatrix = rowStruct.cellMatrix;

			limitedNodes = rowStruct.tbodyEl.children().slice(levelLimit) // get level <tr> elements past the limit
				.addClass('fc-limited').get(); // hide elements and get a simple DOM-nodes array

			// iterate though segments in the last allowable level
			for (i = 0; i < levelSegs.length; i++) {
				seg = levelSegs[i];
				emptyCellsUntil(seg.leftCol); // process empty cells before the segment

				// determine *all* segments below `seg` that occupy the same columns
				colSegsBelow = [];
				totalSegsBelow = 0;
				while (col <= seg.rightCol) {
					segsBelow = this.getCellSegs(row, col, levelLimit);
					colSegsBelow.push(segsBelow);
					totalSegsBelow += segsBelow.length;
					col++;
				}

				if (totalSegsBelow) { // do we need to replace this segment with one or many "more" links?
					td = cellMatrix[levelLimit - 1][seg.leftCol]; // the segment's parent cell
					rowspan = td.attr('rowspan') || 1;
					segMoreNodes = [];

					// make a replacement <td> for each column the segment occupies. will be one for each colspan
					for (j = 0; j < colSegsBelow.length; j++) {
						moreTd = $('<td class="fc-more-cell"/>').attr('rowspan', rowspan);
						segsBelow = colSegsBelow[j];
						moreLink = this.renderMoreLink(
							row,
							seg.leftCol + j,
							[ seg ].concat(segsBelow) // count seg as hidden too
						);
						moreWrap = $('<div/>').append(moreLink);
						moreTd.append(moreWrap);
						segMoreNodes.push(moreTd[0]);
						moreNodes.push(moreTd[0]);
					}

					td.addClass('fc-limited').after($(segMoreNodes)); // hide original <td> and inject replacements
					limitedNodes.push(td[0]);
				}
			}

			emptyCellsUntil(this.colCnt); // finish off the level
			rowStruct.moreEls = $(moreNodes); // for easy undoing later
			rowStruct.limitedEls = $(limitedNodes); // for easy undoing later
		}
	},


	// Reveals all levels and removes all "more"-related elements for a grid's row.
	// `row` is a row number.
	unlimitRow: function(row) {
		var rowStruct = this.rowStructs[row];

		if (rowStruct.moreEls) {
			rowStruct.moreEls.remove();
			rowStruct.moreEls = null;
		}

		if (rowStruct.limitedEls) {
			rowStruct.limitedEls.removeClass('fc-limited');
			rowStruct.limitedEls = null;
		}
	},


	// Renders an <a> element that represents hidden event element for a cell.
	// Responsible for attaching click handler as well.
	renderMoreLink: function(row, col, hiddenSegs) {
		var _this = this;
		var view = this.view;

		return $('<a class="fc-more"/>')
			.text(
				this.getMoreLinkText(hiddenSegs.length)
			)
			.on('click', function(ev) {
				var clickOption = view.opt('eventLimitClick');
				var date = _this.getCellDate(row, col);
				var moreEl = $(this);
				var dayEl = _this.getCellEl(row, col);
				var allSegs = _this.getCellSegs(row, col);

				// rescope the segments to be within the cell's date
				var reslicedAllSegs = _this.resliceDaySegs(allSegs, date);
				var reslicedHiddenSegs = _this.resliceDaySegs(hiddenSegs, date);

				if (typeof clickOption === 'function') {
					// the returned value can be an atomic option
					clickOption = view.publiclyTrigger('eventLimitClick', null, {
						date: date,
						dayEl: dayEl,
						moreEl: moreEl,
						segs: reslicedAllSegs,
						hiddenSegs: reslicedHiddenSegs
					}, ev);
				}

				if (clickOption === 'popover') {
					_this.showSegPopover(row, col, moreEl, reslicedAllSegs);
				}
				else if (typeof clickOption === 'string') { // a view name
					view.calendar.zoomTo(date, clickOption);
				}
			});
	},


	// Reveals the popover that displays all events within a cell
	showSegPopover: function(row, col, moreLink, segs) {
		var _this = this;
		var view = this.view;
		var moreWrap = moreLink.parent(); // the <div> wrapper around the <a>
		var topEl; // the element we want to match the top coordinate of
		var options;

		if (this.rowCnt == 1) {
			topEl = view.el; // will cause the popover to cover any sort of header
		}
		else {
			topEl = this.rowEls.eq(row); // will align with top of row
		}

		options = {
			className: 'fc-more-popover',
			content: this.renderSegPopoverContent(row, col, segs),
			parentEl: this.view.el, // attach to root of view. guarantees outside of scrollbars.
			top: topEl.offset().top,
			autoHide: true, // when the user clicks elsewhere, hide the popover
			viewportConstrain: view.opt('popoverViewportConstrain'),
			hide: function() {
				// kill everything when the popover is hidden
				// notify events to be removed
				if (_this.popoverSegs) {
					var seg;
					for (var i = 0; i < _this.popoverSegs.length; ++i) {
						seg = _this.popoverSegs[i];
						view.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);
					}
				}
				_this.segPopover.removeElement();
				_this.segPopover = null;
				_this.popoverSegs = null;
			}
		};

		// Determine horizontal coordinate.
		// We use the moreWrap instead of the <td> to avoid border confusion.
		if (this.isRTL) {
			options.right = moreWrap.offset().left + moreWrap.outerWidth() + 1; // +1 to be over cell border
		}
		else {
			options.left = moreWrap.offset().left - 1; // -1 to be over cell border
		}

		this.segPopover = new Popover(options);
		this.segPopover.show();

		// the popover doesn't live within the grid's container element, and thus won't get the event
		// delegated-handlers for free. attach event-related handlers to the popover.
		this.bindSegHandlersToEl(this.segPopover.el);
	},


	// Builds the inner DOM contents of the segment popover
	renderSegPopoverContent: function(row, col, segs) {
		var view = this.view;
		var isTheme = view.opt('theme');
		var title = this.getCellDate(row, col).format(view.opt('dayPopoverFormat'));
		var content = $(
			'<div class="fc-header ' + view.widgetHeaderClass + '">' +
				'<span class="fc-close ' +
					(isTheme ? 'ui-icon ui-icon-closethick' : 'fc-icon fc-icon-x') +
				'"></span>' +
				'<span class="fc-title">' +
					htmlEscape(title) +
				'</span>' +
				'<div class="fc-clear"/>' +
			'</div>' +
			'<div class="fc-body ' + view.widgetContentClass + '">' +
				'<div class="fc-event-container"></div>' +
			'</div>'
		);
		var segContainer = content.find('.fc-event-container');
		var i;

		// render each seg's `el` and only return the visible segs
		segs = this.renderFgSegEls(segs, true); // disableResizing=true
		this.popoverSegs = segs;

		for (i = 0; i < segs.length; i++) {

			// because segments in the popover are not part of a grid coordinate system, provide a hint to any
			// grids that want to do drag-n-drop about which cell it came from
			this.hitsNeeded();
			segs[i].hit = this.getCellHit(row, col);
			this.hitsNotNeeded();

			segContainer.append(segs[i].el);
		}

		return content;
	},


	// Given the events within an array of segment objects, reslice them to be in a single day
	resliceDaySegs: function(segs, dayDate) {

		// build an array of the original events
		var events = $.map(segs, function(seg) {
			return seg.event;
		});

		var dayStart = dayDate.clone();
		var dayEnd = dayStart.clone().add(1, 'days');
		var dayRange = { start: dayStart, end: dayEnd };

		// slice the events with a custom slicing function
		segs = this.eventsToSegs(
			events,
			function(range) {
				var seg = intersectRanges(range, dayRange); // undefind if no intersection
				return seg ? [ seg ] : []; // must return an array of segments
			}
		);

		// force an order because eventsToSegs doesn't guarantee one
		this.sortEventSegs(segs);

		return segs;
	},


	// Generates the text that should be inside a "more" link, given the number of events it represents
	getMoreLinkText: function(num) {
		var opt = this.view.opt('eventLimitText');

		if (typeof opt === 'function') {
			return opt(num);
		}
		else {
			return '+' + num + ' ' + opt;
		}
	},


	// Returns segments within a given cell.
	// If `startLevel` is specified, returns only events including and below that level. Otherwise returns all segs.
	getCellSegs: function(row, col, startLevel) {
		var segMatrix = this.rowStructs[row].segMatrix;
		var level = startLevel || 0;
		var segs = [];
		var seg;

		while (level < segMatrix.length) {
			seg = segMatrix[level][col];
			if (seg) {
				segs.push(seg);
			}
			level++;
		}

		return segs;
	}

});

;;

/* A component that renders one or more columns of vertical time slots
----------------------------------------------------------------------------------------------------------------------*/
// We mixin DayTable, even though there is only a single row of days

var TimeGrid = FC.TimeGrid = Grid.extend(DayTableMixin, {

	slotDuration: null, // duration of a "slot", a distinct time segment on given day, visualized by lines
	snapDuration: null, // granularity of time for dragging and selecting
	snapsPerSlot: null,
	labelFormat: null, // formatting string for times running along vertical axis
	labelInterval: null, // duration of how often a label should be displayed for a slot

	colEls: null, // cells elements in the day-row background
	slatContainerEl: null, // div that wraps all the slat rows
	slatEls: null, // elements running horizontally across all columns
	nowIndicatorEls: null,

	colCoordCache: null,
	slatCoordCache: null,


	constructor: function() {
		Grid.apply(this, arguments); // call the super-constructor

		this.processOptions();
	},


	// Renders the time grid into `this.el`, which should already be assigned.
	// Relies on the view's colCnt. In the future, this component should probably be self-sufficient.
	renderDates: function() {
		this.el.html(this.renderHtml());
		this.colEls = this.el.find('.fc-day, .fc-disabled-day');
		this.slatContainerEl = this.el.find('.fc-slats');
		this.slatEls = this.slatContainerEl.find('tr');

		this.colCoordCache = new CoordCache({
			els: this.colEls,
			isHorizontal: true
		});
		this.slatCoordCache = new CoordCache({
			els: this.slatEls,
			isVertical: true
		});

		this.renderContentSkeleton();
	},


	// Renders the basic HTML skeleton for the grid
	renderHtml: function() {
		return '' +
			'<div class="fc-bg">' +
				'<table>' +
					this.renderBgTrHtml(0) + // row=0
				'</table>' +
			'</div>' +
			'<div class="fc-slats">' +
				'<table>' +
					this.renderSlatRowHtml() +
				'</table>' +
			'</div>';
	},


	// Generates the HTML for the horizontal "slats" that run width-wise. Has a time axis on a side. Depends on RTL.
	renderSlatRowHtml: function() {
		var view = this.view;
		var isRTL = this.isRTL;
		var html = '';
		var slotTime = moment.duration(+this.view.minTime); // wish there was .clone() for durations
		var slotDate; // will be on the view's first day, but we only care about its time
		var isLabeled;
		var axisHtml;

		// Calculate the time for each slot
		while (slotTime < this.view.maxTime) {
			slotDate = this.start.clone().time(slotTime);
			isLabeled = isInt(divideDurationByDuration(slotTime, this.labelInterval));

			axisHtml =
				'<td class="fc-axis fc-time ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
					(isLabeled ?
						'<span>' + // for matchCellWidths
							htmlEscape(slotDate.format(this.labelFormat)) +
						'</span>' :
						''
						) +
				'</td>';

			html +=
				'<tr data-time="' + slotDate.format('HH:mm:ss') + '"' +
					(isLabeled ? '' : ' class="fc-minor"') +
					'>' +
					(!isRTL ? axisHtml : '') +
					'<td class="' + view.widgetContentClass + '"/>' +
					(isRTL ? axisHtml : '') +
				"</tr>";

			slotTime.add(this.slotDuration);
		}

		return html;
	},


	/* Options
	------------------------------------------------------------------------------------------------------------------*/


	// Parses various options into properties of this object
	processOptions: function() {
		var view = this.view;
		var slotDuration = view.opt('slotDuration');
		var snapDuration = view.opt('snapDuration');
		var input;

		slotDuration = moment.duration(slotDuration);
		snapDuration = snapDuration ? moment.duration(snapDuration) : slotDuration;

		this.slotDuration = slotDuration;
		this.snapDuration = snapDuration;
		this.snapsPerSlot = slotDuration / snapDuration; // TODO: ensure an integer multiple?

		this.minResizeDuration = snapDuration; // hack

		// might be an array value (for TimelineView).
		// if so, getting the most granular entry (the last one probably).
		input = view.opt('slotLabelFormat');
		if ($.isArray(input)) {
			input = input[input.length - 1];
		}

		this.labelFormat =
			input ||
			view.opt('smallTimeFormat'); // the computed default

		input = view.opt('slotLabelInterval');
		this.labelInterval = input ?
			moment.duration(input) :
			this.computeLabelInterval(slotDuration);
	},


	// Computes an automatic value for slotLabelInterval
	computeLabelInterval: function(slotDuration) {
		var i;
		var labelInterval;
		var slotsPerLabel;

		// find the smallest stock label interval that results in more than one slots-per-label
		for (i = AGENDA_STOCK_SUB_DURATIONS.length - 1; i >= 0; i--) {
			labelInterval = moment.duration(AGENDA_STOCK_SUB_DURATIONS[i]);
			slotsPerLabel = divideDurationByDuration(labelInterval, slotDuration);
			if (isInt(slotsPerLabel) && slotsPerLabel > 1) {
				return labelInterval;
			}
		}

		return moment.duration(slotDuration); // fall back. clone
	},


	// Computes a default event time formatting string if `timeFormat` is not explicitly defined
	computeEventTimeFormat: function() {
		return this.view.opt('noMeridiemTimeFormat'); // like "6:30" (no AM/PM)
	},


	// Computes a default `displayEventEnd` value if one is not expliclty defined
	computeDisplayEventEnd: function() {
		return true;
	},


	/* Hit System
	------------------------------------------------------------------------------------------------------------------*/


	prepareHits: function() {
		this.colCoordCache.build();
		this.slatCoordCache.build();
	},


	releaseHits: function() {
		this.colCoordCache.clear();
		// NOTE: don't clear slatCoordCache because we rely on it for computeTimeTop
	},


	queryHit: function(leftOffset, topOffset) {
		var snapsPerSlot = this.snapsPerSlot;
		var colCoordCache = this.colCoordCache;
		var slatCoordCache = this.slatCoordCache;

		if (colCoordCache.isLeftInBounds(leftOffset) && slatCoordCache.isTopInBounds(topOffset)) {
			var colIndex = colCoordCache.getHorizontalIndex(leftOffset);
			var slatIndex = slatCoordCache.getVerticalIndex(topOffset);

			if (colIndex != null && slatIndex != null) {
				var slatTop = slatCoordCache.getTopOffset(slatIndex);
				var slatHeight = slatCoordCache.getHeight(slatIndex);
				var partial = (topOffset - slatTop) / slatHeight; // floating point number between 0 and 1
				var localSnapIndex = Math.floor(partial * snapsPerSlot); // the snap # relative to start of slat
				var snapIndex = slatIndex * snapsPerSlot + localSnapIndex;
				var snapTop = slatTop + (localSnapIndex / snapsPerSlot) * slatHeight;
				var snapBottom = slatTop + ((localSnapIndex + 1) / snapsPerSlot) * slatHeight;

				return {
					col: colIndex,
					snap: snapIndex,
					component: this, // needed unfortunately :(
					left: colCoordCache.getLeftOffset(colIndex),
					right: colCoordCache.getRightOffset(colIndex),
					top: snapTop,
					bottom: snapBottom
				};
			}
		}
	},


	getHitSpan: function(hit) {
		var start = this.getCellDate(0, hit.col); // row=0
		var time = this.computeSnapTime(hit.snap); // pass in the snap-index
		var end;

		start.time(time);
		end = start.clone().add(this.snapDuration);

		return { start: start, end: end };
	},


	getHitEl: function(hit) {
		return this.colEls.eq(hit.col);
	},


	/* Dates
	------------------------------------------------------------------------------------------------------------------*/


	rangeUpdated: function() {
		this.updateDayTable();
	},


	// Given a row number of the grid, representing a "snap", returns a time (Duration) from its start-of-day
	computeSnapTime: function(snapIndex) {
		return moment.duration(this.view.minTime + this.snapDuration * snapIndex);
	},


	// Slices up the given span (unzoned start/end with other misc data) into an array of segments
	spanToSegs: function(span) {
		var segs = this.sliceRangeByTimes(span);
		var i;

		for (i = 0; i < segs.length; i++) {
			if (this.isRTL) {
				segs[i].col = this.daysPerRow - 1 - segs[i].dayIndex;
			}
			else {
				segs[i].col = segs[i].dayIndex;
			}
		}

		return segs;
	},


	sliceRangeByTimes: function(range) {
		var segs = [];
		var seg;
		var dayIndex;
		var dayDate;
		var dayRange;

		for (dayIndex = 0; dayIndex < this.daysPerRow; dayIndex++) {
			dayDate = this.dayDates[dayIndex].clone().time(0); // TODO: better API for this?
			dayRange = {
				start: dayDate.clone().add(this.view.minTime), // don't use .time() because it sux with negatives
				end: dayDate.clone().add(this.view.maxTime)
			};
			seg = intersectRanges(range, dayRange); // both will be ambig timezone
			if (seg) {
				seg.dayIndex = dayIndex;
				segs.push(seg);
			}
		}

		return segs;
	},


	/* Coordinates
	------------------------------------------------------------------------------------------------------------------*/


	updateSize: function(isResize) { // NOT a standard Grid method
		this.slatCoordCache.build();

		if (isResize) {
			this.updateSegVerticals(
				[].concat(this.fgSegs || [], this.bgSegs || [], this.businessSegs || [])
			);
		}
	},


	getTotalSlatHeight: function() {
		return this.slatContainerEl.outerHeight();
	},


	// Computes the top coordinate, relative to the bounds of the grid, of the given date.
	// A `startOfDayDate` must be given for avoiding ambiguity over how to treat midnight.
	computeDateTop: function(date, startOfDayDate) {
		return this.computeTimeTop(
			moment.duration(
				date - startOfDayDate.clone().stripTime()
			)
		);
	},


	// Computes the top coordinate, relative to the bounds of the grid, of the given time (a Duration).
	computeTimeTop: function(time) {
		var len = this.slatEls.length;
		var slatCoverage = (time - this.view.minTime) / this.slotDuration; // floating-point value of # of slots covered
		var slatIndex;
		var slatRemainder;

		// compute a floating-point number for how many slats should be progressed through.
		// from 0 to number of slats (inclusive)
		// constrained because minTime/maxTime might be customized.
		slatCoverage = Math.max(0, slatCoverage);
		slatCoverage = Math.min(len, slatCoverage);

		// an integer index of the furthest whole slat
		// from 0 to number slats (*exclusive*, so len-1)
		slatIndex = Math.floor(slatCoverage);
		slatIndex = Math.min(slatIndex, len - 1);

		// how much further through the slatIndex slat (from 0.0-1.0) must be covered in addition.
		// could be 1.0 if slatCoverage is covering *all* the slots
		slatRemainder = slatCoverage - slatIndex;

		return this.slatCoordCache.getTopPosition(slatIndex) +
			this.slatCoordCache.getHeight(slatIndex) * slatRemainder;
	},



	/* Event Drag Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being dragged over the specified date(s).
	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(eventLocation, seg) {
		var eventSpans;
		var i;

		if (seg) { // if there is event information for this drag, render a helper event

			// returns mock event elements
			// signal that a helper has been rendered
			return this.renderEventLocationHelper(eventLocation, seg);
		}
		else { // otherwise, just render a highlight
			eventSpans = this.eventToSpans(eventLocation);

			for (i = 0; i < eventSpans.length; i++) {
				this.renderHighlight(eventSpans[i]);
			}
		}
	},


	// Unrenders any visual indication of an event being dragged
	unrenderDrag: function() {
		this.unrenderHelper();
		this.unrenderHighlight();
	},


	/* Event Resize Visualization
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of an event being resized
	renderEventResize: function(eventLocation, seg) {
		return this.renderEventLocationHelper(eventLocation, seg); // returns mock event elements
	},


	// Unrenders any visual indication of an event being resized
	unrenderEventResize: function() {
		this.unrenderHelper();
	},


	/* Event Helper
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a mock "helper" event. `sourceSeg` is the original segment object and might be null (an external drag)
	renderHelper: function(event, sourceSeg) {
		return this.renderHelperSegs(this.eventToSegs(event), sourceSeg); // returns mock event elements
	},


	// Unrenders any mock helper event
	unrenderHelper: function() {
		this.unrenderHelperSegs();
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
		this.renderBusinessSegs(
			this.buildBusinessHourSegs()
		);
	},


	unrenderBusinessHours: function() {
		this.unrenderBusinessSegs();
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
		return 'minute'; // will refresh on the minute
	},


	renderNowIndicator: function(date) {
		// seg system might be overkill, but it handles scenario where line needs to be rendered
		//  more than once because of columns with the same date (resources columns for example)
		var segs = this.spanToSegs({ start: date, end: date });
		var top = this.computeDateTop(date, date);
		var nodes = [];
		var i;

		// render lines within the columns
		for (i = 0; i < segs.length; i++) {
			nodes.push($('<div class="fc-now-indicator fc-now-indicator-line"></div>')
				.css('top', top)
				.appendTo(this.colContainerEls.eq(segs[i].col))[0]);
		}

		// render an arrow over the axis
		if (segs.length > 0) { // is the current time in view?
			nodes.push($('<div class="fc-now-indicator fc-now-indicator-arrow"></div>')
				.css('top', top)
				.appendTo(this.el.find('.fc-content-skeleton'))[0]);
		}

		this.nowIndicatorEls = $(nodes);
	},


	unrenderNowIndicator: function() {
		if (this.nowIndicatorEls) {
			this.nowIndicatorEls.remove();
			this.nowIndicatorEls = null;
		}
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection. Overrides the default, which was to simply render a highlight.
	renderSelection: function(span) {
		if (this.view.opt('selectHelper')) { // this setting signals that a mock helper event should be rendered

			// normally acceps an eventLocation, span has a start/end, which is good enough
			this.renderEventLocationHelper(span);
		}
		else {
			this.renderHighlight(span);
		}
	},


	// Unrenders any visual indication of a selection
	unrenderSelection: function() {
		this.unrenderHelper();
		this.unrenderHighlight();
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	renderHighlight: function(span) {
		this.renderHighlightSegs(this.spanToSegs(span));
	},


	unrenderHighlight: function() {
		this.unrenderHighlightSegs();
	}

});

;;

/* Methods for rendering SEGMENTS, pieces of content that live on the view
 ( this file is no longer just for events )
----------------------------------------------------------------------------------------------------------------------*/

TimeGrid.mixin({

	colContainerEls: null, // containers for each column

	// inner-containers for each column where different types of segs live
	fgContainerEls: null,
	bgContainerEls: null,
	helperContainerEls: null,
	highlightContainerEls: null,
	businessContainerEls: null,

	// arrays of different types of displayed segments
	fgSegs: null,
	bgSegs: null,
	helperSegs: null,
	highlightSegs: null,
	businessSegs: null,


	// Renders the DOM that the view's content will live in
	renderContentSkeleton: function() {
		var cellHtml = '';
		var i;
		var skeletonEl;

		for (i = 0; i < this.colCnt; i++) {
			cellHtml +=
				'<td>' +
					'<div class="fc-content-col">' +
						'<div class="fc-event-container fc-helper-container"></div>' +
						'<div class="fc-event-container"></div>' +
						'<div class="fc-highlight-container"></div>' +
						'<div class="fc-bgevent-container"></div>' +
						'<div class="fc-business-container"></div>' +
					'</div>' +
				'</td>';
		}

		skeletonEl = $(
			'<div class="fc-content-skeleton">' +
				'<table>' +
					'<tr>' + cellHtml + '</tr>' +
				'</table>' +
			'</div>'
		);

		this.colContainerEls = skeletonEl.find('.fc-content-col');
		this.helperContainerEls = skeletonEl.find('.fc-helper-container');
		this.fgContainerEls = skeletonEl.find('.fc-event-container:not(.fc-helper-container)');
		this.bgContainerEls = skeletonEl.find('.fc-bgevent-container');
		this.highlightContainerEls = skeletonEl.find('.fc-highlight-container');
		this.businessContainerEls = skeletonEl.find('.fc-business-container');

		this.bookendCells(skeletonEl.find('tr')); // TODO: do this on string level
		this.el.append(skeletonEl);
	},


	/* Foreground Events
	------------------------------------------------------------------------------------------------------------------*/


	renderFgSegs: function(segs) {
		segs = this.renderFgSegsIntoContainers(segs, this.fgContainerEls);
		this.fgSegs = segs;
		return segs; // needed for Grid::renderEvents
	},


	unrenderFgSegs: function() {
		this.unrenderNamedSegs('fgSegs');
	},


	/* Foreground Helper Events
	------------------------------------------------------------------------------------------------------------------*/


	renderHelperSegs: function(segs, sourceSeg) {
		var helperEls = [];
		var i, seg;
		var sourceEl;

		segs = this.renderFgSegsIntoContainers(segs, this.helperContainerEls);

		// Try to make the segment that is in the same row as sourceSeg look the same
		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			if (sourceSeg && sourceSeg.col === seg.col) {
				sourceEl = sourceSeg.el;
				seg.el.css({
					left: sourceEl.css('left'),
					right: sourceEl.css('right'),
					'margin-left': sourceEl.css('margin-left'),
					'margin-right': sourceEl.css('margin-right')
				});
			}
			helperEls.push(seg.el[0]);
		}

		this.helperSegs = segs;

		return $(helperEls); // must return rendered helpers
	},


	unrenderHelperSegs: function() {
		this.unrenderNamedSegs('helperSegs');
	},


	/* Background Events
	------------------------------------------------------------------------------------------------------------------*/


	renderBgSegs: function(segs) {
		segs = this.renderFillSegEls('bgEvent', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.bgContainerEls);
		this.bgSegs = segs;
		return segs; // needed for Grid::renderEvents
	},


	unrenderBgSegs: function() {
		this.unrenderNamedSegs('bgSegs');
	},


	/* Highlight
	------------------------------------------------------------------------------------------------------------------*/


	renderHighlightSegs: function(segs) {
		segs = this.renderFillSegEls('highlight', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.highlightContainerEls);
		this.highlightSegs = segs;
	},


	unrenderHighlightSegs: function() {
		this.unrenderNamedSegs('highlightSegs');
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessSegs: function(segs) {
		segs = this.renderFillSegEls('businessHours', segs); // TODO: old fill system
		this.updateSegVerticals(segs);
		this.attachSegsByCol(this.groupSegsByCol(segs), this.businessContainerEls);
		this.businessSegs = segs;
	},


	unrenderBusinessSegs: function() {
		this.unrenderNamedSegs('businessSegs');
	},


	/* Seg Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given a flat array of segments, return an array of sub-arrays, grouped by each segment's col
	groupSegsByCol: function(segs) {
		var segsByCol = [];
		var i;

		for (i = 0; i < this.colCnt; i++) {
			segsByCol.push([]);
		}

		for (i = 0; i < segs.length; i++) {
			segsByCol[segs[i].col].push(segs[i]);
		}

		return segsByCol;
	},


	// Given segments grouped by column, insert the segments' elements into a parallel array of container
	// elements, each living within a column.
	attachSegsByCol: function(segsByCol, containerEls) {
		var col;
		var segs;
		var i;

		for (col = 0; col < this.colCnt; col++) { // iterate each column grouping
			segs = segsByCol[col];

			for (i = 0; i < segs.length; i++) {
				containerEls.eq(col).append(segs[i].el);
			}
		}
	},


	// Given the name of a property of `this` object, assumed to be an array of segments,
	// loops through each segment and removes from DOM. Will null-out the property afterwards.
	unrenderNamedSegs: function(propName) {
		var segs = this[propName];
		var i;

		if (segs) {
			for (i = 0; i < segs.length; i++) {
				segs[i].el.remove();
			}
			this[propName] = null;
		}
	},



	/* Foreground Event Rendering Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given an array of foreground segments, render a DOM element for each, computes position,
	// and attaches to the column inner-container elements.
	renderFgSegsIntoContainers: function(segs, containerEls) {
		var segsByCol;
		var col;

		segs = this.renderFgSegEls(segs); // will call fgSegHtml
		segsByCol = this.groupSegsByCol(segs);

		for (col = 0; col < this.colCnt; col++) {
			this.updateFgSegCoords(segsByCol[col]);
		}

		this.attachSegsByCol(segsByCol, containerEls);

		return segs;
	},


	// Renders the HTML for a single event segment's default rendering
	fgSegHtml: function(seg, disableResizing) {
		var view = this.view;
		var event = seg.event;
		var isDraggable = view.isEventDraggable(event);
		var isResizableFromStart = !disableResizing && seg.isStart && view.isEventResizableFromStart(event);
		var isResizableFromEnd = !disableResizing && seg.isEnd && view.isEventResizableFromEnd(event);
		var classes = this.getSegClasses(seg, isDraggable, isResizableFromStart || isResizableFromEnd);
		var skinCss = cssToStr(this.getSegSkinCss(seg));
		var timeText;
		var fullTimeText; // more verbose time text. for the print stylesheet
		var startTimeText; // just the start time text

		classes.unshift('fc-time-grid-event', 'fc-v-event');

		if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day...
			// Don't display time text on segments that run entirely through a day.
			// That would appear as midnight-midnight and would look dumb.
			// Otherwise, display the time text for the *segment's* times (like 6pm-midnight or midnight-10am)
			if (seg.isStart || seg.isEnd) {
				timeText = this.getEventTimeText(seg);
				fullTimeText = this.getEventTimeText(seg, 'LT');
				startTimeText = this.getEventTimeText(seg, null, false); // displayEnd=false
			}
		} else {
			// Display the normal time text for the *event's* times
			timeText = this.getEventTimeText(event);
			fullTimeText = this.getEventTimeText(event, 'LT');
			startTimeText = this.getEventTimeText(event, null, false); // displayEnd=false
		}

		return '<a class="' + classes.join(' ') + '"' +
			(event.url ?
				' href="' + htmlEscape(event.url) + '"' :
				''
				) +
			(skinCss ?
				' style="' + skinCss + '"' :
				''
				) +
			'>' +
				'<div class="fc-content">' +
					(timeText ?
						'<div class="fc-time"' +
						' data-start="' + htmlEscape(startTimeText) + '"' +
						' data-full="' + htmlEscape(fullTimeText) + '"' +
						'>' +
							'<span>' + htmlEscape(timeText) + '</span>' +
						'</div>' :
						''
						) +
					(event.title ?
						'<div class="fc-title">' +
							htmlEscape(event.title) + 
						'</div>' :
						''
						) +
				'</div>' +
				'<div class="fc-bg"/>' +
				/* TODO: write CSS for this
				(isResizableFromStart ?
					'<div class="fc-resizer fc-start-resizer" />' :
					''
					) +
				*/
				(isResizableFromEnd ?
					'<div class="fc-resizer fc-end-resizer" />' :
					''
					) +
			'</a>';
	},


	/* Seg Position Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes the CSS top/bottom coordinates for each segment element.
	// Works when called after initial render, after a window resize/zoom for example.
	updateSegVerticals: function(segs) {
		this.computeSegVerticals(segs);
		this.assignSegVerticals(segs);
	},


	// For each segment in an array, computes and assigns its top and bottom properties
	computeSegVerticals: function(segs) {
		var i, seg;
		var dayDate;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			dayDate = this.dayDates[seg.dayIndex];

			seg.top = this.computeDateTop(seg.start, dayDate);
			seg.bottom = this.computeDateTop(seg.end, dayDate);
		}
	},


	// Given segments that already have their top/bottom properties computed, applies those values to
	// the segments' elements.
	assignSegVerticals: function(segs) {
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			seg.el.css(this.generateSegVerticalCss(seg));
		}
	},


	// Generates an object with CSS properties for the top/bottom coordinates of a segment element
	generateSegVerticalCss: function(seg) {
		return {
			top: seg.top,
			bottom: -seg.bottom // flipped because needs to be space beyond bottom edge of event container
		};
	},


	/* Foreground Event Positioning Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Given segments that are assumed to all live in the *same column*,
	// compute their verical/horizontal coordinates and assign to their elements.
	updateFgSegCoords: function(segs) {
		this.computeSegVerticals(segs); // horizontals relies on this
		this.computeFgSegHorizontals(segs); // compute horizontal coordinates, z-index's, and reorder the array
		this.assignSegVerticals(segs);
		this.assignFgSegHorizontals(segs);
	},


	// Given an array of segments that are all in the same column, sets the backwardCoord and forwardCoord on each.
	// NOTE: Also reorders the given array by date!
	computeFgSegHorizontals: function(segs) {
		var levels;
		var level0;
		var i;

		this.sortEventSegs(segs); // order by certain criteria
		levels = buildSlotSegLevels(segs);
		computeForwardSlotSegs(levels);

		if ((level0 = levels[0])) {

			for (i = 0; i < level0.length; i++) {
				computeSlotSegPressures(level0[i]);
			}

			for (i = 0; i < level0.length; i++) {
				this.computeFgSegForwardBack(level0[i], 0, 0);
			}
		}
	},


	// Calculate seg.forwardCoord and seg.backwardCoord for the segment, where both values range
	// from 0 to 1. If the calendar is left-to-right, the seg.backwardCoord maps to "left" and
	// seg.forwardCoord maps to "right" (via percentage). Vice-versa if the calendar is right-to-left.
	//
	// The segment might be part of a "series", which means consecutive segments with the same pressure
	// who's width is unknown until an edge has been hit. `seriesBackwardPressure` is the number of
	// segments behind this one in the current series, and `seriesBackwardCoord` is the starting
	// coordinate of the first segment in the series.
	computeFgSegForwardBack: function(seg, seriesBackwardPressure, seriesBackwardCoord) {
		var forwardSegs = seg.forwardSegs;
		var i;

		if (seg.forwardCoord === undefined) { // not already computed

			if (!forwardSegs.length) {

				// if there are no forward segments, this segment should butt up against the edge
				seg.forwardCoord = 1;
			}
			else {

				// sort highest pressure first
				this.sortForwardSegs(forwardSegs);

				// this segment's forwardCoord will be calculated from the backwardCoord of the
				// highest-pressure forward segment.
				this.computeFgSegForwardBack(forwardSegs[0], seriesBackwardPressure + 1, seriesBackwardCoord);
				seg.forwardCoord = forwardSegs[0].backwardCoord;
			}

			// calculate the backwardCoord from the forwardCoord. consider the series
			seg.backwardCoord = seg.forwardCoord -
				(seg.forwardCoord - seriesBackwardCoord) / // available width for series
				(seriesBackwardPressure + 1); // # of segments in the series

			// use this segment's coordinates to computed the coordinates of the less-pressurized
			// forward segments
			for (i=0; i<forwardSegs.length; i++) {
				this.computeFgSegForwardBack(forwardSegs[i], 0, seg.forwardCoord);
			}
		}
	},


	sortForwardSegs: function(forwardSegs) {
		forwardSegs.sort(proxy(this, 'compareForwardSegs'));
	},


	// A cmp function for determining which forward segment to rely on more when computing coordinates.
	compareForwardSegs: function(seg1, seg2) {
		// put higher-pressure first
		return seg2.forwardPressure - seg1.forwardPressure ||
			// put segments that are closer to initial edge first (and favor ones with no coords yet)
			(seg1.backwardCoord || 0) - (seg2.backwardCoord || 0) ||
			// do normal sorting...
			this.compareEventSegs(seg1, seg2);
	},


	// Given foreground event segments that have already had their position coordinates computed,
	// assigns position-related CSS values to their elements.
	assignFgSegHorizontals: function(segs) {
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			seg.el.css(this.generateFgSegHorizontalCss(seg));

			// if the height is short, add a className for alternate styling
			if (seg.bottom - seg.top < 30) {
				seg.el.addClass('fc-short');
			}
		}
	},


	// Generates an object with CSS properties/values that should be applied to an event segment element.
	// Contains important positioning-related properties that should be applied to any event element, customized or not.
	generateFgSegHorizontalCss: function(seg) {
		var shouldOverlap = this.view.opt('slotEventOverlap');
		var backwardCoord = seg.backwardCoord; // the left side if LTR. the right side if RTL. floating-point
		var forwardCoord = seg.forwardCoord; // the right side if LTR. the left side if RTL. floating-point
		var props = this.generateSegVerticalCss(seg); // get top/bottom first
		var left; // amount of space from left edge, a fraction of the total width
		var right; // amount of space from right edge, a fraction of the total width

		if (shouldOverlap) {
			// double the width, but don't go beyond the maximum forward coordinate (1.0)
			forwardCoord = Math.min(1, backwardCoord + (forwardCoord - backwardCoord) * 2);
		}

		if (this.isRTL) {
			left = 1 - forwardCoord;
			right = backwardCoord;
		}
		else {
			left = backwardCoord;
			right = 1 - forwardCoord;
		}

		props.zIndex = seg.level + 1; // convert from 0-base to 1-based
		props.left = left * 100 + '%';
		props.right = right * 100 + '%';

		if (shouldOverlap && seg.forwardPressure) {
			// add padding to the edge so that forward stacked events don't cover the resizer's icon
			props[this.isRTL ? 'marginLeft' : 'marginRight'] = 10 * 2; // 10 is a guesstimate of the icon's width
		}

		return props;
	}

});


// Builds an array of segments "levels". The first level will be the leftmost tier of segments if the calendar is
// left-to-right, or the rightmost if the calendar is right-to-left. Assumes the segments are already ordered by date.
function buildSlotSegLevels(segs) {
	var levels = [];
	var i, seg;
	var j;

	for (i=0; i<segs.length; i++) {
		seg = segs[i];

		// go through all the levels and stop on the first level where there are no collisions
		for (j=0; j<levels.length; j++) {
			if (!computeSlotSegCollisions(seg, levels[j]).length) {
				break;
			}
		}

		seg.level = j;

		(levels[j] || (levels[j] = [])).push(seg);
	}

	return levels;
}


// For every segment, figure out the other segments that are in subsequent
// levels that also occupy the same vertical space. Accumulate in seg.forwardSegs
function computeForwardSlotSegs(levels) {
	var i, level;
	var j, seg;
	var k;

	for (i=0; i<levels.length; i++) {
		level = levels[i];

		for (j=0; j<level.length; j++) {
			seg = level[j];

			seg.forwardSegs = [];
			for (k=i+1; k<levels.length; k++) {
				computeSlotSegCollisions(seg, levels[k], seg.forwardSegs);
			}
		}
	}
}


// Figure out which path forward (via seg.forwardSegs) results in the longest path until
// the furthest edge is reached. The number of segments in this path will be seg.forwardPressure
function computeSlotSegPressures(seg) {
	var forwardSegs = seg.forwardSegs;
	var forwardPressure = 0;
	var i, forwardSeg;

	if (seg.forwardPressure === undefined) { // not already computed

		for (i=0; i<forwardSegs.length; i++) {
			forwardSeg = forwardSegs[i];

			// figure out the child's maximum forward path
			computeSlotSegPressures(forwardSeg);

			// either use the existing maximum, or use the child's forward pressure
			// plus one (for the forwardSeg itself)
			forwardPressure = Math.max(
				forwardPressure,
				1 + forwardSeg.forwardPressure
			);
		}

		seg.forwardPressure = forwardPressure;
	}
}


// Find all the segments in `otherSegs` that vertically collide with `seg`.
// Append into an optionally-supplied `results` array and return.
function computeSlotSegCollisions(seg, otherSegs, results) {
	results = results || [];

	for (var i=0; i<otherSegs.length; i++) {
		if (isSlotSegCollision(seg, otherSegs[i])) {
			results.push(otherSegs[i]);
		}
	}

	return results;
}


// Do these segments occupy the same vertical space?
function isSlotSegCollision(seg1, seg2) {
	return seg1.bottom > seg2.top && seg1.top < seg2.bottom;
}

;;

/* An abstract class from which other views inherit from
----------------------------------------------------------------------------------------------------------------------*/

var View = FC.View = Class.extend(EmitterMixin, ListenerMixin, {

	type: null, // subclass' view name (string)
	name: null, // deprecated. use `type` instead
	title: null, // the text that will be displayed in the header's title

	calendar: null, // owner Calendar object
	viewSpec: null,
	options: null, // hash containing all options. already merged with view-specific-options
	el: null, // the view's containing element. set by Calendar

	isDateSet: false,
	isDateRendered: false,
	dateRenderQueue: null,

	isEventsBound: false,
	isEventsSet: false,
	isEventsRendered: false,
	eventRenderQueue: null,

	isRTL: false,
	isSelected: false, // boolean whether a range of time is user-selected or not
	selectedEvent: null,

	eventOrderSpecs: null, // criteria for ordering events when they have same date/time

	// classNames styled by jqui themes
	widgetHeaderClass: null,
	widgetContentClass: null,
	highlightStateClass: null,

	// for date utils, computed from options
	nextDayThreshold: null,
	isHiddenDayHash: null,

	// now indicator
	isNowIndicatorRendered: null,
	initialNowDate: null, // result first getNow call
	initialNowQueriedMs: null, // ms time the getNow was called
	nowIndicatorTimeoutID: null, // for refresh timing of now indicator
	nowIndicatorIntervalID: null, // "


	constructor: function(calendar, viewSpec) {

		this.calendar = calendar;
		this.viewSpec = viewSpec;

		// shortcuts
		this.type = viewSpec.type;
		this.options = viewSpec.options;

		// .name is deprecated
		this.name = this.type;

		this.nextDayThreshold = moment.duration(this.opt('nextDayThreshold'));
		this.initThemingProps();
		this.initHiddenDays();
		this.isRTL = this.opt('isRTL');

		this.eventOrderSpecs = parseFieldSpecs(this.opt('eventOrder'));

		this.dateRenderQueue = new TaskQueue();
		this.eventRenderQueue = new TaskQueue(this.opt('eventRenderWait'));

		this.initialize();
	},


	// A good place for subclasses to initialize member variables
	initialize: function() {
		// subclasses can implement
	},


	// Retrieves an option with the given name
	opt: function(name) {
		return this.options[name];
	},


	// Triggers handlers that are view-related. Modifies args before passing to calendar.
	publiclyTrigger: function(name, thisObj) { // arguments beyond thisObj are passed along
		var calendar = this.calendar;

		return calendar.publiclyTrigger.apply(
			calendar,
			[name, thisObj || this].concat(
				Array.prototype.slice.call(arguments, 2), // arguments beyond thisObj
				[ this ] // always make the last argument a reference to the view. TODO: deprecate
			)
		);
	},


	// Returns a proxy of the given promise that will be rejected if the given event fires
	// before the promise resolves.
	rejectOn: function(eventName, promise) {
		var _this = this;

		return new Promise(function(resolve, reject) {
			_this.one(eventName, reject);

			function cleanup() {
				_this.off(eventName, reject);
			}

			promise.then(function(res) { // success
				cleanup();
				resolve(res);
			}, function() { // failure
				cleanup();
				reject();
			});
		});
	},


	/* Title and Date Formatting
	------------------------------------------------------------------------------------------------------------------*/


	// Sets the view's title property to the most updated computed value
	updateTitle: function() {
		this.title = this.computeTitle();
		this.calendar.setToolbarsTitle(this.title);
	},


	// Computes what the title at the top of the calendar should be for this view
	computeTitle: function() {
		var range;

		// for views that span a large unit of time, show the proper interval, ignoring stray days before and after
		if (/^(year|month)$/.test(this.currentRangeUnit)) {
			range = this.currentRange;
		}
		else { // for day units or smaller, use the actual day range
			range = this.activeRange;
		}

		return this.formatRange(
			{
				// in case currentRange has a time, make sure timezone is correct
				start: this.calendar.applyTimezone(range.start),
				end: this.calendar.applyTimezone(range.end)
			},
			this.opt('titleFormat') || this.computeTitleFormat(),
			this.opt('titleRangeSeparator')
		);
	},


	// Generates the format string that should be used to generate the title for the current date range.
	// Attempts to compute the most appropriate format if not explicitly specified with `titleFormat`.
	computeTitleFormat: function() {
		if (this.currentRangeUnit == 'year') {
			return 'YYYY';
		}
		else if (this.currentRangeUnit == 'month') {
			return this.opt('monthYearFormat'); // like "September 2014"
		}
		else if (this.currentRangeAs('days') > 1) {
			return 'll'; // multi-day range. shorter, like "Sep 9 - 10 2014"
		}
		else {
			return 'LL'; // one day. longer, like "September 9 2014"
		}
	},


	// Utility for formatting a range. Accepts a range object, formatting string, and optional separator.
	// Displays all-day ranges naturally, with an inclusive end. Takes the current isRTL into account.
	// The timezones of the dates within `range` will be respected.
	formatRange: function(range, formatStr, separator) {
		var end = range.end;

		if (!end.hasTime()) { // all-day?
			end = end.clone().subtract(1); // convert to inclusive. last ms of previous day
		}

		return formatRange(range.start, end, formatStr, separator, this.opt('isRTL'));
	},


	getAllDayHtml: function() {
		return this.opt('allDayHtml') || htmlEscape(this.opt('allDayText'));
	},


	/* Navigation
	------------------------------------------------------------------------------------------------------------------*/


	// Generates HTML for an anchor to another view into the calendar.
	// Will either generate an <a> tag or a non-clickable <span> tag, depending on enabled settings.
	// `gotoOptions` can either be a moment input, or an object with the form:
	// { date, type, forceOff }
	// `type` is a view-type like "day" or "week". default value is "day".
	// `attrs` and `innerHtml` are use to generate the rest of the HTML tag.
	buildGotoAnchorHtml: function(gotoOptions, attrs, innerHtml) {
		var date, type, forceOff;
		var finalOptions;

		if ($.isPlainObject(gotoOptions)) {
			date = gotoOptions.date;
			type = gotoOptions.type;
			forceOff = gotoOptions.forceOff;
		}
		else {
			date = gotoOptions; // a single moment input
		}
		date = FC.moment(date); // if a string, parse it

		finalOptions = { // for serialization into the link
			date: date.format('YYYY-MM-DD'),
			type: type || 'day'
		};

		if (typeof attrs === 'string') {
			innerHtml = attrs;
			attrs = null;
		}

		attrs = attrs ? ' ' + attrsToStr(attrs) : ''; // will have a leading space
		innerHtml = innerHtml || '';

		if (!forceOff && this.opt('navLinks')) {
			return '<a' + attrs +
				' data-goto="' + htmlEscape(JSON.stringify(finalOptions)) + '">' +
				innerHtml +
				'</a>';
		}
		else {
			return '<span' + attrs + '>' +
				innerHtml +
				'</span>';
		}
	},


	// Rendering Non-date-related Content
	// -----------------------------------------------------------------------------------------------------------------


	// Sets the container element that the view should render inside of, does global DOM-related initializations,
	// and renders all the non-date-related content inside.
	setElement: function(el) {
		this.el = el;
		this.bindGlobalHandlers();
		this.renderSkeleton();
	},


	// Removes the view's container element from the DOM, clearing any content beforehand.
	// Undoes any other DOM-related attachments.
	removeElement: function() {
		this.unsetDate();
		this.unrenderSkeleton();

		this.unbindGlobalHandlers();

		this.el.remove();
		// NOTE: don't null-out this.el in case the View was destroyed within an API callback.
		// We don't null-out the View's other jQuery element references upon destroy,
		//  so we shouldn't kill this.el either.
	},


	// Renders the basic structure of the view before any content is rendered
	renderSkeleton: function() {
		// subclasses should implement
	},


	// Unrenders the basic structure of the view
	unrenderSkeleton: function() {
		// subclasses should implement
	},


	// Date Setting/Unsetting
	// -----------------------------------------------------------------------------------------------------------------


	setDate: function(date) {
		var isReset = this.isDateSet;

		this.isDateSet = true;
		this.handleRawDate(date);
		this.trigger(isReset ? 'dateReset' : 'dateSet', date);
	},


	unsetDate: function() {
		if (this.isDateSet) {
			this.isDateSet = false;
			this.handleDateUnset();
			this.trigger('dateUnset');
		}
	},


	// Date Handling
	// -----------------------------------------------------------------------------------------------------------------


	handleRawDate: function(date) {
		var _this = this;
		var dateProfile = this.buildDateProfile(date, null, true); // forceToValid=true

		if (!this.isSameDateProfile(dateProfile)) { // real change
			this.handleDate(dateProfile);
		}
		else {
			// View might have no date change, but still needs to render (because of a view unrender/rerender).
			// Wait for possible queued unrenders. TODO: refactor.
			this.dateRenderQueue.add(function() {
				if (!_this.isDateRendered) {
					_this.handleDate(dateProfile);
				}
			});
		}
	},


	handleDate: function(dateProfile) {
		var _this = this;

		this.unbindEvents(); // will do nothing if not already bound
		this.requestDateRender(dateProfile).then(function() {
			// wish we could start earlier, but setDateProfile needs to execute first
			_this.bindEvents(); // will request events
		});
	},


	handleDateUnset: function() {
		this.unbindEvents();
		this.requestDateUnrender();
	},


	// Date Render Queuing
	// -----------------------------------------------------------------------------------------------------------------


	// if dateProfile not specified, uses current
	requestDateRender: function(dateProfile) {
		var _this = this;

		return this.dateRenderQueue.add(function() {
			return _this.executeDateRender(dateProfile);
		});
	},


	requestDateUnrender: function() {
		var _this = this;

		return this.dateRenderQueue.add(function() {
			return _this.executeDateUnrender();
		});
	},


	// Date High-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// if dateProfile not specified, uses current
	executeDateRender: function(dateProfile) {
		var _this = this;

		if (dateProfile) {
			_this.setDateProfile(dateProfile);
		}

		this.updateTitle();
		this.calendar.updateToolbarButtons();

		// if rendering a new date, reset scroll to initial state (scrollTime)
		if (dateProfile) {
			this.captureInitialScroll();
		}
		else {
			this.captureScroll(); // a rerender of the current date
		}

		this.freezeHeight();

		// potential issue: date-unrendering will happen with the *new* range
		return this.executeDateUnrender().then(function() {

			if (_this.render) {
				_this.render(); // TODO: deprecate
			}

			_this.renderDates();
			_this.updateSize();
			_this.renderBusinessHours(); // might need coordinates, so should go after updateSize()
			_this.startNowIndicator();

			_this.thawHeight();
			_this.releaseScroll();

			_this.isDateRendered = true;
			_this.onDateRender();
			_this.trigger('dateRender');
		});
	},


	executeDateUnrender: function() {
		var _this = this;

		if (_this.isDateRendered) {
			return this.requestEventsUnrender().then(function() {

				_this.unselect();
				_this.stopNowIndicator();
				_this.triggerUnrender();
				_this.unrenderBusinessHours();
				_this.unrenderDates();

				if (_this.destroy) {
					_this.destroy(); // TODO: deprecate
				}

				_this.isDateRendered = false;
				_this.trigger('dateUnrender');
			});
		}
		else {
			return Promise.resolve();
		}
	},


	// Date Rendering Triggers
	// -----------------------------------------------------------------------------------------------------------------


	onDateRender: function() {
		this.triggerRender();
	},


	// Date Low-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// date-cell content only
	renderDates: function() {
		// subclasses should implement
	},


	// date-cell content only
	unrenderDates: function() {
		// subclasses should override
	},


	// Misc view rendering utils
	// -------------------------


	// Signals that the view's content has been rendered
	triggerRender: function() {
		this.publiclyTrigger('viewRender', this, this, this.el);
	},


	// Signals that the view's content is about to be unrendered
	triggerUnrender: function() {
		this.publiclyTrigger('viewDestroy', this, this, this.el);
	},


	// Binds DOM handlers to elements that reside outside the view container, such as the document
	bindGlobalHandlers: function() {
		this.listenTo(GlobalEmitter.get(), {
			touchstart: this.processUnselect,
			mousedown: this.handleDocumentMousedown
		});
	},


	// Unbinds DOM handlers from elements that reside outside the view container
	unbindGlobalHandlers: function() {
		this.stopListeningTo(GlobalEmitter.get());
	},


	// Initializes internal variables related to theming
	initThemingProps: function() {
		var tm = this.opt('theme') ? 'ui' : 'fc';

		this.widgetHeaderClass = tm + '-widget-header';
		this.widgetContentClass = tm + '-widget-content';
		this.highlightStateClass = tm + '-state-highlight';
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	// Renders business-hours onto the view. Assumes updateSize has already been called.
	renderBusinessHours: function() {
		// subclasses should implement
	},


	// Unrenders previously-rendered business-hours
	unrenderBusinessHours: function() {
		// subclasses should implement
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	// Immediately render the current time indicator and begins re-rendering it at an interval,
	// which is defined by this.getNowIndicatorUnit().
	// TODO: somehow do this for the current whole day's background too
	startNowIndicator: function() {
		var _this = this;
		var unit;
		var update;
		var delay; // ms wait value

		if (this.opt('nowIndicator')) {
			unit = this.getNowIndicatorUnit();
			if (unit) {
				update = proxy(this, 'updateNowIndicator'); // bind to `this`

				this.initialNowDate = this.calendar.getNow();
				this.initialNowQueriedMs = +new Date();
				this.renderNowIndicator(this.initialNowDate);
				this.isNowIndicatorRendered = true;

				// wait until the beginning of the next interval
				delay = this.initialNowDate.clone().startOf(unit).add(1, unit) - this.initialNowDate;
				this.nowIndicatorTimeoutID = setTimeout(function() {
					_this.nowIndicatorTimeoutID = null;
					update();
					delay = +moment.duration(1, unit);
					delay = Math.max(100, delay); // prevent too frequent
					_this.nowIndicatorIntervalID = setInterval(update, delay); // update every interval
				}, delay);
			}
		}
	},


	// rerenders the now indicator, computing the new current time from the amount of time that has passed
	// since the initial getNow call.
	updateNowIndicator: function() {
		if (this.isNowIndicatorRendered) {
			this.unrenderNowIndicator();
			this.renderNowIndicator(
				this.initialNowDate.clone().add(new Date() - this.initialNowQueriedMs) // add ms
			);
		}
	},


	// Immediately unrenders the view's current time indicator and stops any re-rendering timers.
	// Won't cause side effects if indicator isn't rendered.
	stopNowIndicator: function() {
		if (this.isNowIndicatorRendered) {

			if (this.nowIndicatorTimeoutID) {
				clearTimeout(this.nowIndicatorTimeoutID);
				this.nowIndicatorTimeoutID = null;
			}
			if (this.nowIndicatorIntervalID) {
				clearTimeout(this.nowIndicatorIntervalID);
				this.nowIndicatorIntervalID = null;
			}

			this.unrenderNowIndicator();
			this.isNowIndicatorRendered = false;
		}
	},


	// Returns a string unit, like 'second' or 'minute' that defined how often the current time indicator
	// should be refreshed. If something falsy is returned, no time indicator is rendered at all.
	getNowIndicatorUnit: function() {
		// subclasses should implement
	},


	// Renders a current time indicator at the given datetime
	renderNowIndicator: function(date) {
		// subclasses should implement
	},


	// Undoes the rendering actions from renderNowIndicator
	unrenderNowIndicator: function() {
		// subclasses should implement
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes anything dependant upon sizing of the container element of the grid
	updateSize: function(isResize) {

		if (isResize) {
			this.captureScroll();
		}

		this.updateHeight(isResize);
		this.updateWidth(isResize);
		this.updateNowIndicator();

		if (isResize) {
			this.releaseScroll();
		}
	},


	// Refreshes the horizontal dimensions of the calendar
	updateWidth: function(isResize) {
		// subclasses should implement
	},


	// Refreshes the vertical dimensions of the calendar
	updateHeight: function(isResize) {
		var calendar = this.calendar; // we poll the calendar for height information

		this.setHeight(
			calendar.getSuggestedViewHeight(),
			calendar.isHeightAuto()
		);
	},


	// Updates the vertical dimensions of the calendar to the specified height.
	// if `isAuto` is set to true, height becomes merely a suggestion and the view should use its "natural" height.
	setHeight: function(height, isAuto) {
		// subclasses should implement
	},


	/* Scroller
	------------------------------------------------------------------------------------------------------------------*/


	capturedScroll: null,
	capturedScrollDepth: 0,


	captureScroll: function() {
		if (!(this.capturedScrollDepth++)) {
			this.capturedScroll = this.isDateRendered ? this.queryScroll() : {}; // require a render first
			return true; // root?
		}
		return false;
	},


	captureInitialScroll: function(forcedScroll) {
		if (this.captureScroll()) { // root?
			this.capturedScroll.isInitial = true;

			if (forcedScroll) {
				$.extend(this.capturedScroll, forcedScroll);
			}
			else {
				this.capturedScroll.isComputed = true;
			}
		}
	},


	releaseScroll: function() {
		var scroll = this.capturedScroll;
		var isRoot = this.discardScroll();

		if (scroll.isComputed) {
			if (isRoot) {
				// only compute initial scroll if it will actually be used (is the root capture)
				$.extend(scroll, this.computeInitialScroll());
			}
			else {
				scroll = null; // scroll couldn't be computed. don't apply it to the DOM
			}
		}

		if (scroll) {
			// we act immediately on a releaseScroll operation, as opposed to captureScroll.
			// if capture/release wraps a render operation that screws up the scroll,
			// we still want to restore it a good state after, regardless of depth.

			if (scroll.isInitial) {
				this.hardSetScroll(scroll); // outsmart how browsers set scroll on initial DOM
			}
			else {
				this.setScroll(scroll);
			}
		}
	},


	discardScroll: function() {
		if (!(--this.capturedScrollDepth)) {
			this.capturedScroll = null;
			return true; // root?
		}
		return false;
	},


	computeInitialScroll: function() {
		return {};
	},


	queryScroll: function() {
		return {};
	},


	hardSetScroll: function(scroll) {
		var _this = this;
		var exec = function() { _this.setScroll(scroll); };
		exec();
		setTimeout(exec, 0); // to surely clear the browser's initial scroll for the DOM
	},


	setScroll: function(scroll) {
	},


	/* Height Freezing
	------------------------------------------------------------------------------------------------------------------*/


	freezeHeight: function() {
		this.calendar.freezeContentHeight();
	},


	thawHeight: function() {
		this.calendar.thawContentHeight();
	},


	// Event Binding/Unbinding
	// -----------------------------------------------------------------------------------------------------------------


	bindEvents: function() {
		var _this = this;

		if (!this.isEventsBound) {
			this.isEventsBound = true;
			this.rejectOn('eventsUnbind', this.requestEvents()).then(function(events) { // TODO: test rejection
				_this.listenTo(_this.calendar, 'eventsReset', _this.setEvents);
				_this.setEvents(events);
			});
		}
	},


	unbindEvents: function() {
		if (this.isEventsBound) {
			this.isEventsBound = false;
			this.stopListeningTo(this.calendar, 'eventsReset');
			this.unsetEvents();
			this.trigger('eventsUnbind');
		}
	},


	// Event Setting/Unsetting
	// -----------------------------------------------------------------------------------------------------------------


	setEvents: function(events) {
		var isReset = this.isEventSet;

		this.isEventsSet = true;
		this.handleEvents(events, isReset);
		this.trigger(isReset ? 'eventsReset' : 'eventsSet', events);
	},


	unsetEvents: function() {
		if (this.isEventsSet) {
			this.isEventsSet = false;
			this.handleEventsUnset();
			this.trigger('eventsUnset');
		}
	},


	whenEventsSet: function() {
		var _this = this;

		if (this.isEventsSet) {
			return Promise.resolve(this.getCurrentEvents());
		}
		else {
			return new Promise(function(resolve) {
				_this.one('eventsSet', resolve);
			});
		}
	},


	// Event Handling
	// -----------------------------------------------------------------------------------------------------------------


	handleEvents: function(events, isReset) {
		this.requestEventsRender(events);
	},


	handleEventsUnset: function() {
		this.requestEventsUnrender();
	},


	// Event Render Queuing
	// -----------------------------------------------------------------------------------------------------------------


	// assumes any previous event renders have been cleared already
	requestEventsRender: function(events) {
		var _this = this;

		return this.eventRenderQueue.add(function() { // might not return a promise if debounced!? bad
			return _this.executeEventsRender(events);
		});
	},


	requestEventsUnrender: function() {
		var _this = this;

		if (this.isEventsRendered) {
			return this.eventRenderQueue.addQuickly(function() {
				return _this.executeEventsUnrender();
			});
		}
		else {
			return Promise.resolve();
		}
	},


	requestCurrentEventsRender: function() {
		if (this.isEventsSet) {
			this.requestEventsRender(this.getCurrentEvents());
		}
		else {
			return Promise.reject();
		}
	},


	// Event High-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	executeEventsRender: function(events) {
		var _this = this;

		this.captureScroll();
		this.freezeHeight();

		return this.executeEventsUnrender().then(function() {
			_this.renderEvents(events);

			_this.thawHeight();
			_this.releaseScroll();

			_this.isEventsRendered = true;
			_this.onEventsRender();
			_this.trigger('eventsRender');
		});
	},


	executeEventsUnrender: function() {
		if (this.isEventsRendered) {
			this.onBeforeEventsUnrender();

			this.captureScroll();
			this.freezeHeight();

			if (this.destroyEvents) {
				this.destroyEvents(); // TODO: deprecate
			}

			this.unrenderEvents();

			this.thawHeight();
			this.releaseScroll();

			this.isEventsRendered = false;
			this.trigger('eventsUnrender');
		}

		return Promise.resolve(); // always synchronous
	},


	// Event Rendering Triggers
	// -----------------------------------------------------------------------------------------------------------------


	// Signals that all events have been rendered
	onEventsRender: function() {
		this.renderedEventSegEach(function(seg) {
			this.publiclyTrigger('eventAfterRender', seg.event, seg.event, seg.el);
		});
		this.publiclyTrigger('eventAfterAllRender');
	},


	// Signals that all event elements are about to be removed
	onBeforeEventsUnrender: function() {
		this.renderedEventSegEach(function(seg) {
			this.publiclyTrigger('eventDestroy', seg.event, seg.event, seg.el);
		});
	},


	// Event Low-level Rendering
	// -----------------------------------------------------------------------------------------------------------------


	// Renders the events onto the view.
	renderEvents: function(events) {
		// subclasses should implement
	},


	// Removes event elements from the view.
	unrenderEvents: function() {
		// subclasses should implement
	},


	// Event Data Access
	// -----------------------------------------------------------------------------------------------------------------


	requestEvents: function() {
		return this.calendar.requestEvents(
			this.activeRange.start,
			this.activeRange.end
		);
	},


	getCurrentEvents: function() {
		return this.calendar.getPrunedEventCache();
	},


	// Event Rendering Utils
	// -----------------------------------------------------------------------------------------------------------------


	// Given an event and the default element used for rendering, returns the element that should actually be used.
	// Basically runs events and elements through the eventRender hook.
	resolveEventEl: function(event, el) {
		var custom = this.publiclyTrigger('eventRender', event, event, el);

		if (custom === false) { // means don't render at all
			el = null;
		}
		else if (custom && custom !== true) {
			el = $(custom);
		}

		return el;
	},


	// Hides all rendered event segments linked to the given event
	showEvent: function(event) {
		this.renderedEventSegEach(function(seg) {
			seg.el.css('visibility', '');
		}, event);
	},


	// Shows all rendered event segments linked to the given event
	hideEvent: function(event) {
		this.renderedEventSegEach(function(seg) {
			seg.el.css('visibility', 'hidden');
		}, event);
	},


	// Iterates through event segments that have been rendered (have an el). Goes through all by default.
	// If the optional `event` argument is specified, only iterates through segments linked to that event.
	// The `this` value of the callback function will be the view.
	renderedEventSegEach: function(func, event) {
		var segs = this.getEventSegs();
		var i;

		for (i = 0; i < segs.length; i++) {
			if (!event || segs[i].event._id === event._id) {
				if (segs[i].el) {
					func.call(this, segs[i]);
				}
			}
		}
	},


	// Retrieves all the rendered segment objects for the view
	getEventSegs: function() {
		// subclasses must implement
		return [];
	},


	/* Event Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/


	// Computes if the given event is allowed to be dragged by the user
	isEventDraggable: function(event) {
		return this.isEventStartEditable(event);
	},


	isEventStartEditable: function(event) {
		return firstDefined(
			event.startEditable,
			(event.source || {}).startEditable,
			this.opt('eventStartEditable'),
			this.isEventGenerallyEditable(event)
		);
	},


	isEventGenerallyEditable: function(event) {
		return firstDefined(
			event.editable,
			(event.source || {}).editable,
			this.opt('editable')
		);
	},


	// Must be called when an event in the view is dropped onto new location.
	// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
	reportSegDrop: function(seg, dropLocation, largeUnit, el, ev) {
		var calendar = this.calendar;
		var mutateResult = calendar.mutateSeg(seg, dropLocation, largeUnit);
		var undoFunc = function() {
			mutateResult.undo();
			calendar.reportEventChange();
		};

		this.triggerEventDrop(seg.event, mutateResult.dateDelta, undoFunc, el, ev);
		calendar.reportEventChange(); // will rerender events
	},


	// Triggers event-drop handlers that have subscribed via the API
	triggerEventDrop: function(event, dateDelta, undoFunc, el, ev) {
		this.publiclyTrigger('eventDrop', el[0], event, dateDelta, undoFunc, ev, {}); // {} = jqui dummy
	},


	/* External Element Drag-n-Drop
	------------------------------------------------------------------------------------------------------------------*/


	// Must be called when an external element, via jQuery UI, has been dropped onto the calendar.
	// `meta` is the parsed data that has been embedded into the dragging event.
	// `dropLocation` is an object that contains the new zoned start/end/allDay values for the event.
	reportExternalDrop: function(meta, dropLocation, el, ev, ui) {
		var eventProps = meta.eventProps;
		var eventInput;
		var event;

		// Try to build an event object and render it. TODO: decouple the two
		if (eventProps) {
			eventInput = $.extend({}, eventProps, dropLocation);
			event = this.calendar.renderEvent(eventInput, meta.stick)[0]; // renderEvent returns an array
		}

		this.triggerExternalDrop(event, dropLocation, el, ev, ui);
	},


	// Triggers external-drop handlers that have subscribed via the API
	triggerExternalDrop: function(event, dropLocation, el, ev, ui) {

		// trigger 'drop' regardless of whether element represents an event
		this.publiclyTrigger('drop', el[0], dropLocation.start, ev, ui);

		if (event) {
			this.publiclyTrigger('eventReceive', null, event); // signal an external event landed
		}
	},


	/* Drag-n-Drop Rendering (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a event or external-element drag over the given drop zone.
	// If an external-element, seg will be `null`.
	// Must return elements used for any mock events.
	renderDrag: function(dropLocation, seg) {
		// subclasses must implement
	},


	// Unrenders a visual indication of an event or external-element being dragged.
	unrenderDrag: function() {
		// subclasses must implement
	},


	/* Event Resizing
	------------------------------------------------------------------------------------------------------------------*/


	// Computes if the given event is allowed to be resized from its starting edge
	isEventResizableFromStart: function(event) {
		return this.opt('eventResizableFromStart') && this.isEventResizable(event);
	},


	// Computes if the given event is allowed to be resized from its ending edge
	isEventResizableFromEnd: function(event) {
		return this.isEventResizable(event);
	},


	// Computes if the given event is allowed to be resized by the user at all
	isEventResizable: function(event) {
		var source = event.source || {};

		return firstDefined(
			event.durationEditable,
			source.durationEditable,
			this.opt('eventDurationEditable'),
			event.editable,
			source.editable,
			this.opt('editable')
		);
	},


	// Must be called when an event in the view has been resized to a new length
	reportSegResize: function(seg, resizeLocation, largeUnit, el, ev) {
		var calendar = this.calendar;
		var mutateResult = calendar.mutateSeg(seg, resizeLocation, largeUnit);
		var undoFunc = function() {
			mutateResult.undo();
			calendar.reportEventChange();
		};

		this.triggerEventResize(seg.event, mutateResult.durationDelta, undoFunc, el, ev);
		calendar.reportEventChange(); // will rerender events
	},


	// Triggers event-resize handlers that have subscribed via the API
	triggerEventResize: function(event, durationDelta, undoFunc, el, ev) {
		this.publiclyTrigger('eventResize', el[0], event, durationDelta, undoFunc, ev, {}); // {} = jqui dummy
	},


	/* Selection (time range)
	------------------------------------------------------------------------------------------------------------------*/


	// Selects a date span on the view. `start` and `end` are both Moments.
	// `ev` is the native mouse event that begin the interaction.
	select: function(span, ev) {
		this.unselect(ev);
		this.renderSelection(span);
		this.reportSelection(span, ev);
	},


	// Renders a visual indication of the selection
	renderSelection: function(span) {
		// subclasses should implement
	},


	// Called when a new selection is made. Updates internal state and triggers handlers.
	reportSelection: function(span, ev) {
		this.isSelected = true;
		this.triggerSelect(span, ev);
	},


	// Triggers handlers to 'select'
	triggerSelect: function(span, ev) {
		this.publiclyTrigger(
			'select',
			null,
			this.calendar.applyTimezone(span.start), // convert to calendar's tz for external API
			this.calendar.applyTimezone(span.end), // "
			ev
		);
	},


	// Undoes a selection. updates in the internal state and triggers handlers.
	// `ev` is the native mouse event that began the interaction.
	unselect: function(ev) {
		if (this.isSelected) {
			this.isSelected = false;
			if (this.destroySelection) {
				this.destroySelection(); // TODO: deprecate
			}
			this.unrenderSelection();
			this.publiclyTrigger('unselect', null, ev);
		}
	},


	// Unrenders a visual indication of selection
	unrenderSelection: function() {
		// subclasses should implement
	},


	/* Event Selection
	------------------------------------------------------------------------------------------------------------------*/


	selectEvent: function(event) {
		if (!this.selectedEvent || this.selectedEvent !== event) {
			this.unselectEvent();
			this.renderedEventSegEach(function(seg) {
				seg.el.addClass('fc-selected');
			}, event);
			this.selectedEvent = event;
		}
	},


	unselectEvent: function() {
		if (this.selectedEvent) {
			this.renderedEventSegEach(function(seg) {
				seg.el.removeClass('fc-selected');
			}, this.selectedEvent);
			this.selectedEvent = null;
		}
	},


	isEventSelected: function(event) {
		// event references might change on refetchEvents(), while selectedEvent doesn't,
		// so compare IDs
		return this.selectedEvent && this.selectedEvent._id === event._id;
	},


	/* Mouse / Touch Unselecting (time range & event unselection)
	------------------------------------------------------------------------------------------------------------------*/
	// TODO: move consistently to down/start or up/end?
	// TODO: don't kill previous selection if touch scrolling


	handleDocumentMousedown: function(ev) {
		if (isPrimaryMouseButton(ev)) {
			this.processUnselect(ev);
		}
	},


	processUnselect: function(ev) {
		this.processRangeUnselect(ev);
		this.processEventUnselect(ev);
	},


	processRangeUnselect: function(ev) {
		var ignore;

		// is there a time-range selection?
		if (this.isSelected && this.opt('unselectAuto')) {
			// only unselect if the clicked element is not identical to or inside of an 'unselectCancel' element
			ignore = this.opt('unselectCancel');
			if (!ignore || !$(ev.target).closest(ignore).length) {
				this.unselect(ev);
			}
		}
	},


	processEventUnselect: function(ev) {
		if (this.selectedEvent) {
			if (!$(ev.target).closest('.fc-selected').length) {
				this.unselectEvent();
			}
		}
	},


	/* Day Click
	------------------------------------------------------------------------------------------------------------------*/


	// Triggers handlers to 'dayClick'
	// Span has start/end of the clicked area. Only the start is useful.
	triggerDayClick: function(span, dayEl, ev) {
		this.publiclyTrigger(
			'dayClick',
			dayEl,
			this.calendar.applyTimezone(span.start), // convert to calendar's timezone for external API
			ev
		);
	},


	/* Date Utils
	------------------------------------------------------------------------------------------------------------------*/


	// Returns the date range of the full days the given range visually appears to occupy.
	// Returns a new range object.
	computeDayRange: function(range) {
		var startDay = range.start.clone().stripTime(); // the beginning of the day the range starts
		var end = range.end;
		var endDay = null;
		var endTimeMS;

		if (end) {
			endDay = end.clone().stripTime(); // the beginning of the day the range exclusively ends
			endTimeMS = +end.time(); // # of milliseconds into `endDay`

			// If the end time is actually inclusively part of the next day and is equal to or
			// beyond the next day threshold, adjust the end to be the exclusive end of `endDay`.
			// Otherwise, leaving it as inclusive will cause it to exclude `endDay`.
			if (endTimeMS && endTimeMS >= this.nextDayThreshold) {
				endDay.add(1, 'days');
			}
		}

		// If no end was specified, or if it is within `startDay` but not past nextDayThreshold,
		// assign the default duration of one day.
		if (!end || endDay <= startDay) {
			endDay = startDay.clone().add(1, 'days');
		}

		return { start: startDay, end: endDay };
	},


	// Does the given event visually appear to occupy more than one day?
	isMultiDayEvent: function(event) {
		var range = this.computeDayRange(event); // event is range-ish

		return range.end.diff(range.start, 'days') > 1;
	}

});

;;

View.mixin({

	// range the view is formally responsible for.
	// for example, a month view might have 1st-31st, excluding padded dates
	currentRange: null,
	currentRangeUnit: null, // name of largest unit being displayed, like "month" or "week"

	// date range with a rendered skeleton
	// includes not-active days that need some sort of DOM
	renderRange: null,

	// dates that display events and accept drag-n-drop
	activeRange: null,

	// constraint for where prev/next operations can go and where events can be dragged/resized to.
	// an object with optional start and end properties.
	validRange: null,

	// how far the current date will move for a prev/next operation
	dateIncrement: null,

	// stores the *calendar's* current date after setDate
	// TODO: entirely Calendar's responsibility
	currentDate: null,

	minTime: null, // Duration object that denotes the first visible time of any given day
	maxTime: null, // Duration object that denotes the exclusive visible end time of any given day
	usesMinMaxTime: false, // whether minTime/maxTime will affect the activeRange. Views must opt-in.

	// DEPRECATED
	start: null, // use activeRange.start
	end: null, // use activeRange.end
	intervalStart: null, // use currentRange.start
	intervalEnd: null, // use currentRange.end


	/* Date Range Computation
	------------------------------------------------------------------------------------------------------------------*/


	isSameDateProfile: function(dateProfile) {
		return this.activeRange && isRangesEqual(this.activeRange, dateProfile.activeRange);
	},


	setDateProfile: function(dateProfile) {
		this.currentRange = dateProfile.currentRange;
		this.currentRangeUnit = dateProfile.currentRangeUnit;
		this.renderRange = dateProfile.renderRange;
		this.activeRange = dateProfile.activeRange;
		this.validRange = dateProfile.validRange;
		this.dateIncrement = dateProfile.dateIncrement;
		this.currentDate = dateProfile.date;
		this.minTime = dateProfile.minTime;
		this.maxTime = dateProfile.maxTime;

		// DEPRECATED, but we need to keep it updated
		this.start = dateProfile.activeRange.start;
		this.end = dateProfile.activeRange.end;
		this.intervalStart = dateProfile.currentRange.start;
		this.intervalEnd = dateProfile.currentRange.end;
	},


	// Builds a structure with info about what the dates/ranges will be for the "prev" view.
	buildPrevDateProfile: function(date) {
		var prevDate = date.clone().startOf(this.currentRangeUnit).subtract(this.dateIncrement);

		return this.buildDateProfile(prevDate, -1);
	},


	// Builds a structure with info about what the dates/ranges will be for the "next" view.
	buildNextDateProfile: function(date) {
		var nextDate = date.clone().startOf(this.currentRangeUnit).add(this.dateIncrement);

		return this.buildDateProfile(nextDate, 1);
	},


	// Builds a structure holding dates/ranges for rendering around the given date.
	// Optional direction param indicates whether the date is being incremented/decremented
	// from its previous value. decremented = -1, incremented = 1 (default).
	buildDateProfile: function(date, direction, forceToValid) {
		var validRange = this.buildValidRange();
		var minTime = null;
		var maxTime = null;
		var currentInfo;
		var renderRange;
		var activeRange;
		var isValid;

		if (forceToValid) {
			date = constrainDate(date, validRange);
		}

		currentInfo = this.buildCurrentRangeInfo(date, direction);
		renderRange = this.buildRenderRange(currentInfo.range, currentInfo.unit);
		activeRange = cloneRange(renderRange);

		if (!this.opt('showNonCurrentDates')) {
			activeRange = constrainRange(activeRange, currentInfo.range);
		}

		minTime = moment.duration(this.opt('minTime'));
		maxTime = moment.duration(this.opt('maxTime'));
		this.adjustActiveRange(activeRange, minTime, maxTime);

		activeRange = constrainRange(activeRange, validRange);
		date = constrainDate(date, activeRange);

		// it's invalid if the originally requested date is not contained,
		// or if the range is completely outside of the valid range.
		isValid = doRangesIntersect(currentInfo.range, validRange);

		return {
			validRange: validRange,
			currentRange: currentInfo.range,
			currentRangeUnit: currentInfo.unit,
			activeRange: activeRange,
			renderRange: renderRange,
			minTime: minTime,
			maxTime: maxTime,
			isValid: isValid,
			date: date,
			dateIncrement: this.buildDateIncrement(currentInfo.duration)
				// pass a fallback (might be null) ^
		};
	},


	// Builds an object with optional start/end properties.
	// Indicates the minimum/maximum dates to display.
	buildValidRange: function() {
		return this.getRangeOption('validRange', this.calendar.getNow()) || {};
	},


	// Builds a structure with info about the "current" range, the range that is
	// highlighted as being the current month for example.
	// See buildDateProfile for a description of `direction`.
	// Guaranteed to have `range` and `unit` properties. `duration` is optional.
	buildCurrentRangeInfo: function(date, direction) {
		var duration = null;
		var unit = null;
		var range = null;
		var dayCount;

		if (this.viewSpec.duration) {
			duration = this.viewSpec.duration;
			unit = this.viewSpec.durationUnit;
			range = this.buildRangeFromDuration(date, direction, duration, unit);
		}
		else if ((dayCount = this.opt('dayCount'))) {
			unit = 'day';
			range = this.buildRangeFromDayCount(date, direction, dayCount);
		}
		else if ((range = this.buildCustomVisibleRange(date))) {
			unit = computeGreatestUnit(range.start, range.end);
		}
		else {
			duration = this.getFallbackDuration();
			unit = computeGreatestUnit(duration);
			range = this.buildRangeFromDuration(date, direction, duration, unit);
		}

		this.normalizeCurrentRange(range, unit); // modifies in-place

		return { duration: duration, unit: unit, range: range };
	},


	getFallbackDuration: function() {
		return moment.duration({ days: 1 });
	},


	// If the range has day units or larger, remove times. Otherwise, ensure times.
	normalizeCurrentRange: function(range, unit) {

		if (/^(year|month|week|day)$/.test(unit)) { // whole-days?
			range.start.stripTime();
			range.end.stripTime();
		}
		else { // needs to have a time?
			if (!range.start.hasTime()) {
				range.start.time(0); // give 00:00 time
			}
			if (!range.end.hasTime()) {
				range.end.time(0); // give 00:00 time
			}
		}
	},


	// Mutates the given activeRange to have time values (un-ambiguate)
	// if the minTime or maxTime causes the range to expand.
	// TODO: eventually activeRange should *always* have times.
	adjustActiveRange: function(range, minTime, maxTime) {
		var hasSpecialTimes = false;

		if (this.usesMinMaxTime) {

			if (minTime < 0) {
				range.start.time(0).add(minTime);
				hasSpecialTimes = true;
			}

			if (maxTime > 24 * 60 * 60 * 1000) { // beyond 24 hours?
				range.end.time(maxTime - (24 * 60 * 60 * 1000));
				hasSpecialTimes = true;
			}

			if (hasSpecialTimes) {
				if (!range.start.hasTime()) {
					range.start.time(0);
				}
				if (!range.end.hasTime()) {
					range.end.time(0);
				}
			}
		}
	},


	// Builds the "current" range when it is specified as an explicit duration.
	// `unit` is the already-computed computeGreatestUnit value of duration.
	buildRangeFromDuration: function(date, direction, duration, unit) {
		var alignment = this.opt('dateAlignment');
		var start = date.clone();
		var end;
		var dateIncrementInput;
		var dateIncrementDuration;

		// if the view displays a single day or smaller
		if (duration.as('days') <= 1) {
			if (this.isHiddenDay(start)) {
				start = this.skipHiddenDays(start, direction);
				start.startOf('day');
			}
		}

		// compute what the alignment should be
		if (!alignment) {
			dateIncrementInput = this.opt('dateIncrement');

			if (dateIncrementInput) {
				dateIncrementDuration = moment.duration(dateIncrementInput);

				// use the smaller of the two units
				if (dateIncrementDuration < duration) {
					alignment = computeDurationGreatestUnit(dateIncrementDuration, dateIncrementInput);
				}
				else {
					alignment = unit;
				}
			}
			else {
				alignment = unit;
			}
		}

		start.startOf(alignment);
		end = start.clone().add(duration);

		return { start: start, end: end };
	},


	// Builds the "current" range when a dayCount is specified.
	buildRangeFromDayCount: function(date, direction, dayCount) {
		var customAlignment = this.opt('dateAlignment');
		var runningCount = 0;
		var start = date.clone();
		var end;

		if (customAlignment) {
			start.startOf(customAlignment);
		}

		start.startOf('day');
		start = this.skipHiddenDays(start, direction);

		end = start.clone();
		do {
			end.add(1, 'day');
			if (!this.isHiddenDay(end)) {
				runningCount++;
			}
		} while (runningCount < dayCount);

		return { start: start, end: end };
	},


	// Builds a normalized range object for the "visible" range,
	// which is a way to define the currentRange and activeRange at the same time.
	buildCustomVisibleRange: function(date) {
		var visibleRange = this.getRangeOption(
			'visibleRange',
			this.calendar.moment(date) // correct zone. also generates new obj that avoids mutations
		);

		if (visibleRange && (!visibleRange.start || !visibleRange.end)) {
			return null;
		}

		return visibleRange;
	},


	// Computes the range that will represent the element/cells for *rendering*,
	// but which may have voided days/times.
	buildRenderRange: function(currentRange, currentRangeUnit) {
		// cut off days in the currentRange that are hidden
		return this.trimHiddenDays(currentRange);
	},


	// Compute the duration value that should be added/substracted to the current date
	// when a prev/next operation happens.
	buildDateIncrement: function(fallback) {
		var dateIncrementInput = this.opt('dateIncrement');
		var customAlignment;

		if (dateIncrementInput) {
			return moment.duration(dateIncrementInput);
		}
		else if ((customAlignment = this.opt('dateAlignment'))) {
			return moment.duration(1, customAlignment);
		}
		else if (fallback) {
			return fallback;
		}
		else {
			return moment.duration({ days: 1 });
		}
	},


	// Remove days from the beginning and end of the range that are computed as hidden.
	trimHiddenDays: function(inputRange) {
		return {
			start: this.skipHiddenDays(inputRange.start),
			end: this.skipHiddenDays(inputRange.end, -1, true) // exclusively move backwards
		};
	},


	// Compute the number of the give units in the "current" range.
	// Will return a floating-point number. Won't round.
	currentRangeAs: function(unit) {
		var currentRange = this.currentRange;
		return currentRange.end.diff(currentRange.start, unit, true);
	},


	// Arguments after name will be forwarded to a hypothetical function value
	// WARNING: passed-in arguments will be given to generator functions as-is and can cause side-effects.
	// Always clone your objects if you fear mutation.
	getRangeOption: function(name) {
		var val = this.opt(name);

		if (typeof val === 'function') {
			val = val.apply(
				null,
				Array.prototype.slice.call(arguments, 1)
			);
		}

		if (val) {
			return this.calendar.parseRange(val);
		}
	},


	/* Hidden Days
	------------------------------------------------------------------------------------------------------------------*/


	// Initializes internal variables related to calculating hidden days-of-week
	initHiddenDays: function() {
		var hiddenDays = this.opt('hiddenDays') || []; // array of day-of-week indices that are hidden
		var isHiddenDayHash = []; // is the day-of-week hidden? (hash with day-of-week-index -> bool)
		var dayCnt = 0;
		var i;

		if (this.opt('weekends') === false) {
			hiddenDays.push(0, 6); // 0=sunday, 6=saturday
		}

		for (i = 0; i < 7; i++) {
			if (
				!(isHiddenDayHash[i] = $.inArray(i, hiddenDays) !== -1)
			) {
				dayCnt++;
			}
		}

		if (!dayCnt) {
			throw 'invalid hiddenDays'; // all days were hidden? bad.
		}

		this.isHiddenDayHash = isHiddenDayHash;
	},


	// Is the current day hidden?
	// `day` is a day-of-week index (0-6), or a Moment
	isHiddenDay: function(day) {
		if (moment.isMoment(day)) {
			day = day.day();
		}
		return this.isHiddenDayHash[day];
	},


	// Incrementing the current day until it is no longer a hidden day, returning a copy.
	// DOES NOT CONSIDER validRange!
	// If the initial value of `date` is not a hidden day, don't do anything.
	// Pass `isExclusive` as `true` if you are dealing with an end date.
	// `inc` defaults to `1` (increment one day forward each time)
	skipHiddenDays: function(date, inc, isExclusive) {
		var out = date.clone();
		inc = inc || 1;
		while (
			this.isHiddenDayHash[(out.day() + (isExclusive ? inc : 0) + 7) % 7]
		) {
			out.add(inc, 'days');
		}
		return out;
	}

});

;;

/*
Embodies a div that has potential scrollbars
*/
var Scroller = FC.Scroller = Class.extend({

	el: null, // the guaranteed outer element
	scrollEl: null, // the element with the scrollbars
	overflowX: null,
	overflowY: null,


	constructor: function(options) {
		options = options || {};
		this.overflowX = options.overflowX || options.overflow || 'auto';
		this.overflowY = options.overflowY || options.overflow || 'auto';
	},


	render: function() {
		this.el = this.renderEl();
		this.applyOverflow();
	},


	renderEl: function() {
		return (this.scrollEl = $('<div class="fc-scroller"></div>'));
	},


	// sets to natural height, unlocks overflow
	clear: function() {
		this.setHeight('auto');
		this.applyOverflow();
	},


	destroy: function() {
		this.el.remove();
	},


	// Overflow
	// -----------------------------------------------------------------------------------------------------------------


	applyOverflow: function() {
		this.scrollEl.css({
			'overflow-x': this.overflowX,
			'overflow-y': this.overflowY
		});
	},


	// Causes any 'auto' overflow values to resolves to 'scroll' or 'hidden'.
	// Useful for preserving scrollbar widths regardless of future resizes.
	// Can pass in scrollbarWidths for optimization.
	lockOverflow: function(scrollbarWidths) {
		var overflowX = this.overflowX;
		var overflowY = this.overflowY;

		scrollbarWidths = scrollbarWidths || this.getScrollbarWidths();

		if (overflowX === 'auto') {
			overflowX = (
					scrollbarWidths.top || scrollbarWidths.bottom || // horizontal scrollbars?
					// OR scrolling pane with massless scrollbars?
					this.scrollEl[0].scrollWidth - 1 > this.scrollEl[0].clientWidth
						// subtract 1 because of IE off-by-one issue
				) ? 'scroll' : 'hidden';
		}

		if (overflowY === 'auto') {
			overflowY = (
					scrollbarWidths.left || scrollbarWidths.right || // vertical scrollbars?
					// OR scrolling pane with massless scrollbars?
					this.scrollEl[0].scrollHeight - 1 > this.scrollEl[0].clientHeight
						// subtract 1 because of IE off-by-one issue
				) ? 'scroll' : 'hidden';
		}

		this.scrollEl.css({ 'overflow-x': overflowX, 'overflow-y': overflowY });
	},


	// Getters / Setters
	// -----------------------------------------------------------------------------------------------------------------


	setHeight: function(height) {
		this.scrollEl.height(height);
	},


	getScrollTop: function() {
		return this.scrollEl.scrollTop();
	},


	setScrollTop: function(top) {
		this.scrollEl.scrollTop(top);
	},


	getClientWidth: function() {
		return this.scrollEl[0].clientWidth;
	},


	getClientHeight: function() {
		return this.scrollEl[0].clientHeight;
	},


	getScrollbarWidths: function() {
		return getScrollbarWidths(this.scrollEl);
	}

});

;;
function Iterator(items) {
    this.items = items || [];
}


/* Calls a method on every item passing the arguments through */
Iterator.prototype.proxyCall = function(methodName) {
    var args = Array.prototype.slice.call(arguments, 1);
    var results = [];

    this.items.forEach(function(item) {
        results.push(item[methodName].apply(item, args));
    });

    return results;
};

;;

/* Toolbar with buttons and title
----------------------------------------------------------------------------------------------------------------------*/

function Toolbar(calendar, toolbarOptions) {
	var t = this;

	// exports
	t.setToolbarOptions = setToolbarOptions;
	t.render = render;
	t.removeElement = removeElement;
	t.updateTitle = updateTitle;
	t.activateButton = activateButton;
	t.deactivateButton = deactivateButton;
	t.disableButton = disableButton;
	t.enableButton = enableButton;
	t.getViewsWithButtons = getViewsWithButtons;
	t.el = null; // mirrors local `el`

	// locals
	var el;
	var viewsWithButtons = [];
	var tm;

	// method to update toolbar-specific options, not calendar-wide options
	function setToolbarOptions(newToolbarOptions) {
		toolbarOptions = newToolbarOptions;
	}

	// can be called repeatedly and will rerender
	function render() {
		var sections = toolbarOptions.layout;

		tm = calendar.options.theme ? 'ui' : 'fc';

		if (sections) {
			if (!el) {
				el = this.el = $("<div class='fc-toolbar "+ toolbarOptions.extraClasses + "'/>");
			}
			else {
				el.empty();
			}
			el.append(renderSection('left'))
				.append(renderSection('right'))
				.append(renderSection('center'))
				.append('<div class="fc-clear"/>');
		}
		else {
			removeElement();
		}
	}


	function removeElement() {
		if (el) {
			el.remove();
			el = t.el = null;
		}
	}


	function renderSection(position) {
		var sectionEl = $('<div class="fc-' + position + '"/>');
		var buttonStr = toolbarOptions.layout[position];

		if (buttonStr) {
			$.each(buttonStr.split(' '), function(i) {
				var groupChildren = $();
				var isOnlyButtons = true;
				var groupEl;

				$.each(this.split(','), function(j, buttonName) {
					var customButtonProps;
					var viewSpec;
					var buttonClick;
					var overrideText; // text explicitly set by calendar's constructor options. overcomes icons
					var defaultText;
					var themeIcon;
					var normalIcon;
					var innerHtml;
					var classes;
					var button; // the element

					if (buttonName == 'title') {
						groupChildren = groupChildren.add($('<h2>&nbsp;</h2>')); // we always want it to take up height
						isOnlyButtons = false;
					}
					else {
						if ((customButtonProps = (calendar.options.customButtons || {})[buttonName])) {
							buttonClick = function(ev) {
								if (customButtonProps.click) {
									customButtonProps.click.call(button[0], ev);
								}
							};
							overrideText = ''; // icons will override text
							defaultText = customButtonProps.text;
						}
						else if ((viewSpec = calendar.getViewSpec(buttonName))) {
							buttonClick = function() {
								calendar.changeView(buttonName);
							};
							viewsWithButtons.push(buttonName);
							overrideText = viewSpec.buttonTextOverride;
							defaultText = viewSpec.buttonTextDefault;
						}
						else if (calendar[buttonName]) { // a calendar method
							buttonClick = function() {
								calendar[buttonName]();
							};
							overrideText = (calendar.overrides.buttonText || {})[buttonName];
							defaultText = calendar.options.buttonText[buttonName]; // everything else is considered default
						}

						if (buttonClick) {

							themeIcon =
								customButtonProps ?
									customButtonProps.themeIcon :
									calendar.options.themeButtonIcons[buttonName];

							normalIcon =
								customButtonProps ?
									customButtonProps.icon :
									calendar.options.buttonIcons[buttonName];

							if (overrideText) {
								innerHtml = htmlEscape(overrideText);
							}
							else if (themeIcon && calendar.options.theme) {
								innerHtml = "<span class='ui-icon ui-icon-" + themeIcon + "'></span>";
							}
							else if (normalIcon && !calendar.options.theme) {
								innerHtml = "<span class='fc-icon fc-icon-" + normalIcon + "'></span>";
							}
							else {
								innerHtml = htmlEscape(defaultText);
							}

							classes = [
								'fc-' + buttonName + '-button',
								tm + '-button',
								tm + '-state-default'
							];

							button = $( // type="button" so that it doesn't submit a form
								'<button type="button" class="' + classes.join(' ') + '">' +
									innerHtml +
								'</button>'
								)
								.click(function(ev) {
									// don't process clicks for disabled buttons
									if (!button.hasClass(tm + '-state-disabled')) {

										buttonClick(ev);

										// after the click action, if the button becomes the "active" tab, or disabled,
										// it should never have a hover class, so remove it now.
										if (
											button.hasClass(tm + '-state-active') ||
											button.hasClass(tm + '-state-disabled')
										) {
											button.removeClass(tm + '-state-hover');
										}
									}
								})
								.mousedown(function() {
									// the *down* effect (mouse pressed in).
									// only on buttons that are not the "active" tab, or disabled
									button
										.not('.' + tm + '-state-active')
										.not('.' + tm + '-state-disabled')
										.addClass(tm + '-state-down');
								})
								.mouseup(function() {
									// undo the *down* effect
									button.removeClass(tm + '-state-down');
								})
								.hover(
									function() {
										// the *hover* effect.
										// only on buttons that are not the "active" tab, or disabled
										button
											.not('.' + tm + '-state-active')
											.not('.' + tm + '-state-disabled')
											.addClass(tm + '-state-hover');
									},
									function() {
										// undo the *hover* effect
										button
											.removeClass(tm + '-state-hover')
											.removeClass(tm + '-state-down'); // if mouseleave happens before mouseup
									}
								);

							groupChildren = groupChildren.add(button);
						}
					}
				});

				if (isOnlyButtons) {
					groupChildren
						.first().addClass(tm + '-corner-left').end()
						.last().addClass(tm + '-corner-right').end();
				}

				if (groupChildren.length > 1) {
					groupEl = $('<div/>');
					if (isOnlyButtons) {
						groupEl.addClass('fc-button-group');
					}
					groupEl.append(groupChildren);
					sectionEl.append(groupEl);
				}
				else {
					sectionEl.append(groupChildren); // 1 or 0 children
				}
			});
		}

		return sectionEl;
	}


	function updateTitle(text) {
		if (el) {
			el.find('h2').text(text);
		}
	}


	function activateButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.addClass(tm + '-state-active');
		}
	}


	function deactivateButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.removeClass(tm + '-state-active');
		}
	}


	function disableButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.prop('disabled', true)
				.addClass(tm + '-state-disabled');
		}
	}


	function enableButton(buttonName) {
		if (el) {
			el.find('.fc-' + buttonName + '-button')
				.prop('disabled', false)
				.removeClass(tm + '-state-disabled');
		}
	}


	function getViewsWithButtons() {
		return viewsWithButtons;
	}

}

;;

var Calendar = FC.Calendar = Class.extend({

	dirDefaults: null, // option defaults related to LTR or RTL
	localeDefaults: null, // option defaults related to current locale
	overrides: null, // option overrides given to the fullCalendar constructor
	dynamicOverrides: null, // options set with dynamic setter method. higher precedence than view overrides.
	options: null, // all defaults combined with overrides
	viewSpecCache: null, // cache of view definitions
	view: null, // current View object
	currentDate: null, // unzoned moment. private (public API should use getDate instead)
	header: null,
	footer: null,
	loadingLevel: 0, // number of simultaneous loading tasks


	// a lot of this class' OOP logic is scoped within this constructor function,
	// but in the future, write individual methods on the prototype.
	constructor: Calendar_constructor,


	// Subclasses can override this for initialization logic after the constructor has been called
	initialize: function() {
	},


	// Computes the flattened options hash for the calendar and assigns to `this.options`.
	// Assumes this.overrides and this.dynamicOverrides have already been initialized.
	populateOptionsHash: function() {
		var locale, localeDefaults;
		var isRTL, dirDefaults;

		locale = firstDefined( // explicit locale option given?
			this.dynamicOverrides.locale,
			this.overrides.locale
		);
		localeDefaults = localeOptionHash[locale];
		if (!localeDefaults) { // explicit locale option not given or invalid?
			locale = Calendar.defaults.locale;
			localeDefaults = localeOptionHash[locale] || {};
		}

		isRTL = firstDefined( // based on options computed so far, is direction RTL?
			this.dynamicOverrides.isRTL,
			this.overrides.isRTL,
			localeDefaults.isRTL,
			Calendar.defaults.isRTL
		);
		dirDefaults = isRTL ? Calendar.rtlDefaults : {};

		this.dirDefaults = dirDefaults;
		this.localeDefaults = localeDefaults;
		this.options = mergeOptions([ // merge defaults and overrides. lowest to highest precedence
			Calendar.defaults, // global defaults
			dirDefaults,
			localeDefaults,
			this.overrides,
			this.dynamicOverrides
		]);
		populateInstanceComputableOptions(this.options); // fill in gaps with computed options
	},


	// Gets information about how to create a view. Will use a cache.
	getViewSpec: function(viewType) {
		var cache = this.viewSpecCache;

		return cache[viewType] || (cache[viewType] = this.buildViewSpec(viewType));
	},


	// Given a duration singular unit, like "week" or "day", finds a matching view spec.
	// Preference is given to views that have corresponding buttons.
	getUnitViewSpec: function(unit) {
		var viewTypes;
		var i;
		var spec;

		if ($.inArray(unit, unitsDesc) != -1) {

			// put views that have buttons first. there will be duplicates, but oh well
			viewTypes = this.header.getViewsWithButtons(); // TODO: include footer as well?
			$.each(FC.views, function(viewType) { // all views
				viewTypes.push(viewType);
			});

			for (i = 0; i < viewTypes.length; i++) {
				spec = this.getViewSpec(viewTypes[i]);
				if (spec) {
					if (spec.singleUnit == unit) {
						return spec;
					}
				}
			}
		}
	},


	// Builds an object with information on how to create a given view
	buildViewSpec: function(requestedViewType) {
		var viewOverrides = this.overrides.views || {};
		var specChain = []; // for the view. lowest to highest priority
		var defaultsChain = []; // for the view. lowest to highest priority
		var overridesChain = []; // for the view. lowest to highest priority
		var viewType = requestedViewType;
		var spec; // for the view
		var overrides; // for the view
		var durationInput;
		var duration;
		var unit;

		// iterate from the specific view definition to a more general one until we hit an actual View class
		while (viewType) {
			spec = fcViews[viewType];
			overrides = viewOverrides[viewType];
			viewType = null; // clear. might repopulate for another iteration

			if (typeof spec === 'function') { // TODO: deprecate
				spec = { 'class': spec };
			}

			if (spec) {
				specChain.unshift(spec);
				defaultsChain.unshift(spec.defaults || {});
				durationInput = durationInput || spec.duration;
				viewType = viewType || spec.type;
			}

			if (overrides) {
				overridesChain.unshift(overrides); // view-specific option hashes have options at zero-level
				durationInput = durationInput || overrides.duration;
				viewType = viewType || overrides.type;
			}
		}

		spec = mergeProps(specChain);
		spec.type = requestedViewType;
		if (!spec['class']) {
			return false;
		}

		// fall back to top-level `duration` option
		durationInput = durationInput ||
			this.dynamicOverrides.duration ||
			this.overrides.duration;

		if (durationInput) {
			duration = moment.duration(durationInput);

			if (duration.valueOf()) { // valid?

				unit = computeDurationGreatestUnit(duration, durationInput);

				spec.duration = duration;
				spec.durationUnit = unit;

				// view is a single-unit duration, like "week" or "day"
				// incorporate options for this. lowest priority
				if (duration.as(unit) === 1) {
					spec.singleUnit = unit;
					overridesChain.unshift(viewOverrides[unit] || {});
				}
			}
		}

		spec.defaults = mergeOptions(defaultsChain);
		spec.overrides = mergeOptions(overridesChain);

		this.buildViewSpecOptions(spec);
		this.buildViewSpecButtonText(spec, requestedViewType);

		return spec;
	},


	// Builds and assigns a view spec's options object from its already-assigned defaults and overrides
	buildViewSpecOptions: function(spec) {
		spec.options = mergeOptions([ // lowest to highest priority
			Calendar.defaults, // global defaults
			spec.defaults, // view's defaults (from ViewSubclass.defaults)
			this.dirDefaults,
			this.localeDefaults, // locale and dir take precedence over view's defaults!
			this.overrides, // calendar's overrides (options given to constructor)
			spec.overrides, // view's overrides (view-specific options)
			this.dynamicOverrides // dynamically set via setter. highest precedence
		]);
		populateInstanceComputableOptions(spec.options);
	},


	// Computes and assigns a view spec's buttonText-related options
	buildViewSpecButtonText: function(spec, requestedViewType) {

		// given an options object with a possible `buttonText` hash, lookup the buttonText for the
		// requested view, falling back to a generic unit entry like "week" or "day"
		function queryButtonText(options) {
			var buttonText = options.buttonText || {};
			return buttonText[requestedViewType] ||
				// view can decide to look up a certain key
				(spec.buttonTextKey ? buttonText[spec.buttonTextKey] : null) ||
				// a key like "month"
				(spec.singleUnit ? buttonText[spec.singleUnit] : null);
		}

		// highest to lowest priority
		spec.buttonTextOverride =
			queryButtonText(this.dynamicOverrides) ||
			queryButtonText(this.overrides) || // constructor-specified buttonText lookup hash takes precedence
			spec.overrides.buttonText; // `buttonText` for view-specific options is a string

		// highest to lowest priority. mirrors buildViewSpecOptions
		spec.buttonTextDefault =
			queryButtonText(this.localeDefaults) ||
			queryButtonText(this.dirDefaults) ||
			spec.defaults.buttonText || // a single string. from ViewSubclass.defaults
			queryButtonText(Calendar.defaults) ||
			(spec.duration ? this.humanizeDuration(spec.duration) : null) || // like "3 days"
			requestedViewType; // fall back to given view name
	},


	// Given a view name for a custom view or a standard view, creates a ready-to-go View object
	instantiateView: function(viewType) {
		var spec = this.getViewSpec(viewType);

		return new spec['class'](this, spec);
	},


	// Returns a boolean about whether the view is okay to instantiate at some point
	isValidViewType: function(viewType) {
		return Boolean(this.getViewSpec(viewType));
	},


	// Should be called when any type of async data fetching begins
	pushLoading: function() {
		if (!(this.loadingLevel++)) {
			this.publiclyTrigger('loading', null, true, this.view);
		}
	},


	// Should be called when any type of async data fetching completes
	popLoading: function() {
		if (!(--this.loadingLevel)) {
			this.publiclyTrigger('loading', null, false, this.view);
		}
	},


	// Given arguments to the select method in the API, returns a span (unzoned start/end and other info)
	buildSelectSpan: function(zonedStartInput, zonedEndInput) {
		var start = this.moment(zonedStartInput).stripZone();
		var end;

		if (zonedEndInput) {
			end = this.moment(zonedEndInput).stripZone();
		}
		else if (start.hasTime()) {
			end = start.clone().add(this.defaultTimedEventDuration);
		}
		else {
			end = start.clone().add(this.defaultAllDayEventDuration);
		}

		return { start: start, end: end };
	},


	// Current Date
	// ------------


	/*
	Called before initialize()
	*/
	initCurrentDate: function() {
		// compute the initial ambig-timezone date
		if (this.options.defaultDate != null) {
			this.currentDate = this.moment(this.options.defaultDate).stripZone();
		}
		else {
			this.currentDate = this.getNow(); // getNow already returns unzoned
		}
	},


	changeView: function(viewName, dateOrRange) {

		if (dateOrRange) {

			if (dateOrRange.start && dateOrRange.end) { // a range
				this.recordOptionOverrides({ // will not rerender
					visibleRange: dateOrRange
				});
			}
			else { // a date
				this.currentDate = this.moment(dateOrRange).stripZone(); // just like gotoDate
			}
		}

		this.renderView(viewName);
	},


	prev: function() {
		var prevInfo = this.view.buildPrevDateProfile(this.currentDate);

		if (prevInfo.isValid) {
			this.currentDate = prevInfo.date;
			this.renderView();
		}
	},


	next: function() {
		var nextInfo = this.view.buildNextDateProfile(this.currentDate);

		if (nextInfo.isValid) {
			this.currentDate = nextInfo.date;
			this.renderView();
		}
	},


	prevYear: function() {
		this.currentDate.add(-1, 'years');
		this.renderView();
	},


	nextYear: function() {
		this.currentDate.add(1, 'years');
		this.renderView();
	},


	today: function() {
		this.currentDate = this.getNow(); // should deny like prev/next?
		this.renderView();
	},


	gotoDate: function(zonedDateInput) {
		this.currentDate = this.moment(zonedDateInput).stripZone();
		this.renderView();
	},


	incrementDate: function(delta) {
		this.currentDate.add(moment.duration(delta));
		this.renderView();
	},


	// for external API
	getDate: function() {
		return this.applyTimezone(this.currentDate); // infuse the calendar's timezone
	},


	// will return `null` if invalid range
	parseRange: function(rangeInput) {
		var start = null;
		var end = null;

		if (rangeInput.start) {
			start = this.moment(rangeInput.start).stripZone();
		}

		if (rangeInput.end) {
			end = this.moment(rangeInput.end).stripZone();
		}

		if (!start && !end) {
			return null;
		}

		if (start && end && end.isBefore(start)) {
			return null;
		}

		return { start: start, end: end };
	}

});


Calendar.mixin(EmitterMixin);


function Calendar_constructor(element, overrides) {
	var t = this;

	// declare the current calendar instance relies on GlobalEmitter. needed for garbage collection.
	GlobalEmitter.needed();


	// Exports
	// -----------------------------------------------------------------------------------

	t.render = render;
	t.destroy = destroy;
	t.rerenderEvents = rerenderEvents;
	t.select = select;
	t.unselect = unselect;
	t.zoomTo = zoomTo;
	t.getCalendar = getCalendar;
	t.getView = getView;
	t.option = option; // getter/setter method
	t.recordOptionOverrides = recordOptionOverrides;
	t.publiclyTrigger = publiclyTrigger;


	// Options
	// -----------------------------------------------------------------------------------

	t.dynamicOverrides = {};
	t.viewSpecCache = {};
	t.optionHandlers = {}; // for Calendar.options.js
	t.overrides = $.extend({}, overrides); // make a copy

	t.populateOptionsHash(); // sets this.options



	// Locale-data Internals
	// -----------------------------------------------------------------------------------
	// Apply overrides to the current locale's data

	var localeData;

	// Called immediately, and when any of the options change.
	// Happens before any internal objects rebuild or rerender, because this is very core.
	t.bindOptions([
		'locale', 'monthNames', 'monthNamesShort', 'dayNames', 'dayNamesShort', 'firstDay', 'weekNumberCalculation'
	], function(locale, monthNames, monthNamesShort, dayNames, dayNamesShort, firstDay, weekNumberCalculation) {

		// normalize
		if (weekNumberCalculation === 'iso') {
			weekNumberCalculation = 'ISO'; // normalize
		}

		localeData = createObject( // make a cheap copy
			getMomentLocaleData(locale) // will fall back to en
		);

		if (monthNames) {
			localeData._months = monthNames;
		}
		if (monthNamesShort) {
			localeData._monthsShort = monthNamesShort;
		}
		if (dayNames) {
			localeData._weekdays = dayNames;
		}
		if (dayNamesShort) {
			localeData._weekdaysShort = dayNamesShort;
		}

		if (firstDay == null && weekNumberCalculation === 'ISO') {
			firstDay = 1;
		}
		if (firstDay != null) {
			var _week = createObject(localeData._week); // _week: { dow: # }
			_week.dow = firstDay;
			localeData._week = _week;
		}

		if ( // whitelist certain kinds of input
			weekNumberCalculation === 'ISO' ||
			weekNumberCalculation === 'local' ||
			typeof weekNumberCalculation === 'function'
		) {
			localeData._fullCalendar_weekCalc = weekNumberCalculation; // moment-ext will know what to do with it
		}

		// If the internal current date object already exists, move to new locale.
		// We do NOT need to do this technique for event dates, because this happens when converting to "segments".
		if (t.currentDate) {
			localizeMoment(t.currentDate); // sets to localeData
		}
	});


	// Calendar-specific Date Utilities
	// -----------------------------------------------------------------------------------


	t.defaultAllDayEventDuration = moment.duration(t.options.defaultAllDayEventDuration);
	t.defaultTimedEventDuration = moment.duration(t.options.defaultTimedEventDuration);


	// Builds a moment using the settings of the current calendar: timezone and locale.
	// Accepts anything the vanilla moment() constructor accepts.
	t.moment = function() {
		var mom;

		if (t.options.timezone === 'local') {
			mom = FC.moment.apply(null, arguments);

			// Force the moment to be local, because FC.moment doesn't guarantee it.
			if (mom.hasTime()) { // don't give ambiguously-timed moments a local zone
				mom.local();
			}
		}
		else if (t.options.timezone === 'UTC') {
			mom = FC.moment.utc.apply(null, arguments); // process as UTC
		}
		else {
			mom = FC.moment.parseZone.apply(null, arguments); // let the input decide the zone
		}

		localizeMoment(mom);

		return mom;
	};


	// Updates the given moment's locale settings to the current calendar locale settings.
	function localizeMoment(mom) {
		mom._locale = localeData;
	}
	t.localizeMoment = localizeMoment;


	// Returns a boolean about whether or not the calendar knows how to calculate
	// the timezone offset of arbitrary dates in the current timezone.
	t.getIsAmbigTimezone = function() {
		return t.options.timezone !== 'local' && t.options.timezone !== 'UTC';
	};


	// Returns a copy of the given date in the current timezone. Has no effect on dates without times.
	t.applyTimezone = function(date) {
		if (!date.hasTime()) {
			return date.clone();
		}

		var zonedDate = t.moment(date.toArray());
		var timeAdjust = date.time() - zonedDate.time();
		var adjustedZonedDate;

		// Safari sometimes has problems with this coersion when near DST. Adjust if necessary. (bug #2396)
		if (timeAdjust) { // is the time result different than expected?
			adjustedZonedDate = zonedDate.clone().add(timeAdjust); // add milliseconds
			if (date.time() - adjustedZonedDate.time() === 0) { // does it match perfectly now?
				zonedDate = adjustedZonedDate;
			}
		}

		return zonedDate;
	};


	// Returns a moment for the current date, as defined by the client's computer or from the `now` option.
	// Will return an moment with an ambiguous timezone.
	t.getNow = function() {
		var now = t.options.now;
		if (typeof now === 'function') {
			now = now();
		}
		return t.moment(now).stripZone();
	};


	// Get an event's normalized end date. If not present, calculate it from the defaults.
	t.getEventEnd = function(event) {
		if (event.end) {
			return event.end.clone();
		}
		else {
			return t.getDefaultEventEnd(event.allDay, event.start);
		}
	};


	// Given an event's allDay status and start date, return what its fallback end date should be.
	// TODO: rename to computeDefaultEventEnd
	t.getDefaultEventEnd = function(allDay, zonedStart) {
		var end = zonedStart.clone();

		if (allDay) {
			end.stripTime().add(t.defaultAllDayEventDuration);
		}
		else {
			end.add(t.defaultTimedEventDuration);
		}

		if (t.getIsAmbigTimezone()) {
			end.stripZone(); // we don't know what the tzo should be
		}

		return end;
	};


	// Produces a human-readable string for the given duration.
	// Side-effect: changes the locale of the given duration.
	t.humanizeDuration = function(duration) {
		return duration.locale(t.options.locale).humanize();
	};



	// Imports
	// -----------------------------------------------------------------------------------


	EventManager.call(t);



	// Locals
	// -----------------------------------------------------------------------------------


	var _element = element[0];
	var toolbarsManager;
	var header;
	var footer;
	var content;
	var tm; // for making theme classes
	var currentView; // NOTE: keep this in sync with this.view
	var viewsByType = {}; // holds all instantiated view instances, current or not
	var suggestedViewHeight;
	var windowResizeProxy; // wraps the windowResize function
	var ignoreWindowResize = 0;


	this.initCurrentDate();


	// Main Rendering
	// -----------------------------------------------------------------------------------


	function render() {
		if (!content) {
			initialRender();
		}
		else if (elementVisible()) {
			// mainly for the public API
			calcSize();
			renderView();
		}
	}


	function initialRender() {
		element.addClass('fc');

		// event delegation for nav links
		element.on('click.fc', 'a[data-goto]', function(ev) {
			var anchorEl = $(this);
			var gotoOptions = anchorEl.data('goto'); // will automatically parse JSON
			var date = t.moment(gotoOptions.date);
			var viewType = gotoOptions.type;

			// property like "navLinkDayClick". might be a string or a function
			var customAction = currentView.opt('navLink' + capitaliseFirstLetter(viewType) + 'Click');

			if (typeof customAction === 'function') {
				customAction(date, ev);
			}
			else {
				if (typeof customAction === 'string') {
					viewType = customAction;
				}
				zoomTo(date, viewType);
			}
		});

		// called immediately, and upon option change
		t.bindOption('theme', function(theme) {
			tm = theme ? 'ui' : 'fc'; // affects a larger scope
			element.toggleClass('ui-widget', theme);
			element.toggleClass('fc-unthemed', !theme);
		});

		// called immediately, and upon option change.
		// HACK: locale often affects isRTL, so we explicitly listen to that too.
		t.bindOptions([ 'isRTL', 'locale' ], function(isRTL) {
			element.toggleClass('fc-ltr', !isRTL);
			element.toggleClass('fc-rtl', isRTL);
		});

		content = $("<div class='fc-view-container'/>").prependTo(element);

		var toolbars = buildToolbars();
		toolbarsManager = new Iterator(toolbars);

		header = t.header = toolbars[0];
		footer = t.footer = toolbars[1];

		renderHeader();
		renderFooter();
		renderView(t.options.defaultView);

		if (t.options.handleWindowResize) {
			windowResizeProxy = debounce(windowResize, t.options.windowResizeDelay); // prevents rapid calls
			$(window).resize(windowResizeProxy);
		}
	}


	function destroy() {

		if (currentView) {
			currentView.removeElement();

			// NOTE: don't null-out currentView/t.view in case API methods are called after destroy.
			// It is still the "current" view, just not rendered.
		}

		toolbarsManager.proxyCall('removeElement');
		content.remove();
		element.removeClass('fc fc-ltr fc-rtl fc-unthemed ui-widget');

		element.off('.fc'); // unbind nav link handlers

		if (windowResizeProxy) {
			$(window).unbind('resize', windowResizeProxy);
		}

		GlobalEmitter.unneeded();
	}


	function elementVisible() {
		return element.is(':visible');
	}



	// View Rendering
	// -----------------------------------------------------------------------------------


	// Renders a view because of a date change, view-type change, or for the first time.
	// If not given a viewType, keep the current view but render different dates.
	// Accepts an optional scroll state to restore to.
	function renderView(viewType, forcedScroll) {
		ignoreWindowResize++;

		var needsClearView = currentView && viewType && currentView.type !== viewType;

		// if viewType is changing, remove the old view's rendering
		if (needsClearView) {
			freezeContentHeight(); // prevent a scroll jump when view element is removed
			clearView();
		}

		// if viewType changed, or the view was never created, create a fresh view
		if (!currentView && viewType) {
			currentView = t.view =
				viewsByType[viewType] ||
				(viewsByType[viewType] = t.instantiateView(viewType));

			currentView.setElement(
				$("<div class='fc-view fc-" + viewType + "-view' />").appendTo(content)
			);
			toolbarsManager.proxyCall('activateButton', viewType);
		}

		if (currentView) {

			if (elementVisible()) {

				if (forcedScroll) {
					currentView.captureInitialScroll(forcedScroll);
				}

				currentView.setDate(t.currentDate);

				// TODO: make setDate return the revised date.
				// Difficult because of the pseudo-async nature, promises.
				t.currentDate = currentView.currentDate;

				if (forcedScroll) {
					currentView.releaseScroll();
				}
			}
		}

		if (needsClearView) {
			thawContentHeight();
		}

		ignoreWindowResize--;
	}
	t.renderView = renderView;


	// Unrenders the current view and reflects this change in the Header.
	// Unregsiters the `currentView`, but does not remove from viewByType hash.
	function clearView() {
		toolbarsManager.proxyCall('deactivateButton', currentView.type);
		currentView.removeElement();
		currentView = t.view = null;
	}


	// Destroys the view, including the view object. Then, re-instantiates it and renders it.
	// Maintains the same scroll state.
	// TODO: maintain any other user-manipulated state.
	function reinitView() {
		ignoreWindowResize++;
		freezeContentHeight();

		var viewType = currentView.type;
		var scrollState = currentView.queryScroll();
		clearView();
		calcSize();
		renderView(viewType, scrollState);

		thawContentHeight();
		ignoreWindowResize--;
	}



	// Resizing
	// -----------------------------------------------------------------------------------


	t.getSuggestedViewHeight = function() {
		if (suggestedViewHeight === undefined) {
			calcSize();
		}
		return suggestedViewHeight;
	};


	t.isHeightAuto = function() {
		return t.options.contentHeight === 'auto' || t.options.height === 'auto';
	};


	function updateSize(shouldRecalc) {
		if (elementVisible()) {

			if (shouldRecalc) {
				_calcSize();
			}

			ignoreWindowResize++;
			currentView.updateSize(true); // isResize=true. will poll getSuggestedViewHeight() and isHeightAuto()
			ignoreWindowResize--;

			return true; // signal success
		}
	}


	function calcSize() {
		if (elementVisible()) {
			_calcSize();
		}
	}


	function _calcSize() { // assumes elementVisible
		var contentHeightInput = t.options.contentHeight;
		var heightInput = t.options.height;

		if (typeof contentHeightInput === 'number') { // exists and not 'auto'
			suggestedViewHeight = contentHeightInput;
		}
		else if (typeof contentHeightInput === 'function') { // exists and is a function
			suggestedViewHeight = contentHeightInput();
		}
		else if (typeof heightInput === 'number') { // exists and not 'auto'
			suggestedViewHeight = heightInput - queryToolbarsHeight();
		}
		else if (typeof heightInput === 'function') { // exists and is a function
			suggestedViewHeight = heightInput() - queryToolbarsHeight();
		}
		else if (heightInput === 'parent') { // set to height of parent element
			suggestedViewHeight = element.parent().height() - queryToolbarsHeight();
		}
		else {
			suggestedViewHeight = Math.round(content.width() / Math.max(t.options.aspectRatio, .5));
		}
	}


	function queryToolbarsHeight() {
		return toolbarsManager.items.reduce(function(accumulator, toolbar) {
			var toolbarHeight = toolbar.el ? toolbar.el.outerHeight(true) : 0; // includes margin
			return accumulator + toolbarHeight;
		}, 0);
	}


	function windowResize(ev) {
		if (
			!ignoreWindowResize &&
			ev.target === window && // so we don't process jqui "resize" events that have bubbled up
			currentView.renderRange // view has already been rendered
		) {
			if (updateSize(true)) {
				currentView.publiclyTrigger('windowResize', _element);
			}
		}
	}



	/* Event Rendering
	-----------------------------------------------------------------------------*/


	function rerenderEvents() { // API method. destroys old events if previously rendered.
		if (elementVisible()) {
			t.reportEventChange(); // will re-trasmit events to the view, causing a rerender
		}
	}



	/* Toolbars
	-----------------------------------------------------------------------------*/


	function buildToolbars() {
		return [
			new Toolbar(t, computeHeaderOptions()),
			new Toolbar(t, computeFooterOptions())
		];
	}


	function computeHeaderOptions() {
		return {
			extraClasses: 'fc-header-toolbar',
			layout: t.options.header
		};
	}


	function computeFooterOptions() {
		return {
			extraClasses: 'fc-footer-toolbar',
			layout: t.options.footer
		};
	}


	// can be called repeatedly and Header will rerender
	function renderHeader() {
		header.setToolbarOptions(computeHeaderOptions());
		header.render();
		if (header.el) {
			element.prepend(header.el);
		}
	}


	// can be called repeatedly and Footer will rerender
	function renderFooter() {
		footer.setToolbarOptions(computeFooterOptions());
		footer.render();
		if (footer.el) {
			element.append(footer.el);
		}
	}


	t.setToolbarsTitle = function(title) {
		toolbarsManager.proxyCall('updateTitle', title);
	};


	t.updateToolbarButtons = function() {
		var now = t.getNow();
		var todayInfo = currentView.buildDateProfile(now);
		var prevInfo = currentView.buildPrevDateProfile(t.currentDate);
		var nextInfo = currentView.buildNextDateProfile(t.currentDate);

		toolbarsManager.proxyCall(
			(todayInfo.isValid && !isDateWithinRange(now, currentView.currentRange)) ?
				'enableButton' :
				'disableButton',
			'today'
		);

		toolbarsManager.proxyCall(
			prevInfo.isValid ?
				'enableButton' :
				'disableButton',
			'prev'
		);

		toolbarsManager.proxyCall(
			nextInfo.isValid ?
				'enableButton' :
				'disableButton',
			'next'
		);
	};



	/* Selection
	-----------------------------------------------------------------------------*/


	// this public method receives start/end dates in any format, with any timezone
	function select(zonedStartInput, zonedEndInput) {
		currentView.select(
			t.buildSelectSpan.apply(t, arguments)
		);
	}


	function unselect() { // safe to be called before renderView
		if (currentView) {
			currentView.unselect();
		}
	}


	// Forces navigation to a view for the given date.
	// `viewType` can be a specific view name or a generic one like "week" or "day".
	function zoomTo(newDate, viewType) {
		var spec;

		viewType = viewType || 'day'; // day is default zoom
		spec = t.getViewSpec(viewType) || t.getUnitViewSpec(viewType);

		t.currentDate = newDate.clone();
		renderView(spec ? spec.type : null);
	}



	/* Height "Freezing"
	-----------------------------------------------------------------------------*/


	t.freezeContentHeight = freezeContentHeight;
	t.thawContentHeight = thawContentHeight;

	var freezeContentHeightDepth = 0;


	function freezeContentHeight() {
		if (!(freezeContentHeightDepth++)) {
			content.css({
				width: '100%',
				height: content.height(),
				overflow: 'hidden'
			});
		}
	}


	function thawContentHeight() {
		if (!(--freezeContentHeightDepth)) {
			content.css({
				width: '',
				height: '',
				overflow: ''
			});
		}
	}



	/* Misc
	-----------------------------------------------------------------------------*/


	function getCalendar() {
		return t;
	}


	function getView() {
		return currentView;
	}


	function option(name, value) {
		var newOptionHash;

		if (typeof name === 'string') {
			if (value === undefined) { // getter
				return t.options[name];
			}
			else { // setter for individual option
				newOptionHash = {};
				newOptionHash[name] = value;
				setOptions(newOptionHash);
			}
		}
		else if (typeof name === 'object') { // compound setter with object input
			setOptions(name);
		}
	}


	function setOptions(newOptionHash) {
		var optionCnt = 0;
		var optionName;

		recordOptionOverrides(newOptionHash);

		for (optionName in newOptionHash) {
			optionCnt++;
		}

		// special-case handling of single option change.
		// if only one option change, `optionName` will be its name.
		if (optionCnt === 1) {
			if (optionName === 'height' || optionName === 'contentHeight' || optionName === 'aspectRatio') {
				updateSize(true); // true = allow recalculation of height
				return;
			}
			else if (optionName === 'defaultDate') {
				return; // can't change date this way. use gotoDate instead
			}
			else if (optionName === 'businessHours') {
				if (currentView) {
					currentView.unrenderBusinessHours();
					currentView.renderBusinessHours();
				}
				return;
			}
			else if (optionName === 'timezone') {
				t.rezoneArrayEventSources();
				t.refetchEvents();
				return;
			}
		}

		// catch-all. rerender the header and footer and rebuild/rerender the current view
		renderHeader();
		renderFooter();
		viewsByType = {}; // even non-current views will be affected by this option change. do before rerender
		reinitView();
	}


	// stores the new options internally, but does not rerender anything.
	function recordOptionOverrides(newOptionHash) {
		var optionName;

		for (optionName in newOptionHash) {
			t.dynamicOverrides[optionName] = newOptionHash[optionName];
		}

		t.viewSpecCache = {}; // the dynamic override invalidates the options in this cache, so just clear it
		t.populateOptionsHash(); // this.options needs to be recomputed after the dynamic override

		// trigger handlers after this.options has been updated
		for (optionName in newOptionHash) {
			t.triggerOptionHandlers(optionName); // recall bindOption/bindOptions
		}
	}


	function publiclyTrigger(name, thisObj) {
		var args = Array.prototype.slice.call(arguments, 2);

		thisObj = thisObj || _element;
		this.triggerWith(name, thisObj, args); // Emitter's method

		if (t.options[name]) {
			return t.options[name].apply(thisObj, args);
		}
	}

	t.initialize();
}

;;
/*
Options binding/triggering system.
*/
Calendar.mixin({

	// A map of option names to arrays of handler objects. Initialized to {} in Calendar.
	// Format for a handler object:
	// {
	//   func // callback function to be called upon change
	//   names // option names whose values should be given to func
	// }
	optionHandlers: null, 

	// Calls handlerFunc immediately, and when the given option has changed.
	// handlerFunc will be given the option value.
	bindOption: function(optionName, handlerFunc) {
		this.bindOptions([ optionName ], handlerFunc);
	},

	// Calls handlerFunc immediately, and when any of the given options change.
	// handlerFunc will be given each option value as ordered function arguments.
	bindOptions: function(optionNames, handlerFunc) {
		var handlerObj = { func: handlerFunc, names: optionNames };
		var i;

		for (i = 0; i < optionNames.length; i++) {
			this.registerOptionHandlerObj(optionNames[i], handlerObj);
		}

		this.triggerOptionHandlerObj(handlerObj);
	},

	// Puts the given handler object into the internal hash
	registerOptionHandlerObj: function(optionName, handlerObj) {
		(this.optionHandlers[optionName] || (this.optionHandlers[optionName] = []))
			.push(handlerObj);
	},

	// Reports that the given option has changed, and calls all appropriate handlers.
	triggerOptionHandlers: function(optionName) {
		var handlerObjs = this.optionHandlers[optionName] || [];
		var i;

		for (i = 0; i < handlerObjs.length; i++) {
			this.triggerOptionHandlerObj(handlerObjs[i]);
		}
	},

	// Calls the callback for a specific handler object, passing in the appropriate arguments.
	triggerOptionHandlerObj: function(handlerObj) {
		var optionNames = handlerObj.names;
		var optionValues = [];
		var i;

		for (i = 0; i < optionNames.length; i++) {
			optionValues.push(this.options[optionNames[i]]);
		}

		handlerObj.func.apply(this, optionValues); // maintain the Calendar's `this` context
	}

});

;;

Calendar.defaults = {

	titleRangeSeparator: ' \u2013 ', // en dash
	monthYearFormat: 'MMMM YYYY', // required for en. other locales rely on datepicker computable option

	defaultTimedEventDuration: '02:00:00',
	defaultAllDayEventDuration: { days: 1 },
	forceEventDuration: false,
	nextDayThreshold: '09:00:00', // 9am

	// display
	defaultView: 'month',
	aspectRatio: 1.35,
	header: {
		left: 'title',
		center: '',
		right: 'today prev,next'
	},
	weekends: true,
	weekNumbers: false,

	weekNumberTitle: 'W',
	weekNumberCalculation: 'local',
	
	//editable: false,

	//nowIndicator: false,

	scrollTime: '06:00:00',
	minTime: '00:00:00',
	maxTime: '24:00:00',
	showNonCurrentDates: true,
	
	// event ajax
	lazyFetching: true,
	startParam: 'start',
	endParam: 'end',
	timezoneParam: 'timezone',

	timezone: false,

	//allDayDefault: undefined,

	// locale
	isRTL: false,
	buttonText: {
		prev: "prev",
		next: "next",
		prevYear: "prev year",
		nextYear: "next year",
		year: 'year', // TODO: locale files need to specify this
		today: 'today',
		month: 'month',
		week: 'week',
		day: 'day'
	},

	buttonIcons: {
		prev: 'left-single-arrow',
		next: 'right-single-arrow',
		prevYear: 'left-double-arrow',
		nextYear: 'right-double-arrow'
	},

	allDayText: 'all-day',
	
	// jquery-ui theming
	theme: false,
	themeButtonIcons: {
		prev: 'circle-triangle-w',
		next: 'circle-triangle-e',
		prevYear: 'seek-prev',
		nextYear: 'seek-next'
	},

	//eventResizableFromStart: false,
	dragOpacity: .75,
	dragRevertDuration: 500,
	dragScroll: true,
	
	//selectable: false,
	unselectAuto: true,
	//selectMinDistance: 0,
	
	dropAccept: '*',

	eventOrder: 'title',
	//eventRenderWait: null,

	eventLimit: false,
	eventLimitText: 'more',
	eventLimitClick: 'popover',
	dayPopoverFormat: 'LL',
	
	handleWindowResize: true,
	windowResizeDelay: 100, // milliseconds before an updateSize happens

	longPressDelay: 1000
	
};


Calendar.englishDefaults = { // used by locale.js
	dayPopoverFormat: 'dddd, MMMM D'
};


Calendar.rtlDefaults = { // right-to-left defaults
	header: { // TODO: smarter solution (first/center/last ?)
		left: 'next,prev today',
		center: '',
		right: 'title'
	},
	buttonIcons: {
		prev: 'right-single-arrow',
		next: 'left-single-arrow',
		prevYear: 'right-double-arrow',
		nextYear: 'left-double-arrow'
	},
	themeButtonIcons: {
		prev: 'circle-triangle-e',
		next: 'circle-triangle-w',
		nextYear: 'seek-prev',
		prevYear: 'seek-next'
	}
};

;;

var localeOptionHash = FC.locales = {}; // initialize and expose


// TODO: document the structure and ordering of a FullCalendar locale file


// Initialize jQuery UI datepicker translations while using some of the translations
// Will set this as the default locales for datepicker.
FC.datepickerLocale = function(localeCode, dpLocaleCode, dpOptions) {

	// get the FullCalendar internal option hash for this locale. create if necessary
	var fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});

	// transfer some simple options from datepicker to fc
	fcOptions.isRTL = dpOptions.isRTL;
	fcOptions.weekNumberTitle = dpOptions.weekHeader;

	// compute some more complex options from datepicker
	$.each(dpComputableOptions, function(name, func) {
		fcOptions[name] = func(dpOptions);
	});

	// is jQuery UI Datepicker is on the page?
	if ($.datepicker) {

		// Register the locale data.
		// FullCalendar and MomentJS use locale codes like "pt-br" but Datepicker
		// does it like "pt-BR" or if it doesn't have the locale, maybe just "pt".
		// Make an alias so the locale can be referenced either way.
		$.datepicker.regional[dpLocaleCode] =
			$.datepicker.regional[localeCode] = // alias
				dpOptions;

		// Alias 'en' to the default locale data. Do this every time.
		$.datepicker.regional.en = $.datepicker.regional[''];

		// Set as Datepicker's global defaults.
		$.datepicker.setDefaults(dpOptions);
	}
};


// Sets FullCalendar-specific translations. Will set the locales as the global default.
FC.locale = function(localeCode, newFcOptions) {
	var fcOptions;
	var momOptions;

	// get the FullCalendar internal option hash for this locale. create if necessary
	fcOptions = localeOptionHash[localeCode] || (localeOptionHash[localeCode] = {});

	// provided new options for this locales? merge them in
	if (newFcOptions) {
		fcOptions = localeOptionHash[localeCode] = mergeOptions([ fcOptions, newFcOptions ]);
	}

	// compute locale options that weren't defined.
	// always do this. newFcOptions can be undefined when initializing from i18n file,
	// so no way to tell if this is an initialization or a default-setting.
	momOptions = getMomentLocaleData(localeCode); // will fall back to en
	$.each(momComputableOptions, function(name, func) {
		if (fcOptions[name] == null) {
			fcOptions[name] = func(momOptions, fcOptions);
		}
	});

	// set it as the default locale for FullCalendar
	Calendar.defaults.locale = localeCode;
};


// NOTE: can't guarantee any of these computations will run because not every locale has datepicker
// configs, so make sure there are English fallbacks for these in the defaults file.
var dpComputableOptions = {

	buttonText: function(dpOptions) {
		return {
			// the translations sometimes wrongly contain HTML entities
			prev: stripHtmlEntities(dpOptions.prevText),
			next: stripHtmlEntities(dpOptions.nextText),
			today: stripHtmlEntities(dpOptions.currentText)
		};
	},

	// Produces format strings like "MMMM YYYY" -> "September 2014"
	monthYearFormat: function(dpOptions) {
		return dpOptions.showMonthAfterYear ?
			'YYYY[' + dpOptions.yearSuffix + '] MMMM' :
			'MMMM YYYY[' + dpOptions.yearSuffix + ']';
	}

};

var momComputableOptions = {

	// Produces format strings like "ddd M/D" -> "Fri 9/15"
	dayOfMonthFormat: function(momOptions, fcOptions) {
		var format = momOptions.longDateFormat('l'); // for the format like "M/D/YYYY"

		// strip the year off the edge, as well as other misc non-whitespace chars
		format = format.replace(/^Y+[^\w\s]*|[^\w\s]*Y+$/g, '');

		if (fcOptions.isRTL) {
			format += ' ddd'; // for RTL, add day-of-week to end
		}
		else {
			format = 'ddd ' + format; // for LTR, add day-of-week to beginning
		}
		return format;
	},

	// Produces format strings like "h:mma" -> "6:00pm"
	mediumTimeFormat: function(momOptions) { // can't be called `timeFormat` because collides with option
		return momOptions.longDateFormat('LT')
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h(:mm)a" -> "6pm" / "6:30pm"
	smallTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '(:mm)')
			.replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h(:mm)t" -> "6p" / "6:30p"
	extraSmallTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '(:mm)')
			.replace(/(\Wmm)$/, '($1)') // like above, but for foreign locales
			.replace(/\s*a$/i, 't'); // convert to AM/PM/am/pm to lowercase one-letter. remove any spaces beforehand
	},

	// Produces format strings like "ha" / "H" -> "6pm" / "18"
	hourFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(':mm', '')
			.replace(/(\Wmm)$/, '') // like above, but for foreign locales
			.replace(/\s*a$/i, 'a'); // convert AM/PM/am/pm to lowercase. remove any spaces beforehand
	},

	// Produces format strings like "h:mm" -> "6:30" (with no AM/PM)
	noMeridiemTimeFormat: function(momOptions) {
		return momOptions.longDateFormat('LT')
			.replace(/\s*a$/i, ''); // remove trailing AM/PM
	}

};


// options that should be computed off live calendar options (considers override options)
// TODO: best place for this? related to locale?
// TODO: flipping text based on isRTL is a bad idea because the CSS `direction` might want to handle it
var instanceComputableOptions = {

	// Produces format strings for results like "Mo 16"
	smallDayDateFormat: function(options) {
		return options.isRTL ?
			'D dd' :
			'dd D';
	},

	// Produces format strings for results like "Wk 5"
	weekFormat: function(options) {
		return options.isRTL ?
			'w[ ' + options.weekNumberTitle + ']' :
			'[' + options.weekNumberTitle + ' ]w';
	},

	// Produces format strings for results like "Wk5"
	smallWeekFormat: function(options) {
		return options.isRTL ?
			'w[' + options.weekNumberTitle + ']' :
			'[' + options.weekNumberTitle + ']w';
	}

};

function populateInstanceComputableOptions(options) {
	$.each(instanceComputableOptions, function(name, func) {
		if (options[name] == null) {
			options[name] = func(options);
		}
	});
}


// Returns moment's internal locale data. If doesn't exist, returns English.
function getMomentLocaleData(localeCode) {
	return moment.localeData(localeCode) || moment.localeData('en');
}


// Initialize English by forcing computation of moment-derived options.
// Also, sets it as the default.
FC.locale('en', Calendar.englishDefaults);

;;

FC.sourceNormalizers = [];
FC.sourceFetchers = [];

var ajaxDefaults = {
	dataType: 'json',
	cache: false
};

var eventGUID = 1;


function EventManager() { // assumed to be a calendar
	var t = this;


	// exports
	t.requestEvents = requestEvents;
	t.reportEventChange = reportEventChange;
	t.isFetchNeeded = isFetchNeeded;
	t.fetchEvents = fetchEvents;
	t.fetchEventSources = fetchEventSources;
	t.refetchEvents = refetchEvents;
	t.refetchEventSources = refetchEventSources;
	t.getEventSources = getEventSources;
	t.getEventSourceById = getEventSourceById;
	t.addEventSource = addEventSource;
	t.removeEventSource = removeEventSource;
	t.removeEventSources = removeEventSources;
	t.updateEvent = updateEvent;
	t.updateEvents = updateEvents;
	t.renderEvent = renderEvent;
	t.renderEvents = renderEvents;
	t.removeEvents = removeEvents;
	t.clientEvents = clientEvents;
	t.mutateEvent = mutateEvent;
	t.normalizeEventDates = normalizeEventDates;
	t.normalizeEventTimes = normalizeEventTimes;


	// locals
	var stickySource = { events: [] };
	var sources = [ stickySource ];
	var rangeStart, rangeEnd;
	var pendingSourceCnt = 0; // outstanding fetch requests, max one per source
	var cache = []; // holds events that have already been expanded
	var prunedCache; // like cache, but only events that intersect with rangeStart/rangeEnd


	$.each(
		(t.options.events ? [ t.options.events ] : []).concat(t.options.eventSources || []),
		function(i, sourceInput) {
			var source = buildEventSource(sourceInput);
			if (source) {
				sources.push(source);
			}
		}
	);



	function requestEvents(start, end) {
		if (!t.options.lazyFetching || isFetchNeeded(start, end)) {
			return fetchEvents(start, end);
		}
		else {
			return Promise.resolve(prunedCache);
		}
	}


	function reportEventChange() {
		prunedCache = filterEventsWithinRange(cache);
		t.trigger('eventsReset', prunedCache);
	}


	function filterEventsWithinRange(events) {
		var filteredEvents = [];
		var i, event;

		for (i = 0; i < events.length; i++) {
			event = events[i];

			if (
				event.start.clone().stripZone() < rangeEnd &&
				t.getEventEnd(event).stripZone() > rangeStart
			) {
				filteredEvents.push(event);
			}
		}

		return filteredEvents;
	}


	t.getEventCache = function() {
		return cache;
	};


	t.getPrunedEventCache = function() {
		return prunedCache;
	};



	/* Fetching
	-----------------------------------------------------------------------------*/


	// start and end are assumed to be unzoned
	function isFetchNeeded(start, end) {
		return !rangeStart || // nothing has been fetched yet?
			start < rangeStart || end > rangeEnd; // is part of the new range outside of the old range?
	}


	function fetchEvents(start, end) {
		rangeStart = start;
		rangeEnd = end;
		return refetchEvents();
	}


	// poorly named. fetches all sources with current `rangeStart` and `rangeEnd`.
	function refetchEvents() {
		return fetchEventSources(sources, 'reset');
	}


	// poorly named. fetches a subset of event sources.
	function refetchEventSources(matchInputs) {
		return fetchEventSources(getEventSourcesByMatchArray(matchInputs));
	}


	// expects an array of event source objects (the originals, not copies)
	// `specialFetchType` is an optimization parameter that affects purging of the event cache.
	function fetchEventSources(specificSources, specialFetchType) {
		var i, source;

		if (specialFetchType === 'reset') {
			cache = [];
		}
		else if (specialFetchType !== 'add') {
			cache = excludeEventsBySources(cache, specificSources);
		}

		for (i = 0; i < specificSources.length; i++) {
			source = specificSources[i];

			// already-pending sources have already been accounted for in pendingSourceCnt
			if (source._status !== 'pending') {
				pendingSourceCnt++;
			}

			source._fetchId = (source._fetchId || 0) + 1;
			source._status = 'pending';
		}

		for (i = 0; i < specificSources.length; i++) {
			source = specificSources[i];
			tryFetchEventSource(source, source._fetchId);
		}

		if (pendingSourceCnt) {
			return new Promise(function(resolve) {
				t.one('eventsReceived', resolve); // will send prunedCache
			});
		}
		else { // executed all synchronously, or no sources at all
			return Promise.resolve(prunedCache);
		}
	}


	// fetches an event source and processes its result ONLY if it is still the current fetch.
	// caller is responsible for incrementing pendingSourceCnt first.
	function tryFetchEventSource(source, fetchId) {
		_fetchEventSource(source, function(eventInputs) {
			var isArraySource = $.isArray(source.events);
			var i, eventInput;
			var abstractEvent;

			if (
				// is this the source's most recent fetch?
				// if not, rely on an upcoming fetch of this source to decrement pendingSourceCnt
				fetchId === source._fetchId &&
				// event source no longer valid?
				source._status !== 'rejected'
			) {
				source._status = 'resolved';

				if (eventInputs) {
					for (i = 0; i < eventInputs.length; i++) {
						eventInput = eventInputs[i];

						if (isArraySource) { // array sources have already been convert to Event Objects
							abstractEvent = eventInput;
						}
						else {
							abstractEvent = buildEventFromInput(eventInput, source);
						}

						if (abstractEvent) { // not false (an invalid event)
							cache.push.apply( // append
								cache,
								expandEvent(abstractEvent) // add individual expanded events to the cache
							);
						}
					}
				}

				decrementPendingSourceCnt();
			}
		});
	}


	function rejectEventSource(source) {
		var wasPending = source._status === 'pending';

		source._status = 'rejected';

		if (wasPending) {
			decrementPendingSourceCnt();
		}
	}


	function decrementPendingSourceCnt() {
		pendingSourceCnt--;
		if (!pendingSourceCnt) {
			reportEventChange(cache); // updates prunedCache
			t.trigger('eventsReceived', prunedCache);
		}
	}


	function _fetchEventSource(source, callback) {
		var i;
		var fetchers = FC.sourceFetchers;
		var res;

		for (i=0; i<fetchers.length; i++) {
			res = fetchers[i].call(
				t, // this, the Calendar object
				source,
				rangeStart.clone(),
				rangeEnd.clone(),
				t.options.timezone,
				callback
			);

			if (res === true) {
				// the fetcher is in charge. made its own async request
				return;
			}
			else if (typeof res == 'object') {
				// the fetcher returned a new source. process it
				_fetchEventSource(res, callback);
				return;
			}
		}

		var events = source.events;
		if (events) {
			if ($.isFunction(events)) {
				t.pushLoading();
				events.call(
					t, // this, the Calendar object
					rangeStart.clone(),
					rangeEnd.clone(),
					t.options.timezone,
					function(events) {
						callback(events);
						t.popLoading();
					}
				);
			}
			else if ($.isArray(events)) {
				callback(events);
			}
			else {
				callback();
			}
		}else{
			var url = source.url;
			if (url) {
				var success = source.success;
				var error = source.error;
				var complete = source.complete;

				// retrieve any outbound GET/POST $.ajax data from the options
				var customData;
				if ($.isFunction(source.data)) {
					// supplied as a function that returns a key/value object
					customData = source.data();
				}
				else {
					// supplied as a straight key/value object
					customData = source.data;
				}

				// use a copy of the custom data so we can modify the parameters
				// and not affect the passed-in object.
				var data = $.extend({}, customData || {});

				var startParam = firstDefined(source.startParam, t.options.startParam);
				var endParam = firstDefined(source.endParam, t.options.endParam);
				var timezoneParam = firstDefined(source.timezoneParam, t.options.timezoneParam);

				if (startParam) {
					data[startParam] = rangeStart.format();
				}
				if (endParam) {
					data[endParam] = rangeEnd.format();
				}
				if (t.options.timezone && t.options.timezone != 'local') {
					data[timezoneParam] = t.options.timezone;
				}

				t.pushLoading();
				$.ajax($.extend({}, ajaxDefaults, source, {
					data: data,
					success: function(events) {
						events = events || [];
						var res = applyAll(success, this, arguments);
						if ($.isArray(res)) {
							events = res;
						}
						callback(events);
					},
					error: function() {
						applyAll(error, this, arguments);
						callback();
					},
					complete: function() {
						applyAll(complete, this, arguments);
						t.popLoading();
					}
				}));
			}else{
				callback();
			}
		}
	}



	/* Sources
	-----------------------------------------------------------------------------*/


	function addEventSource(sourceInput) {
		var source = buildEventSource(sourceInput);
		if (source) {
			sources.push(source);
			fetchEventSources([ source ], 'add'); // will eventually call reportEventChange
		}
	}


	function buildEventSource(sourceInput) { // will return undefined if invalid source
		var normalizers = FC.sourceNormalizers;
		var source;
		var i;

		if ($.isFunction(sourceInput) || $.isArray(sourceInput)) {
			source = { events: sourceInput };
		}
		else if (typeof sourceInput === 'string') {
			source = { url: sourceInput };
		}
		else if (typeof sourceInput === 'object') {
			source = $.extend({}, sourceInput); // shallow copy
		}

		if (source) {

			// TODO: repeat code, same code for event classNames
			if (source.className) {
				if (typeof source.className === 'string') {
					source.className = source.className.split(/\s+/);
				}
				// otherwise, assumed to be an array
			}
			else {
				source.className = [];
			}

			// for array sources, we convert to standard Event Objects up front
			if ($.isArray(source.events)) {
				source.origArray = source.events; // for removeEventSource
				source.events = $.map(source.events, function(eventInput) {
					return buildEventFromInput(eventInput, source);
				});
			}

			for (i=0; i<normalizers.length; i++) {
				normalizers[i].call(t, source);
			}

			return source;
		}
	}


	function removeEventSource(matchInput) {
		removeSpecificEventSources(
			getEventSourcesByMatch(matchInput)
		);
	}


	// if called with no arguments, removes all.
	function removeEventSources(matchInputs) {
		if (matchInputs == null) {
			removeSpecificEventSources(sources, true); // isAll=true
		}
		else {
			removeSpecificEventSources(
				getEventSourcesByMatchArray(matchInputs)
			);
		}
	}


	function removeSpecificEventSources(targetSources, isAll) {
		var i;

		// cancel pending requests
		for (i = 0; i < targetSources.length; i++) {
			rejectEventSource(targetSources[i]);
		}

		if (isAll) { // an optimization
			sources = [];
			cache = [];
		}
		else {
			// remove from persisted source list
			sources = $.grep(sources, function(source) {
				for (i = 0; i < targetSources.length; i++) {
					if (source === targetSources[i]) {
						return false; // exclude
					}
				}
				return true; // include
			});

			cache = excludeEventsBySources(cache, targetSources);
		}

		reportEventChange();
	}


	function getEventSources() {
		return sources.slice(1); // returns a shallow copy of sources with stickySource removed
	}


	function getEventSourceById(id) {
		return $.grep(sources, function(source) {
			return source.id && source.id === id;
		})[0];
	}


	// like getEventSourcesByMatch, but accepts multple match criteria (like multiple IDs)
	function getEventSourcesByMatchArray(matchInputs) {

		// coerce into an array
		if (!matchInputs) {
			matchInputs = [];
		}
		else if (!$.isArray(matchInputs)) {
			matchInputs = [ matchInputs ];
		}

		var matchingSources = [];
		var i;

		// resolve raw inputs to real event source objects
		for (i = 0; i < matchInputs.length; i++) {
			matchingSources.push.apply( // append
				matchingSources,
				getEventSourcesByMatch(matchInputs[i])
			);
		}

		return matchingSources;
	}


	// matchInput can either by a real event source object, an ID, or the function/URL for the source.
	// returns an array of matching source objects.
	function getEventSourcesByMatch(matchInput) {
		var i, source;

		// given an proper event source object
		for (i = 0; i < sources.length; i++) {
			source = sources[i];
			if (source === matchInput) {
				return [ source ];
			}
		}

		// an ID match
		source = getEventSourceById(matchInput);
		if (source) {
			return [ source ];
		}

		return $.grep(sources, function(source) {
			return isSourcesEquivalent(matchInput, source);
		});
	}


	function isSourcesEquivalent(source1, source2) {
		return source1 && source2 && getSourcePrimitive(source1) == getSourcePrimitive(source2);
	}


	function getSourcePrimitive(source) {
		return (
			(typeof source === 'object') ? // a normalized event source?
				(source.origArray || source.googleCalendarId || source.url || source.events) : // get the primitive
				null
		) ||
		source; // the given argument *is* the primitive
	}


	// util
	// returns a filtered array without events that are part of any of the given sources
	function excludeEventsBySources(specificEvents, specificSources) {
		return $.grep(specificEvents, function(event) {
			for (var i = 0; i < specificSources.length; i++) {
				if (event.source === specificSources[i]) {
					return false; // exclude
				}
			}
			return true; // keep
		});
	}



	/* Manipulation
	-----------------------------------------------------------------------------*/


	// Only ever called from the externally-facing API
	function updateEvent(event) {
		updateEvents([ event ]);
	}


	// Only ever called from the externally-facing API
	function updateEvents(events) {
		var i, event;

		for (i = 0; i < events.length; i++) {
			event = events[i];

			// massage start/end values, even if date string values
			event.start = t.moment(event.start);
			if (event.end) {
				event.end = t.moment(event.end);
			}
			else {
				event.end = null;
			}

			mutateEvent(event, getMiscEventProps(event)); // will handle start/end/allDay normalization
		}

		reportEventChange(); // reports event modifications (so we can redraw)
	}


	// Returns a hash of misc event properties that should be copied over to related events.
	function getMiscEventProps(event) {
		var props = {};

		$.each(event, function(name, val) {
			if (isMiscEventPropName(name)) {
				if (val !== undefined && isAtomic(val)) { // a defined non-object
					props[name] = val;
				}
			}
		});

		return props;
	}

	// non-date-related, non-id-related, non-secret
	function isMiscEventPropName(name) {
		return !/^_|^(id|allDay|start|end)$/.test(name);
	}


	// returns the expanded events that were created
	function renderEvent(eventInput, stick) {
		return renderEvents([ eventInput ], stick);
	}


	// returns the expanded events that were created
	function renderEvents(eventInputs, stick) {
		var renderedEvents = [];
		var renderableEvents;
		var abstractEvent;
		var i, j, event;

		for (i = 0; i < eventInputs.length; i++) {
			abstractEvent = buildEventFromInput(eventInputs[i]);

			if (abstractEvent) { // not false (a valid input)
				renderableEvents = expandEvent(abstractEvent);

				for (j = 0; j < renderableEvents.length; j++) {
					event = renderableEvents[j];

					if (!event.source) {
						if (stick) {
							stickySource.events.push(event);
							event.source = stickySource;
						}
						cache.push(event);
					}
				}

				renderedEvents = renderedEvents.concat(renderableEvents);
			}
		}

		if (renderedEvents.length) { // any new events rendered?
			reportEventChange();
		}

		return renderedEvents;
	}


	function removeEvents(filter) {
		var eventID;
		var i;

		if (filter == null) { // null or undefined. remove all events
			filter = function() { return true; }; // will always match
		}
		else if (!$.isFunction(filter)) { // an event ID
			eventID = filter + '';
			filter = function(event) {
				return event._id == eventID;
			};
		}

		// Purge event(s) from our local cache
		cache = $.grep(cache, filter, true); // inverse=true

		// Remove events from array sources.
		// This works because they have been converted to official Event Objects up front.
		// (and as a result, event._id has been calculated).
		for (i=0; i<sources.length; i++) {
			if ($.isArray(sources[i].events)) {
				sources[i].events = $.grep(sources[i].events, filter, true);
			}
		}

		reportEventChange();
	}


	function clientEvents(filter) {
		if ($.isFunction(filter)) {
			return $.grep(cache, filter);
		}
		else if (filter != null) { // not null, not undefined. an event ID
			filter += '';
			return $.grep(cache, function(e) {
				return e._id == filter;
			});
		}
		return cache; // else, return all
	}


	// Makes sure all array event sources have their internal event objects
	// converted over to the Calendar's current timezone.
	t.rezoneArrayEventSources = function() {
		var i;
		var events;
		var j;

		for (i = 0; i < sources.length; i++) {
			events = sources[i].events;
			if ($.isArray(events)) {

				for (j = 0; j < events.length; j++) {
					rezoneEventDates(events[j]);
				}
			}
		}
	};

	function rezoneEventDates(event) {
		event.start = t.moment(event.start);
		if (event.end) {
			event.end = t.moment(event.end);
		}
		backupEventDates(event);
	}


	/* Event Normalization
	-----------------------------------------------------------------------------*/


	// Given a raw object with key/value properties, returns an "abstract" Event object.
	// An "abstract" event is an event that, if recurring, will not have been expanded yet.
	// Will return `false` when input is invalid.
	// `source` is optional
	function buildEventFromInput(input, source) {
		var out = {};
		var start, end;
		var allDay;

		if (t.options.eventDataTransform) {
			input = t.options.eventDataTransform(input);
		}
		if (source && source.eventDataTransform) {
			input = source.eventDataTransform(input);
		}

		// Copy all properties over to the resulting object.
		// The special-case properties will be copied over afterwards.
		$.extend(out, input);

		if (source) {
			out.source = source;
		}

		out._id = input._id || (input.id === undefined ? '_fc' + eventGUID++ : input.id + '');

		if (input.className) {
			if (typeof input.className == 'string') {
				out.className = input.className.split(/\s+/);
			}
			else { // assumed to be an array
				out.className = input.className;
			}
		}
		else {
			out.className = [];
		}

		start = input.start || input.date; // "date" is an alias for "start"
		end = input.end;

		// parse as a time (Duration) if applicable
		if (isTimeString(start)) {
			start = moment.duration(start);
		}
		if (isTimeString(end)) {
			end = moment.duration(end);
		}

		if (input.dow || moment.isDuration(start) || moment.isDuration(end)) {

			// the event is "abstract" (recurring) so don't calculate exact start/end dates just yet
			out.start = start ? moment.duration(start) : null; // will be a Duration or null
			out.end = end ? moment.duration(end) : null; // will be a Duration or null
			out._recurring = true; // our internal marker
		}
		else {

			if (start) {
				start = t.moment(start);
				if (!start.isValid()) {
					return false;
				}
			}

			if (end) {
				end = t.moment(end);
				if (!end.isValid()) {
					end = null; // let defaults take over
				}
			}

			allDay = input.allDay;
			if (allDay === undefined) { // still undefined? fallback to default
				allDay = firstDefined(
					source ? source.allDayDefault : undefined,
					t.options.allDayDefault
				);
				// still undefined? normalizeEventDates will calculate it
			}

			assignDatesToEvent(start, end, allDay, out);
		}

		t.normalizeEvent(out); // hook for external use. a prototype method

		return out;
	}
	t.buildEventFromInput = buildEventFromInput;


	// Normalizes and assigns the given dates to the given partially-formed event object.
	// NOTE: mutates the given start/end moments. does not make a copy.
	function assignDatesToEvent(start, end, allDay, event) {
		event.start = start;
		event.end = end;
		event.allDay = allDay;
		normalizeEventDates(event);
		backupEventDates(event);
	}


	// Ensures proper values for allDay/start/end. Accepts an Event object, or a plain object with event-ish properties.
	// NOTE: Will modify the given object.
	function normalizeEventDates(eventProps) {

		normalizeEventTimes(eventProps);

		if (eventProps.end && !eventProps.end.isAfter(eventProps.start)) {
			eventProps.end = null;
		}

		if (!eventProps.end) {
			if (t.options.forceEventDuration) {
				eventProps.end = t.getDefaultEventEnd(eventProps.allDay, eventProps.start);
			}
			else {
				eventProps.end = null;
			}
		}
	}


	// Ensures the allDay property exists and the timeliness of the start/end dates are consistent
	function normalizeEventTimes(eventProps) {
		if (eventProps.allDay == null) {
			eventProps.allDay = !(eventProps.start.hasTime() || (eventProps.end && eventProps.end.hasTime()));
		}

		if (eventProps.allDay) {
			eventProps.start.stripTime();
			if (eventProps.end) {
				// TODO: consider nextDayThreshold here? If so, will require a lot of testing and adjustment
				eventProps.end.stripTime();
			}
		}
		else {
			if (!eventProps.start.hasTime()) {
				eventProps.start = t.applyTimezone(eventProps.start.time(0)); // will assign a 00:00 time
			}
			if (eventProps.end && !eventProps.end.hasTime()) {
				eventProps.end = t.applyTimezone(eventProps.end.time(0)); // will assign a 00:00 time
			}
		}
	}


	// If the given event is a recurring event, break it down into an array of individual instances.
	// If not a recurring event, return an array with the single original event.
	// If given a falsy input (probably because of a failed buildEventFromInput call), returns an empty array.
	// HACK: can override the recurring window by providing custom rangeStart/rangeEnd (for businessHours).
	function expandEvent(abstractEvent, _rangeStart, _rangeEnd) {
		var events = [];
		var dowHash;
		var dow;
		var i;
		var date;
		var startTime, endTime;
		var start, end;
		var event;

		_rangeStart = _rangeStart || rangeStart;
		_rangeEnd = _rangeEnd || rangeEnd;

		if (abstractEvent) {
			if (abstractEvent._recurring) {

				// make a boolean hash as to whether the event occurs on each day-of-week
				if ((dow = abstractEvent.dow)) {
					dowHash = {};
					for (i = 0; i < dow.length; i++) {
						dowHash[dow[i]] = true;
					}
				}

				// iterate through every day in the current range
				date = _rangeStart.clone().stripTime(); // holds the date of the current day
				while (date.isBefore(_rangeEnd)) {

					if (!dowHash || dowHash[date.day()]) { // if everyday, or this particular day-of-week

						startTime = abstractEvent.start; // the stored start and end properties are times (Durations)
						endTime = abstractEvent.end; // "
						start = date.clone();
						end = null;

						if (startTime) {
							start = start.time(startTime);
						}
						if (endTime) {
							end = date.clone().time(endTime);
						}

						event = $.extend({}, abstractEvent); // make a copy of the original
						assignDatesToEvent(
							start, end,
							!startTime && !endTime, // allDay?
							event
						);
						events.push(event);
					}

					date.add(1, 'days');
				}
			}
			else {
				events.push(abstractEvent); // return the original event. will be a one-item array
			}
		}

		return events;
	}
	t.expandEvent = expandEvent;



	/* Event Modification Math
	-----------------------------------------------------------------------------------------*/


	// Modifies an event and all related events by applying the given properties.
	// Special date-diffing logic is used for manipulation of dates.
	// If `props` does not contain start/end dates, the updated values are assumed to be the event's current start/end.
	// All date comparisons are done against the event's pristine _start and _end dates.
	// Returns an object with delta information and a function to undo all operations.
	// For making computations in a granularity greater than day/time, specify largeUnit.
	// NOTE: The given `newProps` might be mutated for normalization purposes.
	function mutateEvent(event, newProps, largeUnit) {
		var miscProps = {};
		var oldProps;
		var clearEnd;
		var startDelta;
		var endDelta;
		var durationDelta;
		var undoFunc;

		// diffs the dates in the appropriate way, returning a duration
		function diffDates(date1, date0) { // date1 - date0
			if (largeUnit) {
				return diffByUnit(date1, date0, largeUnit);
			}
			else if (newProps.allDay) {
				return diffDay(date1, date0);
			}
			else {
				return diffDayTime(date1, date0);
			}
		}

		newProps = newProps || {};

		// normalize new date-related properties
		if (!newProps.start) {
			newProps.start = event.start.clone();
		}
		if (newProps.end === undefined) {
			newProps.end = event.end ? event.end.clone() : null;
		}
		if (newProps.allDay == null) { // is null or undefined?
			newProps.allDay = event.allDay;
		}
		normalizeEventDates(newProps);

		// create normalized versions of the original props to compare against
		// need a real end value, for diffing
		oldProps = {
			start: event._start.clone(),
			end: event._end ? event._end.clone() : t.getDefaultEventEnd(event._allDay, event._start),
			allDay: newProps.allDay // normalize the dates in the same regard as the new properties
		};
		normalizeEventDates(oldProps);

		// need to clear the end date if explicitly changed to null
		clearEnd = event._end !== null && newProps.end === null;

		// compute the delta for moving the start date
		startDelta = diffDates(newProps.start, oldProps.start);

		// compute the delta for moving the end date
		if (newProps.end) {
			endDelta = diffDates(newProps.end, oldProps.end);
			durationDelta = endDelta.subtract(startDelta);
		}
		else {
			durationDelta = null;
		}

		// gather all non-date-related properties
		$.each(newProps, function(name, val) {
			if (isMiscEventPropName(name)) {
				if (val !== undefined) {
					miscProps[name] = val;
				}
			}
		});

		// apply the operations to the event and all related events
		undoFunc = mutateEvents(
			clientEvents(event._id), // get events with this ID
			clearEnd,
			newProps.allDay,
			startDelta,
			durationDelta,
			miscProps
		);

		return {
			dateDelta: startDelta,
			durationDelta: durationDelta,
			undo: undoFunc
		};
	}


	// Modifies an array of events in the following ways (operations are in order):
	// - clear the event's `end`
	// - convert the event to allDay
	// - add `dateDelta` to the start and end
	// - add `durationDelta` to the event's duration
	// - assign `miscProps` to the event
	//
	// Returns a function that can be called to undo all the operations.
	//
	// TODO: don't use so many closures. possible memory issues when lots of events with same ID.
	//
	function mutateEvents(events, clearEnd, allDay, dateDelta, durationDelta, miscProps) {
		var isAmbigTimezone = t.getIsAmbigTimezone();
		var undoFunctions = [];

		// normalize zero-length deltas to be null
		if (dateDelta && !dateDelta.valueOf()) { dateDelta = null; }
		if (durationDelta && !durationDelta.valueOf()) { durationDelta = null; }

		$.each(events, function(i, event) {
			var oldProps;
			var newProps;

			// build an object holding all the old values, both date-related and misc.
			// for the undo function.
			oldProps = {
				start: event.start.clone(),
				end: event.end ? event.end.clone() : null,
				allDay: event.allDay
			};
			$.each(miscProps, function(name) {
				oldProps[name] = event[name];
			});

			// new date-related properties. work off the original date snapshot.
			// ok to use references because they will be thrown away when backupEventDates is called.
			newProps = {
				start: event._start,
				end: event._end,
				allDay: allDay // normalize the dates in the same regard as the new properties
			};
			normalizeEventDates(newProps); // massages start/end/allDay

			// strip or ensure the end date
			if (clearEnd) {
				newProps.end = null;
			}
			else if (durationDelta && !newProps.end) { // the duration translation requires an end date
				newProps.end = t.getDefaultEventEnd(newProps.allDay, newProps.start);
			}

			if (dateDelta) {
				newProps.start.add(dateDelta);
				if (newProps.end) {
					newProps.end.add(dateDelta);
				}
			}

			if (durationDelta) {
				newProps.end.add(durationDelta); // end already ensured above
			}

			// if the dates have changed, and we know it is impossible to recompute the
			// timezone offsets, strip the zone.
			if (
				isAmbigTimezone &&
				!newProps.allDay &&
				(dateDelta || durationDelta)
			) {
				newProps.start.stripZone();
				if (newProps.end) {
					newProps.end.stripZone();
				}
			}

			$.extend(event, miscProps, newProps); // copy over misc props, then date-related props
			backupEventDates(event); // regenerate internal _start/_end/_allDay

			undoFunctions.push(function() {
				$.extend(event, oldProps);
				backupEventDates(event); // regenerate internal _start/_end/_allDay
			});
		});

		return function() {
			for (var i = 0; i < undoFunctions.length; i++) {
				undoFunctions[i]();
			}
		};
	}

}


// returns an undo function
Calendar.prototype.mutateSeg = function(seg, newProps) {
	return this.mutateEvent(seg.event, newProps);
};


// hook for external libs to manipulate event properties upon creation.
// should manipulate the event in-place.
Calendar.prototype.normalizeEvent = function(event) {
};


// Does the given span (start, end, and other location information)
// fully contain the other?
Calendar.prototype.spanContainsSpan = function(outerSpan, innerSpan) {
	var eventStart = outerSpan.start.clone().stripZone();
	var eventEnd = this.getEventEnd(outerSpan).stripZone();

	return innerSpan.start >= eventStart && innerSpan.end <= eventEnd;
};


// Returns a list of events that the given event should be compared against when being considered for a move to
// the specified span. Attached to the Calendar's prototype because EventManager is a mixin for a Calendar.
Calendar.prototype.getPeerEvents = function(span, event) {
	var cache = this.getEventCache();
	var peerEvents = [];
	var i, otherEvent;

	for (i = 0; i < cache.length; i++) {
		otherEvent = cache[i];
		if (
			!event ||
			event._id !== otherEvent._id // don't compare the event to itself or other related [repeating] events
		) {
			peerEvents.push(otherEvent);
		}
	}

	return peerEvents;
};


// updates the "backup" properties, which are preserved in order to compute diffs later on.
function backupEventDates(event) {
	event._allDay = event.allDay;
	event._start = event.start.clone();
	event._end = event.end ? event.end.clone() : null;
}


/* Overlapping / Constraining
-----------------------------------------------------------------------------------------*/


// Determines if the given event can be relocated to the given span (unzoned start/end with other misc data)
Calendar.prototype.isEventSpanAllowed = function(span, event) {
	var source = event.source || {};

	var constraint = firstDefined(
		event.constraint,
		source.constraint,
		this.options.eventConstraint
	);

	var overlap = firstDefined(
		event.overlap,
		source.overlap,
		this.options.eventOverlap
	);

	return this.isSpanAllowed(span, constraint, overlap, event) &&
		(!this.options.eventAllow || this.options.eventAllow(span, event) !== false);
};


// Determines if an external event can be relocated to the given span (unzoned start/end with other misc data)
Calendar.prototype.isExternalSpanAllowed = function(eventSpan, eventLocation, eventProps) {
	var eventInput;
	var event;

	// note: very similar logic is in View's reportExternalDrop
	if (eventProps) {
		eventInput = $.extend({}, eventProps, eventLocation);
		event = this.expandEvent(
			this.buildEventFromInput(eventInput)
		)[0];
	}

	if (event) {
		return this.isEventSpanAllowed(eventSpan, event);
	}
	else { // treat it as a selection

		return this.isSelectionSpanAllowed(eventSpan);
	}
};


// Determines the given span (unzoned start/end with other misc data) can be selected.
Calendar.prototype.isSelectionSpanAllowed = function(span) {
	return this.isSpanAllowed(span, this.options.selectConstraint, this.options.selectOverlap) &&
		(!this.options.selectAllow || this.options.selectAllow(span) !== false);
};


// Returns true if the given span (caused by an event drop/resize or a selection) is allowed to exist
// according to the constraint/overlap settings.
// `event` is not required if checking a selection.
Calendar.prototype.isSpanAllowed = function(span, constraint, overlap, event) {
	var constraintEvents;
	var anyContainment;
	var peerEvents;
	var i, peerEvent;
	var peerOverlap;

	// the range must be fully contained by at least one of produced constraint events
	if (constraint != null) {

		// not treated as an event! intermediate data structure
		// TODO: use ranges in the future
		constraintEvents = this.constraintToEvents(constraint);
		if (constraintEvents) { // not invalid

			anyContainment = false;
			for (i = 0; i < constraintEvents.length; i++) {
				if (this.spanContainsSpan(constraintEvents[i], span)) {
					anyContainment = true;
					break;
				}
			}

			if (!anyContainment) {
				return false;
			}
		}
	}

	peerEvents = this.getPeerEvents(span, event);

	for (i = 0; i < peerEvents.length; i++)  {
		peerEvent = peerEvents[i];

		// there needs to be an actual intersection before disallowing anything
		if (this.eventIntersectsRange(peerEvent, span)) {

			// evaluate overlap for the given range and short-circuit if necessary
			if (overlap === false) {
				return false;
			}
			// if the event's overlap is a test function, pass the peer event in question as the first param
			else if (typeof overlap === 'function' && !overlap(peerEvent, event)) {
				return false;
			}

			// if we are computing if the given range is allowable for an event, consider the other event's
			// EventObject-specific or Source-specific `overlap` property
			if (event) {
				peerOverlap = firstDefined(
					peerEvent.overlap,
					(peerEvent.source || {}).overlap
					// we already considered the global `eventOverlap`
				);
				if (peerOverlap === false) {
					return false;
				}
				// if the peer event's overlap is a test function, pass the subject event as the first param
				if (typeof peerOverlap === 'function' && !peerOverlap(event, peerEvent)) {
					return false;
				}
			}
		}
	}

	return true;
};


// Given an event input from the API, produces an array of event objects. Possible event inputs:
// 'businessHours'
// An event ID (number or string)
// An object with specific start/end dates or a recurring event (like what businessHours accepts)
Calendar.prototype.constraintToEvents = function(constraintInput) {

	if (constraintInput === 'businessHours') {
		return this.getCurrentBusinessHourEvents();
	}

	if (typeof constraintInput === 'object') {
		if (constraintInput.start != null) { // needs to be event-like input
			return this.expandEvent(this.buildEventFromInput(constraintInput));
		}
		else {
			return null; // invalid
		}
	}

	return this.clientEvents(constraintInput); // probably an ID
};


// Does the event's date range intersect with the given range?
// start/end already assumed to have stripped zones :(
Calendar.prototype.eventIntersectsRange = function(event, range) {
	var eventStart = event.start.clone().stripZone();
	var eventEnd = this.getEventEnd(event).stripZone();

	return range.start < eventEnd && range.end > eventStart;
};


/* Business Hours
-----------------------------------------------------------------------------------------*/

var BUSINESS_HOUR_EVENT_DEFAULTS = {
	id: '_fcBusinessHours', // will relate events from different calls to expandEvent
	start: '09:00',
	end: '17:00',
	dow: [ 1, 2, 3, 4, 5 ], // monday - friday
	rendering: 'inverse-background'
	// classNames are defined in businessHoursSegClasses
};

// Return events objects for business hours within the current view.
// Abuse of our event system :(
Calendar.prototype.getCurrentBusinessHourEvents = function(wholeDay) {
	return this.computeBusinessHourEvents(wholeDay, this.options.businessHours);
};

// Given a raw input value from options, return events objects for business hours within the current view.
Calendar.prototype.computeBusinessHourEvents = function(wholeDay, input) {
	if (input === true) {
		return this.expandBusinessHourEvents(wholeDay, [ {} ]);
	}
	else if ($.isPlainObject(input)) {
		return this.expandBusinessHourEvents(wholeDay, [ input ]);
	}
	else if ($.isArray(input)) {
		return this.expandBusinessHourEvents(wholeDay, input, true);
	}
	else {
		return [];
	}
};

// inputs expected to be an array of objects.
// if ignoreNoDow is true, will ignore entries that don't specify a day-of-week (dow) key.
Calendar.prototype.expandBusinessHourEvents = function(wholeDay, inputs, ignoreNoDow) {
	var view = this.getView();
	var events = [];
	var i, input;

	for (i = 0; i < inputs.length; i++) {
		input = inputs[i];

		if (ignoreNoDow && !input.dow) {
			continue;
		}

		// give defaults. will make a copy
		input = $.extend({}, BUSINESS_HOUR_EVENT_DEFAULTS, input);

		// if a whole-day series is requested, clear the start/end times
		if (wholeDay) {
			input.start = null;
			input.end = null;
		}

		events.push.apply(events, // append
			this.expandEvent(
				this.buildEventFromInput(input),
				view.activeRange.start,
				view.activeRange.end
			)
		);
	}

	return events;
};

;;

/* An abstract class for the "basic" views, as well as month view. Renders one or more rows of day cells.
----------------------------------------------------------------------------------------------------------------------*/
// It is a manager for a DayGrid subcomponent, which does most of the heavy lifting.
// It is responsible for managing width/height.

var BasicView = FC.BasicView = View.extend({

	scroller: null,

	dayGridClass: DayGrid, // class the dayGrid will be instantiated from (overridable by subclasses)
	dayGrid: null, // the main subcomponent that does most of the heavy lifting

	dayNumbersVisible: false, // display day numbers on each day cell?
	colWeekNumbersVisible: false, // display week numbers along the side?
	cellWeekNumbersVisible: false, // display week numbers in day cell?

	weekNumberWidth: null, // width of all the week-number cells running down the side

	headContainerEl: null, // div that hold's the dayGrid's rendered date header
	headRowEl: null, // the fake row element of the day-of-week header


	initialize: function() {
		this.dayGrid = this.instantiateDayGrid();

		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},


	// Generates the DayGrid object this view needs. Draws from this.dayGridClass
	instantiateDayGrid: function() {
		// generate a subclass on the fly with BasicView-specific behavior
		// TODO: cache this subclass
		var subclass = this.dayGridClass.extend(basicDayGridMethods);

		return new subclass(this);
	},


	// Computes the date range that will be rendered.
	buildRenderRange: function(currentRange, currentRangeUnit) {
		var renderRange = View.prototype.buildRenderRange.apply(this, arguments);

		// year and month views should be aligned with weeks. this is already done for week
		if (/^(year|month)$/.test(currentRangeUnit)) {
			renderRange.start.startOf('week');

			// make end-of-week if not already
			if (renderRange.end.weekday()) {
				renderRange.end.add(1, 'week').startOf('week'); // exclusively move backwards
			}
		}

		return this.trimHiddenDays(renderRange);
	},


	// Renders the view into `this.el`, which should already be assigned
	renderDates: function() {

		this.dayGrid.breakOnWeeks = /year|month|week/.test(this.currentRangeUnit); // do before Grid::setRange
		this.dayGrid.setRange(this.renderRange);

		this.dayNumbersVisible = this.dayGrid.rowCnt > 1; // TODO: make grid responsible
		if (this.opt('weekNumbers')) {
			if (this.opt('weekNumbersWithinDays')) {
				this.cellWeekNumbersVisible = true;
				this.colWeekNumbersVisible = false;
			}
			else {
				this.cellWeekNumbersVisible = false;
				this.colWeekNumbersVisible = true;
			};
		}
		this.dayGrid.numbersVisible = this.dayNumbersVisible ||
			this.cellWeekNumbersVisible || this.colWeekNumbersVisible;

		this.el.addClass('fc-basic-view').html(this.renderSkeletonHtml());
		this.renderHead();

		this.scroller.render();
		var dayGridContainerEl = this.scroller.el.addClass('fc-day-grid-container');
		var dayGridEl = $('<div class="fc-day-grid" />').appendTo(dayGridContainerEl);
		this.el.find('.fc-body > tr > td').append(dayGridContainerEl);

		this.dayGrid.setElement(dayGridEl);
		this.dayGrid.renderDates(this.hasRigidRows());
	},


	// render the day-of-week headers
	renderHead: function() {
		this.headContainerEl =
			this.el.find('.fc-head-container')
				.html(this.dayGrid.renderHeadHtml());
		this.headRowEl = this.headContainerEl.find('.fc-row');
	},


	// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
	// always completely kill the dayGrid's rendering.
	unrenderDates: function() {
		this.dayGrid.unrenderDates();
		this.dayGrid.removeElement();
		this.scroller.destroy();
	},


	renderBusinessHours: function() {
		this.dayGrid.renderBusinessHours();
	},


	unrenderBusinessHours: function() {
		this.dayGrid.unrenderBusinessHours();
	},


	// Builds the HTML skeleton for the view.
	// The day-grid component will render inside of a container defined by this HTML.
	renderSkeletonHtml: function() {
		return '' +
			'<table>' +
				'<thead class="fc-head">' +
					'<tr>' +
						'<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
					'</tr>' +
				'</thead>' +
				'<tbody class="fc-body">' +
					'<tr>' +
						'<td class="' + this.widgetContentClass + '"></td>' +
					'</tr>' +
				'</tbody>' +
			'</table>';
	},


	// Generates an HTML attribute string for setting the width of the week number column, if it is known
	weekNumberStyleAttr: function() {
		if (this.weekNumberWidth !== null) {
			return 'style="width:' + this.weekNumberWidth + 'px"';
		}
		return '';
	},


	// Determines whether each row should have a constant height
	hasRigidRows: function() {
		var eventLimit = this.opt('eventLimit');
		return eventLimit && typeof eventLimit !== 'number';
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	// Refreshes the horizontal dimensions of the view
	updateWidth: function() {
		if (this.colWeekNumbersVisible) {
			// Make sure all week number cells running down the side have the same width.
			// Record the width for cells created later.
			this.weekNumberWidth = matchCellWidths(
				this.el.find('.fc-week-number')
			);
		}
	},


	// Adjusts the vertical dimensions of the view to the specified values
	setHeight: function(totalHeight, isAuto) {
		var eventLimit = this.opt('eventLimit');
		var scrollerHeight;
		var scrollbarWidths;

		// reset all heights to be natural
		this.scroller.clear();
		uncompensateScroll(this.headRowEl);

		this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

		// is the event limit a constant level number?
		if (eventLimit && typeof eventLimit === 'number') {
			this.dayGrid.limitRows(eventLimit); // limit the levels first so the height can redistribute after
		}

		// distribute the height to the rows
		// (totalHeight is a "recommended" value if isAuto)
		scrollerHeight = this.computeScrollerHeight(totalHeight);
		this.setGridHeight(scrollerHeight, isAuto);

		// is the event limit dynamically calculated?
		if (eventLimit && typeof eventLimit !== 'number') {
			this.dayGrid.limitRows(eventLimit); // limit the levels after the grid's row heights have been set
		}

		if (!isAuto) { // should we force dimensions of the scroll container?

			this.scroller.setHeight(scrollerHeight);
			scrollbarWidths = this.scroller.getScrollbarWidths();

			if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

				compensateScroll(this.headRowEl, scrollbarWidths);

				// doing the scrollbar compensation might have created text overflow which created more height. redo
				scrollerHeight = this.computeScrollerHeight(totalHeight);
				this.scroller.setHeight(scrollerHeight);
			}

			// guarantees the same scrollbar widths
			this.scroller.lockOverflow(scrollbarWidths);
		}
	},


	// given a desired total height of the view, returns what the height of the scroller should be
	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},


	// Sets the height of just the DayGrid component in this view
	setGridHeight: function(height, isAuto) {
		if (isAuto) {
			undistributeHeight(this.dayGrid.rowEls); // let the rows be their natural height with no expanding
		}
		else {
			distributeHeight(this.dayGrid.rowEls, height, true); // true = compensate for height-hogging rows
		}
	},


	/* Scroll
	------------------------------------------------------------------------------------------------------------------*/


	computeInitialScroll: function() {
		return { top: 0 };
	},


	queryScroll: function() {
		return { top: this.scroller.getScrollTop() };
	},


	setScroll: function(scroll) {
		this.scroller.setScrollTop(scroll.top);
	},


	/* Hit Areas
	------------------------------------------------------------------------------------------------------------------*/
	// forward all hit-related method calls to dayGrid


	hitsNeeded: function() {
		this.dayGrid.hitsNeeded();
	},


	hitsNotNeeded: function() {
		this.dayGrid.hitsNotNeeded();
	},


	prepareHits: function() {
		this.dayGrid.prepareHits();
	},


	releaseHits: function() {
		this.dayGrid.releaseHits();
	},


	queryHit: function(left, top) {
		return this.dayGrid.queryHit(left, top);
	},


	getHitSpan: function(hit) {
		return this.dayGrid.getHitSpan(hit);
	},


	getHitEl: function(hit) {
		return this.dayGrid.getHitEl(hit);
	},


	/* Events
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the given events onto the view and populates the segments array
	renderEvents: function(events) {
		this.dayGrid.renderEvents(events);

		this.updateHeight(); // must compensate for events that overflow the row
	},


	// Retrieves all segment objects that are rendered in the view
	getEventSegs: function() {
		return this.dayGrid.getEventSegs();
	},


	// Unrenders all event elements and clears internal segment data
	unrenderEvents: function() {
		this.dayGrid.unrenderEvents();

		// we DON'T need to call updateHeight() because
		// a renderEvents() call always happens after this, which will eventually call updateHeight()
	},


	/* Dragging (for both events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(dropLocation, seg) {
		return this.dayGrid.renderDrag(dropLocation, seg);
	},


	unrenderDrag: function() {
		this.dayGrid.unrenderDrag();
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection
	renderSelection: function(span) {
		this.dayGrid.renderSelection(span);
	},


	// Unrenders a visual indications of a selection
	unrenderSelection: function() {
		this.dayGrid.unrenderSelection();
	}

});


// Methods that will customize the rendering behavior of the BasicView's dayGrid
var basicDayGridMethods = {


	// Generates the HTML that will go before the day-of week header cells
	renderHeadIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '' +
				'<th class="fc-week-number ' + view.widgetHeaderClass + '" ' + view.weekNumberStyleAttr() + '>' +
					'<span>' + // needed for matchCellWidths
						htmlEscape(view.opt('weekNumberTitle')) +
					'</span>' +
				'</th>';
		}

		return '';
	},


	// Generates the HTML that will go before content-skeleton cells that display the day/week numbers
	renderNumberIntroHtml: function(row) {
		var view = this.view;
		var weekStart = this.getCellDate(row, 0);

		if (view.colWeekNumbersVisible) {
			return '' +
				'<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '>' +
					view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
						{ date: weekStart, type: 'week', forceOff: this.colCnt === 1 },
						weekStart.format('w') // inner HTML
					) +
				'</td>';
		}

		return '';
	},


	// Generates the HTML that goes before the day bg cells for each day-row
	renderBgIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '<td class="fc-week-number ' + view.widgetContentClass + '" ' +
				view.weekNumberStyleAttr() + '></td>';
		}

		return '';
	},


	// Generates the HTML that goes before every other type of row generated by DayGrid.
	// Affects helper-skeleton and highlight-skeleton rows.
	renderIntroHtml: function() {
		var view = this.view;

		if (view.colWeekNumbersVisible) {
			return '<td class="fc-week-number" ' + view.weekNumberStyleAttr() + '></td>';
		}

		return '';
	}

};

;;

/* A month view with day cells running in rows (one-per-week) and columns
----------------------------------------------------------------------------------------------------------------------*/

var MonthView = FC.MonthView = BasicView.extend({


	// Computes the date range that will be rendered.
	buildRenderRange: function() {
		var renderRange = BasicView.prototype.buildRenderRange.apply(this, arguments);
		var rowCnt;

		// ensure 6 weeks
		if (this.isFixedWeeks()) {
			rowCnt = Math.ceil( // could be partial weeks due to hiddenDays
				renderRange.end.diff(renderRange.start, 'weeks', true) // dontRound=true
			);
			renderRange.end.add(6 - rowCnt, 'weeks');
		}

		return renderRange;
	},


	// Overrides the default BasicView behavior to have special multi-week auto-height logic
	setGridHeight: function(height, isAuto) {

		// if auto, make the height of each row the height that it would be if there were 6 weeks
		if (isAuto) {
			height *= this.rowCnt / 6;
		}

		distributeHeight(this.dayGrid.rowEls, height, !isAuto); // if auto, don't compensate for height-hogging rows
	},


	isFixedWeeks: function() {
		return this.opt('fixedWeekCount');
	}

});

;;

fcViews.basic = {
	'class': BasicView
};

fcViews.basicDay = {
	type: 'basic',
	duration: { days: 1 }
};

fcViews.basicWeek = {
	type: 'basic',
	duration: { weeks: 1 }
};

fcViews.month = {
	'class': MonthView,
	duration: { months: 1 }, // important for prev/next
	defaults: {
		fixedWeekCount: true
	}
};
;;

/* An abstract class for all agenda-related views. Displays one more columns with time slots running vertically.
----------------------------------------------------------------------------------------------------------------------*/
// Is a manager for the TimeGrid subcomponent and possibly the DayGrid subcomponent (if allDaySlot is on).
// Responsible for managing width/height.

var AgendaView = FC.AgendaView = View.extend({

	scroller: null,

	timeGridClass: TimeGrid, // class used to instantiate the timeGrid. subclasses can override
	timeGrid: null, // the main time-grid subcomponent of this view

	dayGridClass: DayGrid, // class used to instantiate the dayGrid. subclasses can override
	dayGrid: null, // the "all-day" subcomponent. if all-day is turned off, this will be null

	axisWidth: null, // the width of the time axis running down the side

	headContainerEl: null, // div that hold's the timeGrid's rendered date header
	noScrollRowEls: null, // set of fake row elements that must compensate when scroller has scrollbars

	// when the time-grid isn't tall enough to occupy the given height, we render an <hr> underneath
	bottomRuleEl: null,

	// indicates that minTime/maxTime affects rendering
	usesMinMaxTime: true,


	initialize: function() {
		this.timeGrid = this.instantiateTimeGrid();

		if (this.opt('allDaySlot')) { // should we display the "all-day" area?
			this.dayGrid = this.instantiateDayGrid(); // the all-day subcomponent of this view
		}

		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},


	// Instantiates the TimeGrid object this view needs. Draws from this.timeGridClass
	instantiateTimeGrid: function() {
		var subclass = this.timeGridClass.extend(agendaTimeGridMethods);

		return new subclass(this);
	},


	// Instantiates the DayGrid object this view might need. Draws from this.dayGridClass
	instantiateDayGrid: function() {
		var subclass = this.dayGridClass.extend(agendaDayGridMethods);

		return new subclass(this);
	},


	/* Rendering
	------------------------------------------------------------------------------------------------------------------*/


	// Renders the view into `this.el`, which has already been assigned
	renderDates: function() {

		this.timeGrid.setRange(this.renderRange);

		if (this.dayGrid) {
			this.dayGrid.setRange(this.renderRange);
		}

		this.el.addClass('fc-agenda-view').html(this.renderSkeletonHtml());
		this.renderHead();

		this.scroller.render();
		var timeGridWrapEl = this.scroller.el.addClass('fc-time-grid-container');
		var timeGridEl = $('<div class="fc-time-grid" />').appendTo(timeGridWrapEl);
		this.el.find('.fc-body > tr > td').append(timeGridWrapEl);

		this.timeGrid.setElement(timeGridEl);
		this.timeGrid.renderDates();

		// the <hr> that sometimes displays under the time-grid
		this.bottomRuleEl = $('<hr class="fc-divider ' + this.widgetHeaderClass + '"/>')
			.appendTo(this.timeGrid.el); // inject it into the time-grid

		if (this.dayGrid) {
			this.dayGrid.setElement(this.el.find('.fc-day-grid'));
			this.dayGrid.renderDates();

			// have the day-grid extend it's coordinate area over the <hr> dividing the two grids
			this.dayGrid.bottomCoordPadding = this.dayGrid.el.next('hr').outerHeight();
		}

		this.noScrollRowEls = this.el.find('.fc-row:not(.fc-scroller *)'); // fake rows not within the scroller
	},


	// render the day-of-week headers
	renderHead: function() {
		this.headContainerEl =
			this.el.find('.fc-head-container')
				.html(this.timeGrid.renderHeadHtml());
	},


	// Unrenders the content of the view. Since we haven't separated skeleton rendering from date rendering,
	// always completely kill each grid's rendering.
	unrenderDates: function() {
		this.timeGrid.unrenderDates();
		this.timeGrid.removeElement();

		if (this.dayGrid) {
			this.dayGrid.unrenderDates();
			this.dayGrid.removeElement();
		}

		this.scroller.destroy();
	},


	// Builds the HTML skeleton for the view.
	// The day-grid and time-grid components will render inside containers defined by this HTML.
	renderSkeletonHtml: function() {
		return '' +
			'<table>' +
				'<thead class="fc-head">' +
					'<tr>' +
						'<td class="fc-head-container ' + this.widgetHeaderClass + '"></td>' +
					'</tr>' +
				'</thead>' +
				'<tbody class="fc-body">' +
					'<tr>' +
						'<td class="' + this.widgetContentClass + '">' +
							(this.dayGrid ?
								'<div class="fc-day-grid"/>' +
								'<hr class="fc-divider ' + this.widgetHeaderClass + '"/>' :
								''
								) +
						'</td>' +
					'</tr>' +
				'</tbody>' +
			'</table>';
	},


	// Generates an HTML attribute string for setting the width of the axis, if it is known
	axisStyleAttr: function() {
		if (this.axisWidth !== null) {
			 return 'style="width:' + this.axisWidth + 'px"';
		}
		return '';
	},


	/* Business Hours
	------------------------------------------------------------------------------------------------------------------*/


	renderBusinessHours: function() {
		this.timeGrid.renderBusinessHours();

		if (this.dayGrid) {
			this.dayGrid.renderBusinessHours();
		}
	},


	unrenderBusinessHours: function() {
		this.timeGrid.unrenderBusinessHours();

		if (this.dayGrid) {
			this.dayGrid.unrenderBusinessHours();
		}
	},


	/* Now Indicator
	------------------------------------------------------------------------------------------------------------------*/


	getNowIndicatorUnit: function() {
		return this.timeGrid.getNowIndicatorUnit();
	},


	renderNowIndicator: function(date) {
		this.timeGrid.renderNowIndicator(date);
	},


	unrenderNowIndicator: function() {
		this.timeGrid.unrenderNowIndicator();
	},


	/* Dimensions
	------------------------------------------------------------------------------------------------------------------*/


	updateSize: function(isResize) {
		this.timeGrid.updateSize(isResize);

		View.prototype.updateSize.call(this, isResize); // call the super-method
	},


	// Refreshes the horizontal dimensions of the view
	updateWidth: function() {
		// make all axis cells line up, and record the width so newly created axis cells will have it
		this.axisWidth = matchCellWidths(this.el.find('.fc-axis'));
	},


	// Adjusts the vertical dimensions of the view to the specified values
	setHeight: function(totalHeight, isAuto) {
		var eventLimit;
		var scrollerHeight;
		var scrollbarWidths;

		// reset all dimensions back to the original state
		this.bottomRuleEl.hide(); // .show() will be called later if this <hr> is necessary
		this.scroller.clear(); // sets height to 'auto' and clears overflow
		uncompensateScroll(this.noScrollRowEls);

		// limit number of events in the all-day area
		if (this.dayGrid) {
			this.dayGrid.removeSegPopover(); // kill the "more" popover if displayed

			eventLimit = this.opt('eventLimit');
			if (eventLimit && typeof eventLimit !== 'number') {
				eventLimit = AGENDA_ALL_DAY_EVENT_LIMIT; // make sure "auto" goes to a real number
			}
			if (eventLimit) {
				this.dayGrid.limitRows(eventLimit);
			}
		}

		if (!isAuto) { // should we force dimensions of the scroll container?

			scrollerHeight = this.computeScrollerHeight(totalHeight);
			this.scroller.setHeight(scrollerHeight);
			scrollbarWidths = this.scroller.getScrollbarWidths();

			if (scrollbarWidths.left || scrollbarWidths.right) { // using scrollbars?

				// make the all-day and header rows lines up
				compensateScroll(this.noScrollRowEls, scrollbarWidths);

				// the scrollbar compensation might have changed text flow, which might affect height, so recalculate
				// and reapply the desired height to the scroller.
				scrollerHeight = this.computeScrollerHeight(totalHeight);
				this.scroller.setHeight(scrollerHeight);
			}

			// guarantees the same scrollbar widths
			this.scroller.lockOverflow(scrollbarWidths);

			// if there's any space below the slats, show the horizontal rule.
			// this won't cause any new overflow, because lockOverflow already called.
			if (this.timeGrid.getTotalSlatHeight() < scrollerHeight) {
				this.bottomRuleEl.show();
			}
		}
	},


	// given a desired total height of the view, returns what the height of the scroller should be
	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},


	/* Scroll
	------------------------------------------------------------------------------------------------------------------*/


	// Computes the initial pre-configured scroll state prior to allowing the user to change it
	computeInitialScroll: function() {
		var scrollTime = moment.duration(this.opt('scrollTime'));
		var top = this.timeGrid.computeTimeTop(scrollTime);

		// zoom can give weird floating-point values. rather scroll a little bit further
		top = Math.ceil(top);

		if (top) {
			top++; // to overcome top border that slots beyond the first have. looks better
		}

		return { top: top };
	},


	queryScroll: function() {
		return { top: this.scroller.getScrollTop() };
	},


	setScroll: function(scroll) {
		this.scroller.setScrollTop(scroll.top);
	},


	/* Hit Areas
	------------------------------------------------------------------------------------------------------------------*/
	// forward all hit-related method calls to the grids (dayGrid might not be defined)


	hitsNeeded: function() {
		this.timeGrid.hitsNeeded();
		if (this.dayGrid) {
			this.dayGrid.hitsNeeded();
		}
	},


	hitsNotNeeded: function() {
		this.timeGrid.hitsNotNeeded();
		if (this.dayGrid) {
			this.dayGrid.hitsNotNeeded();
		}
	},


	prepareHits: function() {
		this.timeGrid.prepareHits();
		if (this.dayGrid) {
			this.dayGrid.prepareHits();
		}
	},


	releaseHits: function() {
		this.timeGrid.releaseHits();
		if (this.dayGrid) {
			this.dayGrid.releaseHits();
		}
	},


	queryHit: function(left, top) {
		var hit = this.timeGrid.queryHit(left, top);

		if (!hit && this.dayGrid) {
			hit = this.dayGrid.queryHit(left, top);
		}

		return hit;
	},


	getHitSpan: function(hit) {
		// TODO: hit.component is set as a hack to identify where the hit came from
		return hit.component.getHitSpan(hit);
	},


	getHitEl: function(hit) {
		// TODO: hit.component is set as a hack to identify where the hit came from
		return hit.component.getHitEl(hit);
	},


	/* Events
	------------------------------------------------------------------------------------------------------------------*/


	// Renders events onto the view and populates the View's segment array
	renderEvents: function(events) {
		var dayEvents = [];
		var timedEvents = [];
		var daySegs = [];
		var timedSegs;
		var i;

		// separate the events into all-day and timed
		for (i = 0; i < events.length; i++) {
			if (events[i].allDay) {
				dayEvents.push(events[i]);
			}
			else {
				timedEvents.push(events[i]);
			}
		}

		// render the events in the subcomponents
		timedSegs = this.timeGrid.renderEvents(timedEvents);
		if (this.dayGrid) {
			daySegs = this.dayGrid.renderEvents(dayEvents);
		}

		// the all-day area is flexible and might have a lot of events, so shift the height
		this.updateHeight();
	},


	// Retrieves all segment objects that are rendered in the view
	getEventSegs: function() {
		return this.timeGrid.getEventSegs().concat(
			this.dayGrid ? this.dayGrid.getEventSegs() : []
		);
	},


	// Unrenders all event elements and clears internal segment data
	unrenderEvents: function() {

		// unrender the events in the subcomponents
		this.timeGrid.unrenderEvents();
		if (this.dayGrid) {
			this.dayGrid.unrenderEvents();
		}

		// we DON'T need to call updateHeight() because
		// a renderEvents() call always happens after this, which will eventually call updateHeight()
	},


	/* Dragging (for events and external elements)
	------------------------------------------------------------------------------------------------------------------*/


	// A returned value of `true` signals that a mock "helper" event has been rendered.
	renderDrag: function(dropLocation, seg) {
		if (dropLocation.start.hasTime()) {
			return this.timeGrid.renderDrag(dropLocation, seg);
		}
		else if (this.dayGrid) {
			return this.dayGrid.renderDrag(dropLocation, seg);
		}
	},


	unrenderDrag: function() {
		this.timeGrid.unrenderDrag();
		if (this.dayGrid) {
			this.dayGrid.unrenderDrag();
		}
	},


	/* Selection
	------------------------------------------------------------------------------------------------------------------*/


	// Renders a visual indication of a selection
	renderSelection: function(span) {
		if (span.start.hasTime() || span.end.hasTime()) {
			this.timeGrid.renderSelection(span);
		}
		else if (this.dayGrid) {
			this.dayGrid.renderSelection(span);
		}
	},


	// Unrenders a visual indications of a selection
	unrenderSelection: function() {
		this.timeGrid.unrenderSelection();
		if (this.dayGrid) {
			this.dayGrid.unrenderSelection();
		}
	}

});


// Methods that will customize the rendering behavior of the AgendaView's timeGrid
// TODO: move into TimeGrid
var agendaTimeGridMethods = {


	// Generates the HTML that will go before the day-of week header cells
	renderHeadIntroHtml: function() {
		var view = this.view;
		var weekText;

		if (view.opt('weekNumbers')) {
			weekText = this.start.format(view.opt('smallWeekFormat'));

			return '' +
				'<th class="fc-axis fc-week-number ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '>' +
					view.buildGotoAnchorHtml( // aside from link, important for matchCellWidths
						{ date: this.start, type: 'week', forceOff: this.colCnt > 1 },
						htmlEscape(weekText) // inner HTML
					) +
				'</th>';
		}
		else {
			return '<th class="fc-axis ' + view.widgetHeaderClass + '" ' + view.axisStyleAttr() + '></th>';
		}
	},


	// Generates the HTML that goes before the bg of the TimeGrid slot area. Long vertical column.
	renderBgIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '></td>';
	},


	// Generates the HTML that goes before all other types of cells.
	// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
	renderIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
	}

};


// Methods that will customize the rendering behavior of the AgendaView's dayGrid
var agendaDayGridMethods = {


	// Generates the HTML that goes before the all-day cells
	renderBgIntroHtml: function() {
		var view = this.view;

		return '' +
			'<td class="fc-axis ' + view.widgetContentClass + '" ' + view.axisStyleAttr() + '>' +
				'<span>' + // needed for matchCellWidths
					view.getAllDayHtml() +
				'</span>' +
			'</td>';
	},


	// Generates the HTML that goes before all other types of cells.
	// Affects content-skeleton, helper-skeleton, highlight-skeleton for both the time-grid and day-grid.
	renderIntroHtml: function() {
		var view = this.view;

		return '<td class="fc-axis" ' + view.axisStyleAttr() + '></td>';
	}

};

;;

var AGENDA_ALL_DAY_EVENT_LIMIT = 5;

// potential nice values for the slot-duration and interval-duration
// from largest to smallest
var AGENDA_STOCK_SUB_DURATIONS = [
	{ hours: 1 },
	{ minutes: 30 },
	{ minutes: 15 },
	{ seconds: 30 },
	{ seconds: 15 }
];

fcViews.agenda = {
	'class': AgendaView,
	defaults: {
		allDaySlot: true,
		slotDuration: '00:30:00',
		slotEventOverlap: true // a bad name. confused with overlap/constraint system
	}
};

fcViews.agendaDay = {
	type: 'agenda',
	duration: { days: 1 }
};

fcViews.agendaWeek = {
	type: 'agenda',
	duration: { weeks: 1 }
};
;;

/*
Responsible for the scroller, and forwarding event-related actions into the "grid"
*/
var ListView = View.extend({

	grid: null,
	scroller: null,

	initialize: function() {
		this.grid = new ListViewGrid(this);
		this.scroller = new Scroller({
			overflowX: 'hidden',
			overflowY: 'auto'
		});
	},

	renderSkeleton: function() {
		this.el.addClass(
			'fc-list-view ' +
			this.widgetContentClass
		);

		this.scroller.render();
		this.scroller.el.appendTo(this.el);

		this.grid.setElement(this.scroller.scrollEl);
	},

	unrenderSkeleton: function() {
		this.scroller.destroy(); // will remove the Grid too
	},

	setHeight: function(totalHeight, isAuto) {
		this.scroller.setHeight(this.computeScrollerHeight(totalHeight));
	},

	computeScrollerHeight: function(totalHeight) {
		return totalHeight -
			subtractInnerElHeight(this.el, this.scroller.el); // everything that's NOT the scroller
	},

	renderDates: function() {
		this.grid.setRange(this.renderRange); // needs to process range-related options
	},

	renderEvents: function(events) {
		this.grid.renderEvents(events);
	},

	unrenderEvents: function() {
		this.grid.unrenderEvents();
	},

	isEventResizable: function(event) {
		return false;
	},

	isEventDraggable: function(event) {
		return false;
	}

});

/*
Responsible for event rendering and user-interaction.
Its "el" is the inner-content of the above view's scroller.
*/
var ListViewGrid = Grid.extend({

	segSelector: '.fc-list-item', // which elements accept event actions
	hasDayInteractions: false, // no day selection or day clicking

	// slices by day
	spanToSegs: function(span) {
		var view = this.view;
		var dayStart = view.renderRange.start.clone().time(0); // timed, so segs get times!
		var dayIndex = 0;
		var seg;
		var segs = [];

		while (dayStart < view.renderRange.end) {

			seg = intersectRanges(span, {
				start: dayStart,
				end: dayStart.clone().add(1, 'day')
			});

			if (seg) {
				seg.dayIndex = dayIndex;
				segs.push(seg);
			}

			dayStart.add(1, 'day');
			dayIndex++;

			// detect when span won't go fully into the next day,
			// and mutate the latest seg to the be the end.
			if (
				seg && !seg.isEnd && span.end.hasTime() &&
				span.end < dayStart.clone().add(this.view.nextDayThreshold)
			) {
				seg.end = span.end.clone();
				seg.isEnd = true;
				break;
			}
		}

		return segs;
	},

	// like "4:00am"
	computeEventTimeFormat: function() {
		return this.view.opt('mediumTimeFormat');
	},

	// for events with a url, the whole <tr> should be clickable,
	// but it's impossible to wrap with an <a> tag. simulate this.
	handleSegClick: function(seg, ev) {
		var url;

		Grid.prototype.handleSegClick.apply(this, arguments); // super. might prevent the default action

		// not clicking on or within an <a> with an href
		if (!$(ev.target).closest('a[href]').length) {
			url = seg.event.url;
			if (url && !ev.isDefaultPrevented()) { // jsEvent not cancelled in handler
				window.location.href = url; // simulate link click
			}
		}
	},

	// returns list of foreground segs that were actually rendered
	renderFgSegs: function(segs) {
		segs = this.renderFgSegEls(segs); // might filter away hidden events

		if (!segs.length) {
			this.renderEmptyMessage();
		}
		else {
			this.renderSegList(segs);
		}

		return segs;
	},

	renderEmptyMessage: function() {
		this.el.html(
			'<div class="fc-list-empty-wrap2">' + // TODO: try less wraps
			'<div class="fc-list-empty-wrap1">' +
			'<div class="fc-list-empty">' +
				htmlEscape(this.view.opt('noEventsMessage')) +
			'</div>' +
			'</div>' +
			'</div>'
		);
	},

	// render the event segments in the view
	renderSegList: function(allSegs) {
		var segsByDay = this.groupSegsByDay(allSegs); // sparse array
		var dayIndex;
		var daySegs;
		var i;
		var tableEl = $('<table class="fc-list-table"><tbody/></table>');
		var tbodyEl = tableEl.find('tbody');

		for (dayIndex = 0; dayIndex < segsByDay.length; dayIndex++) {
			daySegs = segsByDay[dayIndex];
			if (daySegs) { // sparse array, so might be undefined

				// append a day header
				tbodyEl.append(this.dayHeaderHtml(
					this.view.renderRange.start.clone().add(dayIndex, 'days')
				));

				this.sortEventSegs(daySegs);

				for (i = 0; i < daySegs.length; i++) {
					tbodyEl.append(daySegs[i].el); // append event row
				}
			}
		}

		this.el.empty().append(tableEl);
	},

	// Returns a sparse array of arrays, segs grouped by their dayIndex
	groupSegsByDay: function(segs) {
		var segsByDay = []; // sparse array
		var i, seg;

		for (i = 0; i < segs.length; i++) {
			seg = segs[i];
			(segsByDay[seg.dayIndex] || (segsByDay[seg.dayIndex] = []))
				.push(seg);
		}

		return segsByDay;
	},

	// generates the HTML for the day headers that live amongst the event rows
	dayHeaderHtml: function(dayDate) {
		var view = this.view;
		var mainFormat = view.opt('listDayFormat');
		var altFormat = view.opt('listDayAltFormat');

		return '<tr class="fc-list-heading" data-date="' + dayDate.format('YYYY-MM-DD') + '">' +
			'<td class="' + view.widgetHeaderClass + '" colspan="3">' +
				(mainFormat ?
					view.buildGotoAnchorHtml(
						dayDate,
						{ 'class': 'fc-list-heading-main' },
						htmlEscape(dayDate.format(mainFormat)) // inner HTML
					) :
					'') +
				(altFormat ?
					view.buildGotoAnchorHtml(
						dayDate,
						{ 'class': 'fc-list-heading-alt' },
						htmlEscape(dayDate.format(altFormat)) // inner HTML
					) :
					'') +
			'</td>' +
		'</tr>';
	},

	// generates the HTML for a single event row
	fgSegHtml: function(seg) {
		var view = this.view;
		var classes = [ 'fc-list-item' ].concat(this.getSegCustomClasses(seg));
		var bgColor = this.getSegBackgroundColor(seg);
		var event = seg.event;
		var url = event.url;
		var timeHtml;

		if (event.allDay) {
			timeHtml = view.getAllDayHtml();
		}
		else if (view.isMultiDayEvent(event)) { // if the event appears to span more than one day
			if (seg.isStart || seg.isEnd) { // outer segment that probably lasts part of the day
				timeHtml = htmlEscape(this.getEventTimeText(seg));
			}
			else { // inner segment that lasts the whole day
				timeHtml = view.getAllDayHtml();
			}
		}
		else {
			// Display the normal time text for the *event's* times
			timeHtml = htmlEscape(this.getEventTimeText(event));
		}

		if (url) {
			classes.push('fc-has-url');
		}

		return '<tr class="' + classes.join(' ') + '">' +
			(this.displayEventTime ?
				'<td class="fc-list-item-time ' + view.widgetContentClass + '">' +
					(timeHtml || '') +
				'</td>' :
				'') +
			'<td class="fc-list-item-marker ' + view.widgetContentClass + '">' +
				'<span class="fc-event-dot"' +
				(bgColor ?
					' style="background-color:' + bgColor + '"' :
					'') +
				'></span>' +
			'</td>' +
			'<td class="fc-list-item-title ' + view.widgetContentClass + '">' +
				'<a' + (url ? ' href="' + htmlEscape(url) + '"' : '') + '>' +
					htmlEscape(seg.event.title || '') +
				'</a>' +
			'</td>' +
		'</tr>';
	}

});

;;

fcViews.list = {
	'class': ListView,
	buttonTextKey: 'list', // what to lookup in locale files
	defaults: {
		buttonText: 'list', // text to display for English
		listDayFormat: 'LL', // like "January 1, 2016"
		noEventsMessage: 'No events to display'
	}
};

fcViews.listDay = {
	type: 'list',
	duration: { days: 1 },
	defaults: {
		listDayFormat: 'dddd' // day-of-week is all we need. full date is probably in header
	}
};

fcViews.listWeek = {
	type: 'list',
	duration: { weeks: 1 },
	defaults: {
		listDayFormat: 'dddd', // day-of-week is more important
		listDayAltFormat: 'LL'
	}
};

fcViews.listMonth = {
	type: 'list',
	duration: { month: 1 },
	defaults: {
		listDayAltFormat: 'dddd' // day-of-week is nice-to-have
	}
};

fcViews.listYear = {
	type: 'list',
	duration: { year: 1 },
	defaults: {
		listDayAltFormat: 'dddd' // day-of-week is nice-to-have
	}
};

;;

return FC; // export for Node/CommonJS
});;(function($){
/**
 * jqGrid English Translation
 * Tony Tomov tony@trirand.com
 * http://trirand.com/blog/
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 **/
/*global jQuery, define */
	var locInfo = {
		defaults : {
			recordtext: "View {0} - {1} of {2}",
			emptyrecords: "No records to view",
			loadtext: "Loading...",
			savetext: "Saving...",
			pgtext : "Page {0} of {1}",
			pgfirst : "First Page",
			pglast : "Last Page",
			pgnext : "Next Page",
			pgprev : "Previous Page",
			pgrecs : "Records per Page",
			showhide: "Toggle Expand Collapse Grid",
			// mobile
			pagerCaption : "Grid::Page Settings",
			pageText : "Page:",
			recordPage : "Records per Page",
			nomorerecs : "No more records...",
			scrollPullup: "Pull up to load more...",
			scrollPulldown : "Pull down to refresh...",
			scrollRefresh : "Release to refresh..."
		},
		search : {
			caption: "Search...",
			Find: "Find",
			Reset: "Reset",
			odata: [{ oper:'eq', text:'equal'},{ oper:'ne', text:'not equal'},{ oper:'lt', text:'less'},{ oper:'le', text:'less or equal'},{ oper:'gt', text:'greater'},{ oper:'ge', text:'greater or equal'},{ oper:'bw', text:'begins with'},{ oper:'bn', text:'does not begin with'},{ oper:'in', text:'is in'},{ oper:'ni', text:'is not in'},{ oper:'ew', text:'ends with'},{ oper:'en', text:'does not end with'},{ oper:'cn', text:'contains'},{ oper:'nc', text:'does not contain'},{ oper:'nu', text:'is null'},{ oper:'nn', text:'is not null'}, {oper:'bt', text:'between'}],
			groupOps: [{ op: "AND", text: "all" },{ op: "OR",  text: "any" }],
			operandTitle : "Click to select search operation.",
			resetTitle : "Reset Search Value",
			addsubgrup : "Add subgroup",
			addrule : "Add rule",
			delgroup : "Delete group",
			delrule : "Delete rule"
		},
		edit : {
			addCaption: "Add Record",
			editCaption: "Edit Record",
			bSubmit: "Submit",
			bCancel: "Cancel",
			bClose: "Close",
			saveData: "Data has been changed! Save changes?",
			bYes : "Yes",
			bNo : "No",
			bExit : "Cancel",
			msg: {
				required:"Field is required",
				number:"Please, enter valid number",
				minValue:"value must be greater than or equal to ",
				maxValue:"value must be less than or equal to",
				email: "is not a valid e-mail",
				integer: "Please, enter valid integer value",
				date: "Please, enter valid date value",
				url: "is not a valid URL. Prefix required ('http://' or 'https://')",
				nodefined : " is not defined!",
				novalue : " return value is required!",
				customarray : "Custom function should return array!",
				customfcheck : "Custom function should be present in case of custom checking!"

			}
		},
		view : {
			caption: "View Record",
			bClose: "Close"
		},
		del : {
			caption: "Delete",
			msg: "Delete selected record(s)?",
			bSubmit: "Delete",
			bCancel: "Cancel"
		},
		nav : {
			edittext: "",
			edittitle: "Edit selected row",
			addtext:"",
			addtitle: "Add new row",
			deltext: "",
			deltitle: "Delete selected row",
			searchtext: "",
			searchtitle: "Find records",
			refreshtext: "",
			refreshtitle: "Reload Grid",
			alertcap: "Warning",
			alerttext: "Please, select row",
			viewtext: "",
			viewtitle: "View selected row",
			savetext: "",
			savetitle: "Save row",
			canceltext: "",
			canceltitle : "Cancel row editing",
			selectcaption : "Actions..."
		},
		col : {
			caption: "Select columns",
			bSubmit: "Ok",
			bCancel: "Cancel"
		},
		errors : {
			errcap : "Error",
			nourl : "No url is set",
			norecords: "No records to process",
			model : "Length of colNames <> colModel!"
		},
		formatter : {
			integer : {thousandsSeparator: ",", defaultValue: '0'},
			number : {decimalSeparator:".", thousandsSeparator: ",", decimalPlaces: 2, defaultValue: '0.00'},
			currency : {decimalSeparator:".", thousandsSeparator: ",", decimalPlaces: 2, prefix: "", suffix:"", defaultValue: '0.00'},
			date : {
				dayNames:   [
					"Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat",
					"Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"
				],
				monthNames: [
					"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec",
					"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
				],
				AmPm : ["am","pm","AM","PM"],
				S: function (j) {return j < 11 || j > 13 ? ['st', 'nd', 'rd', 'th'][Math.min((j - 1) % 10, 3)] : 'th';},
				srcformat: 'Y-m-d',
				newformat: 'n/j/Y',
				parseRe : /[#%\\\/:_;.,\t\s-]/,
				masks : {
					// see http://php.net/manual/en/function.date.php for PHP format used in jqGrid
					// and see http://docs.jquery.com/UI/Datepicker/formatDate
					// and https://github.com/jquery/globalize#dates for alternative formats used frequently
					// one can find on https://github.com/jquery/globalize/tree/master/lib/cultures many
					// information about date, time, numbers and currency formats used in different countries
					// one should just convert the information in PHP format
					ISO8601Long:"Y-m-d H:i:s",
					ISO8601Short:"Y-m-d",
					// short date:
					//    n - Numeric representation of a month, without leading zeros
					//    j - Day of the month without leading zeros
					//    Y - A full numeric representation of a year, 4 digits
					// example: 3/1/2012 which means 1 March 2012
					ShortDate: "n/j/Y", // in jQuery UI Datepicker: "M/d/yyyy"
					// long date:
					//    l - A full textual representation of the day of the week
					//    F - A full textual representation of a month
					//    d - Day of the month, 2 digits with leading zeros
					//    Y - A full numeric representation of a year, 4 digits
					LongDate: "l, F d, Y", // in jQuery UI Datepicker: "dddd, MMMM dd, yyyy"
					// long date with long time:
					//    l - A full textual representation of the day of the week
					//    F - A full textual representation of a month
					//    d - Day of the month, 2 digits with leading zeros
					//    Y - A full numeric representation of a year, 4 digits
					//    g - 12-hour format of an hour without leading zeros
					//    i - Minutes with leading zeros
					//    s - Seconds, with leading zeros
					//    A - Uppercase Ante meridiem and Post meridiem (AM or PM)
					FullDateTime: "l, F d, Y g:i:s A", // in jQuery UI Datepicker: "dddd, MMMM dd, yyyy h:mm:ss tt"
					// month day:
					//    F - A full textual representation of a month
					//    d - Day of the month, 2 digits with leading zeros
					MonthDay: "F d", // in jQuery UI Datepicker: "MMMM dd"
					// short time (without seconds)
					//    g - 12-hour format of an hour without leading zeros
					//    i - Minutes with leading zeros
					//    A - Uppercase Ante meridiem and Post meridiem (AM or PM)
					ShortTime: "g:i A", // in jQuery UI Datepicker: "h:mm tt"
					// long time (with seconds)
					//    g - 12-hour format of an hour without leading zeros
					//    i - Minutes with leading zeros
					//    s - Seconds, with leading zeros
					//    A - Uppercase Ante meridiem and Post meridiem (AM or PM)
					LongTime: "g:i:s A", // in jQuery UI Datepicker: "h:mm:ss tt"
					SortableDateTime: "Y-m-d\\TH:i:s",
					UniversalSortableDateTime: "Y-m-d H:i:sO",
					// month with year
					//    Y - A full numeric representation of a year, 4 digits
					//    F - A full textual representation of a month
					YearMonth: "F, Y" // in jQuery UI Datepicker: "MMMM, yyyy"
				},
				reformatAfterEdit : false,
				userLocalTime : false
			},
			baseLinkUrl: '',
			showAction: '',
			target: '',
			checkbox : {disabled:true},
			idName : 'id'
		},
		colmenu : {
			sortasc : "Sort Ascending",
			sortdesc : "Sort Descending",
			columns : "Columns",
			filter : "Filter",
			grouping : "Group By",
			ungrouping : "Ungroup",
			searchTitle : "Get items with value that:",
			freeze : "Freeze",
			unfreeze : "Unfreeze",
			reorder : "Move to reorder"
		}
	};

	$.jgrid = $.jgrid || {};
	if (!$.jgrid.hasOwnProperty("regional")) {
		$.jgrid.regional = {};
	}
	$.jgrid.regional.en = $.jgrid.regional["en-EN"] = locInfo;
	$.extend($.jgrid, locInfo);
	
})(jQuery);;(function($){
/**
 * jqGrid Russian Translation v1.0 02.07.2009 (based on translation by Alexey Kanaev v1.1 21.01.2009, http://softcore.com.ru)
 * Sergey Dyagovchenko
 * http://d.sumy.ua
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
**/
var locInfo = {
	defaults : {
		recordtext: "Просмотр {0} - {1} из {2}",
	  emptyrecords: "Нет записей для просмотра",
		loadtext: "Загрузка...",
		pgtext : "Стр. {0} из {1}"
	},
	search : {
    caption: "Поиск...",
    Find: "Найти",
    Reset: "Сброс",
    odata : ['равно', 'не равно', 'меньше', 'меньше или равно','больше','больше или равно', 'начинается с','не начинается с','находится в','не находится в','заканчивается на','не заканчивается на','содержит','не содержит'],
    groupOps: [	{ op: "AND", text: "все" },	{ op: "OR",  text: "любой" }	],
    matchText: " совпадает",
    rulesText: " правила"
	},
	edit : {
    addCaption: "Добавить запись",
    editCaption: "Редактировать запись",
    bSubmit: "Сохранить",
    bCancel: "Отмена",
		bClose: "Закрыть",
		saveData: "Данные были измененны! Сохранить изменения?",
		bYes : "Да",
		bNo : "Нет",
		bExit : "Отмена",
	    msg: {
        required:"Поле является обязательным",
        number:"Пожалуйста, введите правильное число",
        minValue:"значение должно быть больше либо равно",
        maxValue:"значение должно быть меньше либо равно",
        email: "некорректное значение e-mail",
        integer: "Пожалуйста, введите целое число",
        date: "Пожалуйста, введите правильную дату",
        url: "неверная ссылка. Необходимо ввести префикс ('http://' or 'https://')",
		nodefined : " is not defined!",
		novalue : " return value is required!",
		customarray : "Custom function should return array!",
		customfcheck : "Custom function should be present in case of custom checking!"
		}
	},
	view : {
	    caption: "Просмотр записи",
	    bClose: "Закрыть"
	},
	del : {
	    caption: "Удалить",
	    msg: "Удалить выбранную запись(и)?",
	    bSubmit: "Удалить",
	    bCancel: "Отмена"
	},
	nav : {
  		edittext: " ",
	    edittitle: "Редактировать выбранную запись",
  		addtext:" ",
	    addtitle: "Добавить новую запись",
	    deltext: " ",
	    deltitle: "Удалить выбранную запись",
	    searchtext: " ",
	    searchtitle: "Найти записи",
	    refreshtext: "",
	    refreshtitle: "Обновить таблицу",
	    alertcap: "Внимание",
	    alerttext: "Пожалуйста, выберите запись",
  		viewtext: "",
  		viewtitle: "Просмотреть выбранную запись"
	},
	col : {
	    caption: "Показать/скрыть столбцы",
	    bSubmit: "Сохранить",
	    bCancel: "Отмена"	
	},
	errors : {
		errcap : "Ошибка",
		nourl : "URL не установлен",
		norecords: "Нет записей для обработки",
    model : "Число полей не соответствует числу столбцов таблицы!"
	},
	formatter : {
		integer : {thousandsSeparator: " ", defaultValue: '0'},
		number : {decimalSeparator:",", thousandsSeparator: " ", decimalPlaces: 2, defaultValue: '0,00'},
		currency : {decimalSeparator:",", thousandsSeparator: " ", decimalPlaces: 2, prefix: "", suffix:"", defaultValue: '0,00'},
		date : {
			dayNames:   [
				"Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб",
				"Воскресение", "Понедельник", "Вторник", "Среда", "Четверг", "Пятница", "Суббота"
			],
			monthNames: [
				"Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек",
				"Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"
			],
			AmPm : ["am","pm","AM","PM"],
			S: function (j) {return j < 11 || j > 13 ? ['st', 'nd', 'rd', 'th'][Math.min((j - 1) % 10, 3)] : 'th'},
			srcformat: 'Y-m-d',
			newformat: 'd.m.Y',
			masks : {
	            ISO8601Long:"Y-m-d H:i:s",
	            ISO8601Short:"Y-m-d",
	            ShortDate: "n.j.Y",
	            LongDate: "l, F d, Y",
	            FullDateTime: "l, F d, Y G:i:s",
	            MonthDay: "F d",
	            ShortTime: "G:i",
	            LongTime: "G:i:s",
	            SortableDateTime: "Y-m-d\\TH:i:s",
	            UniversalSortableDateTime: "Y-m-d H:i:sO",
	            YearMonth: "F, Y"
	        },
	        reformatAfterEdit : false
		},
		baseLinkUrl: '',
		showAction: '',
	  target: '',
	  checkbox : {disabled:true},
		idName : 'id'
	}
};

	$.jgrid = $.jgrid || {};
	if (!$.jgrid.hasOwnProperty("regional")) {
		$.jgrid.regional = {};
	}
	$.jgrid.regional.ru = $.jgrid.regional["ru-RU"] = locInfo;
	$.extend($.jgrid, locInfo);

})(jQuery);
;(function($){
/**
 * jqGrid Ukrainian Translation v1.0 02.07.2009
 * Sergey Dyagovchenko
 * http://d.sumy.ua
 * Dual licensed under the MIT and GPL licenses:
 * http://www.opensource.org/licenses/mit-license.php
 * http://www.gnu.org/licenses/gpl.html
 **/
/*global jQuery, define */
	var locInfo = {
		defaults : {
			recordtext: "Стор. {0} - {1} з {2}",
			emptyrecords: "Немає записів для перегляду",
			loadtext: "Завантаження...",
			pgtext : "Стор. {0} з {1}",
			savetext: "Saving...",
			pgfirst : "First Page",
			pglast : "Last Page",
			pgnext : "Next Page",
			pgprev : "Previous Page",
			pgrecs : "Records per Page",
			showhide: "Toggle Expand Collapse Grid",
			// mobile
			pagerCaption : "Grid::Page Settings",
			pageText : "Page:",
			recordPage : "Records per Page",
			nomorerecs : "No more records...",
			scrollPullup: "Pull up to load more...",
			scrollPulldown : "Pull down to refresh...",
			scrollRefresh : "Release to refresh..."
		},
		search : {
			caption: "Пошук...",
			Find: "Знайти",
			Reset: "Скидання",
			odata: [{ oper:'eq', text:"рівно"},{ oper:'ne', text:"не рівно"},{ oper:'lt', text:"менше"},{ oper:'le', text:"менше або рівне"},{ oper:'gt', text:"більше"},{ oper:'ge', text:"більше або рівне"},{ oper:'bw', text:"починається з"},{ oper:'bn', text:"не починається з"},{ oper:'in', text:"знаходиться в"},{ oper:'ni', text:"не знаходиться в"},{ oper:'ew', text:"закінчується на"},{ oper:'en', text:"не закінчується на"},{ oper:'cn', text:"містить"},{ oper:'nc', text:"не містить"},{ oper:'nu', text:'is null'},{ oper:'nn', text:'is not null'}, {oper:'bt', text:'between'}],
			groupOps: [	{ op: "AND", text: "все" },	{ op: "OR",  text: "будь-який" }],
			operandTitle : "Click to select search operation.",
			resetTitle : "Reset Search Value",
			addsubgrup : "Add subgroup",
			addrule : "Add rule",
			delgroup : "Delete group",
			delrule : "Delete rule"
		},
		edit : {
			addCaption: "Додати запис",
			editCaption: "Змінити запис",
			bSubmit: "Зберегти",
			bCancel: "Відміна",
			bClose: "Закрити",
			saveData: "До данних були внесені зміни! Зберегти зміни?",
			bYes : "Так",
			bNo : "Ні",
			bExit : "Відміна",
			msg: {
				required:"Поле є обов'язковим",
				number:"Будь ласка, введіть правильне число",
				minValue:"значення повинне бути більше або дорівнює",
				maxValue:"значення повинно бути менше або дорівнює",
				email: "некоректна адреса електронної пошти",
				integer: "Будь ласка, введення дійсне ціле значення",
				date: "Будь ласка, введення дійсне значення дати",
				url: "не дійсний URL. Необхідна приставка ('http://' or 'https://')",
				nodefined : " is not defined!",
				novalue : " return value is required!",
				customarray : "Custom function should return array!",
				customfcheck : "Custom function should be present in case of custom checking!"
			}
		},
		view : {
			caption: "Переглянути запис",
			bClose: "Закрити"
		},
		del : {
			caption: "Видалити",
			msg: "Видалити обраний запис(и)?",
			bSubmit: "Видалити",
			bCancel: "Відміна"
		},
		nav : {
			edittext: " ",
			edittitle: "Змінити вибраний запис",
			addtext:" ",
			addtitle: "Додати новий запис",
			deltext: " ",
			deltitle: "Видалити вибраний запис",
			searchtext: " ",
			searchtitle: "Знайти записи",
			refreshtext: "",
			refreshtitle: "Оновити таблицю",
			alertcap: "Попередження",
			alerttext: "Будь ласка, виберіть запис",
			viewtext: "",
			viewtitle: "Переглянути обраний запис",
			savetext: "",
			savetitle: "Save row",
			canceltext: "",
			canceltitle : "Cancel row editing",
			selectcaption : "Actions..."
		},
		col : {
			caption: "Показати/Приховати стовпці",
			bSubmit: "Зберегти",
			bCancel: "Відміна"
		},
		errors : {
			errcap : "Помилка",
			nourl : "URL не задан",
			norecords: "Немає записів для обробки",
			model : "Число полів не відповідає числу стовпців таблиці!"
		},
		formatter : {
			integer : {thousandsSeparator: " ", defaultValue: '0'},
			number : {decimalSeparator:",", thousandsSeparator: " ", decimalPlaces: 2, defaultValue: '0,00'},
			currency : {decimalSeparator:",", thousandsSeparator: " ", decimalPlaces: 2, prefix: "", suffix:"", defaultValue: '0,00'},
			date : {
				dayNames:   [
					"Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб",
					"Неділя", "Понеділок", "Вівторок", "Середа", "Четвер", "П'ятниця", "Субота"
				],
				monthNames: [
					"Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру",
					"Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень"
				],
				AmPm : ["am","pm","AM","PM"],
				S: function (j) {return j < 11 || j > 13 ? ['st', 'nd', 'rd', 'th'][Math.min((j - 1) % 10, 3)] : 'th'},
				srcformat: 'Y-m-d',
				newformat: 'd.m.Y',
				parseRe : /[#%\\\/:_;.,\t\s-]/,
				masks : {
					ISO8601Long:"Y-m-d H:i:s",
					ISO8601Short:"Y-m-d",
					ShortDate: "n.j.Y",
					LongDate: "l, F d, Y",
					FullDateTime: "l, F d, Y G:i:s",
					MonthDay: "F d",
					ShortTime: "G:i",
					LongTime: "G:i:s",
					SortableDateTime: "Y-m-d\\TH:i:s",
					UniversalSortableDateTime: "Y-m-d H:i:sO",
					YearMonth: "F, Y"
				},
				reformatAfterEdit : false,
				userLocalTime : false
			},
			baseLinkUrl: '',
			showAction: '',
			target: '',
			checkbox : {disabled:true},
			idName : 'id'
		},
		colmenu : {
			sortasc : "Sort Ascending",
			sortdesc : "Sort Descending",
			columns : "Columns",
			filter : "Filter",
			grouping : "Group By",
			ungrouping : "Ungroup",
			searchTitle : "Get items with value that:",
			freeze : "Freeze",
			unfreeze : "Unfreeze",
			reorder : "Move to reorder"
		}
	};

	$.jgrid = $.jgrid || {};
	if (!$.jgrid.hasOwnProperty("regional")) {
		$.jgrid.regional = {};
	}
	$.jgrid.regional.ua = $.jgrid.regional["ua-UA"] = locInfo;
	$.extend($.jgrid, locInfo);

})(jQuery);/*

	jQuery Bubble Popup v.3.0
	http://www.maxvergelli.com/jquery-bubble-popup/
	
	Copyright (c) 2012 Max Vergelli
	
	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:
	
	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.

*/
eval(function(p,a,c,k,e,r){e=function(c){return(c<a?'':e(parseInt(c/a)))+((c=c%a)>35?String.fromCharCode(c+29):c.toString(36))};if(!''.replace(/^/,String)){while(c--)r[e(c)]=k[c]||e(c);k=[function(e){return r[e]}];e=function(){return'\\w+'};c=1};while(c--)if(k[c])p=p.replace(new RegExp('\\b'+e(c)+'\\b','g'),k[c]);return p}('(6(a){a.1i.3t=6(){4 c=X;a(W).1e(6(d,e){4 b=a(e).1I("1R");5(b!=X&&7 b=="1a"&&!a.18(b)&&!a.19(b)&&b.3!=X&&7 b.3=="1a"&&!a.18(b.3)&&!a.19(b.3)&&7 b.3.1t!="1u"){c=b.3.1t?U:Q}12 Q});12 c};a.1i.3u=6(){4 b=X;a(W).1e(6(e,f){4 d=a(f).1I("1R");5(d!=X&&7 d=="1a"&&!a.18(d)&&!a.19(d)&&d.3!=X&&7 d.3=="1a"&&!a.18(d.3)&&!a.19(d.3)&&7 d.3.1S!="1u"&&d.3.1S!=X){b=c(d.3.1S)}12 Q});6 c(d){12 2s 2J(d*2K)}12 b};a.1i.3v=6(){4 b=X;a(W).1e(6(e,f){4 d=a(f).1I("1R");5(d!=X&&7 d=="1a"&&!a.18(d)&&!a.19(d)&&d.3!=X&&7 d.3=="1a"&&!a.18(d.3)&&!a.19(d.3)&&7 d.3.1V!="1u"&&d.3.1V!=X){b=c(d.3.1V)}12 Q});6 c(d){12 2s 2J(d*2K)}12 b};a.1i.3w=6(){4 b=X;a(W).1e(6(e,f){4 d=a(f).1I("1R");5(d!=X&&7 d=="1a"&&!a.18(d)&&!a.19(d)&&d.3!=X&&7 d.3=="1a"&&!a.18(d.3)&&!a.19(d.3)&&7 d.3.1J!="1u"&&d.3.1J!=X){b=c(d.3.1J)}12 Q});6 c(d){12 2s 2J(d*2K)}12 b};a.1i.3x=6(){4 b=X;a(W).1e(6(d,e){4 c=a(e).1I("1R");5(c!=X&&7 c=="1a"&&!a.18(c)&&!a.19(c)&&c.3!=X&&7 c.3=="1a"&&!a.18(c.3)&&!a.19(c.3)&&7 c.3.S!="1u"){b=a("#"+c.3.S).Z>0?a("#"+c.3.S).2k():X}12 Q});12 b};a.1i.3y=6(){4 b=X;a(W).1e(6(d,e){4 c=a(e).1I("1R");5(c!=X&&7 c=="1a"&&!a.18(c)&&!a.19(c)&&c.3!=X&&7 c.3=="1a"&&!a.18(c.3)&&!a.19(c.3)&&7 c.3.S!="1u"){b=c.3.S}12 Q});12 b};a.1i.3z=6(){4 b=0;a(W).1e(6(d,e){4 c=a(e).1I("1R");5(c!=X&&7 c=="1a"&&!a.18(c)&&!a.19(c)&&c.3!=X&&7 c.3=="1a"&&!a.18(c.3)&&!a.19(c.3)&&7 c.3.S!="1u"){a(e).2d("2S");a(e).2d("2T");a(e).2d("2U");a(e).2d("2A");a(e).2d("2L");a(e).2d("2t");a(e).2d("2u");a(e).2d("22");a(e).1I("1R",{});5(a("#"+c.3.S).Z>0){a("#"+c.3.S).2B()}b++}});12 b};a.1i.3A=6(){4 c=Q;a(W).1e(6(d,e){4 b=a(e).1I("1R");5(b!=X&&7 b=="1a"&&!a.18(b)&&!a.19(b)&&b.3!=X&&7 b.3=="1a"&&!a.18(b.3)&&!a.19(b.3)&&7 b.3.S!="1u"){c=U}12 Q});12 c};a.1i.3B=6(){4 b={};a(W).1e(6(c,d){b=a(d).1I("1R");5(b!=X&&7 b=="1a"&&!a.18(b)&&!a.19(b)&&b.3!=X&&7 b.3=="1a"&&!a.18(b.3)&&!a.19(b.3)){3C b.3}1c{b=X}12 Q});5(a.19(b)){b=X}12 b};a.1i.3D=6(b,c){a(W).1e(6(d,e){5(7 c!="1K"){c=U}a(e).1f("2T",[b,c])})};a.1i.3E=6(b){a(W).1e(6(c,d){a(d).1f("2U",[b])})};a.1i.3F=6(b,c){a(W).1e(6(d,e){a(e).1f("2u",[b,c,U]);12 Q})};a.1i.3G=6(b,c){a(W).1e(6(d,e){a(e).1f("2u",[b,c,U])})};a.1i.3H=6(){a(W).1e(6(b,c){a(c).1f("22",[U]);12 Q})};a.1i.3I=6(){a(W).1e(6(b,c){a(c).1f("22",[U])})};a.1i.3J=6(){a(W).1e(6(b,c){a(c).1f("2L");12 Q})};a.1i.3K=6(){a(W).1e(6(b,c){a(c).1f("2L")})};a.1i.3L=6(){a(W).1e(6(b,c){a(c).1f("2t");12 Q})};a.1i.3M=6(){a(W).1e(6(b,c){a(c).1f("2t")})};a.1i.3N=6(e){4 r={2M:W,3O:[],2V:"1R",3a:["T","13","1b"],3b:["R","13","1d"],3c:\'<3d 1v="{1L} {3e}"{2W} S="{2X}"> 									<2Y{2Z}> 									<3f> 									<2v> 										<14 1v="{1L}-T-R"{2l-30}>{2l-2N}</14> 										<14 1v="{1L}-T-13"{2l-3g}>{2l-1W}</14> 										<14 1v="{1L}-T-1d"{2l-31}>{2l-2O}</14> 									</2v> 									<2v> 										<14 1v="{1L}-13-R"{1W-30}>{1W-2N}</14> 										<14 1v="{1L}-1G"{32}>{33}</14> 										<14 1v="{1L}-13-1d"{1W-31}>{1W-2O}</14> 									</2v> 									<2v> 										<14 1v="{1L}-1b-R"{2m-30}>{2m-2N}</14> 										<14 1v="{1L}-1b-13"{2m-3g}>{2m-1W}</14> 										<14 1v="{1L}-1b-1d"{2m-31}>{2m-2O}</14> 									</2v> 									</3f> 									</2Y> 									</3d>\',3:{S:X,1J:X,1V:X,1S:X,1t:Q,1M:Q,1o:Q,1z:Q,1X:Q,1A:Q,23:{}},15:"T",3h:["R","T","1d","1b"],11:"24",34:["R","24","1d","T","13","1b"],2P:["R","24","1d"],35:["T","13","1b"],1n:"3P",1p:X,1q:X,1w:{},1x:{},1G:X,1N:{},V:{11:"24",1C:Q},1j:U,2n:U,25:Q,2o:U,26:"2C",3i:["2C","36"],27:"36",3j:["2C","36"],1O:3k,1P:3k,28:0,29:0,Y:"3l",1Y:"3Q",2a:"3l-3R/",1h:{2D:"3S",1D:"3T"},1T:6(){},1U:6(){},1m:[]};h(e);6 g(v){4 w={3:{},1p:r.1p,1q:r.1q,1w:r.1w,1x:r.1x,15:r.15,11:r.11,1n:r.1n,1O:r.1O,1P:r.1P,28:r.28,29:r.29,26:r.26,27:r.27,V:r.V,1G:r.1G,1N:r.1N,Y:r.Y,1Y:r.1Y,2a:r.2a,1h:r.1h,1j:r.1j,2o:r.2o,2n:r.2n,25:r.25,1T:r.1T,1U:r.1U,1m:r.1m};4 t=a.3U(Q,w,(7 v=="1a"&&!a.18(v)&&!a.19(v)&&v!=X?v:{}));t.3.S=r.3.S;t.3.1J=r.3.1J;t.3.1V=r.3.1V;t.3.1S=r.3.1S;t.3.1t=r.3.1t;t.3.1M=r.3.1M;t.3.1o=r.3.1o;t.3.1z=r.3.1z;t.3.1X=r.3.1X;t.3.1A=r.3.1A;t.3.23=r.3.23;t.1p=(7 t.1p=="1Q"||7 t.1p=="2b")&&10(t.1p)>0?10(t.1p):r.1p;t.1q=(7 t.1q=="1Q"||7 t.1q=="2b")&&10(t.1q)>0?10(t.1q):r.1q;t.1w=t.1w!=X&&7 t.1w=="1a"&&!a.18(t.1w)&&!a.19(t.1w)?t.1w:r.1w;t.1x=t.1x!=X&&7 t.1x=="1a"&&!a.18(t.1x)&&!a.19(t.1x)?t.1x:r.1x;t.15=7 t.15=="1Q"&&o(t.15.1Z(),r.3h)?t.15.1Z():r.15;t.11=7 t.11=="1Q"&&o(t.11.1Z(),r.34)?t.11.1Z():r.11;t.1n=(7 t.1n=="1Q"||7 t.1n=="2b")&&10(t.1n)>=0?10(t.1n):r.1n;t.1O=7 t.1O=="2b"&&10(t.1O)>0?10(t.1O):r.1O;t.1P=7 t.1P=="2b"&&10(t.1P)>0?10(t.1P):r.1P;t.28=7 t.28=="2b"&&t.28>=0?t.28:r.28;t.29=7 t.29=="2b"&&t.29>=0?t.29:r.29;t.26=7 t.26=="1Q"&&o(t.26.1Z(),r.3i)?t.26.1Z():r.26;t.27=7 t.27=="1Q"&&o(t.27.1Z(),r.3j)?t.27.1Z():r.27;t.V=t.V!=X&&7 t.V=="1a"&&!a.18(t.V)&&!a.19(t.V)?t.V:r.V;t.V.11=7 t.V.11!="1u"?t.V.11:r.V.11;t.V.1C=7 t.V.1C!="1u"?t.V.1C:r.V.1C;t.1G=7 t.1G=="1Q"&&t.1G.Z>0?t.1G:r.1G;t.1N=t.1N!=X&&7 t.1N=="1a"&&!a.18(t.1N)&&!a.19(t.1N)?t.1N:r.1N;t.Y=j(7 t.Y=="1Q"&&t.Y.Z>0?t.Y:r.Y);t.1Y=7 t.1Y=="1Q"&&t.1Y.Z>0?a.3m(t.1Y):r.1Y;t.2a=7 t.2a=="1Q"&&t.2a.Z>0?a.3m(t.2a):r.2a;t.1h=t.1h!=X&&7 t.1h=="1a"&&!a.18(t.1h)&&!a.19(t.1h)&&(7 10(t.1h.2D)=="2b"&&7 10(t.1h.1D)=="2b")?t.1h:r.1h;t.1j=7 t.1j=="1K"&&t.1j==U?U:Q;t.2o=7 t.2o=="1K"&&t.2o==U?U:Q;t.2n=7 t.2n=="1K"&&t.2n==U?U:Q;t.25=7 t.25=="1K"&&t.25==U?U:Q;t.1T=7 t.1T=="6"?t.1T:r.1T;t.1U=7 t.1U=="6"?t.1U:r.1U;t.1m=a.18(t.1m)?t.1m:r.1m;5(t.15=="R"||t.15=="1d"){t.11=o(t.11,r.35)?t.11:"13"}1c{t.11=o(t.11,r.2P)?t.11:"24"}20(4 u 2p t.V){2e(u){17"11":t.V.11=7 t.V.11=="1Q"&&o(t.V.11.1Z(),r.34)?t.V.11.1Z():r.V.11;5(t.15=="R"||t.15=="1d"){t.V.11=o(t.V.11,r.35)?t.V.11:"13"}1c{t.V.11=o(t.V.11,r.2P)?t.V.11:"24"}16;17"1C":t.V.1C=t.V.1C==U?U:Q;16}}12 t}6 l(t){5(t==0){12 0}5(t>0){12-(1r.1y(t))}1c{12 1r.1y(t)}}6 o(v,w){4 t=Q;20(4 u 2p w){5(w[u]==v){t=U;16}}12 t}6 k(t){a(t).1e(6(){a("<1H/>")[0].2q=W})}6 b(t){5(t.1m&&t.1m.Z>0){20(4 u=0;u<t.1m.Z;u++){4 v=(t.1m[u].3n(0)!="#"?"#"+t.1m[u]:t.1m[u]);a(v).1k({37:"1C"})}}}6 s(u){5(u.1m&&u.1m.Z>0){20(4 v=0;v<u.1m.Z;v++){4 x=(u.1m[v].3n(0)!="#"?"#"+u.1m[v]:u.1m[v]);a(x).1k({37:"3o"});4 w=a(x).Z;20(4 t=0;t<w.Z;t++){a(w[t]).1k({37:"3o"})}}}}6 m(u){4 w=u.2a;4 t=u.1Y;4 v=(w.2E(w.Z-1)=="/"||w.2E(w.Z-1)=="\\\\")?w.2E(0,w.Z-1)+"/"+t+"/":w+"/"+t+"/";12 v+(u.1j==U?(a.1l.1E?"2f/":""):"2f/")}6 j(t){4 u=t.2E(0,1)=="."?t.2E(1,t.Z):t;12 u}6 q(u){5(a("#"+u.3.S).Z>0){4 t="1b-13";2e(u.15){17"R":t="13-1d";16;17"T":t="1b-13";16;17"1d":t="13-R";16;17"1b":t="T-13";16}5(o(u.V.11,r.2P)){a("#"+u.3.S).1g("14."+u.Y+"-"+t).1k("38-11",u.V.11)}1c{a("#"+u.3.S).1g("14."+u.Y+"-"+t).1k("39-11",u.V.11)}}}6 p(v){4 H=r.3c;4 F=m(v);4 x="";4 G="";4 u="";5(!v.V.1C){2e(v.15){17"R":G="1d";u="{1W-2O}";16;17"T":G="1b";u="{2m-1W}";16;17"1d":G="R";u="{1W-2N}";16;17"1b":G="T";u="{2l-1W}";16}x=\'<1H 2q="\'+F+"V-"+G+"."+(v.1j==U?(a.1l.1E?"1F":"2r"):"1F")+\'" 2w="" 1v="\'+v.Y+\'-V" />\'}4 t=r.3a;4 z=r.3b;4 K,E,A,J;4 B="";4 y="";4 D=2s 3p();20(E 2p t){A="";J="";20(K 2p z){A=t[E]+"-"+z[K];A=A.3V();J="{"+A+"3W}";A="{"+A+"}";5(A==u){H=H.1B(A,x);B=""}1c{H=H.1B(A,"");B=""}5(t[E]+"-"+z[K]!="13-13"){y=F+t[E]+"-"+z[K]+"."+(v.1j==U?(a.1l.1E?"1F":"2r"):"1F");D.3X(y);H=H.1B(J,\' 2Q="\'+B+"3Y-3Z:40("+y+\');"\')}}}5(D.Z>0){k(D)}4 w="";5(v.1x!=X&&7 v.1x=="1a"&&!a.18(v.1x)&&!a.19(v.1x)){20(4 C 2p v.1x){w+=C+":"+v.1x[C]+";"}}w+=(v.1p!=X||v.1q!=X)?(v.1p!=X?"1p:"+v.1p+"21;":"")+(v.1q!=X?"1q:"+v.1q+"21;":""):"";H=w.Z>0?H.1B("{2Z}",\' 2Q="\'+w+\'"\'):H.1B("{2Z}","");4 I="";5(v.1w!=X&&7 v.1w=="1a"&&!a.18(v.1w)&&!a.19(v.1w)){20(4 C 2p v.1w){I+=C+":"+v.1w[C]+";"}}H=I.Z>0?H.1B("{2W}",\' 2Q="\'+I+\'"\'):H.1B("{2W}","");H=H.1B("{3e}",v.Y+"-"+v.1Y);H=v.3.S!=X?H.1B("{2X}",v.3.S):H.1B("{2X}","");41(H.42("{1L}")>-1){H=H.1B("{1L}",v.Y)}H=v.1G!=X?H.1B("{33}",v.1G):H.1B("{33}","");J="";20(4 C 2p v.1N){J+=C+":"+v.1N[C]+";"}H=J.Z>0?H.1B("{32}",\' 2Q="\'+J+\'"\'):H.1B("{32}","");12 H}6 f(){12 1r.43(2s 2J().44()/2K)}6 c(E,N,x){4 O=x.15;4 K=x.11;4 z=x.1n;4 F=x.1h;4 I=2s 3p();4 u=N.2F();4 t=10(u.T);4 y=10(u.R);4 P=10(N.2x(Q));4 L=10(N.2y(Q));4 v=10(E.2x(Q));4 M=10(E.2y(Q));F.1D=1r.1y(10(F.1D));F.2D=1r.1y(10(F.2D));4 w=l(F.1D);4 J=l(F.1D);4 A=l(F.2D);4 H=m(x);2e(K){17"R":I.T=O=="T"?t-M-z+l(w):t+L+z+w;I.R=y+A;16;17"24":4 D=1r.1y(v-P)/2;I.T=O=="T"?t-M-z+l(w):t+L+z+w;I.R=v>=P?y-D:y+D;16;17"1d":4 D=1r.1y(v-P);I.T=O=="T"?t-M-z+l(w):t+L+z+w;I.R=v>=P?y-D+l(A):y+D+l(A);16;17"T":I.T=t+A;I.R=O=="R"?y-v-z+l(J):y+P+z+J;16;17"13":4 D=1r.1y(M-L)/2;I.T=M>=L?t-D:t+D;I.R=O=="R"?y-v-z+l(J):y+P+z+J;16;17"1b":4 D=1r.1y(M-L);I.T=M>=L?t-D+l(A):t+D+l(A);I.R=O=="R"?y-v-z+l(J):y+P+z+J;16}I.15=O;5(a("#"+x.3.S).Z>0&&a("#"+x.3.S).1g("1H."+x.Y+"-V").Z>0){a("#"+x.3.S).1g("1H."+x.Y+"-V").2B();4 G="1b";4 C="1b-13";2e(O){17"R":G="1d";C="13-1d";16;17"T":G="1b";C="1b-13";16;17"1d":G="R";C="13-R";16;17"1b":G="T";C="T-13";16}a("#"+x.3.S).1g("14."+x.Y+"-"+C).2G();a("#"+x.3.S).1g("14."+x.Y+"-"+C).2k(\'<1H 2q="\'+H+"V-"+G+"."+(x.1j==U?(a.1l.1E?"1F":"2r"):"1F")+\'" 2w="" 1v="\'+x.Y+\'-V" />\');q(x)}5(x.2n==U){5(I.T<a(1s).2g()||I.T+M>a(1s).2g()+a(1s).1q()){5(a("#"+x.3.S).Z>0&&a("#"+x.3.S).1g("1H."+x.Y+"-V").Z>0){a("#"+x.3.S).1g("1H."+x.Y+"-V").2B()}4 B="";5(I.T<a(1s).2g()){I.15="1b";I.T=t+L+z+w;5(a("#"+x.3.S).Z>0&&!x.V.1C){a("#"+x.3.S).1g("14."+x.Y+"-T-13").2G();a("#"+x.3.S).1g("14."+x.Y+"-T-13").2k(\'<1H 2q="\'+H+"V-T."+(x.1j==U?(a.1l.1E?"1F":"2r"):"1F")+\'" 2w="" 1v="\'+x.Y+\'-V" />\');B="T-13"}}1c{5(I.T+M>a(1s).2g()+a(1s).1q()){I.15="T";I.T=t-M-z+l(w);5(a("#"+x.3.S).Z>0&&!x.V.1C){a("#"+x.3.S).1g("14."+x.Y+"-1b-13").2G();a("#"+x.3.S).1g("14."+x.Y+"-1b-13").2k(\'<1H 2q="\'+H+"V-1b."+(x.1j==U?(a.1l.1E?"1F":"2r"):"1F")+\'" 2w="" 1v="\'+x.Y+\'-V" />\');B="1b-13"}}}5(I.R<0){I.R=0;5(B.Z>0){a("#"+x.3.S).1g("14."+x.Y+"-"+B).1k("38-11","24")}}1c{5(I.R+v>a(1s).1p()){I.R=a(1s).1p()-v;5(B.Z>0){a("#"+x.3.S).1g("14."+x.Y+"-"+B).1k("38-11","24")}}}}1c{5(I.R<0||I.R+v>a(1s).1p()){5(a("#"+x.3.S).Z>0&&a("#"+x.3.S).1g("1H."+x.Y+"-V").Z>0){a("#"+x.3.S).1g("1H."+x.Y+"-V").2B()}4 B="";5(I.R<0){I.15="1d";I.R=y+P+z+J;5(a("#"+x.3.S).Z>0&&!x.V.1C){a("#"+x.3.S).1g("14."+x.Y+"-13-R").2G();a("#"+x.3.S).1g("14."+x.Y+"-13-R").2k(\'<1H 2q="\'+H+"V-R."+(x.1j==U?(a.1l.1E?"1F":"2r"):"1F")+\'" 2w="" 1v="\'+x.Y+\'-V" />\');B="13-R"}}1c{5(I.R+v>a(1s).1p()){I.15="R";I.R=y-v-z+l(J);5(a("#"+x.3.S).Z>0&&!x.V.1C){a("#"+x.3.S).1g("14."+x.Y+"-13-1d").2G();a("#"+x.3.S).1g("14."+x.Y+"-13-1d").2k(\'<1H 2q="\'+H+"V-1d."+(x.1j==U?(a.1l.1E?"1F":"2r"):"1F")+\'" 2w="" 1v="\'+x.Y+\'-V" />\');B="13-1d"}}}5(I.T<a(1s).2g()){I.T=a(1s).2g();5(B.Z>0){a("#"+x.3.S).1g("14."+x.Y+"-"+B).1k("39-11","13")}}1c{5(I.T+M>a(1s).2g()+a(1s).1q()){I.T=(a(1s).2g()+a(1s).1q())-M;5(B.Z>0){a("#"+x.3.S).1g("14."+x.Y+"-"+B).1k("39-11","13")}}}}}}12 I}6 d(u,t){a(u).1I(r.2V,t)}6 n(t){12 a(t).1I(r.2V)}6 i(t){4 u=t!=X&&7 t=="1a"&&!a.18(t)&&!a.19(t)?U:Q;12 u}6 h(t){a(1s).45(6(){a(r.2M).1e(6(u,v){a(v).1f("2A")})});a(46).47(6(u){a(r.2M).1e(6(v,w){a(w).1f("2S",[u.48,u.49])})});a(r.2M).1e(6(v,w){4 u=g(t);u.3.1J=f();u.3.S=u.Y+"-"+u.3.1J+"-"+v;d(w,u);a(w).2h("2S",6(y,C,B){4 N=n(W);5(i(N)&&i(N.3)&&7 C!="1u"&&7 B!="1u"){5(N.2o){4 E=a(W);4 z=E.2F();4 L=10(z.T);4 H=10(z.R);4 F=10(E.2x(Q));4 K=10(E.2y(Q));4 J=Q;5(H<=C&&C<=F+H&&L<=B&&B<=K+L){J=U}1c{J=Q}5(J&&!N.3.1X){N.3.1X=U;d(W,N);5(N.26=="2C"){a(W).1f("2u")}1c{5(N.25&&a("#"+N.3.S).Z>0){4 x=a("#"+N.3.S);4 A=x.2F();4 D=10(A.T);4 I=10(A.R);4 G=10(x.2x(Q));4 M=10(x.2y(Q));5(I<=C&&C<=G+I&&D<=B&&B<=M+D){}1c{a(W).1f("22")}}1c{a(W).1f("22")}}}1c{5(!J&&N.3.1X){N.3.1X=Q;d(W,N);5(N.27=="2C"){a(W).1f("2u")}1c{5(N.25&&a("#"+N.3.S).Z>0){4 x=a("#"+N.3.S);4 A=x.2F();4 D=10(A.T);4 I=10(A.R);4 G=10(x.2x(Q));4 M=10(x.2y(Q));5(I<=C&&C<=G+I&&D<=B&&B<=M+D){}1c{a(W).1f("22")}}1c{a(W).1f("22")}}}1c{5(!J&&!N.3.1X){5(N.25&&a("#"+N.3.S).Z>0&&!N.3.1o){4 x=a("#"+N.3.S);4 A=x.2F();4 D=10(A.T);4 I=10(A.R);4 G=10(x.2x(Q));4 M=10(x.2y(Q));5(I<=C&&C<=G+I&&D<=B&&B<=M+D){}1c{a(W).1f("22")}}}}}}}});a(w).2h("2T",6(A,x,z){4 y=n(W);5(i(y)&&i(y.3)&&7 x!="1u"){y.3.1V=f();5(7 z=="1K"&&z==U){y.1G=x}d(W,y);5(a("#"+y.3.S).Z>0){a("#"+y.3.S).1g("14."+y.Y+"-1G").2k(x);5(y.3.1z){a(W).1f("2A",[Q])}1c{a(W).1f("2A",[U])}}}});a(w).2h("2U",6(A,z){4 x=n(W);5(i(x)&&i(x.3)){4 y=x;x=g(z);x.3.S=y.3.S;x.3.1J=y.3.1J;x.3.1V=f();x.3.1S=y.3.1S;x.3.1t=y.3.1t;x.3.1M=y.3.1M;x.3.23={};d(W,x)}});a(w).2h("2A",6(A,y){4 z=n(W);5(i(z)&&i(z.3)&&a("#"+z.3.S).Z>0&&z.3.1t==U){4 x=a("#"+z.3.S);4 C=c(x,a(W),z);4 B=2;5(7 y=="1K"&&y==U){x.1k({T:C.T,R:C.R})}1c{2e(z.15){17"R":x.1k({T:C.T,R:(C.15!=z.15?C.R-(1r.1y(z.1h.1D)*B):C.R+(1r.1y(z.1h.1D)*B))});16;17"T":x.1k({T:(C.15!=z.15?C.T-(1r.1y(z.1h.1D)*B):C.T+(1r.1y(z.1h.1D)*B)),R:C.R});16;17"1d":x.1k({T:C.T,R:(C.15!=z.15?C.R+(1r.1y(z.1h.1D)*B):C.R-(1r.1y(z.1h.1D)*B))});16;17"1b":x.1k({T:(C.15!=z.15?C.T+(1r.1y(z.1h.1D)*B):C.T-(1r.1y(z.1h.1D)*B)),R:C.R});16}}}});a(w).2h("2L",6(){4 x=n(W);5(i(x)&&i(x.3)){x.3.1M=U;d(W,x)}});a(w).2h("2t",6(){4 x=n(W);5(i(x)&&i(x.3)){x.3.1M=Q;d(W,x)}});a(w).2h("2u",6(x,A,D,G){4 H=n(W);5((7 G=="1K"&&G==U&&(i(H)&&i(H.3)))||(7 G=="1u"&&(i(H)&&i(H.3)&&!H.3.1M&&!H.3.1t))){5(7 G=="1K"&&G==U){a(W).1f("2t")}H.3.1t=U;H.3.1M=Q;H.3.1o=Q;H.3.1z=Q;5(i(H.3.23)){H=H.3.23}1c{H.3.23={}}5(i(A)){4 C=H;4 F=f();H=g(A);H.3.S=C.3.S;H.3.1J=C.3.1J;H.3.1V=F;H.3.1S=F;H.3.1t=U;H.3.1M=Q;H.3.1o=Q;H.3.1z=Q;H.3.1X=C.3.1X;H.3.1A=C.3.1A;H.3.23={};5(7 D=="1K"&&D==Q){C.3.1V=F;C.3.1S=F;H.3.23=C}}d(W,H);b(H);5(a("#"+H.3.S).Z>0){a("#"+H.3.S).2B()}4 y={};4 B=p(H);y=a(B);y.4a("4b");y=a("#"+H.3.S);y.1k({2c:0,T:"3q",R:"3q",15:"4c",2H:"4d"});5(H.1j==U){5(a.1l.1E&&10(a.1l.2z)<9){a("#"+H.3.S+" 2Y").2I(H.Y+"-2f")}}q(H);4 E=c(y,a(W),H);y.1k({T:E.T,R:E.R});5(E.15==H.15){H.3.1A=Q}1c{H.3.1A=U}d(W,H);4 z=3r(6(){H.3.1o=U;d(w,H);y.3s();2e(H.15){17"R":y.2i({2c:1,R:(H.3.1A?"-=":"+=")+H.1n+"21"},H.1O,"2j",6(){H.3.1o=Q;H.3.1z=U;d(w,H);5(H.1j==U){5(a.1l.1E&&10(a.1l.2z)>8){y.2I(H.Y+"-2f")}}H.1T()});16;17"T":y.2i({2c:1,T:(H.3.1A?"-=":"+=")+H.1n+"21"},H.1O,"2j",6(){H.3.1o=Q;H.3.1z=U;d(w,H);5(H.1j==U){5(a.1l.1E&&10(a.1l.2z)>8){y.2I(H.Y+"-2f")}}H.1T()});16;17"1d":y.2i({2c:1,R:(H.3.1A?"+=":"-=")+H.1n+"21"},H.1O,"2j",6(){H.3.1o=Q;H.3.1z=U;d(w,H);5(H.1j==U){5(a.1l.1E&&10(a.1l.2z)>8){y.2I(H.Y+"-2f")}}H.1T()});16;17"1b":y.2i({2c:1,T:(H.3.1A?"+=":"-=")+H.1n+"21"},H.1O,"2j",6(){H.3.1o=Q;H.3.1z=U;d(w,H);5(H.1j==U){5(a.1l.1E&&10(a.1l.2z)>8){y.2I(H.Y+"-2f")}}H.1T()});16}},H.28)}});a(w).2h("22",6(B,x){4 A=n(W);5((7 x=="1K"&&x==U&&(i(A)&&i(A.3)&&a("#"+A.3.S).Z>0))||(7 x=="1u"&&(i(A)&&i(A.3)&&a("#"+A.3.S).Z>0&&!A.3.1M&&A.3.1t))){5(7 x=="1K"&&x==U){a(W).1f("2t")}A.3.1o=Q;A.3.1z=Q;d(W,A);4 y=a("#"+A.3.S);4 z=7 x=="1u"?A.29:0;4 C=3r(6(){A.3.1o=U;d(w,A);y.3s();5(A.1j==U){5(a.1l.1E&&10(a.1l.2z)>8){y.4e(A.Y+"-2f")}}2e(A.15){17"R":y.2i({2c:0,R:(A.3.1A?"+=":"-=")+A.1n+"21"},A.1P,"2j",6(){A.3.1t=Q;A.3.1o=Q;A.3.1z=U;d(w,A);y.1k("2H","2R");A.1U()});16;17"T":y.2i({2c:0,T:(A.3.1A?"+=":"-=")+A.1n+"21"},A.1P,"2j",6(){A.3.1t=Q;A.3.1o=Q;A.3.1z=U;d(w,A);y.1k("2H","2R");A.1U()});16;17"1d":y.2i({2c:0,R:(A.3.1A?"-=":"+=")+A.1n+"21"},A.1P,"2j",6(){A.3.1t=Q;A.3.1o=Q;A.3.1z=U;d(w,A);y.1k("2H","2R");A.1U()});16;17"1b":y.2i({2c:0,T:(A.3.1A?"-=":"+=")+A.1n+"21"},A.1P,"2j",6(){A.3.1t=Q;A.3.1o=Q;A.3.1z=U;d(w,A);y.1k("2H","2R");A.1U()});16}},z);A.3.1S=f();A.3.1M=Q;d(W,A);s(A)}})})}12 W}})(4f);',62,264,'|||privateVars|var|if|function|typeof|||||||||||||||||||||||||||||||||||||||||||||false|left|id|top|true|tail|this|null|baseClass|length|parseInt|align|return|middle|td|position|break|case|isArray|isEmptyObject|object|bottom|else|right|each|trigger|find|themeMargins|fn|dropShadow|css|browser|hideElementId|distance|is_animating|width|height|Math|window|is_open|undefined|class|divStyle|tableStyle|abs|is_animation_complete|is_position_changed|replace|hidden|difference|msie|gif|innerHtml|img|data|creation_datetime|boolean|BASE_CLASS|is_freezed|innerHtmlStyle|openingSpeed|closingSpeed|string|private_jquerybubblepopup_options|last_display_datetime|afterShown|afterHidden|last_modified_datetime|MIDDLE|is_mouse_over|themeName|toLowerCase|for|px|hidebubblepopup|last_options|center|selectable|mouseOver|mouseOut|openingDelay|closingDelay|themePath|number|opacity|unbind|switch|ie|scrollTop|bind|animate|swing|html|TOP|BOTTOM|alwaysVisible|manageMouseEvents|in|src|png|new|unfreezebubblepopup|showbubblepopup|tr|alt|outerWidth|outerHeight|version|positionbubblepopup|remove|show|total|substring|offset|empty|display|addClass|Date|1000|freezebubblepopup|me|LEFT|RIGHT|alignHorizontalValues|style|none|managebubblepopup|setbubblepopupinnerhtml|setbubblepopupoptions|options_key|DIV_STYLE|DIV_ID|table|TABLE_STYLE|LEFT_STYLE|RIGHT_STYLE|INNERHTML_STYLE|INNERHTML|alignValues|alignVerticalValues|hide|visibility|text|vertical|model_tr|model_td|model_markup|div|TEMPLATE_CLASS|tbody|MIDDLE_STYLE|positionValues|mouseOverValues|mouseOutValues|250|jquerybubblepopup|trim|charAt|visible|Array|0px|setTimeout|stop|IsBubblePopupOpen|GetBubblePopupLastDisplayDateTime|GetBubblePopupLastModifiedDateTime|GetBubblePopupCreationDateTime|GetBubblePopupMarkup|GetBubblePopupID|RemoveBubblePopup|HasBubblePopup|GetBubblePopupOptions|delete|SetBubblePopupInnerHtml|SetBubblePopupOptions|ShowBubblePopup|ShowAllBubblePopups|HideBubblePopup|HideAllBubblePopups|FreezeBubblePopup|FreezeAllBubblePopups|UnfreezeBubblePopup|UnfreezeAllBubblePopups|CreateBubblePopup|cache|20px|azure|themes|13px|10px|extend|toUpperCase|_STYLE|push|background|image|url|while|indexOf|round|getTime|resize|document|mousemove|pageX|pageY|appendTo|body|absolute|block|removeClass|jQuery'.split('|'),0,{}));/*!
 * jQuery UI 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function( $, undefined ) {

// prevent duplicate loading
// this is only a problem because we proxy existing functions
// and we don't want to double proxy them
$.ui = $.ui || {};
if ( $.ui.version ) {
	return;
}

$.extend( $.ui, {
	version: "1.8.21",

	keyCode: {
		ALT: 18,
		BACKSPACE: 8,
		CAPS_LOCK: 20,
		COMMA: 188,
		COMMAND: 91,
		COMMAND_LEFT: 91, // COMMAND
		COMMAND_RIGHT: 93,
		CONTROL: 17,
		DELETE: 46,
		DOWN: 40,
		END: 35,
		ENTER: 13,
		ESCAPE: 27,
		HOME: 36,
		INSERT: 45,
		LEFT: 37,
		MENU: 93, // COMMAND_RIGHT
		NUMPAD_ADD: 107,
		NUMPAD_DECIMAL: 110,
		NUMPAD_DIVIDE: 111,
		NUMPAD_ENTER: 108,
		NUMPAD_MULTIPLY: 106,
		NUMPAD_SUBTRACT: 109,
		PAGE_DOWN: 34,
		PAGE_UP: 33,
		PERIOD: 190,
		RIGHT: 39,
		SHIFT: 16,
		SPACE: 32,
		TAB: 9,
		UP: 38,
		WINDOWS: 91 // COMMAND
	}
});

// plugins
$.fn.extend({
	propAttr: $.fn.prop || $.fn.attr,

	_focus: $.fn.focus,
	focus: function( delay, fn ) {
		return typeof delay === "number" ?
			this.each(function() {
				var elem = this;
				setTimeout(function() {
					$( elem ).focus();
					if ( fn ) {
						fn.call( elem );
					}
				}, delay );
			}) :
			this._focus.apply( this, arguments );
	},

	scrollParent: function() {
		var scrollParent;
		if (($.browser.msie && (/(static|relative)/).test(this.css('position'))) || (/absolute/).test(this.css('position'))) {
			scrollParent = this.parents().filter(function() {
				return (/(relative|absolute|fixed)/).test($.curCSS(this,'position',1)) && (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));
			}).eq(0);
		} else {
			scrollParent = this.parents().filter(function() {
				return (/(auto|scroll)/).test($.curCSS(this,'overflow',1)+$.curCSS(this,'overflow-y',1)+$.curCSS(this,'overflow-x',1));
			}).eq(0);
		}

		return (/fixed/).test(this.css('position')) || !scrollParent.length ? $(document) : scrollParent;
	},

	zIndex: function( zIndex ) {
		if ( zIndex !== undefined ) {
			return this.css( "zIndex", zIndex );
		}

		if ( this.length ) {
			var elem = $( this[ 0 ] ), position, value;
			while ( elem.length && elem[ 0 ] !== document ) {
				// Ignore z-index if position is set to a value where z-index is ignored by the browser
				// This makes behavior of this function consistent across browsers
				// WebKit always returns auto if the element is positioned
				position = elem.css( "position" );
				if ( position === "absolute" || position === "relative" || position === "fixed" ) {
					// IE returns 0 when zIndex is not specified
					// other browsers return a string
					// we ignore the case of nested elements with an explicit value of 0
					// <div style="z-index: -10;"><div style="z-index: 0;"></div></div>
					value = parseInt( elem.css( "zIndex" ), 10 );
					if ( !isNaN( value ) && value !== 0 ) {
						return value;
					}
				}
				elem = elem.parent();
			}
		}

		return 0;
	},

	disableSelection: function() {
		return this.bind( ( $.support.selectstart ? "selectstart" : "mousedown" ) +
			".ui-disableSelection", function( event ) {
				event.preventDefault();
			});
	},

	enableSelection: function() {
		return this.unbind( ".ui-disableSelection" );
	}
});

$.each( [ "Width", "Height" ], function( i, name ) {
	var side = name === "Width" ? [ "Left", "Right" ] : [ "Top", "Bottom" ],
		type = name.toLowerCase(),
		orig = {
			innerWidth: $.fn.innerWidth,
			innerHeight: $.fn.innerHeight,
			outerWidth: $.fn.outerWidth,
			outerHeight: $.fn.outerHeight
		};

	function reduce( elem, size, border, margin ) {
		$.each( side, function() {
			size -= parseFloat( $.curCSS( elem, "padding" + this, true) ) || 0;
			if ( border ) {
				size -= parseFloat( $.curCSS( elem, "border" + this + "Width", true) ) || 0;
			}
			if ( margin ) {
				size -= parseFloat( $.curCSS( elem, "margin" + this, true) ) || 0;
			}
		});
		return size;
	}

	$.fn[ "inner" + name ] = function( size ) {
		if ( size === undefined ) {
			return orig[ "inner" + name ].call( this );
		}

		return this.each(function() {
			$( this ).css( type, reduce( this, size ) + "px" );
		});
	};

	$.fn[ "outer" + name] = function( size, margin ) {
		if ( typeof size !== "number" ) {
			return orig[ "outer" + name ].call( this, size );
		}

		return this.each(function() {
			$( this).css( type, reduce( this, size, true, margin ) + "px" );
		});
	};
});

// selectors
function focusable( element, isTabIndexNotNaN ) {
	var nodeName = element.nodeName.toLowerCase();
	if ( "area" === nodeName ) {
		var map = element.parentNode,
			mapName = map.name,
			img;
		if ( !element.href || !mapName || map.nodeName.toLowerCase() !== "map" ) {
			return false;
		}
		img = $( "img[usemap=#" + mapName + "]" )[0];
		return !!img && visible( img );
	}
	return ( /input|select|textarea|button|object/.test( nodeName )
		? !element.disabled
		: "a" == nodeName
			? element.href || isTabIndexNotNaN
			: isTabIndexNotNaN)
		// the element and all of its ancestors must be visible
		&& visible( element );
}

function visible( element ) {
	return !$( element ).parents().andSelf().filter(function() {
		return $.curCSS( this, "visibility" ) === "hidden" ||
			$.expr.filters.hidden( this );
	}).length;
}

$.extend( $.expr[ ":" ], {
	data: function( elem, i, match ) {
		return !!$.data( elem, match[ 3 ] );
	},

	focusable: function( element ) {
		return focusable( element, !isNaN( $.attr( element, "tabindex" ) ) );
	},

	tabbable: function( element ) {
		var tabIndex = $.attr( element, "tabindex" ),
			isTabIndexNaN = isNaN( tabIndex );
		return ( isTabIndexNaN || tabIndex >= 0 ) && focusable( element, !isTabIndexNaN );
	}
});

// support
$(function() {
	var body = document.body,
		div = body.appendChild( div = document.createElement( "div" ) );

	// access offsetHeight before setting the style to prevent a layout bug
	// in IE 9 which causes the elemnt to continue to take up space even
	// after it is removed from the DOM (#8026)
	div.offsetHeight;

	$.extend( div.style, {
		minHeight: "100px",
		height: "auto",
		padding: 0,
		borderWidth: 0
	});

	$.support.minHeight = div.offsetHeight === 100;
	$.support.selectstart = "onselectstart" in div;

	// set display to none to avoid a layout bug in IE
	// http://dev.jquery.com/ticket/4014
	body.removeChild( div ).style.display = "none";
});





// deprecated
$.extend( $.ui, {
	// $.ui.plugin is deprecated.  Use the proxy pattern instead.
	plugin: {
		add: function( module, option, set ) {
			var proto = $.ui[ module ].prototype;
			for ( var i in set ) {
				proto.plugins[ i ] = proto.plugins[ i ] || [];
				proto.plugins[ i ].push( [ option, set[ i ] ] );
			}
		},
		call: function( instance, name, args ) {
			var set = instance.plugins[ name ];
			if ( !set || !instance.element[ 0 ].parentNode ) {
				return;
			}
	
			for ( var i = 0; i < set.length; i++ ) {
				if ( instance.options[ set[ i ][ 0 ] ] ) {
					set[ i ][ 1 ].apply( instance.element, args );
				}
			}
		}
	},
	
	// will be deprecated when we switch to jQuery 1.4 - use jQuery.contains()
	contains: function( a, b ) {
		return document.compareDocumentPosition ?
			a.compareDocumentPosition( b ) & 16 :
			a !== b && a.contains( b );
	},
	
	// only used by resizable
	hasScroll: function( el, a ) {
	
		//If overflow is hidden, the element might have extra content, but the user wants to hide it
		if ( $( el ).css( "overflow" ) === "hidden") {
			return false;
		}
	
		var scroll = ( a && a === "left" ) ? "scrollLeft" : "scrollTop",
			has = false;
	
		if ( el[ scroll ] > 0 ) {
			return true;
		}
	
		// TODO: determine which cases actually cause this to happen
		// if the element doesn't have the scroll set, see if it's possible to
		// set the scroll
		el[ scroll ] = 1;
		has = ( el[ scroll ] > 0 );
		el[ scroll ] = 0;
		return has;
	},
	
	// these are odd functions, fix the API or move into individual plugins
	isOverAxis: function( x, reference, size ) {
		//Determines when x coordinate is over "b" element axis
		return ( x > reference ) && ( x < ( reference + size ) );
	},
	isOver: function( y, x, top, left, height, width ) {
		//Determines when x, y coordinates is over "b" element
		return $.ui.isOverAxis( y, top, height ) && $.ui.isOverAxis( x, left, width );
	}
});

})( jQuery );
/*!
 * jQuery UI Widget 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function( $, undefined ) {

// jQuery 1.4+
if ( $.cleanData ) {
	var _cleanData = $.cleanData;
	$.cleanData = function( elems ) {
		for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
			try {
				$( elem ).triggerHandler( "remove" );
			// http://bugs.jquery.com/ticket/8235
			} catch( e ) {}
		}
		_cleanData( elems );
	};
} else {
	var _remove = $.fn.remove;
	$.fn.remove = function( selector, keepData ) {
		return this.each(function() {
			if ( !keepData ) {
				if ( !selector || $.filter( selector, [ this ] ).length ) {
					$( "*", this ).add( [ this ] ).each(function() {
						try {
							$( this ).triggerHandler( "remove" );
						// http://bugs.jquery.com/ticket/8235
						} catch( e ) {}
					});
				}
			}
			return _remove.call( $(this), selector, keepData );
		});
	};
}

$.widget = function( name, base, prototype ) {
	var namespace = name.split( "." )[ 0 ],
		fullName;
	name = name.split( "." )[ 1 ];
	fullName = namespace + "-" + name;

	if ( !prototype ) {
		prototype = base;
		base = $.Widget;
	}

	// create selector for plugin
	$.expr[ ":" ][ fullName ] = function( elem ) {
		return !!$.data( elem, name );
	};

	$[ namespace ] = $[ namespace ] || {};
	$[ namespace ][ name ] = function( options, element ) {
		// allow instantiation without initializing for simple inheritance
		if ( arguments.length ) {
			this._createWidget( options, element );
		}
	};

	var basePrototype = new base();
	// we need to make the options hash a property directly on the new instance
	// otherwise we'll modify the options hash on the prototype that we're
	// inheriting from
//	$.each( basePrototype, function( key, val ) {
//		if ( $.isPlainObject(val) ) {
//			basePrototype[ key ] = $.extend( {}, val );
//		}
//	});
	basePrototype.options = $.extend( true, {}, basePrototype.options );
	$[ namespace ][ name ].prototype = $.extend( true, basePrototype, {
		namespace: namespace,
		widgetName: name,
		widgetEventPrefix: $[ namespace ][ name ].prototype.widgetEventPrefix || name,
		widgetBaseClass: fullName
	}, prototype );

	$.widget.bridge( name, $[ namespace ][ name ] );
};

$.widget.bridge = function( name, object ) {
	$.fn[ name ] = function( options ) {
		var isMethodCall = typeof options === "string",
			args = Array.prototype.slice.call( arguments, 1 ),
			returnValue = this;

		// allow multiple hashes to be passed on init
		options = !isMethodCall && args.length ?
			$.extend.apply( null, [ true, options ].concat(args) ) :
			options;

		// prevent calls to internal methods
		if ( isMethodCall && options.charAt( 0 ) === "_" ) {
			return returnValue;
		}

		if ( isMethodCall ) {
			this.each(function() {
				var instance = $.data( this, name ),
					methodValue = instance && $.isFunction( instance[options] ) ?
						instance[ options ].apply( instance, args ) :
						instance;
				// TODO: add this back in 1.9 and use $.error() (see #5972)
//				if ( !instance ) {
//					throw "cannot call methods on " + name + " prior to initialization; " +
//						"attempted to call method '" + options + "'";
//				}
//				if ( !$.isFunction( instance[options] ) ) {
//					throw "no such method '" + options + "' for " + name + " widget instance";
//				}
//				var methodValue = instance[ options ].apply( instance, args );
				if ( methodValue !== instance && methodValue !== undefined ) {
					returnValue = methodValue;
					return false;
				}
			});
		} else {
			this.each(function() {
				var instance = $.data( this, name );
				if ( instance ) {
					instance.option( options || {} )._init();
				} else {
					$.data( this, name, new object( options, this ) );
				}
			});
		}

		return returnValue;
	};
};

$.Widget = function( options, element ) {
	// allow instantiation without initializing for simple inheritance
	if ( arguments.length ) {
		this._createWidget( options, element );
	}
};

$.Widget.prototype = {
	widgetName: "widget",
	widgetEventPrefix: "",
	options: {
		disabled: false
	},
	_createWidget: function( options, element ) {
		// $.widget.bridge stores the plugin instance, but we do it anyway
		// so that it's stored even before the _create function runs
		$.data( element, this.widgetName, this );
		this.element = $( element );
		this.options = $.extend( true, {},
			this.options,
			this._getCreateOptions(),
			options );

		var self = this;
		this.element.bind( "remove." + this.widgetName, function() {
			self.destroy();
		});

		this._create();
		this._trigger( "create" );
		this._init();
	},
	_getCreateOptions: function() {
		return $.metadata && $.metadata.get( this.element[0] )[ this.widgetName ];
	},
	_create: function() {},
	_init: function() {},

	destroy: function() {
		this.element
			.unbind( "." + this.widgetName )
			.removeData( this.widgetName );
		this.widget()
			.unbind( "." + this.widgetName )
			.removeAttr( "aria-disabled" )
			.removeClass(
				this.widgetBaseClass + "-disabled " +
				"ui-state-disabled" );
	},

	widget: function() {
		return this.element;
	},

	option: function( key, value ) {
		var options = key;

		if ( arguments.length === 0 ) {
			// don't return a reference to the internal hash
			return $.extend( {}, this.options );
		}

		if  (typeof key === "string" ) {
			if ( value === undefined ) {
				return this.options[ key ];
			}
			options = {};
			options[ key ] = value;
		}

		this._setOptions( options );

		return this;
	},
	_setOptions: function( options ) {
		var self = this;
		$.each( options, function( key, value ) {
			self._setOption( key, value );
		});

		return this;
	},
	_setOption: function( key, value ) {
		this.options[ key ] = value;

		if ( key === "disabled" ) {
			this.widget()
				[ value ? "addClass" : "removeClass"](
					this.widgetBaseClass + "-disabled" + " " +
					"ui-state-disabled" )
				.attr( "aria-disabled", value );
		}

		return this;
	},

	enable: function() {
		return this._setOption( "disabled", false );
	},
	disable: function() {
		return this._setOption( "disabled", true );
	},

	_trigger: function( type, event, data ) {
		var prop, orig,
			callback = this.options[ type ];

		data = data || {};
		event = $.Event( event );
		event.type = ( type === this.widgetEventPrefix ?
			type :
			this.widgetEventPrefix + type ).toLowerCase();
		// the original event may come from any element
		// so we need to reset the target on the new event
		event.target = this.element[ 0 ];

		// copy original event properties over to the new event
		orig = event.originalEvent;
		if ( orig ) {
			for ( prop in orig ) {
				if ( !( prop in event ) ) {
					event[ prop ] = orig[ prop ];
				}
			}
		}

		this.element.trigger( event, data );

		return !( $.isFunction(callback) &&
			callback.call( this.element[0], event, data ) === false ||
			event.isDefaultPrevented() );
	}
};

})( jQuery );
/*!
 * jQuery UI Mouse 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var mouseHandled = false;
$( document ).mouseup( function( e ) {
	mouseHandled = false;
});

$.widget("ui.mouse", {
	options: {
		cancel: ':input,option',
		distance: 1,
		delay: 0
	},
	_mouseInit: function() {
		var self = this;

		this.element
			.bind('mousedown.'+this.widgetName, function(event) {
				return self._mouseDown(event);
			})
			.bind('click.'+this.widgetName, function(event) {
				if (true === $.data(event.target, self.widgetName + '.preventClickEvent')) {
				    $.removeData(event.target, self.widgetName + '.preventClickEvent');
					event.stopImmediatePropagation();
					return false;
				}
			});

		this.started = false;
	},

	// TODO: make sure destroying one instance of mouse doesn't mess with
	// other instances of mouse
	_mouseDestroy: function() {
		this.element.unbind('.'+this.widgetName);
		$(document)
			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);
	},

	_mouseDown: function(event) {
		// don't let more than one widget handle mouseStart
		if( mouseHandled ) { return };

		// we may have missed mouseup (out of window)
		(this._mouseStarted && this._mouseUp(event));

		this._mouseDownEvent = event;

		var self = this,
			btnIsLeft = (event.which == 1),
			// event.target.nodeName works around a bug in IE 8 with
			// disabled inputs (#7620)
			elIsCancel = (typeof this.options.cancel == "string" && event.target.nodeName ? $(event.target).closest(this.options.cancel).length : false);
		if (!btnIsLeft || elIsCancel || !this._mouseCapture(event)) {
			return true;
		}

		this.mouseDelayMet = !this.options.delay;
		if (!this.mouseDelayMet) {
			this._mouseDelayTimer = setTimeout(function() {
				self.mouseDelayMet = true;
			}, this.options.delay);
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted = (this._mouseStart(event) !== false);
			if (!this._mouseStarted) {
				event.preventDefault();
				return true;
			}
		}

		// Click event may never have fired (Gecko & Opera)
		if (true === $.data(event.target, this.widgetName + '.preventClickEvent')) {
			$.removeData(event.target, this.widgetName + '.preventClickEvent');
		}

		// these delegates are required to keep context
		this._mouseMoveDelegate = function(event) {
			return self._mouseMove(event);
		};
		this._mouseUpDelegate = function(event) {
			return self._mouseUp(event);
		};
		$(document)
			.bind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.bind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		event.preventDefault();
		
		mouseHandled = true;
		return true;
	},

	_mouseMove: function(event) {
		// IE mouseup check - mouseup happened when mouse was out of window
		if ($.browser.msie && !(document.documentMode >= 9) && !event.button) {
			return this._mouseUp(event);
		}

		if (this._mouseStarted) {
			this._mouseDrag(event);
			return event.preventDefault();
		}

		if (this._mouseDistanceMet(event) && this._mouseDelayMet(event)) {
			this._mouseStarted =
				(this._mouseStart(this._mouseDownEvent, event) !== false);
			(this._mouseStarted ? this._mouseDrag(event) : this._mouseUp(event));
		}

		return !this._mouseStarted;
	},

	_mouseUp: function(event) {
		$(document)
			.unbind('mousemove.'+this.widgetName, this._mouseMoveDelegate)
			.unbind('mouseup.'+this.widgetName, this._mouseUpDelegate);

		if (this._mouseStarted) {
			this._mouseStarted = false;

			if (event.target == this._mouseDownEvent.target) {
			    $.data(event.target, this.widgetName + '.preventClickEvent', true);
			}

			this._mouseStop(event);
		}

		return false;
	},

	_mouseDistanceMet: function(event) {
		return (Math.max(
				Math.abs(this._mouseDownEvent.pageX - event.pageX),
				Math.abs(this._mouseDownEvent.pageY - event.pageY)
			) >= this.options.distance
		);
	},

	_mouseDelayMet: function(event) {
		return this.mouseDelayMet;
	},

	// These are placeholder methods, to be overriden by extending plugin
	_mouseStart: function(event) {},
	_mouseDrag: function(event) {},
	_mouseStop: function(event) {},
	_mouseCapture: function(event) { return true; }
});

})(jQuery);
/*!
 * jQuery UI Position 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Position
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var horizontalPositions = /left|center|right/,
	verticalPositions = /top|center|bottom/,
	center = "center",
	support = {},
	_position = $.fn.position,
	_offset = $.fn.offset;

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var target = $( options.of ),
		targetElem = target[0],
		collision = ( options.collision || "flip" ).split( " " ),
		offset = options.offset ? options.offset.split( " " ) : [ 0, 0 ],
		targetWidth,
		targetHeight,
		basePosition;

	if ( targetElem.nodeType === 9 ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: 0, left: 0 };
	// TODO: use $.isWindow() in 1.9
	} else if ( targetElem.setTimeout ) {
		targetWidth = target.width();
		targetHeight = target.height();
		basePosition = { top: target.scrollTop(), left: target.scrollLeft() };
	} else if ( targetElem.preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
		targetWidth = targetHeight = 0;
		basePosition = { top: options.of.pageY, left: options.of.pageX };
	} else {
		targetWidth = target.outerWidth();
		targetHeight = target.outerHeight();
		basePosition = target.offset();
	}

	// force my and at to have valid horizontal and veritcal positions
	// if a value is missing or invalid, it will be converted to center 
	$.each( [ "my", "at" ], function() {
		var pos = ( options[this] || "" ).split( " " );
		if ( pos.length === 1) {
			pos = horizontalPositions.test( pos[0] ) ?
				pos.concat( [center] ) :
				verticalPositions.test( pos[0] ) ?
					[ center ].concat( pos ) :
					[ center, center ];
		}
		pos[ 0 ] = horizontalPositions.test( pos[0] ) ? pos[ 0 ] : center;
		pos[ 1 ] = verticalPositions.test( pos[1] ) ? pos[ 1 ] : center;
		options[ this ] = pos;
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	// normalize offset option
	offset[ 0 ] = parseInt( offset[0], 10 ) || 0;
	if ( offset.length === 1 ) {
		offset[ 1 ] = offset[ 0 ];
	}
	offset[ 1 ] = parseInt( offset[1], 10 ) || 0;

	if ( options.at[0] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[0] === center ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[1] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[1] === center ) {
		basePosition.top += targetHeight / 2;
	}

	basePosition.left += offset[ 0 ];
	basePosition.top += offset[ 1 ];

	return this.each(function() {
		var elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseInt( $.curCSS( this, "marginLeft", true ) ) || 0,
			marginTop = parseInt( $.curCSS( this, "marginTop", true ) ) || 0,
			collisionWidth = elemWidth + marginLeft +
				( parseInt( $.curCSS( this, "marginRight", true ) ) || 0 ),
			collisionHeight = elemHeight + marginTop +
				( parseInt( $.curCSS( this, "marginBottom", true ) ) || 0 ),
			position = $.extend( {}, basePosition ),
			collisionPosition;

		if ( options.my[0] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[0] === center ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[1] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[1] === center ) {
			position.top -= elemHeight / 2;
		}

		// prevent fractions if jQuery version doesn't support them (see #5280)
		if ( !support.fractions ) {
			position.left = Math.round( position.left );
			position.top = Math.round( position.top );
		}

		collisionPosition = {
			left: position.left - marginLeft,
			top: position.top - marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[i] ] ) {
				$.ui.position[ collision[i] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: offset,
					my: options.my,
					at: options.at
				});
			}
		});

		if ( $.fn.bgiframe ) {
			elem.bgiframe();
		}
		elem.offset( $.extend( position, { using: options.using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft();
			position.left = over > 0 ? position.left - over : Math.max( position.left - data.collisionPosition.left, position.left );
		},
		top: function( position, data ) {
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop();
			position.top = over > 0 ? position.top - over : Math.max( position.top - data.collisionPosition.top, position.top );
		}
	},

	flip: {
		left: function( position, data ) {
			if ( data.at[0] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.left + data.collisionWidth - win.width() - win.scrollLeft(),
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					-data.targetWidth,
				offset = -2 * data.offset[ 0 ];
			position.left += data.collisionPosition.left < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		},
		top: function( position, data ) {
			if ( data.at[1] === center ) {
				return;
			}
			var win = $( window ),
				over = data.collisionPosition.top + data.collisionHeight - win.height() - win.scrollTop(),
				myOffset = data.my[ 1 ] === "top" ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					-data.targetHeight,
				offset = -2 * data.offset[ 1 ];
			position.top += data.collisionPosition.top < 0 ?
				myOffset + atOffset + offset :
				over > 0 ?
					myOffset + atOffset + offset :
					0;
		}
	}
};

// offset setter from jQuery 1.4
if ( !$.offset.setOffset ) {
	$.offset.setOffset = function( elem, options ) {
		// set position first, in-case top/left are set even on static elem
		if ( /static/.test( $.curCSS( elem, "position" ) ) ) {
			elem.style.position = "relative";
		}
		var curElem   = $( elem ),
			curOffset = curElem.offset(),
			curTop    = parseInt( $.curCSS( elem, "top",  true ), 10 ) || 0,
			curLeft   = parseInt( $.curCSS( elem, "left", true ), 10)  || 0,
			props     = {
				top:  (options.top  - curOffset.top)  + curTop,
				left: (options.left - curOffset.left) + curLeft
			};
		
		if ( 'using' in options ) {
			options.using.call( elem, props );
		} else {
			curElem.css( props );
		}
	};

	$.fn.offset = function( options ) {
		var elem = this[ 0 ];
		if ( !elem || !elem.ownerDocument ) { return null; }
		if ( options ) {
			if ( $.isFunction( options ) ) {
				return this.each(function( i ) {
					$( this ).offset( options.call( this, i, $( this ).offset() ) );
				});
			}
			return this.each(function() {
				$.offset.setOffset( this, options );
			});
		}
		return _offset.call( this );
	};
}

// fraction support test (older versions of jQuery don't support fractions)
(function () {
	var body = document.getElementsByTagName( "body" )[ 0 ], 
		div = document.createElement( "div" ),
		testElement, testElementParent, testElementStyle, offset, offsetTotal;

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( var i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px; top: 10.432325px; height: 30px; width: 201px;";

	offset = $( div ).offset( function( _, offset ) {
		return offset;
	}).offset();

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );

	offsetTotal = offset.top + offset.left + ( body ? 2000 : 0 );
	support.fractions = offsetTotal > 21 && offsetTotal < 22;
})();

}( jQuery ));
/*!
 * jQuery UI Draggable 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Draggables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.draggable", $.ui.mouse, {
	widgetEventPrefix: "drag",
	options: {
		addClasses: true,
		appendTo: "parent",
		axis: false,
		connectToSortable: false,
		containment: false,
		cursor: "auto",
		cursorAt: false,
		grid: false,
		handle: false,
		helper: "original",
		iframeFix: false,
		opacity: false,
		refreshPositions: false,
		revert: false,
		revertDuration: 500,
		scope: "default",
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		snap: false,
		snapMode: "both",
		snapTolerance: 20,
		stack: false,
		zIndex: false
	},
	_create: function() {

		if (this.options.helper == 'original' && !(/^(?:r|a|f)/).test(this.element.css("position")))
			this.element[0].style.position = 'relative';

		(this.options.addClasses && this.element.addClass("ui-draggable"));
		(this.options.disabled && this.element.addClass("ui-draggable-disabled"));

		this._mouseInit();

	},

	destroy: function() {
		if(!this.element.data('draggable')) return;
		this.element
			.removeData("draggable")
			.unbind(".draggable")
			.removeClass("ui-draggable"
				+ " ui-draggable-dragging"
				+ " ui-draggable-disabled");
		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function(event) {

		var o = this.options;

		// among others, prevent a drag on a resizable-handle
		if (this.helper || o.disabled || $(event.target).is('.ui-resizable-handle'))
			return false;

		//Quit if we're not on a valid handle
		this.handle = this._getHandle(event);
		if (!this.handle)
			return false;
		
		if ( o.iframeFix ) {
			$(o.iframeFix === true ? "iframe" : o.iframeFix).each(function() {
				$('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>')
				.css({
					width: this.offsetWidth+"px", height: this.offsetHeight+"px",
					position: "absolute", opacity: "0.001", zIndex: 1000
				})
				.css($(this).offset())
				.appendTo("body");
			});
		}

		return true;

	},

	_mouseStart: function(event) {

		var o = this.options;

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		this.helper.addClass("ui-draggable-dragging");

		//Cache the helper size
		this._cacheHelperProportions();

		//If ddmanager is used for droppables, set the global draggable
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Store the helper's css position
		this.cssPosition = this.helper.css("position");
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.positionAbs = this.element.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		//Generate the original position
		this.originalPosition = this.position = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		//Trigger event + callbacks
		if(this._trigger("start", event) === false) {
			this._clear();
			return false;
		}

		//Recache the helper size
		this._cacheHelperProportions();

		//Prepare the droppable offsets
		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		
		this._mouseDrag(event, true); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		
		//If the ddmanager is used for droppables, inform the manager that dragging has started (see #5003)
		if ( $.ui.ddmanager ) $.ui.ddmanager.dragStart(this, event);
		
		return true;
	},

	_mouseDrag: function(event, noPropagation) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		//Call plugins and callbacks and use the resulting position if something is returned
		if (!noPropagation) {
			var ui = this._uiHash();
			if(this._trigger('drag', event, ui) === false) {
				this._mouseUp({});
				return false;
			}
			this.position = ui.position;
		}

		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		return false;
	},

	_mouseStop: function(event) {

		//If we are using droppables, inform the manager about the drop
		var dropped = false;
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			dropped = $.ui.ddmanager.drop(this, event);

		//if a drop comes from outside (a sortable)
		if(this.dropped) {
			dropped = this.dropped;
			this.dropped = false;
		}
		
		//if the original element is no longer in the DOM don't bother to continue (see #8269)
		var element = this.element[0], elementInDom = false;
		while ( element && (element = element.parentNode) ) {
			if (element == document ) {
				elementInDom = true;
			}
		}
		if ( !elementInDom && this.options.helper === "original" )
			return false;

		if((this.options.revert == "invalid" && !dropped) || (this.options.revert == "valid" && dropped) || this.options.revert === true || ($.isFunction(this.options.revert) && this.options.revert.call(this.element, dropped))) {
			var self = this;
			$(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function() {
				if(self._trigger("stop", event) !== false) {
					self._clear();
				}
			});
		} else {
			if(this._trigger("stop", event) !== false) {
				this._clear();
			}
		}

		return false;
	},
	
	_mouseUp: function(event) {
		if (this.options.iframeFix === true) {
			$("div.ui-draggable-iframeFix").each(function() { 
				this.parentNode.removeChild(this); 
			}); //Remove frame helpers
		}
		
		//If the ddmanager is used for droppables, inform the manager that dragging has stopped (see #5003)
		if( $.ui.ddmanager ) $.ui.ddmanager.dragStop(this, event);
		
		return $.ui.mouse.prototype._mouseUp.call(this, event);
	},
	
	cancel: function() {
		
		if(this.helper.is(".ui-draggable-dragging")) {
			this._mouseUp({});
		} else {
			this._clear();
		}
		
		return this;
		
	},

	_getHandle: function(event) {

		var handle = !this.options.handle || !$(this.options.handle, this.element).length ? true : false;
		$(this.options.handle, this.element)
			.find("*")
			.andSelf()
			.each(function() {
				if(this == event.target) handle = true;
			});

		return handle;

	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event])) : (o.helper == 'clone' ? this.element.clone().removeAttr('id') : this.element);

		if(!helper.parents('body').length)
			helper.appendTo((o.appendTo == 'parent' ? this.element[0].parentNode : o.appendTo));

		if(helper[0] != this.element[0] && !(/(fixed|absolute)/).test(helper.css("position")))
			helper.css("position", "absolute");

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {

		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.element.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.element.css("marginLeft"),10) || 0),
			top: (parseInt(this.element.css("marginTop"),10) || 0),
			right: (parseInt(this.element.css("marginRight"),10) || 0),
			bottom: (parseInt(this.element.css("marginBottom"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			o.containment == 'document' ? 0 : $(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left,
			o.containment == 'document' ? 0 : $(window).scrollTop() - this.offset.relative.top - this.offset.parent.top,
			(o.containment == 'document' ? 0 : $(window).scrollLeft()) + $(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			(o.containment == 'document' ? 0 : $(window).scrollTop()) + ($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment) && o.containment.constructor != Array) {
		        var c = $(o.containment);
			var ce = c[0]; if(!ce) return;
			var co = c.offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				(parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0),
				(parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0),
				(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right,
				(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top  - this.margins.bottom
			];
			this.relative_container = c;

		} else if(o.containment.constructor == Array) {
			this.containment = o.containment;
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);
		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options
		         var containment;
		         if(this.containment) {
				 if (this.relative_container){
				     var co = this.relative_container.offset();
				     containment = [ this.containment[0] + co.left,
						     this.containment[1] + co.top,
						     this.containment[2] + co.left,
						     this.containment[3] + co.top ];
				 }
				 else {
				     containment = this.containment;
				 }

				if(event.pageX - this.offset.click.left < containment[0]) pageX = containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < containment[1]) pageY = containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > containment[2]) pageX = containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > containment[3]) pageY = containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				//Check for grid elements set to 0 to prevent divide by 0 error causing invalid argument errors in IE (see ticket #6950)
				var top = o.grid[1] ? this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1] : this.originalPageY;
				pageY = containment ? (!(top - this.offset.click.top < containment[1] || top - this.offset.click.top > containment[3]) ? top : (!(top - this.offset.click.top < containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = o.grid[0] ? this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0] : this.originalPageX;
				pageX = containment ? (!(left - this.offset.click.left < containment[0] || left - this.offset.click.left > containment[2]) ? left : (!(left - this.offset.click.left < containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && $.browser.version < 526 && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_clear: function() {
		this.helper.removeClass("ui-draggable-dragging");
		if(this.helper[0] != this.element[0] && !this.cancelHelperRemoval) this.helper.remove();
		//if($.ui.ddmanager) $.ui.ddmanager.current = null;
		this.helper = null;
		this.cancelHelperRemoval = false;
	},

	// From now on bulk stuff - mainly helpers

	_trigger: function(type, event, ui) {
		ui = ui || this._uiHash();
		$.ui.plugin.call(this, type, [event, ui]);
		if(type == "drag") this.positionAbs = this._convertPositionTo("absolute"); //The absolute position has to be recalculated after plugins
		return $.Widget.prototype._trigger.call(this, type, event, ui);
	},

	plugins: {},

	_uiHash: function(event) {
		return {
			helper: this.helper,
			position: this.position,
			originalPosition: this.originalPosition,
			offset: this.positionAbs
		};
	}

});

$.extend($.ui.draggable, {
	version: "1.8.21"
});

$.ui.plugin.add("draggable", "connectToSortable", {
	start: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options,
			uiSortable = $.extend({}, ui, { item: inst.element });
		inst.sortables = [];
		$(o.connectToSortable).each(function() {
			var sortable = $.data(this, 'sortable');
			if (sortable && !sortable.options.disabled) {
				inst.sortables.push({
					instance: sortable,
					shouldRevert: sortable.options.revert
				});
				sortable.refreshPositions();	// Call the sortable's refreshPositions at drag start to refresh the containerCache since the sortable container cache is used in drag and needs to be up to date (this will ensure it's initialised as well as being kept in step with any changes that might have happened on the page).
				sortable._trigger("activate", event, uiSortable);
			}
		});

	},
	stop: function(event, ui) {

		//If we are still over the sortable, we fake the stop event of the sortable, but also remove helper
		var inst = $(this).data("draggable"),
			uiSortable = $.extend({}, ui, { item: inst.element });

		$.each(inst.sortables, function() {
			if(this.instance.isOver) {

				this.instance.isOver = 0;

				inst.cancelHelperRemoval = true; //Don't remove the helper in the draggable instance
				this.instance.cancelHelperRemoval = false; //Remove it in the sortable instance (so sortable plugins like revert still work)

				//The sortable revert is supported, and we have to set a temporary dropped variable on the draggable to support revert: 'valid/invalid'
				if(this.shouldRevert) this.instance.options.revert = true;

				//Trigger the stop of the sortable
				this.instance._mouseStop(event);

				this.instance.options.helper = this.instance.options._helper;

				//If the helper has been the original item, restore properties in the sortable
				if(inst.options.helper == 'original')
					this.instance.currentItem.css({ top: 'auto', left: 'auto' });

			} else {
				this.instance.cancelHelperRemoval = false; //Remove the helper in the sortable instance
				this.instance._trigger("deactivate", event, uiSortable);
			}

		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), self = this;

		var checkPos = function(o) {
			var dyClick = this.offset.click.top, dxClick = this.offset.click.left;
			var helperTop = this.positionAbs.top, helperLeft = this.positionAbs.left;
			var itemHeight = o.height, itemWidth = o.width;
			var itemTop = o.top, itemLeft = o.left;

			return $.ui.isOver(helperTop + dyClick, helperLeft + dxClick, itemTop, itemLeft, itemHeight, itemWidth);
		};

		$.each(inst.sortables, function(i) {
			
			//Copy over some variables to allow calling the sortable's native _intersectsWith
			this.instance.positionAbs = inst.positionAbs;
			this.instance.helperProportions = inst.helperProportions;
			this.instance.offset.click = inst.offset.click;
			
			if(this.instance._intersectsWith(this.instance.containerCache)) {

				//If it intersects, we use a little isOver variable and set it once, so our move-in stuff gets fired only once
				if(!this.instance.isOver) {

					this.instance.isOver = 1;
					//Now we fake the start of dragging for the sortable instance,
					//by cloning the list group item, appending it to the sortable and using it as inst.currentItem
					//We can then fire the start event of the sortable with our passed browser event, and our own helper (so it doesn't create a new one)
					this.instance.currentItem = $(self).clone().removeAttr('id').appendTo(this.instance.element).data("sortable-item", true);
					this.instance.options._helper = this.instance.options.helper; //Store helper option to later restore it
					this.instance.options.helper = function() { return ui.helper[0]; };

					event.target = this.instance.currentItem[0];
					this.instance._mouseCapture(event, true);
					this.instance._mouseStart(event, true, true);

					//Because the browser event is way off the new appended portlet, we modify a couple of variables to reflect the changes
					this.instance.offset.click.top = inst.offset.click.top;
					this.instance.offset.click.left = inst.offset.click.left;
					this.instance.offset.parent.left -= inst.offset.parent.left - this.instance.offset.parent.left;
					this.instance.offset.parent.top -= inst.offset.parent.top - this.instance.offset.parent.top;

					inst._trigger("toSortable", event);
					inst.dropped = this.instance.element; //draggable revert needs that
					//hack so receive/update callbacks work (mostly)
					inst.currentItem = inst.element;
					this.instance.fromOutside = inst;

				}

				//Provided we did all the previous steps, we can fire the drag event of the sortable on every draggable drag, when it intersects with the sortable
				if(this.instance.currentItem) this.instance._mouseDrag(event);

			} else {

				//If it doesn't intersect with the sortable, and it intersected before,
				//we fake the drag stop of the sortable, but make sure it doesn't remove the helper by using cancelHelperRemoval
				if(this.instance.isOver) {

					this.instance.isOver = 0;
					this.instance.cancelHelperRemoval = true;
					
					//Prevent reverting on this forced stop
					this.instance.options.revert = false;
					
					// The out event needs to be triggered independently
					this.instance._trigger('out', event, this.instance._uiHash(this.instance));
					
					this.instance._mouseStop(event, true);
					this.instance.options.helper = this.instance.options._helper;

					//Now we remove our currentItem, the list group clone again, and the placeholder, and animate the helper back to it's original size
					this.instance.currentItem.remove();
					if(this.instance.placeholder) this.instance.placeholder.remove();

					inst._trigger("fromSortable", event);
					inst.dropped = false; //draggable revert needs that
				}

			};

		});

	}
});

$.ui.plugin.add("draggable", "cursor", {
	start: function(event, ui) {
		var t = $('body'), o = $(this).data('draggable').options;
		if (t.css("cursor")) o._cursor = t.css("cursor");
		t.css("cursor", o.cursor);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if (o._cursor) $('body').css("cursor", o._cursor);
	}
});

$.ui.plugin.add("draggable", "opacity", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data('draggable').options;
		if(t.css("opacity")) o._opacity = t.css("opacity");
		t.css('opacity', o.opacity);
	},
	stop: function(event, ui) {
		var o = $(this).data('draggable').options;
		if(o._opacity) $(ui.helper).css('opacity', o._opacity);
	}
});

$.ui.plugin.add("draggable", "scroll", {
	start: function(event, ui) {
		var i = $(this).data("draggable");
		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') i.overflowOffset = i.scrollParent.offset();
	},
	drag: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options, scrolled = false;

		if(i.scrollParent[0] != document && i.scrollParent[0].tagName != 'HTML') {

			if(!o.axis || o.axis != 'x') {
				if((i.overflowOffset.top + i.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - i.overflowOffset.top < o.scrollSensitivity)
					i.scrollParent[0].scrollTop = scrolled = i.scrollParent[0].scrollTop - o.scrollSpeed;
			}

			if(!o.axis || o.axis != 'y') {
				if((i.overflowOffset.left + i.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - i.overflowOffset.left < o.scrollSensitivity)
					i.scrollParent[0].scrollLeft = scrolled = i.scrollParent[0].scrollLeft - o.scrollSpeed;
			}

		} else {

			if(!o.axis || o.axis != 'x') {
				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);
			}

			if(!o.axis || o.axis != 'y') {
				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);
			}

		}

		if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(i, event);

	}
});

$.ui.plugin.add("draggable", "snap", {
	start: function(event, ui) {

		var i = $(this).data("draggable"), o = i.options;
		i.snapElements = [];

		$(o.snap.constructor != String ? ( o.snap.items || ':data(draggable)' ) : o.snap).each(function() {
			var $t = $(this); var $o = $t.offset();
			if(this != i.element[0]) i.snapElements.push({
				item: this,
				width: $t.outerWidth(), height: $t.outerHeight(),
				top: $o.top, left: $o.left
			});
		});

	},
	drag: function(event, ui) {

		var inst = $(this).data("draggable"), o = inst.options;
		var d = o.snapTolerance;

		var x1 = ui.offset.left, x2 = x1 + inst.helperProportions.width,
			y1 = ui.offset.top, y2 = y1 + inst.helperProportions.height;

		for (var i = inst.snapElements.length - 1; i >= 0; i--){

			var l = inst.snapElements[i].left, r = l + inst.snapElements[i].width,
				t = inst.snapElements[i].top, b = t + inst.snapElements[i].height;

			//Yes, I know, this is insane ;)
			if(!((l-d < x1 && x1 < r+d && t-d < y1 && y1 < b+d) || (l-d < x1 && x1 < r+d && t-d < y2 && y2 < b+d) || (l-d < x2 && x2 < r+d && t-d < y1 && y1 < b+d) || (l-d < x2 && x2 < r+d && t-d < y2 && y2 < b+d))) {
				if(inst.snapElements[i].snapping) (inst.options.snap.release && inst.options.snap.release.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
				inst.snapElements[i].snapping = false;
				continue;
			}

			if(o.snapMode != 'inner') {
				var ts = Math.abs(t - y2) <= d;
				var bs = Math.abs(b - y1) <= d;
				var ls = Math.abs(l - x2) <= d;
				var rs = Math.abs(r - x1) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l - inst.helperProportions.width }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r }).left - inst.margins.left;
			}

			var first = (ts || bs || ls || rs);

			if(o.snapMode != 'outer') {
				var ts = Math.abs(t - y1) <= d;
				var bs = Math.abs(b - y2) <= d;
				var ls = Math.abs(l - x1) <= d;
				var rs = Math.abs(r - x2) <= d;
				if(ts) ui.position.top = inst._convertPositionTo("relative", { top: t, left: 0 }).top - inst.margins.top;
				if(bs) ui.position.top = inst._convertPositionTo("relative", { top: b - inst.helperProportions.height, left: 0 }).top - inst.margins.top;
				if(ls) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: l }).left - inst.margins.left;
				if(rs) ui.position.left = inst._convertPositionTo("relative", { top: 0, left: r - inst.helperProportions.width }).left - inst.margins.left;
			}

			if(!inst.snapElements[i].snapping && (ts || bs || ls || rs || first))
				(inst.options.snap.snap && inst.options.snap.snap.call(inst.element, event, $.extend(inst._uiHash(), { snapItem: inst.snapElements[i].item })));
			inst.snapElements[i].snapping = (ts || bs || ls || rs || first);

		};

	}
});

$.ui.plugin.add("draggable", "stack", {
	start: function(event, ui) {

		var o = $(this).data("draggable").options;

		var group = $.makeArray($(o.stack)).sort(function(a,b) {
			return (parseInt($(a).css("zIndex"),10) || 0) - (parseInt($(b).css("zIndex"),10) || 0);
		});
		if (!group.length) { return; }
		
		var min = parseInt(group[0].style.zIndex) || 0;
		$(group).each(function(i) {
			this.style.zIndex = min + i;
		});

		this[0].style.zIndex = min + group.length;

	}
});

$.ui.plugin.add("draggable", "zIndex", {
	start: function(event, ui) {
		var t = $(ui.helper), o = $(this).data("draggable").options;
		if(t.css("zIndex")) o._zIndex = t.css("zIndex");
		t.css('zIndex', o.zIndex);
	},
	stop: function(event, ui) {
		var o = $(this).data("draggable").options;
		if(o._zIndex) $(ui.helper).css('zIndex', o._zIndex);
	}
});

})(jQuery);
/*!
 * jQuery UI Droppable 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Droppables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.mouse.js
 *	jquery.ui.draggable.js
 */
(function( $, undefined ) {

$.widget("ui.droppable", {
	widgetEventPrefix: "drop",
	options: {
		accept: '*',
		activeClass: false,
		addClasses: true,
		greedy: false,
		hoverClass: false,
		scope: 'default',
		tolerance: 'intersect'
	},
	_create: function() {

		var o = this.options, accept = o.accept;
		this.isover = 0; this.isout = 1;

		this.accept = $.isFunction(accept) ? accept : function(d) {
			return d.is(accept);
		};

		//Store the droppable's proportions
		this.proportions = { width: this.element[0].offsetWidth, height: this.element[0].offsetHeight };

		// Add the reference and positions to the manager
		$.ui.ddmanager.droppables[o.scope] = $.ui.ddmanager.droppables[o.scope] || [];
		$.ui.ddmanager.droppables[o.scope].push(this);

		(o.addClasses && this.element.addClass("ui-droppable"));

	},

	destroy: function() {
		var drop = $.ui.ddmanager.droppables[this.options.scope];
		for ( var i = 0; i < drop.length; i++ )
			if ( drop[i] == this )
				drop.splice(i, 1);

		this.element
			.removeClass("ui-droppable ui-droppable-disabled")
			.removeData("droppable")
			.unbind(".droppable");

		return this;
	},

	_setOption: function(key, value) {

		if(key == 'accept') {
			this.accept = $.isFunction(value) ? value : function(d) {
				return d.is(value);
			};
		}
		$.Widget.prototype._setOption.apply(this, arguments);
	},

	_activate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.addClass(this.options.activeClass);
		(draggable && this._trigger('activate', event, this.ui(draggable)));
	},

	_deactivate: function(event) {
		var draggable = $.ui.ddmanager.current;
		if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
		(draggable && this._trigger('deactivate', event, this.ui(draggable)));
	},

	_over: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.addClass(this.options.hoverClass);
			this._trigger('over', event, this.ui(draggable));
		}

	},

	_out: function(event) {

		var draggable = $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return; // Bail if draggable and droppable are same element

		if (this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('out', event, this.ui(draggable));
		}

	},

	_drop: function(event,custom) {

		var draggable = custom || $.ui.ddmanager.current;
		if (!draggable || (draggable.currentItem || draggable.element)[0] == this.element[0]) return false; // Bail if draggable and droppable are same element

		var childrenIntersection = false;
		this.element.find(":data(droppable)").not(".ui-draggable-dragging").each(function() {
			var inst = $.data(this, 'droppable');
			if(
				inst.options.greedy
				&& !inst.options.disabled
				&& inst.options.scope == draggable.options.scope
				&& inst.accept.call(inst.element[0], (draggable.currentItem || draggable.element))
				&& $.ui.intersect(draggable, $.extend(inst, { offset: inst.element.offset() }), inst.options.tolerance)
			) { childrenIntersection = true; return false; }
		});
		if(childrenIntersection) return false;

		if(this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
			if(this.options.activeClass) this.element.removeClass(this.options.activeClass);
			if(this.options.hoverClass) this.element.removeClass(this.options.hoverClass);
			this._trigger('drop', event, this.ui(draggable));
			return this.element;
		}

		return false;

	},

	ui: function(c) {
		return {
			draggable: (c.currentItem || c.element),
			helper: c.helper,
			position: c.position,
			offset: c.positionAbs
		};
	}

});

$.extend($.ui.droppable, {
	version: "1.8.21"
});

$.ui.intersect = function(draggable, droppable, toleranceMode) {

	if (!droppable.offset) return false;

	var x1 = (draggable.positionAbs || draggable.position.absolute).left, x2 = x1 + draggable.helperProportions.width,
		y1 = (draggable.positionAbs || draggable.position.absolute).top, y2 = y1 + draggable.helperProportions.height;
	var l = droppable.offset.left, r = l + droppable.proportions.width,
		t = droppable.offset.top, b = t + droppable.proportions.height;

	switch (toleranceMode) {
		case 'fit':
			return (l <= x1 && x2 <= r
				&& t <= y1 && y2 <= b);
			break;
		case 'intersect':
			return (l < x1 + (draggable.helperProportions.width / 2) // Right Half
				&& x2 - (draggable.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (draggable.helperProportions.height / 2) // Bottom Half
				&& y2 - (draggable.helperProportions.height / 2) < b ); // Top Half
			break;
		case 'pointer':
			var draggableLeft = ((draggable.positionAbs || draggable.position.absolute).left + (draggable.clickOffset || draggable.offset.click).left),
				draggableTop = ((draggable.positionAbs || draggable.position.absolute).top + (draggable.clickOffset || draggable.offset.click).top),
				isOver = $.ui.isOver(draggableTop, draggableLeft, t, l, droppable.proportions.height, droppable.proportions.width);
			return isOver;
			break;
		case 'touch':
			return (
					(y1 >= t && y1 <= b) ||	// Top edge touching
					(y2 >= t && y2 <= b) ||	// Bottom edge touching
					(y1 < t && y2 > b)		// Surrounded vertically
				) && (
					(x1 >= l && x1 <= r) ||	// Left edge touching
					(x2 >= l && x2 <= r) ||	// Right edge touching
					(x1 < l && x2 > r)		// Surrounded horizontally
				);
			break;
		default:
			return false;
			break;
		}

};

/*
	This manager tracks offsets of draggables and droppables
*/
$.ui.ddmanager = {
	current: null,
	droppables: { 'default': [] },
	prepareOffsets: function(t, event) {

		var m = $.ui.ddmanager.droppables[t.options.scope] || [];
		var type = event ? event.type : null; // workaround for #2317
		var list = (t.currentItem || t.element).find(":data(droppable)").andSelf();

		droppablesLoop: for (var i = 0; i < m.length; i++) {

			if(m[i].options.disabled || (t && !m[i].accept.call(m[i].element[0],(t.currentItem || t.element)))) continue;	//No disabled and non-accepted
			for (var j=0; j < list.length; j++) { if(list[j] == m[i].element[0]) { m[i].proportions.height = 0; continue droppablesLoop; } }; //Filter out elements in the current dragged item
			m[i].visible = m[i].element.css("display") != "none"; if(!m[i].visible) continue; 									//If the element is not visible, continue

			if(type == "mousedown") m[i]._activate.call(m[i], event); //Activate the droppable if used directly from draggables

			m[i].offset = m[i].element.offset();
			m[i].proportions = { width: m[i].element[0].offsetWidth, height: m[i].element[0].offsetHeight };

		}

	},
	drop: function(draggable, event) {

		var dropped = false;
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(!this.options) return;
			if (!this.options.disabled && this.visible && $.ui.intersect(draggable, this, this.options.tolerance))
				dropped = this._drop.call(this, event) || dropped;

			if (!this.options.disabled && this.visible && this.accept.call(this.element[0],(draggable.currentItem || draggable.element))) {
				this.isout = 1; this.isover = 0;
				this._deactivate.call(this, event);
			}

		});
		return dropped;

	},
	dragStart: function( draggable, event ) {
		//Listen for scrolling so that if the dragging causes scrolling the position of the droppables can be recalculated (see #5003)
		draggable.element.parents( ":not(body,html)" ).bind( "scroll.droppable", function() {
			if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
		});
	},
	drag: function(draggable, event) {

		//If you have a highly dynamic page, you might try this option. It renders positions every time you move the mouse.
		if(draggable.options.refreshPositions) $.ui.ddmanager.prepareOffsets(draggable, event);

		//Run through all droppables and check their positions based on specific tolerance options
		$.each($.ui.ddmanager.droppables[draggable.options.scope] || [], function() {

			if(this.options.disabled || this.greedyChild || !this.visible) return;
			var intersects = $.ui.intersect(draggable, this, this.options.tolerance);

			var c = !intersects && this.isover == 1 ? 'isout' : (intersects && this.isover == 0 ? 'isover' : null);
			if(!c) return;

			var parentInstance;
			if (this.options.greedy) {
				var parent = this.element.parents(':data(droppable):eq(0)');
				if (parent.length) {
					parentInstance = $.data(parent[0], 'droppable');
					parentInstance.greedyChild = (c == 'isover' ? 1 : 0);
				}
			}

			// we just moved into a greedy child
			if (parentInstance && c == 'isover') {
				parentInstance['isover'] = 0;
				parentInstance['isout'] = 1;
				parentInstance._out.call(parentInstance, event);
			}

			this[c] = 1; this[c == 'isout' ? 'isover' : 'isout'] = 0;
			this[c == "isover" ? "_over" : "_out"].call(this, event);

			// we just moved out of a greedy child
			if (parentInstance && c == 'isout') {
				parentInstance['isout'] = 0;
				parentInstance['isover'] = 1;
				parentInstance._over.call(parentInstance, event);
			}
		});

	},
	dragStop: function( draggable, event ) {
		draggable.element.parents( ":not(body,html)" ).unbind( "scroll.droppable" );
		//Call prepareOffsets one final time since IE does not fire return scroll events when overflow was caused by drag (see #5003)
		if( !draggable.options.refreshPositions ) $.ui.ddmanager.prepareOffsets( draggable, event );
	}
};

})(jQuery);
/*!
 * jQuery UI Resizable 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Resizables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.resizable", $.ui.mouse, {
	widgetEventPrefix: "resize",
	options: {
		alsoResize: false,
		animate: false,
		animateDuration: "slow",
		animateEasing: "swing",
		aspectRatio: false,
		autoHide: false,
		containment: false,
		ghost: false,
		grid: false,
		handles: "e,s,se",
		helper: false,
		maxHeight: null,
		maxWidth: null,
		minHeight: 10,
		minWidth: 10,
		zIndex: 1000
	},
	_create: function() {

		var self = this, o = this.options;
		this.element.addClass("ui-resizable");

		$.extend(this, {
			_aspectRatio: !!(o.aspectRatio),
			aspectRatio: o.aspectRatio,
			originalElement: this.element,
			_proportionallyResizeElements: [],
			_helper: o.helper || o.ghost || o.animate ? o.helper || 'ui-resizable-helper' : null
		});

		//Wrap the element if it cannot hold child nodes
		if(this.element[0].nodeName.match(/canvas|textarea|input|select|button|img/i)) {

			//Create a wrapper element and set the wrapper to the new current internal element
			this.element.wrap(
				$('<div class="ui-wrapper" style="overflow: hidden;"></div>').css({
					position: this.element.css('position'),
					width: this.element.outerWidth(),
					height: this.element.outerHeight(),
					top: this.element.css('top'),
					left: this.element.css('left')
				})
			);

			//Overwrite the original this.element
			this.element = this.element.parent().data(
				"resizable", this.element.data('resizable')
			);

			this.elementIsWrapper = true;

			//Move margins to the wrapper
			this.element.css({ marginLeft: this.originalElement.css("marginLeft"), marginTop: this.originalElement.css("marginTop"), marginRight: this.originalElement.css("marginRight"), marginBottom: this.originalElement.css("marginBottom") });
			this.originalElement.css({ marginLeft: 0, marginTop: 0, marginRight: 0, marginBottom: 0});

			//Prevent Safari textarea resize
			this.originalResizeStyle = this.originalElement.css('resize');
			this.originalElement.css('resize', 'none');

			//Push the actual element to our proportionallyResize internal array
			this._proportionallyResizeElements.push(this.originalElement.css({ position: 'static', zoom: 1, display: 'block' }));

			// avoid IE jump (hard set the margin)
			this.originalElement.css({ margin: this.originalElement.css('margin') });

			// fix handlers offset
			this._proportionallyResize();

		}

		this.handles = o.handles || (!$('.ui-resizable-handle', this.element).length ? "e,s,se" : { n: '.ui-resizable-n', e: '.ui-resizable-e', s: '.ui-resizable-s', w: '.ui-resizable-w', se: '.ui-resizable-se', sw: '.ui-resizable-sw', ne: '.ui-resizable-ne', nw: '.ui-resizable-nw' });
		if(this.handles.constructor == String) {

			if(this.handles == 'all') this.handles = 'n,e,s,w,se,sw,ne,nw';
			var n = this.handles.split(","); this.handles = {};

			for(var i = 0; i < n.length; i++) {

				var handle = $.trim(n[i]), hname = 'ui-resizable-'+handle;
				var axis = $('<div class="ui-resizable-handle ' + hname + '"></div>');

				// Apply zIndex to all handles - see #7960
				axis.css({ zIndex: o.zIndex });

				//TODO : What's going on here?
				if ('se' == handle) {
					axis.addClass('ui-icon ui-icon-gripsmall-diagonal-se');
				};

				//Insert into internal handles object and append to element
				this.handles[handle] = '.ui-resizable-'+handle;
				this.element.append(axis);
			}

		}

		this._renderAxis = function(target) {

			target = target || this.element;

			for(var i in this.handles) {

				if(this.handles[i].constructor == String)
					this.handles[i] = $(this.handles[i], this.element).show();

				//Apply pad to wrapper element, needed to fix axis position (textarea, inputs, scrolls)
				if (this.elementIsWrapper && this.originalElement[0].nodeName.match(/textarea|input|select|button/i)) {

					var axis = $(this.handles[i], this.element), padWrapper = 0;

					//Checking the correct pad and border
					padWrapper = /sw|ne|nw|se|n|s/.test(i) ? axis.outerHeight() : axis.outerWidth();

					//The padding type i have to apply...
					var padPos = [ 'padding',
						/ne|nw|n/.test(i) ? 'Top' :
						/se|sw|s/.test(i) ? 'Bottom' :
						/^e$/.test(i) ? 'Right' : 'Left' ].join("");

					target.css(padPos, padWrapper);

					this._proportionallyResize();

				}

				//TODO: What's that good for? There's not anything to be executed left
				if(!$(this.handles[i]).length)
					continue;

			}
		};

		//TODO: make renderAxis a prototype function
		this._renderAxis(this.element);

		this._handles = $('.ui-resizable-handle', this.element)
			.disableSelection();

		//Matching axis name
		this._handles.mouseover(function() {
			if (!self.resizing) {
				if (this.className)
					var axis = this.className.match(/ui-resizable-(se|sw|ne|nw|n|e|s|w)/i);
				//Axis, default = se
				self.axis = axis && axis[1] ? axis[1] : 'se';
			}
		});

		//If we want to auto hide the elements
		if (o.autoHide) {
			this._handles.hide();
			$(this.element)
				.addClass("ui-resizable-autohide")
				.hover(function() {
					if (o.disabled) return;
					$(this).removeClass("ui-resizable-autohide");
					self._handles.show();
				},
				function(){
					if (o.disabled) return;
					if (!self.resizing) {
						$(this).addClass("ui-resizable-autohide");
						self._handles.hide();
					}
				});
		}

		//Initialize the mouse interaction
		this._mouseInit();

	},

	destroy: function() {

		this._mouseDestroy();

		var _destroy = function(exp) {
			$(exp).removeClass("ui-resizable ui-resizable-disabled ui-resizable-resizing")
				.removeData("resizable").unbind(".resizable").find('.ui-resizable-handle').remove();
		};

		//TODO: Unwrap at same DOM position
		if (this.elementIsWrapper) {
			_destroy(this.element);
			var wrapper = this.element;
			wrapper.after(
				this.originalElement.css({
					position: wrapper.css('position'),
					width: wrapper.outerWidth(),
					height: wrapper.outerHeight(),
					top: wrapper.css('top'),
					left: wrapper.css('left')
				})
			).remove();
		}

		this.originalElement.css('resize', this.originalResizeStyle);
		_destroy(this.originalElement);

		return this;
	},

	_mouseCapture: function(event) {
		var handle = false;
		for (var i in this.handles) {
			if ($(this.handles[i])[0] == event.target) {
				handle = true;
			}
		}

		return !this.options.disabled && handle;
	},

	_mouseStart: function(event) {

		var o = this.options, iniPos = this.element.position(), el = this.element;

		this.resizing = true;
		this.documentScroll = { top: $(document).scrollTop(), left: $(document).scrollLeft() };

		// bugfix for http://dev.jquery.com/ticket/1749
		if (el.is('.ui-draggable') || (/absolute/).test(el.css('position'))) {
			el.css({ position: 'absolute', top: iniPos.top, left: iniPos.left });
		}

		this._renderProxy();

		var curleft = num(this.helper.css('left')), curtop = num(this.helper.css('top'));

		if (o.containment) {
			curleft += $(o.containment).scrollLeft() || 0;
			curtop += $(o.containment).scrollTop() || 0;
		}

		//Store needed variables
		this.offset = this.helper.offset();
		this.position = { left: curleft, top: curtop };
		this.size = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalSize = this._helper ? { width: el.outerWidth(), height: el.outerHeight() } : { width: el.width(), height: el.height() };
		this.originalPosition = { left: curleft, top: curtop };
		this.sizeDiff = { width: el.outerWidth() - el.width(), height: el.outerHeight() - el.height() };
		this.originalMousePosition = { left: event.pageX, top: event.pageY };

		//Aspect Ratio
		this.aspectRatio = (typeof o.aspectRatio == 'number') ? o.aspectRatio : ((this.originalSize.width / this.originalSize.height) || 1);

	    var cursor = $('.ui-resizable-' + this.axis).css('cursor');
	    $('body').css('cursor', cursor == 'auto' ? this.axis + '-resize' : cursor);

		el.addClass("ui-resizable-resizing");
		this._propagate("start", event);
		return true;
	},

	_mouseDrag: function(event) {

		//Increase performance, avoid regex
		var el = this.helper, o = this.options, props = {},
			self = this, smp = this.originalMousePosition, a = this.axis;

		var dx = (event.pageX-smp.left)||0, dy = (event.pageY-smp.top)||0;
		var trigger = this._change[a];
		if (!trigger) return false;

		// Calculate the attrs that will be change
		var data = trigger.apply(this, [event, dx, dy]), ie6 = $.browser.msie && $.browser.version < 7, csdif = this.sizeDiff;

		// Put this in the mouseDrag handler since the user can start pressing shift while resizing
		this._updateVirtualBoundaries(event.shiftKey);
		if (this._aspectRatio || event.shiftKey)
			data = this._updateRatio(data, event);

		data = this._respectSize(data, event);

		// plugins callbacks need to be called first
		this._propagate("resize", event);

		el.css({
			top: this.position.top + "px", left: this.position.left + "px",
			width: this.size.width + "px", height: this.size.height + "px"
		});

		if (!this._helper && this._proportionallyResizeElements.length)
			this._proportionallyResize();

		this._updateCache(data);

		// calling the user callback at the end
		this._trigger('resize', event, this.ui());

		return false;
	},

	_mouseStop: function(event) {

		this.resizing = false;
		var o = this.options, self = this;

		if(this._helper) {
			var pr = this._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
				soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
				soffsetw = ista ? 0 : self.sizeDiff.width;

			var s = { width: (self.helper.width()  - soffsetw), height: (self.helper.height() - soffseth) },
				left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
				top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

			if (!o.animate)
				this.element.css($.extend(s, { top: top, left: left }));

			self.helper.height(self.size.height);
			self.helper.width(self.size.width);

			if (this._helper && !o.animate) this._proportionallyResize();
		}

		$('body').css('cursor', 'auto');

		this.element.removeClass("ui-resizable-resizing");

		this._propagate("stop", event);

		if (this._helper) this.helper.remove();
		return false;

	},

    _updateVirtualBoundaries: function(forceAspectRatio) {
        var o = this.options, pMinWidth, pMaxWidth, pMinHeight, pMaxHeight, b;

        b = {
            minWidth: isNumber(o.minWidth) ? o.minWidth : 0,
            maxWidth: isNumber(o.maxWidth) ? o.maxWidth : Infinity,
            minHeight: isNumber(o.minHeight) ? o.minHeight : 0,
            maxHeight: isNumber(o.maxHeight) ? o.maxHeight : Infinity
        };

        if(this._aspectRatio || forceAspectRatio) {
            // We want to create an enclosing box whose aspect ration is the requested one
            // First, compute the "projected" size for each dimension based on the aspect ratio and other dimension
            pMinWidth = b.minHeight * this.aspectRatio;
            pMinHeight = b.minWidth / this.aspectRatio;
            pMaxWidth = b.maxHeight * this.aspectRatio;
            pMaxHeight = b.maxWidth / this.aspectRatio;

            if(pMinWidth > b.minWidth) b.minWidth = pMinWidth;
            if(pMinHeight > b.minHeight) b.minHeight = pMinHeight;
            if(pMaxWidth < b.maxWidth) b.maxWidth = pMaxWidth;
            if(pMaxHeight < b.maxHeight) b.maxHeight = pMaxHeight;
        }
        this._vBoundaries = b;
    },

	_updateCache: function(data) {
		var o = this.options;
		this.offset = this.helper.offset();
		if (isNumber(data.left)) this.position.left = data.left;
		if (isNumber(data.top)) this.position.top = data.top;
		if (isNumber(data.height)) this.size.height = data.height;
		if (isNumber(data.width)) this.size.width = data.width;
	},

	_updateRatio: function(data, event) {

		var o = this.options, cpos = this.position, csize = this.size, a = this.axis;

		if (isNumber(data.height)) data.width = (data.height * this.aspectRatio);
		else if (isNumber(data.width)) data.height = (data.width / this.aspectRatio);

		if (a == 'sw') {
			data.left = cpos.left + (csize.width - data.width);
			data.top = null;
		}
		if (a == 'nw') {
			data.top = cpos.top + (csize.height - data.height);
			data.left = cpos.left + (csize.width - data.width);
		}

		return data;
	},

	_respectSize: function(data, event) {

		var el = this.helper, o = this._vBoundaries, pRatio = this._aspectRatio || event.shiftKey, a = this.axis,
				ismaxw = isNumber(data.width) && o.maxWidth && (o.maxWidth < data.width), ismaxh = isNumber(data.height) && o.maxHeight && (o.maxHeight < data.height),
					isminw = isNumber(data.width) && o.minWidth && (o.minWidth > data.width), isminh = isNumber(data.height) && o.minHeight && (o.minHeight > data.height);

		if (isminw) data.width = o.minWidth;
		if (isminh) data.height = o.minHeight;
		if (ismaxw) data.width = o.maxWidth;
		if (ismaxh) data.height = o.maxHeight;

		var dw = this.originalPosition.left + this.originalSize.width, dh = this.position.top + this.size.height;
		var cw = /sw|nw|w/.test(a), ch = /nw|ne|n/.test(a);

		if (isminw && cw) data.left = dw - o.minWidth;
		if (ismaxw && cw) data.left = dw - o.maxWidth;
		if (isminh && ch)	data.top = dh - o.minHeight;
		if (ismaxh && ch)	data.top = dh - o.maxHeight;

		// fixing jump error on top/left - bug #2330
		var isNotwh = !data.width && !data.height;
		if (isNotwh && !data.left && data.top) data.top = null;
		else if (isNotwh && !data.top && data.left) data.left = null;

		return data;
	},

	_proportionallyResize: function() {

		var o = this.options;
		if (!this._proportionallyResizeElements.length) return;
		var element = this.helper || this.element;

		for (var i=0; i < this._proportionallyResizeElements.length; i++) {

			var prel = this._proportionallyResizeElements[i];

			if (!this.borderDif) {
				var b = [prel.css('borderTopWidth'), prel.css('borderRightWidth'), prel.css('borderBottomWidth'), prel.css('borderLeftWidth')],
					p = [prel.css('paddingTop'), prel.css('paddingRight'), prel.css('paddingBottom'), prel.css('paddingLeft')];

				this.borderDif = $.map(b, function(v, i) {
					var border = parseInt(v,10)||0, padding = parseInt(p[i],10)||0;
					return border + padding;
				});
			}

			if ($.browser.msie && !(!($(element).is(':hidden') || $(element).parents(':hidden').length)))
				continue;

			prel.css({
				height: (element.height() - this.borderDif[0] - this.borderDif[2]) || 0,
				width: (element.width() - this.borderDif[1] - this.borderDif[3]) || 0
			});

		};

	},

	_renderProxy: function() {

		var el = this.element, o = this.options;
		this.elementOffset = el.offset();

		if(this._helper) {

			this.helper = this.helper || $('<div style="overflow:hidden;"></div>');

			// fix ie6 offset TODO: This seems broken
			var ie6 = $.browser.msie && $.browser.version < 7, ie6offset = (ie6 ? 1 : 0),
			pxyoffset = ( ie6 ? 2 : -1 );

			this.helper.addClass(this._helper).css({
				width: this.element.outerWidth() + pxyoffset,
				height: this.element.outerHeight() + pxyoffset,
				position: 'absolute',
				left: this.elementOffset.left - ie6offset +'px',
				top: this.elementOffset.top - ie6offset +'px',
				zIndex: ++o.zIndex //TODO: Don't modify option
			});

			this.helper
				.appendTo("body")
				.disableSelection();

		} else {
			this.helper = this.element;
		}

	},

	_change: {
		e: function(event, dx, dy) {
			return { width: this.originalSize.width + dx };
		},
		w: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { left: sp.left + dx, width: cs.width - dx };
		},
		n: function(event, dx, dy) {
			var o = this.options, cs = this.originalSize, sp = this.originalPosition;
			return { top: sp.top + dy, height: cs.height - dy };
		},
		s: function(event, dx, dy) {
			return { height: this.originalSize.height + dy };
		},
		se: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		sw: function(event, dx, dy) {
			return $.extend(this._change.s.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		},
		ne: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.e.apply(this, [event, dx, dy]));
		},
		nw: function(event, dx, dy) {
			return $.extend(this._change.n.apply(this, arguments), this._change.w.apply(this, [event, dx, dy]));
		}
	},

	_propagate: function(n, event) {
		$.ui.plugin.call(this, n, [event, this.ui()]);
		(n != "resize" && this._trigger(n, event, this.ui()));
	},

	plugins: {},

	ui: function() {
		return {
			originalElement: this.originalElement,
			element: this.element,
			helper: this.helper,
			position: this.position,
			size: this.size,
			originalSize: this.originalSize,
			originalPosition: this.originalPosition
		};
	}

});

$.extend($.ui.resizable, {
	version: "1.8.21"
});

/*
 * Resizable Extensions
 */

$.ui.plugin.add("resizable", "alsoResize", {

	start: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var _store = function (exp) {
			$(exp).each(function() {
				var el = $(this);
				el.data("resizable-alsoresize", {
					width: parseInt(el.width(), 10), height: parseInt(el.height(), 10),
					left: parseInt(el.css('left'), 10), top: parseInt(el.css('top'), 10)
				});
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.parentNode) {
			if (o.alsoResize.length) { o.alsoResize = o.alsoResize[0]; _store(o.alsoResize); }
			else { $.each(o.alsoResize, function (exp) { _store(exp); }); }
		}else{
			_store(o.alsoResize);
		}
	},

	resize: function (event, ui) {
		var self = $(this).data("resizable"), o = self.options, os = self.originalSize, op = self.originalPosition;

		var delta = {
			height: (self.size.height - os.height) || 0, width: (self.size.width - os.width) || 0,
			top: (self.position.top - op.top) || 0, left: (self.position.left - op.left) || 0
		},

		_alsoResize = function (exp, c) {
			$(exp).each(function() {
				var el = $(this), start = $(this).data("resizable-alsoresize"), style = {}, 
					css = c && c.length ? c : el.parents(ui.originalElement[0]).length ? ['width', 'height'] : ['width', 'height', 'top', 'left'];

				$.each(css, function (i, prop) {
					var sum = (start[prop]||0) + (delta[prop]||0);
					if (sum && sum >= 0)
						style[prop] = sum || null;
				});

				el.css(style);
			});
		};

		if (typeof(o.alsoResize) == 'object' && !o.alsoResize.nodeType) {
			$.each(o.alsoResize, function (exp, c) { _alsoResize(exp, c); });
		}else{
			_alsoResize(o.alsoResize);
		}
	},

	stop: function (event, ui) {
		$(this).removeData("resizable-alsoresize");
	}
});

$.ui.plugin.add("resizable", "animate", {

	stop: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options;

		var pr = self._proportionallyResizeElements, ista = pr.length && (/textarea/i).test(pr[0].nodeName),
					soffseth = ista && $.ui.hasScroll(pr[0], 'left') /* TODO - jump height */ ? 0 : self.sizeDiff.height,
						soffsetw = ista ? 0 : self.sizeDiff.width;

		var style = { width: (self.size.width - soffsetw), height: (self.size.height - soffseth) },
					left = (parseInt(self.element.css('left'), 10) + (self.position.left - self.originalPosition.left)) || null,
						top = (parseInt(self.element.css('top'), 10) + (self.position.top - self.originalPosition.top)) || null;

		self.element.animate(
			$.extend(style, top && left ? { top: top, left: left } : {}), {
				duration: o.animateDuration,
				easing: o.animateEasing,
				step: function() {

					var data = {
						width: parseInt(self.element.css('width'), 10),
						height: parseInt(self.element.css('height'), 10),
						top: parseInt(self.element.css('top'), 10),
						left: parseInt(self.element.css('left'), 10)
					};

					if (pr && pr.length) $(pr[0]).css({ width: data.width, height: data.height });

					// propagating resize, and updating values for each animation step
					self._updateCache(data);
					self._propagate("resize", event);

				}
			}
		);
	}

});

$.ui.plugin.add("resizable", "containment", {

	start: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, el = self.element;
		var oc = o.containment,	ce = (oc instanceof $) ? oc.get(0) : (/parent/.test(oc)) ? el.parent().get(0) : oc;
		if (!ce) return;

		self.containerElement = $(ce);

		if (/document/.test(oc) || oc == document) {
			self.containerOffset = { left: 0, top: 0 };
			self.containerPosition = { left: 0, top: 0 };

			self.parentData = {
				element: $(document), left: 0, top: 0,
				width: $(document).width(), height: $(document).height() || document.body.parentNode.scrollHeight
			};
		}

		// i'm a node, so compute top, left, right, bottom
		else {
			var element = $(ce), p = [];
			$([ "Top", "Right", "Left", "Bottom" ]).each(function(i, name) { p[i] = num(element.css("padding" + name)); });

			self.containerOffset = element.offset();
			self.containerPosition = element.position();
			self.containerSize = { height: (element.innerHeight() - p[3]), width: (element.innerWidth() - p[1]) };

			var co = self.containerOffset, ch = self.containerSize.height,	cw = self.containerSize.width,
						width = ($.ui.hasScroll(ce, "left") ? ce.scrollWidth : cw ), height = ($.ui.hasScroll(ce) ? ce.scrollHeight : ch);

			self.parentData = {
				element: ce, left: co.left, top: co.top, width: width, height: height
			};
		}
	},

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options,
				ps = self.containerSize, co = self.containerOffset, cs = self.size, cp = self.position,
				pRatio = self._aspectRatio || event.shiftKey, cop = { top:0, left:0 }, ce = self.containerElement;

		if (ce[0] != document && (/static/).test(ce.css('position'))) cop = co;

		if (cp.left < (self._helper ? co.left : 0)) {
			self.size.width = self.size.width + (self._helper ? (self.position.left - co.left) : (self.position.left - cop.left));
			if (pRatio) self.size.height = self.size.width / self.aspectRatio;
			self.position.left = o.helper ? co.left : 0;
		}

		if (cp.top < (self._helper ? co.top : 0)) {
			self.size.height = self.size.height + (self._helper ? (self.position.top - co.top) : self.position.top);
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
			self.position.top = self._helper ? co.top : 0;
		}

		self.offset.left = self.parentData.left+self.position.left;
		self.offset.top = self.parentData.top+self.position.top;

		var woset = Math.abs( (self._helper ? self.offset.left - cop.left : (self.offset.left - cop.left)) + self.sizeDiff.width ),
					hoset = Math.abs( (self._helper ? self.offset.top - cop.top : (self.offset.top - co.top)) + self.sizeDiff.height );

		var isParent = self.containerElement.get(0) == self.element.parent().get(0),
		    isOffsetRelative = /relative|absolute/.test(self.containerElement.css('position'));

		if(isParent && isOffsetRelative) woset -= self.parentData.left;

		if (woset + self.size.width >= self.parentData.width) {
			self.size.width = self.parentData.width - woset;
			if (pRatio) self.size.height = self.size.width / self.aspectRatio;
		}

		if (hoset + self.size.height >= self.parentData.height) {
			self.size.height = self.parentData.height - hoset;
			if (pRatio) self.size.width = self.size.height * self.aspectRatio;
		}
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options, cp = self.position,
				co = self.containerOffset, cop = self.containerPosition, ce = self.containerElement;

		var helper = $(self.helper), ho = helper.offset(), w = helper.outerWidth() - self.sizeDiff.width, h = helper.outerHeight() - self.sizeDiff.height;

		if (self._helper && !o.animate && (/relative/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

		if (self._helper && !o.animate && (/static/).test(ce.css('position')))
			$(this).css({ left: ho.left - cop.left - co.left, width: w, height: h });

	}
});

$.ui.plugin.add("resizable", "ghost", {

	start: function(event, ui) {

		var self = $(this).data("resizable"), o = self.options, cs = self.size;

		self.ghost = self.originalElement.clone();
		self.ghost
			.css({ opacity: .25, display: 'block', position: 'relative', height: cs.height, width: cs.width, margin: 0, left: 0, top: 0 })
			.addClass('ui-resizable-ghost')
			.addClass(typeof o.ghost == 'string' ? o.ghost : '');

		self.ghost.appendTo(self.helper);

	},

	resize: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost) self.ghost.css({ position: 'relative', height: self.size.height, width: self.size.width });
	},

	stop: function(event, ui){
		var self = $(this).data("resizable"), o = self.options;
		if (self.ghost && self.helper) self.helper.get(0).removeChild(self.ghost.get(0));
	}

});

$.ui.plugin.add("resizable", "grid", {

	resize: function(event, ui) {
		var self = $(this).data("resizable"), o = self.options, cs = self.size, os = self.originalSize, op = self.originalPosition, a = self.axis, ratio = o._aspectRatio || event.shiftKey;
		o.grid = typeof o.grid == "number" ? [o.grid, o.grid] : o.grid;
		var ox = Math.round((cs.width - os.width) / (o.grid[0]||1)) * (o.grid[0]||1), oy = Math.round((cs.height - os.height) / (o.grid[1]||1)) * (o.grid[1]||1);

		if (/^(se|s|e)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
		}
		else if (/^(ne)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
		}
		else if (/^(sw)$/.test(a)) {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.left = op.left - ox;
		}
		else {
			self.size.width = os.width + ox;
			self.size.height = os.height + oy;
			self.position.top = op.top - oy;
			self.position.left = op.left - ox;
		}
	}

});

var num = function(v) {
	return parseInt(v, 10) || 0;
};

var isNumber = function(value) {
	return !isNaN(parseInt(value, 10));
};

})(jQuery);
/*!
 * jQuery UI Selectable 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Selectables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.selectable", $.ui.mouse, {
	options: {
		appendTo: 'body',
		autoRefresh: true,
		distance: 0,
		filter: '*',
		tolerance: 'touch'
	},
	_create: function() {
		var self = this;

		this.element.addClass("ui-selectable");

		this.dragged = false;

		// cache selectee children based on filter
		var selectees;
		this.refresh = function() {
			selectees = $(self.options.filter, self.element[0]);
			selectees.addClass("ui-selectee");
			selectees.each(function() {
				var $this = $(this);
				var pos = $this.offset();
				$.data(this, "selectable-item", {
					element: this,
					$element: $this,
					left: pos.left,
					top: pos.top,
					right: pos.left + $this.outerWidth(),
					bottom: pos.top + $this.outerHeight(),
					startselected: false,
					selected: $this.hasClass('ui-selected'),
					selecting: $this.hasClass('ui-selecting'),
					unselecting: $this.hasClass('ui-unselecting')
				});
			});
		};
		this.refresh();

		this.selectees = selectees.addClass("ui-selectee");

		this._mouseInit();

		this.helper = $("<div class='ui-selectable-helper'></div>");
	},

	destroy: function() {
		this.selectees
			.removeClass("ui-selectee")
			.removeData("selectable-item");
		this.element
			.removeClass("ui-selectable ui-selectable-disabled")
			.removeData("selectable")
			.unbind(".selectable");
		this._mouseDestroy();

		return this;
	},

	_mouseStart: function(event) {
		var self = this;

		this.opos = [event.pageX, event.pageY];

		if (this.options.disabled)
			return;

		var options = this.options;

		this.selectees = $(options.filter, this.element[0]);

		this._trigger("start", event);

		$(options.appendTo).append(this.helper);
		// position helper (lasso)
		this.helper.css({
			"left": event.clientX,
			"top": event.clientY,
			"width": 0,
			"height": 0
		});

		if (options.autoRefresh) {
			this.refresh();
		}

		this.selectees.filter('.ui-selected').each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.startselected = true;
			if (!event.metaKey && !event.ctrlKey) {
				selectee.$element.removeClass('ui-selected');
				selectee.selected = false;
				selectee.$element.addClass('ui-unselecting');
				selectee.unselecting = true;
				// selectable UNSELECTING callback
				self._trigger("unselecting", event, {
					unselecting: selectee.element
				});
			}
		});

		$(event.target).parents().andSelf().each(function() {
			var selectee = $.data(this, "selectable-item");
			if (selectee) {
				var doSelect = (!event.metaKey && !event.ctrlKey) || !selectee.$element.hasClass('ui-selected');
				selectee.$element
					.removeClass(doSelect ? "ui-unselecting" : "ui-selected")
					.addClass(doSelect ? "ui-selecting" : "ui-unselecting");
				selectee.unselecting = !doSelect;
				selectee.selecting = doSelect;
				selectee.selected = doSelect;
				// selectable (UN)SELECTING callback
				if (doSelect) {
					self._trigger("selecting", event, {
						selecting: selectee.element
					});
				} else {
					self._trigger("unselecting", event, {
						unselecting: selectee.element
					});
				}
				return false;
			}
		});

	},

	_mouseDrag: function(event) {
		var self = this;
		this.dragged = true;

		if (this.options.disabled)
			return;

		var options = this.options;

		var x1 = this.opos[0], y1 = this.opos[1], x2 = event.pageX, y2 = event.pageY;
		if (x1 > x2) { var tmp = x2; x2 = x1; x1 = tmp; }
		if (y1 > y2) { var tmp = y2; y2 = y1; y1 = tmp; }
		this.helper.css({left: x1, top: y1, width: x2-x1, height: y2-y1});

		this.selectees.each(function() {
			var selectee = $.data(this, "selectable-item");
			//prevent helper from being selected if appendTo: selectable
			if (!selectee || selectee.element == self.element[0])
				return;
			var hit = false;
			if (options.tolerance == 'touch') {
				hit = ( !(selectee.left > x2 || selectee.right < x1 || selectee.top > y2 || selectee.bottom < y1) );
			} else if (options.tolerance == 'fit') {
				hit = (selectee.left > x1 && selectee.right < x2 && selectee.top > y1 && selectee.bottom < y2);
			}

			if (hit) {
				// SELECT
				if (selectee.selected) {
					selectee.$element.removeClass('ui-selected');
					selectee.selected = false;
				}
				if (selectee.unselecting) {
					selectee.$element.removeClass('ui-unselecting');
					selectee.unselecting = false;
				}
				if (!selectee.selecting) {
					selectee.$element.addClass('ui-selecting');
					selectee.selecting = true;
					// selectable SELECTING callback
					self._trigger("selecting", event, {
						selecting: selectee.element
					});
				}
			} else {
				// UNSELECT
				if (selectee.selecting) {
					if ((event.metaKey || event.ctrlKey) && selectee.startselected) {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						selectee.$element.addClass('ui-selected');
						selectee.selected = true;
					} else {
						selectee.$element.removeClass('ui-selecting');
						selectee.selecting = false;
						if (selectee.startselected) {
							selectee.$element.addClass('ui-unselecting');
							selectee.unselecting = true;
						}
						// selectable UNSELECTING callback
						self._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
				if (selectee.selected) {
					if (!event.metaKey && !event.ctrlKey && !selectee.startselected) {
						selectee.$element.removeClass('ui-selected');
						selectee.selected = false;

						selectee.$element.addClass('ui-unselecting');
						selectee.unselecting = true;
						// selectable UNSELECTING callback
						self._trigger("unselecting", event, {
							unselecting: selectee.element
						});
					}
				}
			}
		});

		return false;
	},

	_mouseStop: function(event) {
		var self = this;

		this.dragged = false;

		var options = this.options;

		$('.ui-unselecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-unselecting');
			selectee.unselecting = false;
			selectee.startselected = false;
			self._trigger("unselected", event, {
				unselected: selectee.element
			});
		});
		$('.ui-selecting', this.element[0]).each(function() {
			var selectee = $.data(this, "selectable-item");
			selectee.$element.removeClass('ui-selecting').addClass('ui-selected');
			selectee.selecting = false;
			selectee.selected = true;
			selectee.startselected = true;
			self._trigger("selected", event, {
				selected: selectee.element
			});
		});
		this._trigger("stop", event);

		this.helper.remove();

		return false;
	}

});

$.extend($.ui.selectable, {
	version: "1.8.21"
});

})(jQuery);
/*!
 * jQuery UI Sortable 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Sortables
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget("ui.sortable", $.ui.mouse, {
	widgetEventPrefix: "sort",
	ready: false,
	options: {
		appendTo: "parent",
		axis: false,
		connectWith: false,
		containment: false,
		cursor: 'auto',
		cursorAt: false,
		dropOnEmpty: true,
		forcePlaceholderSize: false,
		forceHelperSize: false,
		grid: false,
		handle: false,
		helper: "original",
		items: '> *',
		opacity: false,
		placeholder: false,
		revert: false,
		scroll: true,
		scrollSensitivity: 20,
		scrollSpeed: 20,
		scope: "default",
		tolerance: "intersect",
		zIndex: 1000
	},
	_create: function() {

		var o = this.options;
		this.containerCache = {};
		this.element.addClass("ui-sortable");

		//Get the items
		this.refresh();

		//Let's determine if the items are being displayed horizontally
		this.floating = this.items.length ? o.axis === 'x' || (/left|right/).test(this.items[0].item.css('float')) || (/inline|table-cell/).test(this.items[0].item.css('display')) : false;

		//Let's determine the parent's offset
		this.offset = this.element.offset();

		//Initialize mouse events for interaction
		this._mouseInit();
		
		//We're ready to go
		this.ready = true

	},

	destroy: function() {
		$.Widget.prototype.destroy.call( this );
		this.element
			.removeClass("ui-sortable ui-sortable-disabled");
		this._mouseDestroy();

		for ( var i = this.items.length - 1; i >= 0; i-- )
			this.items[i].item.removeData(this.widgetName + "-item");

		return this;
	},

	_setOption: function(key, value){
		if ( key === "disabled" ) {
			this.options[ key ] = value;
	
			this.widget()
				[ value ? "addClass" : "removeClass"]( "ui-sortable-disabled" );
		} else {
			// Don't call widget base _setOption for disable as it adds ui-state-disabled class
			$.Widget.prototype._setOption.apply(this, arguments);
		}
	},

	_mouseCapture: function(event, overrideHandle) {
		var that = this;

		if (this.reverting) {
			return false;
		}

		if(this.options.disabled || this.options.type == 'static') return false;

		//We have to refresh the items data once first
		this._refreshItems(event);

		//Find out if the clicked node (or one of its parents) is a actual item in this.items
		var currentItem = null, self = this, nodes = $(event.target).parents().each(function() {
			if($.data(this, that.widgetName + '-item') == self) {
				currentItem = $(this);
				return false;
			}
		});
		if($.data(event.target, that.widgetName + '-item') == self) currentItem = $(event.target);

		if(!currentItem) return false;
		if(this.options.handle && !overrideHandle) {
			var validHandle = false;

			$(this.options.handle, currentItem).find("*").andSelf().each(function() { if(this == event.target) validHandle = true; });
			if(!validHandle) return false;
		}

		this.currentItem = currentItem;
		this._removeCurrentsFromItems();
		return true;

	},

	_mouseStart: function(event, overrideHandle, noActivation) {

		var o = this.options, self = this;
		this.currentContainer = this;

		//We only need to call refreshPositions, because the refreshItems call has been moved to mouseCapture
		this.refreshPositions();

		//Create and append the visible helper
		this.helper = this._createHelper(event);

		//Cache the helper size
		this._cacheHelperProportions();

		/*
		 * - Position generation -
		 * This block generates everything position related - it's the core of draggables.
		 */

		//Cache the margins of the original element
		this._cacheMargins();

		//Get the next scrolling parent
		this.scrollParent = this.helper.scrollParent();

		//The element's absolute position on the page minus margins
		this.offset = this.currentItem.offset();
		this.offset = {
			top: this.offset.top - this.margins.top,
			left: this.offset.left - this.margins.left
		};

		$.extend(this.offset, {
			click: { //Where the click happened, relative to the element
				left: event.pageX - this.offset.left,
				top: event.pageY - this.offset.top
			},
			parent: this._getParentOffset(),
			relative: this._getRelativeOffset() //This is a relative to absolute position minus the actual position calculation - only used for relative positioned helper
		});

		// Only after we got the offset, we can change the helper's position to absolute
		// TODO: Still need to figure out a way to make relative sorting possible
		this.helper.css("position", "absolute");
		this.cssPosition = this.helper.css("position");
		
		//Generate the original position
		this.originalPosition = this._generatePosition(event);
		this.originalPageX = event.pageX;
		this.originalPageY = event.pageY;

		//Adjust the mouse offset relative to the helper if 'cursorAt' is supplied
		(o.cursorAt && this._adjustOffsetFromHelper(o.cursorAt));

		//Cache the former DOM position
		this.domPosition = { prev: this.currentItem.prev()[0], parent: this.currentItem.parent()[0] };

		//If the helper is not the original, hide the original so it's not playing any role during the drag, won't cause anything bad this way
		if(this.helper[0] != this.currentItem[0]) {
			this.currentItem.hide();
		}

		//Create the placeholder
		this._createPlaceholder();

		//Set a containment if given in the options
		if(o.containment)
			this._setContainment();

		if(o.cursor) { // cursor option
			if ($('body').css("cursor")) this._storedCursor = $('body').css("cursor");
			$('body').css("cursor", o.cursor);
		}

		if(o.opacity) { // opacity option
			if (this.helper.css("opacity")) this._storedOpacity = this.helper.css("opacity");
			this.helper.css("opacity", o.opacity);
		}

		if(o.zIndex) { // zIndex option
			if (this.helper.css("zIndex")) this._storedZIndex = this.helper.css("zIndex");
			this.helper.css("zIndex", o.zIndex);
		}

		//Prepare scrolling
		if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML')
			this.overflowOffset = this.scrollParent.offset();

		//Call callbacks
		this._trigger("start", event, this._uiHash());

		//Recache the helper size
		if(!this._preserveHelperProportions)
			this._cacheHelperProportions();


		//Post 'activate' events to possible containers
		if(!noActivation) {
			 for (var i = this.containers.length - 1; i >= 0; i--) { this.containers[i]._trigger("activate", event, self._uiHash(this)); }
		}

		//Prepare possible droppables
		if($.ui.ddmanager)
			$.ui.ddmanager.current = this;

		if ($.ui.ddmanager && !o.dropBehaviour)
			$.ui.ddmanager.prepareOffsets(this, event);

		this.dragging = true;

		this.helper.addClass("ui-sortable-helper");
		this._mouseDrag(event); //Execute the drag once - this causes the helper not to be visible before getting its correct position
		return true;

	},

	_mouseDrag: function(event) {

		//Compute the helpers position
		this.position = this._generatePosition(event);
		this.positionAbs = this._convertPositionTo("absolute");

		if (!this.lastPositionAbs) {
			this.lastPositionAbs = this.positionAbs;
		}

		//Do scrolling
		if(this.options.scroll) {
			var o = this.options, scrolled = false;
			if(this.scrollParent[0] != document && this.scrollParent[0].tagName != 'HTML') {

				if((this.overflowOffset.top + this.scrollParent[0].offsetHeight) - event.pageY < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop + o.scrollSpeed;
				else if(event.pageY - this.overflowOffset.top < o.scrollSensitivity)
					this.scrollParent[0].scrollTop = scrolled = this.scrollParent[0].scrollTop - o.scrollSpeed;

				if((this.overflowOffset.left + this.scrollParent[0].offsetWidth) - event.pageX < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft + o.scrollSpeed;
				else if(event.pageX - this.overflowOffset.left < o.scrollSensitivity)
					this.scrollParent[0].scrollLeft = scrolled = this.scrollParent[0].scrollLeft - o.scrollSpeed;

			} else {

				if(event.pageY - $(document).scrollTop() < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() - o.scrollSpeed);
				else if($(window).height() - (event.pageY - $(document).scrollTop()) < o.scrollSensitivity)
					scrolled = $(document).scrollTop($(document).scrollTop() + o.scrollSpeed);

				if(event.pageX - $(document).scrollLeft() < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() - o.scrollSpeed);
				else if($(window).width() - (event.pageX - $(document).scrollLeft()) < o.scrollSensitivity)
					scrolled = $(document).scrollLeft($(document).scrollLeft() + o.scrollSpeed);

			}

			if(scrolled !== false && $.ui.ddmanager && !o.dropBehaviour)
				$.ui.ddmanager.prepareOffsets(this, event);
		}

		//Regenerate the absolute position used for position checks
		this.positionAbs = this._convertPositionTo("absolute");

		//Set the helper position
		if(!this.options.axis || this.options.axis != "y") this.helper[0].style.left = this.position.left+'px';
		if(!this.options.axis || this.options.axis != "x") this.helper[0].style.top = this.position.top+'px';

		//Rearrange
		for (var i = this.items.length - 1; i >= 0; i--) {

			//Cache variables and intersection, continue if no intersection
			var item = this.items[i], itemElement = item.item[0], intersection = this._intersectsWithPointer(item);
			if (!intersection) continue;

			if(itemElement != this.currentItem[0] //cannot intersect with itself
				&&	this.placeholder[intersection == 1 ? "next" : "prev"]()[0] != itemElement //no useless actions that have been done before
				&&	!$.ui.contains(this.placeholder[0], itemElement) //no action if the item moved is the parent of the item checked
				&& (this.options.type == 'semi-dynamic' ? !$.ui.contains(this.element[0], itemElement) : true)
				//&& itemElement.parentNode == this.placeholder[0].parentNode // only rearrange items within the same container
			) {

				this.direction = intersection == 1 ? "down" : "up";

				if (this.options.tolerance == "pointer" || this._intersectsWithSides(item)) {
					this._rearrange(event, item);
				} else {
					break;
				}

				this._trigger("change", event, this._uiHash());
				break;
			}
		}

		//Post events to containers
		this._contactContainers(event);

		//Interconnect with droppables
		if($.ui.ddmanager) $.ui.ddmanager.drag(this, event);

		//Call callbacks
		this._trigger('sort', event, this._uiHash());

		this.lastPositionAbs = this.positionAbs;
		return false;

	},

	_mouseStop: function(event, noPropagation) {

		if(!event) return;

		//If we are using droppables, inform the manager about the drop
		if ($.ui.ddmanager && !this.options.dropBehaviour)
			$.ui.ddmanager.drop(this, event);

		if(this.options.revert) {
			var self = this;
			var cur = self.placeholder.offset();

			self.reverting = true;

			$(this.helper).animate({
				left: cur.left - this.offset.parent.left - self.margins.left + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollLeft),
				top: cur.top - this.offset.parent.top - self.margins.top + (this.offsetParent[0] == document.body ? 0 : this.offsetParent[0].scrollTop)
			}, parseInt(this.options.revert, 10) || 500, function() {
				self._clear(event);
			});
		} else {
			this._clear(event, noPropagation);
		}

		return false;

	},

	cancel: function() {

		var self = this;

		if(this.dragging) {

			this._mouseUp({ target: null });

			if(this.options.helper == "original")
				this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
			else
				this.currentItem.show();

			//Post deactivating events to containers
			for (var i = this.containers.length - 1; i >= 0; i--){
				this.containers[i]._trigger("deactivate", null, self._uiHash(this));
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", null, self._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}

		if (this.placeholder) {
			//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
			if(this.placeholder[0].parentNode) this.placeholder[0].parentNode.removeChild(this.placeholder[0]);
			if(this.options.helper != "original" && this.helper && this.helper[0].parentNode) this.helper.remove();

			$.extend(this, {
				helper: null,
				dragging: false,
				reverting: false,
				_noFinalSort: null
			});

			if(this.domPosition.prev) {
				$(this.domPosition.prev).after(this.currentItem);
			} else {
				$(this.domPosition.parent).prepend(this.currentItem);
			}
		}

		return this;

	},

	serialize: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var str = []; o = o || {};

		$(items).each(function() {
			var res = ($(o.item || this).attr(o.attribute || 'id') || '').match(o.expression || (/(.+)[-=_](.+)/));
			if(res) str.push((o.key || res[1]+'[]')+'='+(o.key && o.expression ? res[1] : res[2]));
		});

		if(!str.length && o.key) {
			str.push(o.key + '=');
		}

		return str.join('&');

	},

	toArray: function(o) {

		var items = this._getItemsAsjQuery(o && o.connected);
		var ret = []; o = o || {};

		items.each(function() { ret.push($(o.item || this).attr(o.attribute || 'id') || ''); });
		return ret;

	},

	/* Be careful with the following core functions */
	_intersectsWith: function(item) {

		var x1 = this.positionAbs.left,
			x2 = x1 + this.helperProportions.width,
			y1 = this.positionAbs.top,
			y2 = y1 + this.helperProportions.height;

		var l = item.left,
			r = l + item.width,
			t = item.top,
			b = t + item.height;

		var dyClick = this.offset.click.top,
			dxClick = this.offset.click.left;

		var isOverElement = (y1 + dyClick) > t && (y1 + dyClick) < b && (x1 + dxClick) > l && (x1 + dxClick) < r;

		if(	   this.options.tolerance == "pointer"
			|| this.options.forcePointerForContainers
			|| (this.options.tolerance != "pointer" && this.helperProportions[this.floating ? 'width' : 'height'] > item[this.floating ? 'width' : 'height'])
		) {
			return isOverElement;
		} else {

			return (l < x1 + (this.helperProportions.width / 2) // Right Half
				&& x2 - (this.helperProportions.width / 2) < r // Left Half
				&& t < y1 + (this.helperProportions.height / 2) // Bottom Half
				&& y2 - (this.helperProportions.height / 2) < b ); // Top Half

		}
	},

	_intersectsWithPointer: function(item) {

		var isOverElementHeight = (this.options.axis === 'x') || $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top, item.height),
			isOverElementWidth = (this.options.axis === 'y') || $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left, item.width),
			isOverElement = isOverElementHeight && isOverElementWidth,
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (!isOverElement)
			return false;

		return this.floating ?
			( ((horizontalDirection && horizontalDirection == "right") || verticalDirection == "down") ? 2 : 1 )
			: ( verticalDirection && (verticalDirection == "down" ? 2 : 1) );

	},

	_intersectsWithSides: function(item) {

		var isOverBottomHalf = $.ui.isOverAxis(this.positionAbs.top + this.offset.click.top, item.top + (item.height/2), item.height),
			isOverRightHalf = $.ui.isOverAxis(this.positionAbs.left + this.offset.click.left, item.left + (item.width/2), item.width),
			verticalDirection = this._getDragVerticalDirection(),
			horizontalDirection = this._getDragHorizontalDirection();

		if (this.floating && horizontalDirection) {
			return ((horizontalDirection == "right" && isOverRightHalf) || (horizontalDirection == "left" && !isOverRightHalf));
		} else {
			return verticalDirection && ((verticalDirection == "down" && isOverBottomHalf) || (verticalDirection == "up" && !isOverBottomHalf));
		}

	},

	_getDragVerticalDirection: function() {
		var delta = this.positionAbs.top - this.lastPositionAbs.top;
		return delta != 0 && (delta > 0 ? "down" : "up");
	},

	_getDragHorizontalDirection: function() {
		var delta = this.positionAbs.left - this.lastPositionAbs.left;
		return delta != 0 && (delta > 0 ? "right" : "left");
	},

	refresh: function(event) {
		this._refreshItems(event);
		this.refreshPositions();
		return this;
	},

	_connectWith: function() {
		var options = this.options;
		return options.connectWith.constructor == String
			? [options.connectWith]
			: options.connectWith;
	},
	
	_getItemsAsjQuery: function(connected) {

		var self = this;
		var items = [];
		var queries = [];
		var connectWith = this._connectWith();

		if(connectWith && connected) {
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element) : $(inst.options.items, inst.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), inst]);
					}
				};
			};
		}

		queries.push([$.isFunction(this.options.items) ? this.options.items.call(this.element, null, { options: this.options, item: this.currentItem }) : $(this.options.items, this.element).not(".ui-sortable-helper").not('.ui-sortable-placeholder'), this]);

		for (var i = queries.length - 1; i >= 0; i--){
			queries[i][0].each(function() {
				items.push(this);
			});
		};

		return $(items);

	},

	_removeCurrentsFromItems: function() {

		var list = this.currentItem.find(":data(" + this.widgetName + "-item)");

		for (var i=0; i < this.items.length; i++) {

			for (var j=0; j < list.length; j++) {
				if(list[j] == this.items[i].item[0])
					this.items.splice(i,1);
			};

		};

	},

	_refreshItems: function(event) {

		this.items = [];
		this.containers = [this];
		var items = this.items;
		var self = this;
		var queries = [[$.isFunction(this.options.items) ? this.options.items.call(this.element[0], event, { item: this.currentItem }) : $(this.options.items, this.element), this]];
		var connectWith = this._connectWith();

		if(connectWith && this.ready) { //Shouldn't be run the first time through due to massive slow-down
			for (var i = connectWith.length - 1; i >= 0; i--){
				var cur = $(connectWith[i]);
				for (var j = cur.length - 1; j >= 0; j--){
					var inst = $.data(cur[j], this.widgetName);
					if(inst && inst != this && !inst.options.disabled) {
						queries.push([$.isFunction(inst.options.items) ? inst.options.items.call(inst.element[0], event, { item: this.currentItem }) : $(inst.options.items, inst.element), inst]);
						this.containers.push(inst);
					}
				};
			};
		}

		for (var i = queries.length - 1; i >= 0; i--) {
			var targetData = queries[i][1];
			var _queries = queries[i][0];

			for (var j=0, queriesLength = _queries.length; j < queriesLength; j++) {
				var item = $(_queries[j]);

				item.data(this.widgetName + '-item', targetData); // Data for target checking (mouse manager)

				items.push({
					item: item,
					instance: targetData,
					width: 0, height: 0,
					left: 0, top: 0
				});
			};
		};

	},

	refreshPositions: function(fast) {

		//This has to be redone because due to the item being moved out/into the offsetParent, the offsetParent's position will change
		if(this.offsetParent && this.helper) {
			this.offset.parent = this._getParentOffset();
		}

		for (var i = this.items.length - 1; i >= 0; i--){
			var item = this.items[i];

			//We ignore calculating positions of all connected containers when we're not over them
			if(item.instance != this.currentContainer && this.currentContainer && item.item[0] != this.currentItem[0])
				continue;

			var t = this.options.toleranceElement ? $(this.options.toleranceElement, item.item) : item.item;

			if (!fast) {
				item.width = t.outerWidth();
				item.height = t.outerHeight();
			}

			var p = t.offset();
			item.left = p.left;
			item.top = p.top;
		};

		if(this.options.custom && this.options.custom.refreshContainers) {
			this.options.custom.refreshContainers.call(this);
		} else {
			for (var i = this.containers.length - 1; i >= 0; i--){
				var p = this.containers[i].element.offset();
				this.containers[i].containerCache.left = p.left;
				this.containers[i].containerCache.top = p.top;
				this.containers[i].containerCache.width	= this.containers[i].element.outerWidth();
				this.containers[i].containerCache.height = this.containers[i].element.outerHeight();
			};
		}

		return this;
	},

	_createPlaceholder: function(that) {

		var self = that || this, o = self.options;

		if(!o.placeholder || o.placeholder.constructor == String) {
			var className = o.placeholder;
			o.placeholder = {
				element: function() {

					var el = $(document.createElement(self.currentItem[0].nodeName))
						.addClass(className || self.currentItem[0].className+" ui-sortable-placeholder")
						.removeClass("ui-sortable-helper")[0];

					if(!className)
						el.style.visibility = "hidden";

					return el;
				},
				update: function(container, p) {

					// 1. If a className is set as 'placeholder option, we don't force sizes - the class is responsible for that
					// 2. The option 'forcePlaceholderSize can be enabled to force it even if a class name is specified
					if(className && !o.forcePlaceholderSize) return;

					//If the element doesn't have a actual height by itself (without styles coming from a stylesheet), it receives the inline height from the dragged item
					if(!p.height()) { p.height(self.currentItem.innerHeight() - parseInt(self.currentItem.css('paddingTop')||0, 10) - parseInt(self.currentItem.css('paddingBottom')||0, 10)); };
					if(!p.width()) { p.width(self.currentItem.innerWidth() - parseInt(self.currentItem.css('paddingLeft')||0, 10) - parseInt(self.currentItem.css('paddingRight')||0, 10)); };
				}
			};
		}

		//Create the placeholder
		self.placeholder = $(o.placeholder.element.call(self.element, self.currentItem));

		//Append it after the actual current item
		self.currentItem.after(self.placeholder);

		//Update the size of the placeholder (TODO: Logic to fuzzy, see line 316/317)
		o.placeholder.update(self, self.placeholder);

	},

	_contactContainers: function(event) {
		
		// get innermost container that intersects with item 
		var innermostContainer = null, innermostIndex = null;		
		
		
		for (var i = this.containers.length - 1; i >= 0; i--){

			// never consider a container that's located within the item itself 
			if($.ui.contains(this.currentItem[0], this.containers[i].element[0]))
				continue;

			if(this._intersectsWith(this.containers[i].containerCache)) {

				// if we've already found a container and it's more "inner" than this, then continue 
				if(innermostContainer && $.ui.contains(this.containers[i].element[0], innermostContainer.element[0]))
					continue;

				innermostContainer = this.containers[i]; 
				innermostIndex = i;
					
			} else {
				// container doesn't intersect. trigger "out" event if necessary 
				if(this.containers[i].containerCache.over) {
					this.containers[i]._trigger("out", event, this._uiHash(this));
					this.containers[i].containerCache.over = 0;
				}
			}

		}
		
		// if no intersecting containers found, return 
		if(!innermostContainer) return; 

		// move the item into the container if it's not there already
		if(this.containers.length === 1) {
			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} else if(this.currentContainer != this.containers[innermostIndex]) {

			//When entering a new container, we will find the item with the least distance and append our item near it
			var dist = 10000; var itemWithLeastDistance = null; var base = this.positionAbs[this.containers[innermostIndex].floating ? 'left' : 'top'];
			for (var j = this.items.length - 1; j >= 0; j--) {
				if(!$.ui.contains(this.containers[innermostIndex].element[0], this.items[j].item[0])) continue;
				var cur = this.containers[innermostIndex].floating ? this.items[j].item.offset().left : this.items[j].item.offset().top;
				if(Math.abs(cur - base) < dist) {
					dist = Math.abs(cur - base); itemWithLeastDistance = this.items[j];
					this.direction = (cur - base > 0) ? 'down' : 'up';
				}
			}

			if(!itemWithLeastDistance && !this.options.dropOnEmpty) //Check if dropOnEmpty is enabled
				return;

			this.currentContainer = this.containers[innermostIndex];
			itemWithLeastDistance ? this._rearrange(event, itemWithLeastDistance, null, true) : this._rearrange(event, null, this.containers[innermostIndex].element, true);
			this._trigger("change", event, this._uiHash());
			this.containers[innermostIndex]._trigger("change", event, this._uiHash(this));

			//Update the placeholder
			this.options.placeholder.update(this.currentContainer, this.placeholder);

			this.containers[innermostIndex]._trigger("over", event, this._uiHash(this));
			this.containers[innermostIndex].containerCache.over = 1;
		} 
	
		
	},

	_createHelper: function(event) {

		var o = this.options;
		var helper = $.isFunction(o.helper) ? $(o.helper.apply(this.element[0], [event, this.currentItem])) : (o.helper == 'clone' ? this.currentItem.clone() : this.currentItem);

		if(!helper.parents('body').length) //Add the helper to the DOM if that didn't happen already
			$(o.appendTo != 'parent' ? o.appendTo : this.currentItem[0].parentNode)[0].appendChild(helper[0]);

		if(helper[0] == this.currentItem[0])
			this._storedCSS = { width: this.currentItem[0].style.width, height: this.currentItem[0].style.height, position: this.currentItem.css("position"), top: this.currentItem.css("top"), left: this.currentItem.css("left") };

		if(helper[0].style.width == '' || o.forceHelperSize) helper.width(this.currentItem.width());
		if(helper[0].style.height == '' || o.forceHelperSize) helper.height(this.currentItem.height());

		return helper;

	},

	_adjustOffsetFromHelper: function(obj) {
		if (typeof obj == 'string') {
			obj = obj.split(' ');
		}
		if ($.isArray(obj)) {
			obj = {left: +obj[0], top: +obj[1] || 0};
		}
		if ('left' in obj) {
			this.offset.click.left = obj.left + this.margins.left;
		}
		if ('right' in obj) {
			this.offset.click.left = this.helperProportions.width - obj.right + this.margins.left;
		}
		if ('top' in obj) {
			this.offset.click.top = obj.top + this.margins.top;
		}
		if ('bottom' in obj) {
			this.offset.click.top = this.helperProportions.height - obj.bottom + this.margins.top;
		}
	},

	_getParentOffset: function() {


		//Get the offsetParent and cache its position
		this.offsetParent = this.helper.offsetParent();
		var po = this.offsetParent.offset();

		// This is a special case where we need to modify a offset calculated on start, since the following happened:
		// 1. The position of the helper is absolute, so it's position is calculated based on the next positioned parent
		// 2. The actual offset parent is a child of the scroll parent, and the scroll parent isn't the document, which means that
		//    the scroll is included in the initial calculation of the offset of the parent, and never recalculated upon drag
		if(this.cssPosition == 'absolute' && this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) {
			po.left += this.scrollParent.scrollLeft();
			po.top += this.scrollParent.scrollTop();
		}

		if((this.offsetParent[0] == document.body) //This needs to be actually done for all browsers, since pageX/pageY includes this information
		|| (this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == 'html' && $.browser.msie)) //Ugly IE fix
			po = { top: 0, left: 0 };

		return {
			top: po.top + (parseInt(this.offsetParent.css("borderTopWidth"),10) || 0),
			left: po.left + (parseInt(this.offsetParent.css("borderLeftWidth"),10) || 0)
		};

	},

	_getRelativeOffset: function() {

		if(this.cssPosition == "relative") {
			var p = this.currentItem.position();
			return {
				top: p.top - (parseInt(this.helper.css("top"),10) || 0) + this.scrollParent.scrollTop(),
				left: p.left - (parseInt(this.helper.css("left"),10) || 0) + this.scrollParent.scrollLeft()
			};
		} else {
			return { top: 0, left: 0 };
		}

	},

	_cacheMargins: function() {
		this.margins = {
			left: (parseInt(this.currentItem.css("marginLeft"),10) || 0),
			top: (parseInt(this.currentItem.css("marginTop"),10) || 0)
		};
	},

	_cacheHelperProportions: function() {
		this.helperProportions = {
			width: this.helper.outerWidth(),
			height: this.helper.outerHeight()
		};
	},

	_setContainment: function() {

		var o = this.options;
		if(o.containment == 'parent') o.containment = this.helper[0].parentNode;
		if(o.containment == 'document' || o.containment == 'window') this.containment = [
			0 - this.offset.relative.left - this.offset.parent.left,
			0 - this.offset.relative.top - this.offset.parent.top,
			$(o.containment == 'document' ? document : window).width() - this.helperProportions.width - this.margins.left,
			($(o.containment == 'document' ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top
		];

		if(!(/^(document|window|parent)$/).test(o.containment)) {
			var ce = $(o.containment)[0];
			var co = $(o.containment).offset();
			var over = ($(ce).css("overflow") != 'hidden');

			this.containment = [
				co.left + (parseInt($(ce).css("borderLeftWidth"),10) || 0) + (parseInt($(ce).css("paddingLeft"),10) || 0) - this.margins.left,
				co.top + (parseInt($(ce).css("borderTopWidth"),10) || 0) + (parseInt($(ce).css("paddingTop"),10) || 0) - this.margins.top,
				co.left+(over ? Math.max(ce.scrollWidth,ce.offsetWidth) : ce.offsetWidth) - (parseInt($(ce).css("borderLeftWidth"),10) || 0) - (parseInt($(ce).css("paddingRight"),10) || 0) - this.helperProportions.width - this.margins.left,
				co.top+(over ? Math.max(ce.scrollHeight,ce.offsetHeight) : ce.offsetHeight) - (parseInt($(ce).css("borderTopWidth"),10) || 0) - (parseInt($(ce).css("paddingBottom"),10) || 0) - this.helperProportions.height - this.margins.top
			];
		}

	},

	_convertPositionTo: function(d, pos) {

		if(!pos) pos = this.position;
		var mod = d == "absolute" ? 1 : -1;
		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		return {
			top: (
				pos.top																	// The absolute mouse position
				+ this.offset.relative.top * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.top * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ) * mod)
			),
			left: (
				pos.left																// The absolute mouse position
				+ this.offset.relative.left * mod										// Only for relative positioned nodes: Relative offset from element to offset parent
				+ this.offset.parent.left * mod											// The offsetParent's offset without borders (offset + border)
				- ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ) * mod)
			)
		};

	},

	_generatePosition: function(event) {

		var o = this.options, scroll = this.cssPosition == 'absolute' && !(this.scrollParent[0] != document && $.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent, scrollIsRootNode = (/(html|body)/i).test(scroll[0].tagName);

		// This is another very weird special case that only happens for relative elements:
		// 1. If the css position is relative
		// 2. and the scroll parent is the document or similar to the offset parent
		// we have to refresh the relative offset during the scroll so there are no jumps
		if(this.cssPosition == 'relative' && !(this.scrollParent[0] != document && this.scrollParent[0] != this.offsetParent[0])) {
			this.offset.relative = this._getRelativeOffset();
		}

		var pageX = event.pageX;
		var pageY = event.pageY;

		/*
		 * - Position constraining -
		 * Constrain the position to a mix of grid, containment.
		 */

		if(this.originalPosition) { //If we are not dragging yet, we won't check for options

			if(this.containment) {
				if(event.pageX - this.offset.click.left < this.containment[0]) pageX = this.containment[0] + this.offset.click.left;
				if(event.pageY - this.offset.click.top < this.containment[1]) pageY = this.containment[1] + this.offset.click.top;
				if(event.pageX - this.offset.click.left > this.containment[2]) pageX = this.containment[2] + this.offset.click.left;
				if(event.pageY - this.offset.click.top > this.containment[3]) pageY = this.containment[3] + this.offset.click.top;
			}

			if(o.grid) {
				var top = this.originalPageY + Math.round((pageY - this.originalPageY) / o.grid[1]) * o.grid[1];
				pageY = this.containment ? (!(top - this.offset.click.top < this.containment[1] || top - this.offset.click.top > this.containment[3]) ? top : (!(top - this.offset.click.top < this.containment[1]) ? top - o.grid[1] : top + o.grid[1])) : top;

				var left = this.originalPageX + Math.round((pageX - this.originalPageX) / o.grid[0]) * o.grid[0];
				pageX = this.containment ? (!(left - this.offset.click.left < this.containment[0] || left - this.offset.click.left > this.containment[2]) ? left : (!(left - this.offset.click.left < this.containment[0]) ? left - o.grid[0] : left + o.grid[0])) : left;
			}

		}

		return {
			top: (
				pageY																// The absolute mouse position
				- this.offset.click.top													// Click offset (relative to the element)
				- this.offset.relative.top												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.top												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollTop() : ( scrollIsRootNode ? 0 : scroll.scrollTop() ) ))
			),
			left: (
				pageX																// The absolute mouse position
				- this.offset.click.left												// Click offset (relative to the element)
				- this.offset.relative.left												// Only for relative positioned nodes: Relative offset from element to offset parent
				- this.offset.parent.left												// The offsetParent's offset without borders (offset + border)
				+ ($.browser.safari && this.cssPosition == 'fixed' ? 0 : ( this.cssPosition == 'fixed' ? -this.scrollParent.scrollLeft() : scrollIsRootNode ? 0 : scroll.scrollLeft() ))
			)
		};

	},

	_rearrange: function(event, i, a, hardRefresh) {

		a ? a[0].appendChild(this.placeholder[0]) : i.item[0].parentNode.insertBefore(this.placeholder[0], (this.direction == 'down' ? i.item[0] : i.item[0].nextSibling));

		//Various things done here to improve the performance:
		// 1. we create a setTimeout, that calls refreshPositions
		// 2. on the instance, we have a counter variable, that get's higher after every append
		// 3. on the local scope, we copy the counter variable, and check in the timeout, if it's still the same
		// 4. this lets only the last addition to the timeout stack through
		this.counter = this.counter ? ++this.counter : 1;
		var self = this, counter = this.counter;

		window.setTimeout(function() {
			if(counter == self.counter) self.refreshPositions(!hardRefresh); //Precompute after each DOM insertion, NOT on mousemove
		},0);

	},

	_clear: function(event, noPropagation) {

		this.reverting = false;
		// We delay all events that have to be triggered to after the point where the placeholder has been removed and
		// everything else normalized again
		var delayedTriggers = [], self = this;

		// We first have to update the dom position of the actual currentItem
		// Note: don't do it if the current item is already removed (by a user), or it gets reappended (see #4088)
		if(!this._noFinalSort && this.currentItem.parent().length) this.placeholder.before(this.currentItem);
		this._noFinalSort = null;

		if(this.helper[0] == this.currentItem[0]) {
			for(var i in this._storedCSS) {
				if(this._storedCSS[i] == 'auto' || this._storedCSS[i] == 'static') this._storedCSS[i] = '';
			}
			this.currentItem.css(this._storedCSS).removeClass("ui-sortable-helper");
		} else {
			this.currentItem.show();
		}

		if(this.fromOutside && !noPropagation) delayedTriggers.push(function(event) { this._trigger("receive", event, this._uiHash(this.fromOutside)); });
		if((this.fromOutside || this.domPosition.prev != this.currentItem.prev().not(".ui-sortable-helper")[0] || this.domPosition.parent != this.currentItem.parent()[0]) && !noPropagation) delayedTriggers.push(function(event) { this._trigger("update", event, this._uiHash()); }); //Trigger update callback if the DOM position has changed
		if(!$.ui.contains(this.element[0], this.currentItem[0])) { //Node was moved out of the current element
			if(!noPropagation) delayedTriggers.push(function(event) { this._trigger("remove", event, this._uiHash()); });
			for (var i = this.containers.length - 1; i >= 0; i--){
				if($.ui.contains(this.containers[i].element[0], this.currentItem[0]) && !noPropagation) {
					delayedTriggers.push((function(c) { return function(event) { c._trigger("receive", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
					delayedTriggers.push((function(c) { return function(event) { c._trigger("update", event, this._uiHash(this));  }; }).call(this, this.containers[i]));
				}
			};
		};

		//Post events to containers
		for (var i = this.containers.length - 1; i >= 0; i--){
			if(!noPropagation) delayedTriggers.push((function(c) { return function(event) { c._trigger("deactivate", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
			if(this.containers[i].containerCache.over) {
				delayedTriggers.push((function(c) { return function(event) { c._trigger("out", event, this._uiHash(this)); };  }).call(this, this.containers[i]));
				this.containers[i].containerCache.over = 0;
			}
		}

		//Do what was originally in plugins
		if(this._storedCursor) $('body').css("cursor", this._storedCursor); //Reset cursor
		if(this._storedOpacity) this.helper.css("opacity", this._storedOpacity); //Reset opacity
		if(this._storedZIndex) this.helper.css("zIndex", this._storedZIndex == 'auto' ? '' : this._storedZIndex); //Reset z-index

		this.dragging = false;
		if(this.cancelHelperRemoval) {
			if(!noPropagation) {
				this._trigger("beforeStop", event, this._uiHash());
				for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
				this._trigger("stop", event, this._uiHash());
			}
			return false;
		}

		if(!noPropagation) this._trigger("beforeStop", event, this._uiHash());

		//$(this.placeholder[0]).remove(); would have been the jQuery way - unfortunately, it unbinds ALL events from the original node!
		this.placeholder[0].parentNode.removeChild(this.placeholder[0]);

		if(this.helper[0] != this.currentItem[0]) this.helper.remove(); this.helper = null;

		if(!noPropagation) {
			for (var i=0; i < delayedTriggers.length; i++) { delayedTriggers[i].call(this, event); }; //Trigger all delayed events
			this._trigger("stop", event, this._uiHash());
		}

		this.fromOutside = false;
		return true;

	},

	_trigger: function() {
		if ($.Widget.prototype._trigger.apply(this, arguments) === false) {
			this.cancel();
		}
	},

	_uiHash: function(inst) {
		var self = inst || this;
		return {
			helper: self.helper,
			placeholder: self.placeholder || $([]),
			position: self.position,
			originalPosition: self.originalPosition,
			offset: self.positionAbs,
			item: self.currentItem,
			sender: inst ? inst.element : null
		};
	}

});

$.extend($.ui.sortable, {
	version: "1.8.21"
});

})(jQuery);
/*!
 * jQuery UI Accordion 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Accordion
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget( "ui.accordion", {
	options: {
		active: 0,
		animated: "slide",
		autoHeight: true,
		clearStyle: false,
		collapsible: false,
		event: "click",
		fillSpace: false,
		header: "> li > :first-child,> :not(li):even",
		icons: {
			header: "ui-icon-triangle-1-e",
			headerSelected: "ui-icon-triangle-1-s"
		},
		navigation: false,
		navigationFilter: function() {
			return this.href.toLowerCase() === location.href.toLowerCase();
		}
	},

	_create: function() {
		var self = this,
			options = self.options;

		self.running = 0;

		self.element
			.addClass( "ui-accordion ui-widget ui-helper-reset" )
			// in lack of child-selectors in CSS
			// we need to mark top-LIs in a UL-accordion for some IE-fix
			.children( "li" )
				.addClass( "ui-accordion-li-fix" );

		self.headers = self.element.find( options.header )
			.addClass( "ui-accordion-header ui-helper-reset ui-state-default ui-corner-all" )
			.bind( "mouseenter.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( "ui-state-hover" );
			})
			.bind( "mouseleave.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( "ui-state-hover" );
			})
			.bind( "focus.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( "ui-state-focus" );
			})
			.bind( "blur.accordion", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( "ui-state-focus" );
			});

		self.headers.next()
			.addClass( "ui-accordion-content ui-helper-reset ui-widget-content ui-corner-bottom" );

		if ( options.navigation ) {
			var current = self.element.find( "a" ).filter( options.navigationFilter ).eq( 0 );
			if ( current.length ) {
				var header = current.closest( ".ui-accordion-header" );
				if ( header.length ) {
					// anchor within header
					self.active = header;
				} else {
					// anchor within content
					self.active = current.closest( ".ui-accordion-content" ).prev();
				}
			}
		}

		self.active = self._findActive( self.active || options.active )
			.addClass( "ui-state-default ui-state-active" )
			.toggleClass( "ui-corner-all" )
			.toggleClass( "ui-corner-top" );
		self.active.next().addClass( "ui-accordion-content-active" );

		self._createIcons();
		self.resize();
		
		// ARIA
		self.element.attr( "role", "tablist" );

		self.headers
			.attr( "role", "tab" )
			.bind( "keydown.accordion", function( event ) {
				return self._keydown( event );
			})
			.next()
				.attr( "role", "tabpanel" );

		self.headers
			.not( self.active || "" )
			.attr({
				"aria-expanded": "false",
				"aria-selected": "false",
				tabIndex: -1
			})
			.next()
				.hide();

		// make sure at least one header is in the tab order
		if ( !self.active.length ) {
			self.headers.eq( 0 ).attr( "tabIndex", 0 );
		} else {
			self.active
				.attr({
					"aria-expanded": "true",
					"aria-selected": "true",
					tabIndex: 0
				});
		}

		// only need links in tab order for Safari
		if ( !$.browser.safari ) {
			self.headers.find( "a" ).attr( "tabIndex", -1 );
		}

		if ( options.event ) {
			self.headers.bind( options.event.split(" ").join(".accordion ") + ".accordion", function(event) {
				self._clickHandler.call( self, event, this );
				event.preventDefault();
			});
		}
	},

	_createIcons: function() {
		var options = this.options;
		if ( options.icons ) {
			$( "<span></span>" )
				.addClass( "ui-icon " + options.icons.header )
				.prependTo( this.headers );
			this.active.children( ".ui-icon" )
				.toggleClass(options.icons.header)
				.toggleClass(options.icons.headerSelected);
			this.element.addClass( "ui-accordion-icons" );
		}
	},

	_destroyIcons: function() {
		this.headers.children( ".ui-icon" ).remove();
		this.element.removeClass( "ui-accordion-icons" );
	},

	destroy: function() {
		var options = this.options;

		this.element
			.removeClass( "ui-accordion ui-widget ui-helper-reset" )
			.removeAttr( "role" );

		this.headers
			.unbind( ".accordion" )
			.removeClass( "ui-accordion-header ui-accordion-disabled ui-helper-reset ui-state-default ui-corner-all ui-state-active ui-state-disabled ui-corner-top" )
			.removeAttr( "role" )
			.removeAttr( "aria-expanded" )
			.removeAttr( "aria-selected" )
			.removeAttr( "tabIndex" );

		this.headers.find( "a" ).removeAttr( "tabIndex" );
		this._destroyIcons();
		var contents = this.headers.next()
			.css( "display", "" )
			.removeAttr( "role" )
			.removeClass( "ui-helper-reset ui-widget-content ui-corner-bottom ui-accordion-content ui-accordion-content-active ui-accordion-disabled ui-state-disabled" );
		if ( options.autoHeight || options.fillHeight ) {
			contents.css( "height", "" );
		}

		return $.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
			
		if ( key == "active" ) {
			this.activate( value );
		}
		if ( key == "icons" ) {
			this._destroyIcons();
			if ( value ) {
				this._createIcons();
			}
		}
		// #5332 - opacity doesn't cascade to positioned elements in IE
		// so we need to add the disabled class to the headers and panels
		if ( key == "disabled" ) {
			this.headers.add(this.headers.next())
				[ value ? "addClass" : "removeClass" ](
					"ui-accordion-disabled ui-state-disabled" );
		}
	},

	_keydown: function( event ) {
		if ( this.options.disabled || event.altKey || event.ctrlKey ) {
			return;
		}

		var keyCode = $.ui.keyCode,
			length = this.headers.length,
			currentIndex = this.headers.index( event.target ),
			toFocus = false;

		switch ( event.keyCode ) {
			case keyCode.RIGHT:
			case keyCode.DOWN:
				toFocus = this.headers[ ( currentIndex + 1 ) % length ];
				break;
			case keyCode.LEFT:
			case keyCode.UP:
				toFocus = this.headers[ ( currentIndex - 1 + length ) % length ];
				break;
			case keyCode.SPACE:
			case keyCode.ENTER:
				this._clickHandler( { target: event.target }, event.target );
				event.preventDefault();
		}

		if ( toFocus ) {
			$( event.target ).attr( "tabIndex", -1 );
			$( toFocus ).attr( "tabIndex", 0 );
			toFocus.focus();
			return false;
		}

		return true;
	},

	resize: function() {
		var options = this.options,
			maxHeight;

		if ( options.fillSpace ) {
			if ( $.browser.msie ) {
				var defOverflow = this.element.parent().css( "overflow" );
				this.element.parent().css( "overflow", "hidden");
			}
			maxHeight = this.element.parent().height();
			if ($.browser.msie) {
				this.element.parent().css( "overflow", defOverflow );
			}

			this.headers.each(function() {
				maxHeight -= $( this ).outerHeight( true );
			});

			this.headers.next()
				.each(function() {
					$( this ).height( Math.max( 0, maxHeight -
						$( this ).innerHeight() + $( this ).height() ) );
				})
				.css( "overflow", "auto" );
		} else if ( options.autoHeight ) {
			maxHeight = 0;
			this.headers.next()
				.each(function() {
					maxHeight = Math.max( maxHeight, $( this ).height( "" ).height() );
				})
				.height( maxHeight );
		}

		return this;
	},

	activate: function( index ) {
		// TODO this gets called on init, changing the option without an explicit call for that
		this.options.active = index;
		// call clickHandler with custom event
		var active = this._findActive( index )[ 0 ];
		this._clickHandler( { target: active }, active );

		return this;
	},

	_findActive: function( selector ) {
		return selector
			? typeof selector === "number"
				? this.headers.filter( ":eq(" + selector + ")" )
				: this.headers.not( this.headers.not( selector ) )
			: selector === false
				? $( [] )
				: this.headers.filter( ":eq(0)" );
	},

	// TODO isn't event.target enough? why the separate target argument?
	_clickHandler: function( event, target ) {
		var options = this.options;
		if ( options.disabled ) {
			return;
		}

		// called only when using activate(false) to close all parts programmatically
		if ( !event.target ) {
			if ( !options.collapsible ) {
				return;
			}
			this.active
				.removeClass( "ui-state-active ui-corner-top" )
				.addClass( "ui-state-default ui-corner-all" )
				.children( ".ui-icon" )
					.removeClass( options.icons.headerSelected )
					.addClass( options.icons.header );
			this.active.next().addClass( "ui-accordion-content-active" );
			var toHide = this.active.next(),
				data = {
					options: options,
					newHeader: $( [] ),
					oldHeader: options.active,
					newContent: $( [] ),
					oldContent: toHide
				},
				toShow = ( this.active = $( [] ) );
			this._toggle( toShow, toHide, data );
			return;
		}

		// get the click target
		var clicked = $( event.currentTarget || target ),
			clickedIsActive = clicked[0] === this.active[0];

		// TODO the option is changed, is that correct?
		// TODO if it is correct, shouldn't that happen after determining that the click is valid?
		options.active = options.collapsible && clickedIsActive ?
			false :
			this.headers.index( clicked );

		// if animations are still active, or the active header is the target, ignore click
		if ( this.running || ( !options.collapsible && clickedIsActive ) ) {
			return;
		}

		// find elements to show and hide
		var active = this.active,
			toShow = clicked.next(),
			toHide = this.active.next(),
			data = {
				options: options,
				newHeader: clickedIsActive && options.collapsible ? $([]) : clicked,
				oldHeader: this.active,
				newContent: clickedIsActive && options.collapsible ? $([]) : toShow,
				oldContent: toHide
			},
			down = this.headers.index( this.active[0] ) > this.headers.index( clicked[0] );

		// when the call to ._toggle() comes after the class changes
		// it causes a very odd bug in IE 8 (see #6720)
		this.active = clickedIsActive ? $([]) : clicked;
		this._toggle( toShow, toHide, data, clickedIsActive, down );

		// switch classes
		active
			.removeClass( "ui-state-active ui-corner-top" )
			.addClass( "ui-state-default ui-corner-all" )
			.children( ".ui-icon" )
				.removeClass( options.icons.headerSelected )
				.addClass( options.icons.header );
		if ( !clickedIsActive ) {
			clicked
				.removeClass( "ui-state-default ui-corner-all" )
				.addClass( "ui-state-active ui-corner-top" )
				.children( ".ui-icon" )
					.removeClass( options.icons.header )
					.addClass( options.icons.headerSelected );
			clicked
				.next()
				.addClass( "ui-accordion-content-active" );
		}

		return;
	},

	_toggle: function( toShow, toHide, data, clickedIsActive, down ) {
		var self = this,
			options = self.options;

		self.toShow = toShow;
		self.toHide = toHide;
		self.data = data;

		var complete = function() {
			if ( !self ) {
				return;
			}
			return self._completed.apply( self, arguments );
		};

		// trigger changestart event
		self._trigger( "changestart", null, self.data );

		// count elements to animate
		self.running = toHide.size() === 0 ? toShow.size() : toHide.size();

		if ( options.animated ) {
			var animOptions = {};

			if ( options.collapsible && clickedIsActive ) {
				animOptions = {
					toShow: $( [] ),
					toHide: toHide,
					complete: complete,
					down: down,
					autoHeight: options.autoHeight || options.fillSpace
				};
			} else {
				animOptions = {
					toShow: toShow,
					toHide: toHide,
					complete: complete,
					down: down,
					autoHeight: options.autoHeight || options.fillSpace
				};
			}

			if ( !options.proxied ) {
				options.proxied = options.animated;
			}

			if ( !options.proxiedDuration ) {
				options.proxiedDuration = options.duration;
			}

			options.animated = $.isFunction( options.proxied ) ?
				options.proxied( animOptions ) :
				options.proxied;

			options.duration = $.isFunction( options.proxiedDuration ) ?
				options.proxiedDuration( animOptions ) :
				options.proxiedDuration;

			var animations = $.ui.accordion.animations,
				duration = options.duration,
				easing = options.animated;

			if ( easing && !animations[ easing ] && !$.easing[ easing ] ) {
				easing = "slide";
			}
			if ( !animations[ easing ] ) {
				animations[ easing ] = function( options ) {
					this.slide( options, {
						easing: easing,
						duration: duration || 700
					});
				};
			}

			animations[ easing ]( animOptions );
		} else {
			if ( options.collapsible && clickedIsActive ) {
				toShow.toggle();
			} else {
				toHide.hide();
				toShow.show();
			}

			complete( true );
		}

		// TODO assert that the blur and focus triggers are really necessary, remove otherwise
		toHide.prev()
			.attr({
				"aria-expanded": "false",
				"aria-selected": "false",
				tabIndex: -1
			})
			.blur();
		toShow.prev()
			.attr({
				"aria-expanded": "true",
				"aria-selected": "true",
				tabIndex: 0
			})
			.focus();
	},

	_completed: function( cancel ) {
		this.running = cancel ? 0 : --this.running;
		if ( this.running ) {
			return;
		}

		if ( this.options.clearStyle ) {
			this.toShow.add( this.toHide ).css({
				height: "",
				overflow: ""
			});
		}

		// other classes are removed before the animation; this one needs to stay until completed
		this.toHide.removeClass( "ui-accordion-content-active" );
		// Work around for rendering bug in IE (#5421)
		if ( this.toHide.length ) {
			this.toHide.parent()[0].className = this.toHide.parent()[0].className;
		}

		this._trigger( "change", null, this.data );
	}
});

$.extend( $.ui.accordion, {
	version: "1.8.21",
	animations: {
		slide: function( options, additions ) {
			options = $.extend({
				easing: "swing",
				duration: 300
			}, options, additions );
			if ( !options.toHide.size() ) {
				options.toShow.animate({
					height: "show",
					paddingTop: "show",
					paddingBottom: "show"
				}, options );
				return;
			}
			if ( !options.toShow.size() ) {
				options.toHide.animate({
					height: "hide",
					paddingTop: "hide",
					paddingBottom: "hide"
				}, options );
				return;
			}
			var overflow = options.toShow.css( "overflow" ),
				percentDone = 0,
				showProps = {},
				hideProps = {},
				fxAttrs = [ "height", "paddingTop", "paddingBottom" ],
				originalWidth;
			// fix width before calculating height of hidden element
			var s = options.toShow;
			originalWidth = s[0].style.width;
			s.width( s.parent().width()
				- parseFloat( s.css( "paddingLeft" ) )
				- parseFloat( s.css( "paddingRight" ) )
				- ( parseFloat( s.css( "borderLeftWidth" ) ) || 0 )
				- ( parseFloat( s.css( "borderRightWidth" ) ) || 0 ) );

			$.each( fxAttrs, function( i, prop ) {
				hideProps[ prop ] = "hide";

				var parts = ( "" + $.css( options.toShow[0], prop ) ).match( /^([\d+-.]+)(.*)$/ );
				showProps[ prop ] = {
					value: parts[ 1 ],
					unit: parts[ 2 ] || "px"
				};
			});
			options.toShow.css({ height: 0, overflow: "hidden" }).show();
			options.toHide
				.filter( ":hidden" )
					.each( options.complete )
				.end()
				.filter( ":visible" )
				.animate( hideProps, {
				step: function( now, settings ) {
					// only calculate the percent when animating height
					// IE gets very inconsistent results when animating elements
					// with small values, which is common for padding
					if ( settings.prop == "height" ) {
						percentDone = ( settings.end - settings.start === 0 ) ? 0 :
							( settings.now - settings.start ) / ( settings.end - settings.start );
					}

					options.toShow[ 0 ].style[ settings.prop ] =
						( percentDone * showProps[ settings.prop ].value )
						+ showProps[ settings.prop ].unit;
				},
				duration: options.duration,
				easing: options.easing,
				complete: function() {
					if ( !options.autoHeight ) {
						options.toShow.css( "height", "" );
					}
					options.toShow.css({
						width: originalWidth,
						overflow: overflow
					});
					options.complete();
				}
			});
		},
		bounceslide: function( options ) {
			this.slide( options, {
				easing: options.down ? "easeOutBounce" : "swing",
				duration: options.down ? 1000 : 200
			});
		}
	}
});

})( jQuery );
/*!
 * jQuery UI Autocomplete 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Autocomplete
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *	jquery.ui.position.js
 */
(function( $, undefined ) {

// used to prevent race conditions with remote data sources
var requestIndex = 0;

$.widget( "ui.autocomplete", {
	options: {
		appendTo: "body",
		autoFocus: false,
		delay: 300,
		minLength: 1,
		position: {
			my: "left top",
			at: "left bottom",
			collision: "none"
		},
		source: null
	},

	pending: 0,

	_create: function() {
		var self = this,
			doc = this.element[ 0 ].ownerDocument,
			suppressKeyPress;
		this.isMultiLine = this.element.is( "textarea" );

		this.element
			.addClass( "ui-autocomplete-input" )
			.attr( "autocomplete", "off" )
			// TODO verify these actually work as intended
			.attr({
				role: "textbox",
				"aria-autocomplete": "list",
				"aria-haspopup": "true"
			})
			.bind( "keydown.autocomplete", function( event ) {
				if ( self.options.disabled || self.element.propAttr( "readOnly" ) ) {
					return;
				}

				suppressKeyPress = false;
				var keyCode = $.ui.keyCode;
				switch( event.keyCode ) {
				case keyCode.PAGE_UP:
					self._move( "previousPage", event );
					break;
				case keyCode.PAGE_DOWN:
					self._move( "nextPage", event );
					break;
				case keyCode.UP:
					self._keyEvent( "previous", event );
					break;
				case keyCode.DOWN:
					self._keyEvent( "next", event );
					break;
				case keyCode.ENTER:
				case keyCode.NUMPAD_ENTER:
					// when menu is open and has focus
					if ( self.menu.active ) {
						// #6055 - Opera still allows the keypress to occur
						// which causes forms to submit
						suppressKeyPress = true;
						event.preventDefault();
					}
					//passthrough - ENTER and TAB both select the current element
				case keyCode.TAB:
					if ( !self.menu.active ) {
						return;
					}
					self.menu.select( event );
					break;
				case keyCode.ESCAPE:
					self.element.val( self.term );
					self.close( event );
					break;
				default:
					// keypress is triggered before the input value is changed
					clearTimeout( self.searching );
					self.searching = setTimeout(function() {
						// only search if the value has changed
						if ( self.term != self.element.val() ) {
							self.selectedItem = null;
							self.search( null, event );
						}
					}, self.options.delay );
					break;
				}
			})
			.bind( "keypress.autocomplete", function( event ) {
				if ( suppressKeyPress ) {
					suppressKeyPress = false;
					event.preventDefault();
				}
			})
			.bind( "focus.autocomplete", function() {
				if ( self.options.disabled ) {
					return;
				}

				self.selectedItem = null;
				self.previous = self.element.val();
			})
			.bind( "blur.autocomplete", function( event ) {
				if ( self.options.disabled ) {
					return;
				}

				clearTimeout( self.searching );
				// clicks on the menu (or a button to trigger a search) will cause a blur event
				self.closing = setTimeout(function() {
					self.close( event );
					self._change( event );
				}, 150 );
			});
		this._initSource();
		this.menu = $( "<ul></ul>" )
			.addClass( "ui-autocomplete" )
			.appendTo( $( this.options.appendTo || "body", doc )[0] )
			// prevent the close-on-blur in case of a "slow" click on the menu (long mousedown)
			.mousedown(function( event ) {
				// clicking on the scrollbar causes focus to shift to the body
				// but we can't detect a mouseup or a click immediately afterward
				// so we have to track the next mousedown and close the menu if
				// the user clicks somewhere outside of the autocomplete
				var menuElement = self.menu.element[ 0 ];
				if ( !$( event.target ).closest( ".ui-menu-item" ).length ) {
					setTimeout(function() {
						$( document ).one( 'mousedown', function( event ) {
							if ( event.target !== self.element[ 0 ] &&
								event.target !== menuElement &&
								!$.ui.contains( menuElement, event.target ) ) {
								self.close();
							}
						});
					}, 1 );
				}

				// use another timeout to make sure the blur-event-handler on the input was already triggered
				setTimeout(function() {
					clearTimeout( self.closing );
				}, 13);
			})
			.menu({
				focus: function( event, ui ) {
					var item = ui.item.data( "item.autocomplete" );
					if ( false !== self._trigger( "focus", event, { item: item } ) ) {
						// use value to match what will end up in the input, if it was a key event
						if ( /^key/.test(event.originalEvent.type) ) {
							self.element.val( decodeHtmlString(item.value) );
						}
					}
				},
				selected: function( event, ui ) {
					var item = ui.item.data( "item.autocomplete" ),
						previous = self.previous;

					// only trigger when focus was lost (click on menu)
					if ( self.element[0] !== doc.activeElement ) {
						self.element.focus();
						self.previous = previous;
						// #6109 - IE triggers two focus events and the second
						// is asynchronous, so we need to reset the previous
						// term synchronously and asynchronously :-(
						setTimeout(function() {
							self.previous = previous;
							self.selectedItem = item;
						}, 1);
					}

					if ( false !== self._trigger( "select", event, { item: item } ) ) {
						self.element.val( decodeHtmlString(item.value) );
					}
					// reset the term after the select event
					// this allows custom select handling to work properly
					self.term = self.element.val();

					self.close( event );
					self.selectedItem = item;
				},
				blur: function( event, ui ) {
					// don't set the value of the text field if it's already correct
					// this prevents moving the cursor unnecessarily
					if ( self.menu.element.is(":visible") &&
						( self.element.val() !== self.term ) ) {
						self.element.val( self.term );
					}
				}
			})
			.zIndex( this.element.zIndex() + 1 )
			// workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
			.css({ top: 0, left: 0 })
			.hide()
			.data( "menu" );
		if ( $.fn.bgiframe ) {
			 this.menu.element.bgiframe();
		}
		// turning off autocomplete prevents the browser from remembering the
		// value when navigating through history, so we re-enable autocomplete
		// if the page is unloaded before the widget is destroyed. #7790
		self.beforeunloadHandler = function() {
			self.element.removeAttr( "autocomplete" );
		};
		$( window ).bind( "beforeunload", self.beforeunloadHandler );

        var decodeDiv = $('<div>');
        var decodeHtmlString = function (str){
            return decodeDiv.html(str).text();
        };
	},

	destroy: function() {
		this.element
			.removeClass( "ui-autocomplete-input" )
			.removeAttr( "autocomplete" )
			.removeAttr( "role" )
			.removeAttr( "aria-autocomplete" )
			.removeAttr( "aria-haspopup" );
		this.menu.element.remove();
		$( window ).unbind( "beforeunload", this.beforeunloadHandler );
		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === "source" ) {
			this._initSource();
		}
		if ( key === "appendTo" ) {
			this.menu.element.appendTo( $( value || "body", this.element[0].ownerDocument )[0] )
		}
		if ( key === "disabled" && value && this.xhr ) {
			this.xhr.abort();
		}
	},

	_initSource: function() {
		var self = this,
			array,
			url;
		if ( $.isArray(this.options.source) ) {
			array = this.options.source;
			this.source = function( request, response ) {
				response( $.ui.autocomplete.filter(array, request.term) );
			};
		} else if ( typeof this.options.source === "string" ) {
			url = this.options.source;
			this.source = function( request, response ) {
				if ( self.xhr ) {
					self.xhr.abort();
				}
				self.xhr = $.ajax({
					url: url,
					data: request,
					dataType: "json",
					success: function( data, status ) {
						response( data );
					},
					error: function() {
						response( [] );
					}
				});
			};
		} else {
			this.source = this.options.source;
		}
	},

	search: function( value, event ) {
		value = value != null ? value : this.element.val();

		// always save the actual value, not the one passed as an argument
		this.term = this.element.val();

		if ( value.length < this.options.minLength ) {
			return this.close( event );
		}

		clearTimeout( this.closing );
		if ( this._trigger( "search", event ) === false ) {
			return;
		}

		return this._search( value );
	},

	_search: function( value ) {
		this.pending++;
		this.element.addClass( "ui-autocomplete-loading" );

		this.source( { term: value }, this._response() );
	},

	_response: function() {
		var that = this,
			index = ++requestIndex;

		return function( content ) {
			if ( index === requestIndex ) {
				that.__response( content );
			}

			that.pending--;
			if ( !that.pending ) {
				that.element.removeClass( "ui-autocomplete-loading" );
			}
		};
	},

	__response: function( content ) {
		if ( !this.options.disabled && content && content.length ) {
			content = this._normalize( content );
			this._suggest( content );
			this._trigger( "open" );
		} else {
			this.close();
		}
	},

	close: function( event ) {
		clearTimeout( this.closing );
		if ( this.menu.element.is(":visible") ) {
			this.menu.element.hide();
			this.menu.deactivate();
			this._trigger( "close", event );
		}
	},
	
	_change: function( event ) {
		if ( this.previous !== this.element.val() ) {
			this._trigger( "change", event, { item: this.selectedItem } );
		}
	},

	_normalize: function( items ) {
		// assume all items have the right format when the first item is complete
		if ( items.length && items[0].label && items[0].value ) {
			return items;
		}
		return $.map( items, function(item) {
			if ( typeof item === "string" ) {
				return {
					label: item,
					value: item
				};
			}
			return $.extend({
				label: item.label || item.value,
				value: item.value || item.label
			}, item );
		});
	},

	_suggest: function( items ) {
		var ul = this.menu.element
			.empty()
			.zIndex( this.element.zIndex() + 1 );
		this._renderMenu( ul, items );
		// TODO refresh should check if the active item is still in the dom, removing the need for a manual deactivate
		this.menu.deactivate();
		this.menu.refresh();

		// size and position menu
		ul.show();
		this._resizeMenu();
		ul.position( $.extend({
			of: this.element
		}, this.options.position ));

		if ( this.options.autoFocus ) {
			this.menu.next( new $.Event("mouseover") );
		}
	},

	_resizeMenu: function() {
		var ul = this.menu.element;
		ul.outerWidth( Math.max(
			// Firefox wraps long text (possibly a rounding bug)
			// so we add 1px to avoid the wrapping (#7513)
			ul.width( "" ).outerWidth() + 1,
			this.element.outerWidth()
		) );
	},

	_renderMenu: function( ul, items ) {
		var self = this;
		$.each( items, function( index, item ) {
			self._renderItem( ul, item );
		});
	},

	_renderItem: function( ul, item) {
        //KK custom
		return $( "<li></li>" )
			.data( "item.autocomplete", item )
			.append( $( "<a></a>" ).html( item.label ) )
			.appendTo( ul );
	},

	_move: function( direction, event ) {
		if ( !this.menu.element.is(":visible") ) {
			this.search( null, event );
			return;
		}
		if ( this.menu.first() && /^previous/.test(direction) ||
				this.menu.last() && /^next/.test(direction) ) {
			this.element.val( this.term );
			this.menu.deactivate();
			return;
		}
		this.menu[ direction ]( event );
	},

	widget: function() {
		return this.menu.element;
	},
	_keyEvent: function( keyEvent, event ) {
		if ( !this.isMultiLine || this.menu.element.is( ":visible" ) ) {
			this._move( keyEvent, event );

			// prevents moving cursor to beginning/end of the text field in some browsers
			event.preventDefault();
		}
	}
});

$.extend( $.ui.autocomplete, {
	escapeRegex: function( value ) {
		return value.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
	},
	filter: function(array, term) {
		var matcher = new RegExp( $.ui.autocomplete.escapeRegex(term), "i" );
		return $.grep( array, function(value) {
			return matcher.test( value.label || value.value || value );
		});
	}
});

}( jQuery ));

/*
 * jQuery UI Menu (not officially released)
 * 
 * This widget isn't yet finished and the API is subject to change. We plan to finish
 * it for the next release. You're welcome to give it a try anyway and give us feedback,
 * as long as you're okay with migrating your code later on. We can help with that, too.
 *
 * Copyright 2010, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Menu
 *
 * Depends:
 *	jquery.ui.core.js
 *  jquery.ui.widget.js
 */
(function($) {

$.widget("ui.menu", {
	_create: function() {
		var self = this;
		this.element
			.addClass("ui-menu ui-widget ui-widget-content ui-corner-all")
			.attr({
				role: "listbox",
				"aria-activedescendant": "ui-active-menuitem"
			})
			.click(function( event ) {
				if ( !$( event.target ).closest( ".ui-menu-item a" ).length ) {
					return;
				}
				// temporary
				event.preventDefault();
				self.select( event );
			});
		this.refresh();
	},
	
	refresh: function() {
		var self = this;

		// don't refresh list items that are already adapted
		var items = this.element.children("li:not(.ui-menu-item):has(a)")
			.addClass("ui-menu-item")
			.attr("role", "menuitem");
		
		items.children("a")
			.addClass("ui-corner-all")
			.attr("tabindex", -1)
			// mouseenter doesn't work with event delegation
			.mouseenter(function( event ) {
				self.activate( event, $(this).parent() );
			})
			.mouseleave(function() {
				self.deactivate();
			});
	},

	activate: function( event, item ) {
		this.deactivate();
		if (this.hasScroll()) {
			var offset = item.offset().top - this.element.offset().top,
				scroll = this.element.scrollTop(),
				elementHeight = this.element.height();
			if (offset < 0) {
				this.element.scrollTop( scroll + offset);
			} else if (offset >= elementHeight) {
				this.element.scrollTop( scroll + offset - elementHeight + item.height());
			}
		}
		this.active = item.eq(0)
			.children("a")
				.addClass("ui-state-hover")
				.attr("id", "ui-active-menuitem")
			.end();
		this._trigger("focus", event, { item: item });
	},

	deactivate: function() {
		if (!this.active) { return; }

		this.active.children("a")
			.removeClass("ui-state-hover")
			.removeAttr("id");
		this._trigger("blur");
		this.active = null;
	},

	next: function(event) {
		this.move("next", ".ui-menu-item:first", event);
	},

	previous: function(event) {
		this.move("prev", ".ui-menu-item:last", event);
	},

	first: function() {
		return this.active && !this.active.prevAll(".ui-menu-item").length;
	},

	last: function() {
		return this.active && !this.active.nextAll(".ui-menu-item").length;
	},

	move: function(direction, edge, event) {
		if (!this.active) {
			this.activate(event, this.element.children(edge));
			return;
		}
		var next = this.active[direction + "All"](".ui-menu-item").eq(0);
		if (next.length) {
			this.activate(event, next);
		} else {
			this.activate(event, this.element.children(edge));
		}
	},

	// TODO merge with previousPage
	nextPage: function(event) {
		if (this.hasScroll()) {
			// TODO merge with no-scroll-else
			if (!this.active || this.last()) {
				this.activate(event, this.element.children(".ui-menu-item:first"));
				return;
			}
			var base = this.active.offset().top,
				height = this.element.height(),
				result = this.element.children(".ui-menu-item").filter(function() {
					var close = $(this).offset().top - base - height + $(this).height();
					// TODO improve approximation
					return close < 10 && close > -10;
				});

			// TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(".ui-menu-item:last");
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(".ui-menu-item")
				.filter(!this.active || this.last() ? ":first" : ":last"));
		}
	},

	// TODO merge with nextPage
	previousPage: function(event) {
		if (this.hasScroll()) {
			// TODO merge with no-scroll-else
			if (!this.active || this.first()) {
				this.activate(event, this.element.children(".ui-menu-item:last"));
				return;
			}

			var base = this.active.offset().top,
				height = this.element.height(),
				result = this.element.children(".ui-menu-item").filter(function() {
					var close = $(this).offset().top - base + height - $(this).height();
					// TODO improve approximation
					return close < 10 && close > -10;
				});

			// TODO try to catch this earlier when scrollTop indicates the last page anyway
			if (!result.length) {
				result = this.element.children(".ui-menu-item:first");
			}
			this.activate(event, result);
		} else {
			this.activate(event, this.element.children(".ui-menu-item")
				.filter(!this.active || this.first() ? ":last" : ":first"));
		}
	},

	hasScroll: function() {
		return this.element.height() < this.element[ $.fn.prop ? "prop" : "attr" ]("scrollHeight");
	},

	select: function( event ) {
		this._trigger("selected", event, { item: this.active });
	}
});

}(jQuery));
/*!
 * jQuery UI Button 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Button
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var lastActive, startXPos, startYPos, clickDragged,
	baseClasses = "ui-button ui-widget ui-state-default ui-corner-all",
	stateClasses = "ui-state-hover ui-state-active ",
	typeClasses = "ui-button-icons-only ui-button-icon-only ui-button-text-icons ui-button-text-icon-primary ui-button-text-icon-secondary ui-button-text-only",
	formResetHandler = function() {
		var buttons = $( this ).find( ":ui-button" );
		setTimeout(function() {
			buttons.button( "refresh" );
		}, 1 );
	},
	radioGroup = function( radio ) {
		var name = radio.name,
			form = radio.form,
			radios = $( [] );
		if ( name ) {
			if ( form ) {
				radios = $( form ).find( "[name='" + name + "']" );
			} else {
				radios = $( "[name='" + name + "']", radio.ownerDocument )
					.filter(function() {
						return !this.form;
					});
			}
		}
		return radios;
	};

$.widget( "ui.button", {
	options: {
		disabled: null,
		text: true,
		label: null,
		icons: {
			primary: null,
			secondary: null
		}
	},
	_create: function() {
		this.element.closest( "form" )
			.unbind( "reset.button" )
			.bind( "reset.button", formResetHandler );

		if ( typeof this.options.disabled !== "boolean" ) {
			this.options.disabled = !!this.element.propAttr( "disabled" );
		} else {
			this.element.propAttr( "disabled", this.options.disabled );
		}

		this._determineButtonType();
		this.hasTitle = !!this.buttonElement.attr( "title" );

		var self = this,
			options = this.options,
			toggleButton = this.type === "checkbox" || this.type === "radio",
			hoverClass = "ui-state-hover" + ( !toggleButton ? " ui-state-active" : "" ),
			focusClass = "ui-state-focus";

		if ( options.label === null ) {
			options.label = this.buttonElement.html();
		}

		this.buttonElement
			.addClass( baseClasses )
			.attr( "role", "button" )
			.bind( "mouseenter.button", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).addClass( "ui-state-hover" );
				if ( this === lastActive ) {
					$( this ).addClass( "ui-state-active" );
				}
			})
			.bind( "mouseleave.button", function() {
				if ( options.disabled ) {
					return;
				}
				$( this ).removeClass( hoverClass );
			})
			.bind( "click.button", function( event ) {
				if ( options.disabled ) {
					event.preventDefault();
					event.stopImmediatePropagation();
				}
			});

		this.element
			.bind( "focus.button", function() {
				// no need to check disabled, focus won't be triggered anyway
				self.buttonElement.addClass( focusClass );
			})
			.bind( "blur.button", function() {
				self.buttonElement.removeClass( focusClass );
			});

		if ( toggleButton ) {
			this.element.bind( "change.button", function() {
				if ( clickDragged ) {
					return;
				}
				self.refresh();
			});
			// if mouse moves between mousedown and mouseup (drag) set clickDragged flag
			// prevents issue where button state changes but checkbox/radio checked state
			// does not in Firefox (see ticket #6970)
			this.buttonElement
				.bind( "mousedown.button", function( event ) {
					if ( options.disabled ) {
						return;
					}
					clickDragged = false;
					startXPos = event.pageX;
					startYPos = event.pageY;
				})
				.bind( "mouseup.button", function( event ) {
					if ( options.disabled ) {
						return;
					}
					if ( startXPos !== event.pageX || startYPos !== event.pageY ) {
						clickDragged = true;
					}
			});
		}

		if ( this.type === "checkbox" ) {
			this.buttonElement.bind( "click.button", function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).toggleClass( "ui-state-active" );
				self.buttonElement.attr( "aria-pressed", self.element[0].checked );
			});
		} else if ( this.type === "radio" ) {
			this.buttonElement.bind( "click.button", function() {
				if ( options.disabled || clickDragged ) {
					return false;
				}
				$( this ).addClass( "ui-state-active" );
				self.buttonElement.attr( "aria-pressed", "true" );

				var radio = self.element[ 0 ];
				radioGroup( radio )
					.not( radio )
					.map(function() {
						return $( this ).button( "widget" )[ 0 ];
					})
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			});
		} else {
			this.buttonElement
				.bind( "mousedown.button", function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).addClass( "ui-state-active" );
					lastActive = this;
					$( document ).one( "mouseup", function() {
						lastActive = null;
					});
				})
				.bind( "mouseup.button", function() {
					if ( options.disabled ) {
						return false;
					}
					$( this ).removeClass( "ui-state-active" );
				})
				.bind( "keydown.button", function(event) {
					if ( options.disabled ) {
						return false;
					}
					if ( event.keyCode == $.ui.keyCode.SPACE || event.keyCode == $.ui.keyCode.ENTER ) {
						$( this ).addClass( "ui-state-active" );
					}
				})
				.bind( "keyup.button", function() {
					$( this ).removeClass( "ui-state-active" );
				});

			if ( this.buttonElement.is("a") ) {
				this.buttonElement.keyup(function(event) {
					if ( event.keyCode === $.ui.keyCode.SPACE ) {
						// TODO pass through original event correctly (just as 2nd argument doesn't work)
						$( this ).click();
					}
				});
			}
		}

		// TODO: pull out $.Widget's handling for the disabled option into
		// $.Widget.prototype._setOptionDisabled so it's easy to proxy and can
		// be overridden by individual plugins
		this._setOption( "disabled", options.disabled );
		this._resetButton();
	},

	_determineButtonType: function() {

		if ( this.element.is(":checkbox") ) {
			this.type = "checkbox";
		} else if ( this.element.is(":radio") ) {
			this.type = "radio";
		} else if ( this.element.is("input") ) {
			this.type = "input";
		} else {
			this.type = "button";
		}

		if ( this.type === "checkbox" || this.type === "radio" ) {
			// we don't search against the document in case the element
			// is disconnected from the DOM
			var ancestor = this.element.parents().filter(":last"),
				labelSelector = "label[for='" + this.element.attr("id") + "']";
			this.buttonElement = ancestor.find( labelSelector );
			if ( !this.buttonElement.length ) {
				ancestor = ancestor.length ? ancestor.siblings() : this.element.siblings();
				this.buttonElement = ancestor.filter( labelSelector );
				if ( !this.buttonElement.length ) {
					this.buttonElement = ancestor.find( labelSelector );
				}
			}
			this.element.addClass( "ui-helper-hidden-accessible" );

			var checked = this.element.is( ":checked" );
			if ( checked ) {
				this.buttonElement.addClass( "ui-state-active" );
			}
			this.buttonElement.attr( "aria-pressed", checked );
		} else {
			this.buttonElement = this.element;
		}
	},

	widget: function() {
		return this.buttonElement;
	},

	destroy: function() {
		this.element
			.removeClass( "ui-helper-hidden-accessible" );
		this.buttonElement
			.removeClass( baseClasses + " " + stateClasses + " " + typeClasses )
			.removeAttr( "role" )
			.removeAttr( "aria-pressed" )
			.html( this.buttonElement.find(".ui-button-text").html() );

		if ( !this.hasTitle ) {
			this.buttonElement.removeAttr( "title" );
		}

		$.Widget.prototype.destroy.call( this );
	},

	_setOption: function( key, value ) {
		$.Widget.prototype._setOption.apply( this, arguments );
		if ( key === "disabled" ) {
			if ( value ) {
				this.element.propAttr( "disabled", true );
			} else {
				this.element.propAttr( "disabled", false );
			}
			return;
		}
		this._resetButton();
	},

	refresh: function() {
		var isDisabled = this.element.is( ":disabled" );
		if ( isDisabled !== this.options.disabled ) {
			this._setOption( "disabled", isDisabled );
		}
		if ( this.type === "radio" ) {
			radioGroup( this.element[0] ).each(function() {
				if ( $( this ).is( ":checked" ) ) {
					$( this ).button( "widget" )
						.addClass( "ui-state-active" )
						.attr( "aria-pressed", "true" );
				} else {
					$( this ).button( "widget" )
						.removeClass( "ui-state-active" )
						.attr( "aria-pressed", "false" );
				}
			});
		} else if ( this.type === "checkbox" ) {
			if ( this.element.is( ":checked" ) ) {
				this.buttonElement
					.addClass( "ui-state-active" )
					.attr( "aria-pressed", "true" );
			} else {
				this.buttonElement
					.removeClass( "ui-state-active" )
					.attr( "aria-pressed", "false" );
			}
		}
	},

	_resetButton: function() {
		if ( this.type === "input" ) {
			if ( this.options.label ) {
				this.element.val( this.options.label );
			}
			return;
		}
		var buttonElement = this.buttonElement.removeClass( typeClasses ),
			buttonText = $( "<span></span>", this.element[0].ownerDocument )
				.addClass( "ui-button-text" )
				.html( this.options.label )
				.appendTo( buttonElement.empty() )
				.text(),
			icons = this.options.icons,
			multipleIcons = icons.primary && icons.secondary,
			buttonClasses = [];  

		if ( icons.primary || icons.secondary ) {
			if ( this.options.text ) {
				buttonClasses.push( "ui-button-text-icon" + ( multipleIcons ? "s" : ( icons.primary ? "-primary" : "-secondary" ) ) );
			}

			if ( icons.primary ) {
				buttonElement.prepend( "<span class='ui-button-icon-primary ui-icon " + icons.primary + "'></span>" );
			}

			if ( icons.secondary ) {
				buttonElement.append( "<span class='ui-button-icon-secondary ui-icon " + icons.secondary + "'></span>" );
			}

			if ( !this.options.text ) {
				buttonClasses.push( multipleIcons ? "ui-button-icons-only" : "ui-button-icon-only" );

				if ( !this.hasTitle ) {
					buttonElement.attr( "title", buttonText );
				}
			}
		} else {
			buttonClasses.push( "ui-button-text-only" );
		}
		buttonElement.addClass( buttonClasses.join( " " ) );
	}
});

$.widget( "ui.buttonset", {
	options: {
		items: ":button, :submit, :reset, :checkbox, :radio, a, :data(button)"
	},

	_create: function() {
		this.element.addClass( "ui-buttonset" );
	},
	
	_init: function() {
		this.refresh();
	},

	_setOption: function( key, value ) {
		if ( key === "disabled" ) {
			this.buttons.button( "option", key, value );
		}

		$.Widget.prototype._setOption.apply( this, arguments );
	},
	
	refresh: function() {
		var rtl = this.element.css( "direction" ) === "rtl";
		
		this.buttons = this.element.find( this.options.items )
			.filter( ":ui-button" )
				.button( "refresh" )
			.end()
			.not( ":ui-button" )
				.button()
			.end()
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-all ui-corner-left ui-corner-right" )
				.filter( ":first" )
					.addClass( rtl ? "ui-corner-right" : "ui-corner-left" )
				.end()
				.filter( ":last" )
					.addClass( rtl ? "ui-corner-left" : "ui-corner-right" )
				.end()
			.end();
	},

	destroy: function() {
		this.element.removeClass( "ui-buttonset" );
		this.buttons
			.map(function() {
				return $( this ).button( "widget" )[ 0 ];
			})
				.removeClass( "ui-corner-left ui-corner-right" )
			.end()
			.button( "destroy" );

		$.Widget.prototype.destroy.call( this );
	}
});

}( jQuery ) );
/*!
 * jQuery UI Dialog 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Dialog
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 *  jquery.ui.button.js
 *	jquery.ui.draggable.js
 *	jquery.ui.mouse.js
 *	jquery.ui.position.js
 *	jquery.ui.resizable.js
 */
(function( $, undefined ) {

var uiDialogClasses =
		'ui-dialog ' +
		'ui-widget ' +
		'ui-widget-content ' +
		'ui-corner-all ',
	sizeRelatedOptions = {
		buttons: true,
		height: true,
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true,
		width: true
	},
	resizableRelatedOptions = {
		maxHeight: true,
		maxWidth: true,
		minHeight: true,
		minWidth: true
	},
	// support for jQuery 1.3.2 - handle common attrFn methods for dialog
	attrFn = $.attrFn || {
		val: true,
		css: true,
		html: true,
		text: true,
		data: true,
		width: true,
		height: true,
		offset: true,
		click: true
	};

$.widget("ui.dialog", {
	options: {
		autoOpen: true,
		buttons: {},
		closeOnEscape: true,
		closeText: 'close',
		dialogClass: '',
		draggable: true,
		hide: null,
		height: 'auto',
		maxHeight: false,
		maxWidth: false,
		minHeight: 150,
		minWidth: 150,
		modal: false,
		position: {
			my: 'center',
			at: 'center',
			collision: 'fit',
			// ensure that the titlebar is never outside the document
			using: function(pos) {
				var topOffset = $(this).css(pos).offset().top;
				if (topOffset < 0) {
					$(this).css('top', pos.top - topOffset);
				}
			}
		},
		resizable: true,
		show: null,
		stack: true,
		title: '',
		width: 300,
		zIndex: 1000
	},

	_create: function() {
		this.originalTitle = this.element.attr('title');
		// #5742 - .attr() might return a DOMElement
		if ( typeof this.originalTitle !== "string" ) {
			this.originalTitle = "";
		}

		this.options.title = this.options.title || this.originalTitle;
		var self = this,
			options = self.options,

			title = options.title || '&#160;',
			titleId = $.ui.dialog.getTitleId(self.element),

			uiDialog = (self.uiDialog = $('<div></div>'))
				.appendTo(document.body)
				.hide()
				.addClass(uiDialogClasses + options.dialogClass)
				.css({
					zIndex: options.zIndex
				})
				// setting tabIndex makes the div focusable
				// setting outline to 0 prevents a border on focus in Mozilla
				.attr('tabIndex', -1).css('outline', 0).keydown(function(event) {
					if (options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
						event.keyCode === $.ui.keyCode.ESCAPE) {
						
						self.close(event);
						event.preventDefault();
					}
				})
				.attr({
					role: 'dialog',
					'aria-labelledby': titleId
				})
				.mousedown(function(event) {
					self.moveToTop(false, event);
				}),

			uiDialogContent = self.element
				.show()
				.removeAttr('title')
				.addClass(
					'ui-dialog-content ' +
					'ui-widget-content')
				.appendTo(uiDialog),

			uiDialogTitlebar = (self.uiDialogTitlebar = $('<div></div>'))
				.addClass(
					'ui-dialog-titlebar ' +
					'ui-widget-header ' +
					'ui-corner-all ' +
					'ui-helper-clearfix'
				)
				.prependTo(uiDialog),

			uiDialogTitlebarClose = $('<a href="#"></a>')
				.addClass(
					'ui-dialog-titlebar-close ' +
					'ui-corner-all'
				)
				.attr('role', 'button')
				.hover(
					function() {
						uiDialogTitlebarClose.addClass('ui-state-hover');
					},
					function() {
						uiDialogTitlebarClose.removeClass('ui-state-hover');
					}
				)
				.focus(function() {
					uiDialogTitlebarClose.addClass('ui-state-focus');
				})
				.blur(function() {
					uiDialogTitlebarClose.removeClass('ui-state-focus');
				})
				.click(function(event) {
					self.close(event);
					return false;
				})
				.appendTo(uiDialogTitlebar),

			uiDialogTitlebarCloseText = (self.uiDialogTitlebarCloseText = $('<span></span>'))
				.addClass(
					'ui-icon ' +
					'ui-icon-closethick'
				)
				.text(options.closeText)
				.appendTo(uiDialogTitlebarClose),

			uiDialogTitle = $('<span></span>')
				.addClass('ui-dialog-title')
				.attr('id', titleId)
				.html(title)
				.prependTo(uiDialogTitlebar);

		//handling of deprecated beforeclose (vs beforeClose) option
		//Ticket #4669 http://dev.jqueryui.com/ticket/4669
		//TODO: remove in 1.9pre
		if ($.isFunction(options.beforeclose) && !$.isFunction(options.beforeClose)) {
			options.beforeClose = options.beforeclose;
		}

		uiDialogTitlebar.find("*").add(uiDialogTitlebar).disableSelection();

		if (options.draggable && $.fn.draggable) {
			self._makeDraggable();
		}
		if (options.resizable && $.fn.resizable) {
			self._makeResizable();
		}

		self._createButtons(options.buttons);
		self._isOpen = false;

		if ($.fn.bgiframe) {
			uiDialog.bgiframe();
		}
	},

	_init: function() {
		if ( this.options.autoOpen ) {
			this.open();
		}
	},

	destroy: function() {
		var self = this;
		
		if (self.overlay) {
			self.overlay.destroy();
		}
		self.uiDialog.hide();
		self.element
			.unbind('.dialog')
			.removeData('dialog')
			.removeClass('ui-dialog-content ui-widget-content')
			.hide().appendTo('body');
		self.uiDialog.remove();

		if (self.originalTitle) {
			self.element.attr('title', self.originalTitle);
		}

		return self;
	},

	widget: function() {
		return this.uiDialog;
	},

	close: function(event) {
		var self = this,
			maxZ, thisZ;
		
		if (false === self._trigger('beforeClose', event)) {
			return;
		}

		if (self.overlay) {
			self.overlay.destroy();
		}
		self.uiDialog.unbind('keypress.ui-dialog');

		self._isOpen = false;

		if (self.options.hide) {
			self.uiDialog.hide(self.options.hide, function() {
				self._trigger('close', event);
			});
		} else {
			self.uiDialog.hide();
			self._trigger('close', event);
		}

		$.ui.dialog.overlay.resize();

		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		if (self.options.modal) {
			maxZ = 0;
			$('.ui-dialog').each(function() {
				if (this !== self.uiDialog[0]) {
					thisZ = $(this).css('z-index');
					if(!isNaN(thisZ)) {
						maxZ = Math.max(maxZ, thisZ);
					}
				}
			});
			$.ui.dialog.maxZ = maxZ;
		}

		return self;
	},

	isOpen: function() {
		return this._isOpen;
	},

	// the force parameter allows us to move modal dialogs to their correct
	// position on open
	moveToTop: function(force, event) {
		var self = this,
			options = self.options,
			saveScroll;

		if ((options.modal && !force) ||
			(!options.stack && !options.modal)) {
			return self._trigger('focus', event);
		}

		if (options.zIndex > $.ui.dialog.maxZ) {
			$.ui.dialog.maxZ = options.zIndex;
		}
		if (self.overlay) {
			$.ui.dialog.maxZ += 1;
			self.overlay.$el.css('z-index', $.ui.dialog.overlay.maxZ = $.ui.dialog.maxZ);
		}

		//Save and then restore scroll since Opera 9.5+ resets when parent z-Index is changed.
		//  http://ui.jquery.com/bugs/ticket/3193
		saveScroll = { scrollTop: self.element.scrollTop(), scrollLeft: self.element.scrollLeft() };
		$.ui.dialog.maxZ += 1;
		self.uiDialog.css('z-index', $.ui.dialog.maxZ);
		self.element.attr(saveScroll);
		self._trigger('focus', event);

		return self;
	},

	open: function() {
		if (this._isOpen) { return; }

		var self = this,
			options = self.options,
			uiDialog = self.uiDialog;

		self.overlay = options.modal ? new $.ui.dialog.overlay(self) : null;
		self._size();
		self._position(options.position);
		uiDialog.show(options.show);
		self.moveToTop(true);

		// prevent tabbing out of modal dialogs
		if ( options.modal ) {
			uiDialog.bind( "keydown.ui-dialog", function( event ) {
				if ( event.keyCode !== $.ui.keyCode.TAB ) {
					return;
				}

				var tabbables = $(':tabbable', this),
					first = tabbables.filter(':first'),
					last  = tabbables.filter(':last');

				if (event.target === last[0] && !event.shiftKey) {
					first.focus(1);
					return false;
				} else if (event.target === first[0] && event.shiftKey) {
					last.focus(1);
					return false;
				}
			});
		}

		// set focus to the first tabbable element in the content area or the first button
		// if there are no tabbable elements, set focus on the dialog itself
		$(self.element.find(':tabbable').get().concat(
			uiDialog.find('.ui-dialog-buttonpane :tabbable').get().concat(
				uiDialog.get()))).eq(0).focus();

		self._isOpen = true;
		self._trigger('open');

		return self;
	},

	_createButtons: function(buttons) {
		var self = this,
			hasButtons = false,
			uiDialogButtonPane = $('<div></div>')
				.addClass(
					'ui-dialog-buttonpane ' +
					'ui-widget-content ' +
					'ui-helper-clearfix'
				),
			uiButtonSet = $( "<div></div>" )
				.addClass( "ui-dialog-buttonset" )
				.appendTo( uiDialogButtonPane );

		// if we already have a button pane, remove it
		self.uiDialog.find('.ui-dialog-buttonpane').remove();

		if (typeof buttons === 'object' && buttons !== null) {
			$.each(buttons, function() {
				return !(hasButtons = true);
			});
		}
		if (hasButtons) {
			$.each(buttons, function(name, props) {
				props = $.isFunction( props ) ?
					{ click: props, text: name } :
					props;
				var button = $('<button type="button"></button>')
					.click(function() {
						props.click.apply(self.element[0], arguments);
					})
					.appendTo(uiButtonSet);
				// can't use .attr( props, true ) with jQuery 1.3.2.
				$.each( props, function( key, value ) {
					if ( key === "click" ) {
						return;
					}
					if ( key in attrFn ) {
						button[ key ]( value );
					} else {
						button.attr( key, value );
					}
				});
				if ($.fn.button) {
					button.button();
				}
			});
			uiDialogButtonPane.appendTo(self.uiDialog);
		}
	},

	_makeDraggable: function() {
		var self = this,
			options = self.options,
			doc = $(document),
			heightBeforeDrag;

		function filteredUi(ui) {
			return {
				position: ui.position,
				offset: ui.offset
			};
		}

		self.uiDialog.draggable({
			cancel: '.ui-dialog-content, .ui-dialog-titlebar-close',
			handle: '.ui-dialog-titlebar',
			containment: 'document',
			start: function(event, ui) {
				heightBeforeDrag = options.height === "auto" ? "auto" : $(this).height();
				$(this).height($(this).height()).addClass("ui-dialog-dragging");
				self._trigger('dragStart', event, filteredUi(ui));
			},
			drag: function(event, ui) {
				self._trigger('drag', event, filteredUi(ui));
			},
			stop: function(event, ui) {
				options.position = [ui.position.left - doc.scrollLeft(),
					ui.position.top - doc.scrollTop()];
				$(this).removeClass("ui-dialog-dragging").height(heightBeforeDrag);
				self._trigger('dragStop', event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		});
	},

	_makeResizable: function(handles) {
		handles = (handles === undefined ? this.options.resizable : handles);
		var self = this,
			options = self.options,
			// .ui-resizable has position: relative defined in the stylesheet
			// but dialogs have to use absolute or fixed positioning
			position = self.uiDialog.css('position'),
			resizeHandles = (typeof handles === 'string' ?
				handles	:
				'n,e,s,w,se,sw,ne,nw'
			);

		function filteredUi(ui) {
			return {
				originalPosition: ui.originalPosition,
				originalSize: ui.originalSize,
				position: ui.position,
				size: ui.size
			};
		}

		self.uiDialog.resizable({
			cancel: '.ui-dialog-content',
			containment: 'document',
			alsoResize: self.element,
			maxWidth: options.maxWidth,
			maxHeight: options.maxHeight,
			minWidth: options.minWidth,
			minHeight: self._minHeight(),
			handles: resizeHandles,
			start: function(event, ui) {
				$(this).addClass("ui-dialog-resizing");
				self._trigger('resizeStart', event, filteredUi(ui));
			},
			resize: function(event, ui) {
				self._trigger('resize', event, filteredUi(ui));
			},
			stop: function(event, ui) {
				$(this).removeClass("ui-dialog-resizing");
				options.height = $(this).height();
				options.width = $(this).width();
				self._trigger('resizeStop', event, filteredUi(ui));
				$.ui.dialog.overlay.resize();
			}
		})
		.css('position', position)
		.find('.ui-resizable-se').addClass('ui-icon ui-icon-grip-diagonal-se');
	},

	_minHeight: function() {
		var options = this.options;

		if (options.height === 'auto') {
			return options.minHeight;
		} else {
			return Math.min(options.minHeight, options.height);
		}
	},

	_position: function(position) {
		var myAt = [],
			offset = [0, 0],
			isVisible;

		if (position) {
			// deep extending converts arrays to objects in jQuery <= 1.3.2 :-(
	//		if (typeof position == 'string' || $.isArray(position)) {
	//			myAt = $.isArray(position) ? position : position.split(' ');

			if (typeof position === 'string' || (typeof position === 'object' && '0' in position)) {
				myAt = position.split ? position.split(' ') : [position[0], position[1]];
				if (myAt.length === 1) {
					myAt[1] = myAt[0];
				}

				$.each(['left', 'top'], function(i, offsetPosition) {
					if (+myAt[i] === myAt[i]) {
						offset[i] = myAt[i];
						myAt[i] = offsetPosition;
					}
				});

				position = {
					my: myAt.join(" "),
					at: myAt.join(" "),
					offset: offset.join(" ")
				};
			} 

			position = $.extend({}, $.ui.dialog.prototype.options.position, position);
		} else {
			position = $.ui.dialog.prototype.options.position;
		}

		// need to show the dialog to get the actual offset in the position plugin
		isVisible = this.uiDialog.is(':visible');
		if (!isVisible) {
			this.uiDialog.show();
		}
		this.uiDialog
			// workaround for jQuery bug #5781 http://dev.jquery.com/ticket/5781
			.css({ top: 0, left: 0 })
			.position($.extend({ of: window }, position));
		if (!isVisible) {
			this.uiDialog.hide();
		}
	},

	_setOptions: function( options ) {
		var self = this,
			resizableOptions = {},
			resize = false;

		$.each( options, function( key, value ) {
			self._setOption( key, value );
			
			if ( key in sizeRelatedOptions ) {
				resize = true;
			}
			if ( key in resizableRelatedOptions ) {
				resizableOptions[ key ] = value;
			}
		});

		if ( resize ) {
			this._size();
		}
		if ( this.uiDialog.is( ":data(resizable)" ) ) {
			this.uiDialog.resizable( "option", resizableOptions );
		}
	},

	_setOption: function(key, value){
		var self = this,
			uiDialog = self.uiDialog;

		switch (key) {
			//handling of deprecated beforeclose (vs beforeClose) option
			//Ticket #4669 http://dev.jqueryui.com/ticket/4669
			//TODO: remove in 1.9pre
			case "beforeclose":
				key = "beforeClose";
				break;
			case "buttons":
				self._createButtons(value);
				break;
			case "closeText":
				// ensure that we always pass a string
				self.uiDialogTitlebarCloseText.text("" + value);
				break;
			case "dialogClass":
				uiDialog
					.removeClass(self.options.dialogClass)
					.addClass(uiDialogClasses + value);
				break;
			case "disabled":
				if (value) {
					uiDialog.addClass('ui-dialog-disabled');
				} else {
					uiDialog.removeClass('ui-dialog-disabled');
				}
				break;
			case "draggable":
				var isDraggable = uiDialog.is( ":data(draggable)" );
				if ( isDraggable && !value ) {
					uiDialog.draggable( "destroy" );
				}
				
				if ( !isDraggable && value ) {
					self._makeDraggable();
				}
				break;
			case "position":
				self._position(value);
				break;
			case "resizable":
				// currently resizable, becoming non-resizable
				var isResizable = uiDialog.is( ":data(resizable)" );
				if (isResizable && !value) {
					uiDialog.resizable('destroy');
				}

				// currently resizable, changing handles
				if (isResizable && typeof value === 'string') {
					uiDialog.resizable('option', 'handles', value);
				}

				// currently non-resizable, becoming resizable
				if (!isResizable && value !== false) {
					self._makeResizable(value);
				}
				break;
			case "title":
				// convert whatever was passed in o a string, for html() to not throw up
				$(".ui-dialog-title", self.uiDialogTitlebar).html("" + (value || '&#160;'));
				break;
		}

		$.Widget.prototype._setOption.apply(self, arguments);
	},

	_size: function() {
		/* If the user has resized the dialog, the .ui-dialog and .ui-dialog-content
		 * divs will both have width and height set, so we need to reset them
		 */
		var options = this.options,
			nonContentHeight,
			minContentHeight,
			isVisible = this.uiDialog.is( ":visible" );

		// reset content sizing
		this.element.show().css({
			width: 'auto',
			minHeight: 0,
			height: 0
		});

		if (options.minWidth > options.width) {
			options.width = options.minWidth;
		}

		// reset wrapper sizing
		// determine the height of all the non-content elements
		nonContentHeight = this.uiDialog.css({
				height: 'auto',
				width: options.width
			})
			.height();
		minContentHeight = Math.max( 0, options.minHeight - nonContentHeight );
		
		if ( options.height === "auto" ) {
			// only needed for IE6 support
			if ( $.support.minHeight ) {
				this.element.css({
					minHeight: minContentHeight,
					height: "auto"
				});
			} else {
				this.uiDialog.show();
				var autoHeight = this.element.css( "height", "auto" ).height();
				if ( !isVisible ) {
					this.uiDialog.hide();
				}
				this.element.height( Math.max( autoHeight, minContentHeight ) );
			}
		} else {
			this.element.height( Math.max( options.height - nonContentHeight, 0 ) );
		}

		if (this.uiDialog.is(':data(resizable)')) {
			this.uiDialog.resizable('option', 'minHeight', this._minHeight());
		}
	}
});

$.extend($.ui.dialog, {
	version: "1.8.21",

	uuid: 0,
	maxZ: 0,

	getTitleId: function($el) {
		var id = $el.attr('id');
		if (!id) {
			this.uuid += 1;
			id = this.uuid;
		}
		return 'ui-dialog-title-' + id;
	},

	overlay: function(dialog) {
		this.$el = $.ui.dialog.overlay.create(dialog);
	}
});

$.extend($.ui.dialog.overlay, {
	instances: [],
	// reuse old instances due to IE memory leak with alpha transparency (see #5185)
	oldInstances: [],
	maxZ: 0,
	events: $.map('focus,mousedown,mouseup,keydown,keypress,click'.split(','),
		function(event) { return event + '.dialog-overlay'; }).join(' '),
	create: function(dialog) {
		if (this.instances.length === 0) {
			// prevent use of anchors and inputs
			// we use a setTimeout in case the overlay is created from an
			// event that we're going to be cancelling (see #2804)
			setTimeout(function() {
				// handle $(el).dialog().dialog('close') (see #4065)
				if ($.ui.dialog.overlay.instances.length) {
					$(document).bind($.ui.dialog.overlay.events, function(event) {
						// stop events if the z-index of the target is < the z-index of the overlay
						// we cannot return true when we don't want to cancel the event (#3523)
						if ($(event.target).zIndex() < $.ui.dialog.overlay.maxZ) {
							return false;
						}
					});
				}
			}, 1);

			// allow closing by pressing the escape key
			$(document).bind('keydown.dialog-overlay', function(event) {
				if (dialog.options.closeOnEscape && !event.isDefaultPrevented() && event.keyCode &&
					event.keyCode === $.ui.keyCode.ESCAPE) {
					
					dialog.close(event);
					event.preventDefault();
				}
			});

			// handle window resize
			$(window).bind('resize.dialog-overlay', $.ui.dialog.overlay.resize);
		}

		var $el = (this.oldInstances.pop() || $('<div></div>').addClass('ui-widget-overlay'))
			.appendTo(document.body)
			.css({
				width: this.width(),
				height: this.height()
			});

		if ($.fn.bgiframe) {
			$el.bgiframe();
		}

		this.instances.push($el);
		return $el;
	},

	destroy: function($el) {
		var indexOf = $.inArray($el, this.instances);
		if (indexOf != -1){
			this.oldInstances.push(this.instances.splice(indexOf, 1)[0]);
		}

		if (this.instances.length === 0) {
			$([document, window]).unbind('.dialog-overlay');
		}

		$el.remove();
		
		// adjust the maxZ to allow other modal dialogs to continue to work (see #4309)
		var maxZ = 0;
		$.each(this.instances, function() {
			maxZ = Math.max(maxZ, this.css('z-index'));
		});
		this.maxZ = maxZ;
	},

	height: function() {
		var scrollHeight,
			offsetHeight;
		// handle IE 6
		if ($.browser.msie && $.browser.version < 7) {
			scrollHeight = Math.max(
				document.documentElement.scrollHeight,
				document.body.scrollHeight
			);
			offsetHeight = Math.max(
				document.documentElement.offsetHeight,
				document.body.offsetHeight
			);

			if (scrollHeight < offsetHeight) {
				return $(window).height() + 'px';
			} else {
				return scrollHeight + 'px';
			}
		// handle "good" browsers
		} else {
			return $(document).height() + 'px';
		}
	},

	width: function() {
		var scrollWidth,
			offsetWidth;
		// handle IE
		if ( $.browser.msie ) {
			scrollWidth = Math.max(
				document.documentElement.scrollWidth,
				document.body.scrollWidth
			);
			offsetWidth = Math.max(
				document.documentElement.offsetWidth,
				document.body.offsetWidth
			);

			if (scrollWidth < offsetWidth) {
				return $(window).width() + 'px';
			} else {
				return scrollWidth + 'px';
			}
		// handle "good" browsers
		} else {
			return $(document).width() + 'px';
		}
	},

	resize: function() {
		/* If the dialog is draggable and the user drags it past the
		 * right edge of the window, the document becomes wider so we
		 * need to stretch the overlay. If the user then drags the
		 * dialog back to the left, the document will become narrower,
		 * so we need to shrink the overlay to the appropriate size.
		 * This is handled by shrinking the overlay before setting it
		 * to the full document size.
		 */
		var $overlays = $([]);
		$.each($.ui.dialog.overlay.instances, function() {
			$overlays = $overlays.add(this);
		});

		$overlays.css({
			width: 0,
			height: 0
		}).css({
			width: $.ui.dialog.overlay.width(),
			height: $.ui.dialog.overlay.height()
		});
	}
});

$.extend($.ui.dialog.overlay.prototype, {
	destroy: function() {
		$.ui.dialog.overlay.destroy(this.$el);
	}
});

}(jQuery));
/*!
 * jQuery UI Slider 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Slider
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.mouse.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

// number of pages in a slider
// (how many times can you page up/down to go through the whole range)
var numPages = 5;

$.widget( "ui.slider", $.ui.mouse, {

	widgetEventPrefix: "slide",

	options: {
		animate: false,
		distance: 0,
		max: 100,
		min: 0,
		orientation: "horizontal",
		range: false,
		step: 1,
		value: 0,
		values: null
	},

	_create: function() {
		var self = this,
			o = this.options,
			existingHandles = this.element.find( ".ui-slider-handle" ).addClass( "ui-state-default ui-corner-all" ),
			handle = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
			handleCount = ( o.values && o.values.length ) || 1,
			handles = [];

		this._keySliding = false;
		this._mouseSliding = false;
		this._animateOff = true;
		this._handleIndex = null;
		this._detectOrientation();
		this._mouseInit();

		this.element
			.addClass( "ui-slider" +
				" ui-slider-" + this.orientation +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" +
				( o.disabled ? " ui-slider-disabled ui-disabled" : "" ) );

		this.range = $([]);

		if ( o.range ) {
			if ( o.range === true ) {
				if ( !o.values ) {
					o.values = [ this._valueMin(), this._valueMin() ];
				}
				if ( o.values.length && o.values.length !== 2 ) {
					o.values = [ o.values[0], o.values[0] ];
				}
			}

			this.range = $( "<div></div>" )
				.appendTo( this.element )
				.addClass( "ui-slider-range" +
				// note: this isn't the most fittingly semantic framework class for this element,
				// but worked best visually with a variety of themes
				" ui-widget-header" + 
				( ( o.range === "min" || o.range === "max" ) ? " ui-slider-range-" + o.range : "" ) );
		}

		for ( var i = existingHandles.length; i < handleCount; i += 1 ) {
			handles.push( handle );
		}

		this.handles = existingHandles.add( $( handles.join( "" ) ).appendTo( self.element ) );

		this.handle = this.handles.eq( 0 );

		this.handles.add( this.range ).filter( "a" )
			.click(function( event ) {
				event.preventDefault();
			})
			.hover(function() {
				if ( !o.disabled ) {
					$( this ).addClass( "ui-state-hover" );
				}
			}, function() {
				$( this ).removeClass( "ui-state-hover" );
			})
			.focus(function() {
				if ( !o.disabled ) {
					$( ".ui-slider .ui-state-focus" ).removeClass( "ui-state-focus" );
					$( this ).addClass( "ui-state-focus" );
				} else {
					$( this ).blur();
				}
			})
			.blur(function() {
				$( this ).removeClass( "ui-state-focus" );
			});

		this.handles.each(function( i ) {
			$( this ).data( "index.ui-slider-handle", i );
		});

		this.handles
			.keydown(function( event ) {
				var index = $( this ).data( "index.ui-slider-handle" ),
					allowed,
					curVal,
					newVal,
					step;
	
				if ( self.options.disabled ) {
					return;
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
					case $.ui.keyCode.END:
					case $.ui.keyCode.PAGE_UP:
					case $.ui.keyCode.PAGE_DOWN:
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						event.preventDefault();
						if ( !self._keySliding ) {
							self._keySliding = true;
							$( this ).addClass( "ui-state-active" );
							allowed = self._start( event, index );
							if ( allowed === false ) {
								return;
							}
						}
						break;
				}
	
				step = self.options.step;
				if ( self.options.values && self.options.values.length ) {
					curVal = newVal = self.values( index );
				} else {
					curVal = newVal = self.value();
				}
	
				switch ( event.keyCode ) {
					case $.ui.keyCode.HOME:
						newVal = self._valueMin();
						break;
					case $.ui.keyCode.END:
						newVal = self._valueMax();
						break;
					case $.ui.keyCode.PAGE_UP:
						newVal = self._trimAlignValue( curVal + ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.PAGE_DOWN:
						newVal = self._trimAlignValue( curVal - ( (self._valueMax() - self._valueMin()) / numPages ) );
						break;
					case $.ui.keyCode.UP:
					case $.ui.keyCode.RIGHT:
						if ( curVal === self._valueMax() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal + step );
						break;
					case $.ui.keyCode.DOWN:
					case $.ui.keyCode.LEFT:
						if ( curVal === self._valueMin() ) {
							return;
						}
						newVal = self._trimAlignValue( curVal - step );
						break;
				}
	
				self._slide( event, index, newVal );
			})
			.keyup(function( event ) {
				var index = $( this ).data( "index.ui-slider-handle" );
	
				if ( self._keySliding ) {
					self._keySliding = false;
					self._stop( event, index );
					self._change( event, index );
					$( this ).removeClass( "ui-state-active" );
				}
	
			});

		this._refreshValue();

		this._animateOff = false;
	},

	destroy: function() {
		this.handles.remove();
		this.range.remove();

		this.element
			.removeClass( "ui-slider" +
				" ui-slider-horizontal" +
				" ui-slider-vertical" +
				" ui-slider-disabled" +
				" ui-widget" +
				" ui-widget-content" +
				" ui-corner-all" )
			.removeData( "slider" )
			.unbind( ".slider" );

		this._mouseDestroy();

		return this;
	},

	_mouseCapture: function( event ) {
		var o = this.options,
			position,
			normValue,
			distance,
			closestHandle,
			self,
			index,
			allowed,
			offset,
			mouseOverHandle;

		if ( o.disabled ) {
			return false;
		}

		this.elementSize = {
			width: this.element.outerWidth(),
			height: this.element.outerHeight()
		};
		this.elementOffset = this.element.offset();

		position = { x: event.pageX, y: event.pageY };
		normValue = this._normValueFromMouse( position );
		distance = this._valueMax() - this._valueMin() + 1;
		self = this;
		this.handles.each(function( i ) {
			var thisDistance = Math.abs( normValue - self.values(i) );
			if ( distance > thisDistance ) {
				distance = thisDistance;
				closestHandle = $( this );
				index = i;
			}
		});

		// workaround for bug #3736 (if both handles of a range are at 0,
		// the first is always used as the one with least distance,
		// and moving it is obviously prevented by preventing negative ranges)
		if( o.range === true && this.values(1) === o.min ) {
			index += 1;
			closestHandle = $( this.handles[index] );
		}

		allowed = this._start( event, index );
		if ( allowed === false ) {
			return false;
		}
		this._mouseSliding = true;

		self._handleIndex = index;

		closestHandle
			.addClass( "ui-state-active" )
			.focus();
		
		offset = closestHandle.offset();
		mouseOverHandle = !$( event.target ).parents().andSelf().is( ".ui-slider-handle" );
		this._clickOffset = mouseOverHandle ? { left: 0, top: 0 } : {
			left: event.pageX - offset.left - ( closestHandle.width() / 2 ),
			top: event.pageY - offset.top -
				( closestHandle.height() / 2 ) -
				( parseInt( closestHandle.css("borderTopWidth"), 10 ) || 0 ) -
				( parseInt( closestHandle.css("borderBottomWidth"), 10 ) || 0) +
				( parseInt( closestHandle.css("marginTop"), 10 ) || 0)
		};

		if ( !this.handles.hasClass( "ui-state-hover" ) ) {
			this._slide( event, index, normValue );
		}
		this._animateOff = true;
		return true;
	},

	_mouseStart: function( event ) {
		return true;
	},

	_mouseDrag: function( event ) {
		var position = { x: event.pageX, y: event.pageY },
			normValue = this._normValueFromMouse( position );
		
		this._slide( event, this._handleIndex, normValue );

		return false;
	},

	_mouseStop: function( event ) {
		this.handles.removeClass( "ui-state-active" );
		this._mouseSliding = false;

		this._stop( event, this._handleIndex );
		this._change( event, this._handleIndex );

		this._handleIndex = null;
		this._clickOffset = null;
		this._animateOff = false;

		return false;
	},
	
	_detectOrientation: function() {
		this.orientation = ( this.options.orientation === "vertical" ) ? "vertical" : "horizontal";
	},

	_normValueFromMouse: function( position ) {
		var pixelTotal,
			pixelMouse,
			percentMouse,
			valueTotal,
			valueMouse;

		if ( this.orientation === "horizontal" ) {
			pixelTotal = this.elementSize.width;
			pixelMouse = position.x - this.elementOffset.left - ( this._clickOffset ? this._clickOffset.left : 0 );
		} else {
			pixelTotal = this.elementSize.height;
			pixelMouse = position.y - this.elementOffset.top - ( this._clickOffset ? this._clickOffset.top : 0 );
		}

		percentMouse = ( pixelMouse / pixelTotal );
		if ( percentMouse > 1 ) {
			percentMouse = 1;
		}
		if ( percentMouse < 0 ) {
			percentMouse = 0;
		}
		if ( this.orientation === "vertical" ) {
			percentMouse = 1 - percentMouse;
		}

		valueTotal = this._valueMax() - this._valueMin();
		valueMouse = this._valueMin() + percentMouse * valueTotal;

		return this._trimAlignValue( valueMouse );
	},

	_start: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}
		return this._trigger( "start", event, uiHash );
	},

	_slide: function( event, index, newVal ) {
		var otherVal,
			newValues,
			allowed;

		if ( this.options.values && this.options.values.length ) {
			otherVal = this.values( index ? 0 : 1 );

			if ( ( this.options.values.length === 2 && this.options.range === true ) && 
					( ( index === 0 && newVal > otherVal) || ( index === 1 && newVal < otherVal ) )
				) {
				newVal = otherVal;
			}

			if ( newVal !== this.values( index ) ) {
				newValues = this.values();
				newValues[ index ] = newVal;
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal,
					values: newValues
				} );
				otherVal = this.values( index ? 0 : 1 );
				if ( allowed !== false ) {
					this.values( index, newVal, true );
				}
			}
		} else {
			if ( newVal !== this.value() ) {
				// A slide can be canceled by returning false from the slide callback
				allowed = this._trigger( "slide", event, {
					handle: this.handles[ index ],
					value: newVal
				} );
				if ( allowed !== false ) {
					this.value( newVal );
				}
			}
		}
	},

	_stop: function( event, index ) {
		var uiHash = {
			handle: this.handles[ index ],
			value: this.value()
		};
		if ( this.options.values && this.options.values.length ) {
			uiHash.value = this.values( index );
			uiHash.values = this.values();
		}

		this._trigger( "stop", event, uiHash );
	},

	_change: function( event, index ) {
		if ( !this._keySliding && !this._mouseSliding ) {
			var uiHash = {
				handle: this.handles[ index ],
				value: this.value()
			};
			if ( this.options.values && this.options.values.length ) {
				uiHash.value = this.values( index );
				uiHash.values = this.values();
			}

			this._trigger( "change", event, uiHash );
		}
	},

	value: function( newValue ) {
		if ( arguments.length ) {
			this.options.value = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, 0 );
			return;
		}

		return this._value();
	},

	values: function( index, newValue ) {
		var vals,
			newValues,
			i;

		if ( arguments.length > 1 ) {
			this.options.values[ index ] = this._trimAlignValue( newValue );
			this._refreshValue();
			this._change( null, index );
			return;
		}

		if ( arguments.length ) {
			if ( $.isArray( arguments[ 0 ] ) ) {
				vals = this.options.values;
				newValues = arguments[ 0 ];
				for ( i = 0; i < vals.length; i += 1 ) {
					vals[ i ] = this._trimAlignValue( newValues[ i ] );
					this._change( null, i );
				}
				this._refreshValue();
			} else {
				if ( this.options.values && this.options.values.length ) {
					return this._values( index );
				} else {
					return this.value();
				}
			}
		} else {
			return this._values();
		}
	},

	_setOption: function( key, value ) {
		var i,
			valsLength = 0;

		if ( $.isArray( this.options.values ) ) {
			valsLength = this.options.values.length;
		}

		$.Widget.prototype._setOption.apply( this, arguments );

		switch ( key ) {
			case "disabled":
				if ( value ) {
					this.handles.filter( ".ui-state-focus" ).blur();
					this.handles.removeClass( "ui-state-hover" );
					this.handles.propAttr( "disabled", true );
					this.element.addClass( "ui-disabled" );
				} else {
					this.handles.propAttr( "disabled", false );
					this.element.removeClass( "ui-disabled" );
				}
				break;
			case "orientation":
				this._detectOrientation();
				this.element
					.removeClass( "ui-slider-horizontal ui-slider-vertical" )
					.addClass( "ui-slider-" + this.orientation );
				this._refreshValue();
				break;
			case "value":
				this._animateOff = true;
				this._refreshValue();
				this._change( null, 0 );
				this._animateOff = false;
				break;
			case "values":
				this._animateOff = true;
				this._refreshValue();
				for ( i = 0; i < valsLength; i += 1 ) {
					this._change( null, i );
				}
				this._animateOff = false;
				break;
		}
	},

	//internal value getter
	// _value() returns value trimmed by min and max, aligned by step
	_value: function() {
		var val = this.options.value;
		val = this._trimAlignValue( val );

		return val;
	},

	//internal values getter
	// _values() returns array of values trimmed by min and max, aligned by step
	// _values( index ) returns single value trimmed by min and max, aligned by step
	_values: function( index ) {
		var val,
			vals,
			i;

		if ( arguments.length ) {
			val = this.options.values[ index ];
			val = this._trimAlignValue( val );

			return val;
		} else {
			// .slice() creates a copy of the array
			// this copy gets trimmed by min and max and then returned
			vals = this.options.values.slice();
			for ( i = 0; i < vals.length; i+= 1) {
				vals[ i ] = this._trimAlignValue( vals[ i ] );
			}

			return vals;
		}
	},
	
	// returns the step-aligned value that val is closest to, between (inclusive) min and max
	_trimAlignValue: function( val ) {
		if ( val <= this._valueMin() ) {
			return this._valueMin();
		}
		if ( val >= this._valueMax() ) {
			return this._valueMax();
		}
		var step = ( this.options.step > 0 ) ? this.options.step : 1,
			valModStep = (val - this._valueMin()) % step,
			alignValue = val - valModStep;

		if ( Math.abs(valModStep) * 2 >= step ) {
			alignValue += ( valModStep > 0 ) ? step : ( -step );
		}

		// Since JavaScript has problems with large floats, round
		// the final value to 5 digits after the decimal point (see #4124)
		return parseFloat( alignValue.toFixed(5) );
	},

	_valueMin: function() {
		return this.options.min;
	},

	_valueMax: function() {
		return this.options.max;
	},
	
	_refreshValue: function() {
		var oRange = this.options.range,
			o = this.options,
			self = this,
			animate = ( !this._animateOff ) ? o.animate : false,
			valPercent,
			_set = {},
			lastValPercent,
			value,
			valueMin,
			valueMax;

		if ( this.options.values && this.options.values.length ) {
			this.handles.each(function( i, j ) {
				valPercent = ( self.values(i) - self._valueMin() ) / ( self._valueMax() - self._valueMin() ) * 100;
				_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
				$( this ).stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );
				if ( self.options.range === true ) {
					if ( self.orientation === "horizontal" ) {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { left: valPercent + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { width: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					} else {
						if ( i === 0 ) {
							self.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { bottom: ( valPercent ) + "%" }, o.animate );
						}
						if ( i === 1 ) {
							self.range[ animate ? "animate" : "css" ]( { height: ( valPercent - lastValPercent ) + "%" }, { queue: false, duration: o.animate } );
						}
					}
				}
				lastValPercent = valPercent;
			});
		} else {
			value = this.value();
			valueMin = this._valueMin();
			valueMax = this._valueMax();
			valPercent = ( valueMax !== valueMin ) ?
					( value - valueMin ) / ( valueMax - valueMin ) * 100 :
					0;
			_set[ self.orientation === "horizontal" ? "left" : "bottom" ] = valPercent + "%";
			this.handle.stop( 1, 1 )[ animate ? "animate" : "css" ]( _set, o.animate );

			if ( oRange === "min" && this.orientation === "horizontal" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { width: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "horizontal" ) {
				this.range[ animate ? "animate" : "css" ]( { width: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
			if ( oRange === "min" && this.orientation === "vertical" ) {
				this.range.stop( 1, 1 )[ animate ? "animate" : "css" ]( { height: valPercent + "%" }, o.animate );
			}
			if ( oRange === "max" && this.orientation === "vertical" ) {
				this.range[ animate ? "animate" : "css" ]( { height: ( 100 - valPercent ) + "%" }, { queue: false, duration: o.animate } );
			}
		}
	}

});

$.extend( $.ui.slider, {
	version: "1.8.21"
});

}(jQuery));
/*!
 * jQuery UI Tabs 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Tabs
 *
 * Depends:
 *	jquery.ui.core.js
 *	jquery.ui.widget.js
 */
(function( $, undefined ) {

var tabId = 0,
	listId = 0;

function getNextTabId() {
	return ++tabId;
}

function getNextListId() {
	return ++listId;
}

$.widget( "ui.tabs", {
	options: {
		add: null,
		ajaxOptions: null,
		cache: false,
		cookie: null, // e.g. { expires: 7, path: '/', domain: 'jquery.com', secure: true }
		collapsible: false,
		disable: null,
		disabled: [],
		enable: null,
		event: "click",
		fx: null, // e.g. { height: 'toggle', opacity: 'toggle', duration: 200 }
		idPrefix: "ui-tabs-",
		load: null,
		panelTemplate: "<div></div>",
		remove: null,
		select: null,
		show: null,
		spinner: "<em>Loading&#8230;</em>",
		tabTemplate: "<li><a href='#{href}'><span>#{label}</span></a></li>"
	},

	_create: function() {
		this._tabify( true );
	},

	_setOption: function( key, value ) {
		if ( key == "selected" ) {
			if (this.options.collapsible && value == this.options.selected ) {
				return;
			}
			this.select( value );
		} else {
			this.options[ key ] = value;
			this._tabify();
		}
	},

	_tabId: function( a ) {
		return a.title && a.title.replace( /\s/g, "_" ).replace( /[^\w\u00c0-\uFFFF-]/g, "" ) ||
			this.options.idPrefix + getNextTabId();
	},

	_sanitizeSelector: function( hash ) {
		// we need this because an id may contain a ":"
		return hash.replace( /:/g, "\\:" );
	},

	_cookie: function() {
		var cookie = this.cookie ||
			( this.cookie = this.options.cookie.name || "ui-tabs-" + getNextListId() );
		return $.cookie.apply( null, [ cookie ].concat( $.makeArray( arguments ) ) );
	},

	_ui: function( tab, panel ) {
		return {
			tab: tab,
			panel: panel,
			index: this.anchors.index( tab )
		};
	},

	_cleanup: function() {
		// restore all former loading tabs labels
		this.lis.filter( ".ui-state-processing" )
			.removeClass( "ui-state-processing" )
			.find( "span:data(label.tabs)" )
				.each(function() {
					var el = $( this );
					el.html( el.data( "label.tabs" ) ).removeData( "label.tabs" );
				});
	},

	_tabify: function( init ) {
		var self = this,
			o = this.options,
			fragmentId = /^#.+/; // Safari 2 reports '#' for an empty hash

		this.list = this.element.find( "ol,ul" ).eq( 0 );
		this.lis = $( " > li:has(a[href])", this.list );
		this.anchors = this.lis.map(function() {
			return $( "a", this )[ 0 ];
		});
		this.panels = $( [] );

		this.anchors.each(function( i, a ) {
			var href = $( a ).attr( "href" );
			// For dynamically created HTML that contains a hash as href IE < 8 expands
			// such href to the full page url with hash and then misinterprets tab as ajax.
			// Same consideration applies for an added tab with a fragment identifier
			// since a[href=#fragment-identifier] does unexpectedly not match.
			// Thus normalize href attribute...
			var hrefBase = href.split( "#" )[ 0 ],
				baseEl;
			if ( hrefBase && ( hrefBase === location.toString().split( "#" )[ 0 ] ||
					( baseEl = $( "base" )[ 0 ]) && hrefBase === baseEl.href ) ) {
				href = a.hash;
				a.href = href;
			}

			// inline tab
			if ( fragmentId.test( href ) ) {
				self.panels = self.panels.add( self.element.find( self._sanitizeSelector( href ) ) );
			// remote tab
			// prevent loading the page itself if href is just "#"
			} else if ( href && href !== "#" ) {
				// required for restore on destroy
				$.data( a, "href.tabs", href );

				// TODO until #3808 is fixed strip fragment identifier from url
				// (IE fails to load from such url)
				$.data( a, "load.tabs", href.replace( /#.*$/, "" ) );

				var id = self._tabId( a );
				a.href = "#" + id;
				var $panel = self.element.find( "#" + id );
				if ( !$panel.length ) {
					$panel = $( o.panelTemplate )
						.attr( "id", id )
						.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" )
						.insertAfter( self.panels[ i - 1 ] || self.list );
					$panel.data( "destroy.tabs", true );
				}
				self.panels = self.panels.add( $panel );
			// invalid tab href
			} else {
				o.disabled.push( i );
			}
		});

		// initialization from scratch
		if ( init ) {
			// attach necessary classes for styling
			this.element.addClass( "ui-tabs ui-widget ui-widget-content ui-corner-all" );
			this.list.addClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" );
			this.lis.addClass( "ui-state-default ui-corner-top" );
			this.panels.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom" );

			// Selected tab
			// use "selected" option or try to retrieve:
			// 1. from fragment identifier in url
			// 2. from cookie
			// 3. from selected class attribute on <li>
			if ( o.selected === undefined ) {
				if ( location.hash ) {
					this.anchors.each(function( i, a ) {
						if ( a.hash == location.hash ) {
							o.selected = i;
							return false;
						}
					});
				}
				if ( typeof o.selected !== "number" && o.cookie ) {
					o.selected = parseInt( self._cookie(), 10 );
				}
				if ( typeof o.selected !== "number" && this.lis.filter( ".ui-tabs-selected" ).length ) {
					o.selected = this.lis.index( this.lis.filter( ".ui-tabs-selected" ) );
				}
				o.selected = o.selected || ( this.lis.length ? 0 : -1 );
			} else if ( o.selected === null ) { // usage of null is deprecated, TODO remove in next release
				o.selected = -1;
			}

			// sanity check - default to first tab...
			o.selected = ( ( o.selected >= 0 && this.anchors[ o.selected ] ) || o.selected < 0 )
				? o.selected
				: 0;

			// Take disabling tabs via class attribute from HTML
			// into account and update option properly.
			// A selected tab cannot become disabled.
			o.disabled = $.unique( o.disabled.concat(
				$.map( this.lis.filter( ".ui-state-disabled" ), function( n, i ) {
					return self.lis.index( n );
				})
			) ).sort();

			if ( $.inArray( o.selected, o.disabled ) != -1 ) {
				o.disabled.splice( $.inArray( o.selected, o.disabled ), 1 );
			}

			// highlight selected tab
			this.panels.addClass( "ui-tabs-hide" );
			this.lis.removeClass( "ui-tabs-selected ui-state-active" );
			// check for length avoids error when initializing empty list
			if ( o.selected >= 0 && this.anchors.length ) {
				self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) ).removeClass( "ui-tabs-hide" );
				this.lis.eq( o.selected ).addClass( "ui-tabs-selected ui-state-active" );

				// seems to be expected behavior that the show callback is fired
				self.element.queue( "tabs", function() {
					self._trigger( "show", null,
						self._ui( self.anchors[ o.selected ], self.element.find( self._sanitizeSelector( self.anchors[ o.selected ].hash ) )[ 0 ] ) );
				});

				this.load( o.selected );
			}

			// clean up to avoid memory leaks in certain versions of IE 6
			// TODO: namespace this event
			$( window ).bind( "unload", function() {
				self.lis.add( self.anchors ).unbind( ".tabs" );
				self.lis = self.anchors = self.panels = null;
			});
		// update selected after add/remove
		} else {
			o.selected = this.lis.index( this.lis.filter( ".ui-tabs-selected" ) );
		}

		// update collapsible
		// TODO: use .toggleClass()
		this.element[ o.collapsible ? "addClass" : "removeClass" ]( "ui-tabs-collapsible" );

		// set or update cookie after init and add/remove respectively
		if ( o.cookie ) {
			this._cookie( o.selected, o.cookie );
		}

		// disable tabs
		for ( var i = 0, li; ( li = this.lis[ i ] ); i++ ) {
			$( li )[ $.inArray( i, o.disabled ) != -1 &&
				// TODO: use .toggleClass()
				!$( li ).hasClass( "ui-tabs-selected" ) ? "addClass" : "removeClass" ]( "ui-state-disabled" );
		}

		// reset cache if switching from cached to not cached
		if ( o.cache === false ) {
			this.anchors.removeData( "cache.tabs" );
		}

		// remove all handlers before, tabify may run on existing tabs after add or option change
		this.lis.add( this.anchors ).unbind( ".tabs" );

		if ( o.event !== "mouseover" ) {
			var addState = function( state, el ) {
				if ( el.is( ":not(.ui-state-disabled)" ) ) {
					el.addClass( "ui-state-" + state );
				}
			};
			var removeState = function( state, el ) {
				el.removeClass( "ui-state-" + state );
			};
			this.lis.bind( "mouseover.tabs" , function() {
				addState( "hover", $( this ) );
			});
			this.lis.bind( "mouseout.tabs", function() {
				removeState( "hover", $( this ) );
			});
			this.anchors.bind( "focus.tabs", function() {
				addState( "focus", $( this ).closest( "li" ) );
			});
			this.anchors.bind( "blur.tabs", function() {
				removeState( "focus", $( this ).closest( "li" ) );
			});
		}

		// set up animations
		var hideFx, showFx;
		if ( o.fx ) {
			if ( $.isArray( o.fx ) ) {
				hideFx = o.fx[ 0 ];
				showFx = o.fx[ 1 ];
			} else {
				hideFx = showFx = o.fx;
			}
		}

		// Reset certain styles left over from animation
		// and prevent IE's ClearType bug...
		function resetStyle( $el, fx ) {
			$el.css( "display", "" );
			if ( !$.support.opacity && fx.opacity ) {
				$el[ 0 ].style.removeAttribute( "filter" );
			}
		}

		// Show a tab...
		var showTab = showFx
			? function( clicked, $show ) {
				$( clicked ).closest( "li" ).addClass( "ui-tabs-selected ui-state-active" );
				$show.hide().removeClass( "ui-tabs-hide" ) // avoid flicker that way
					.animate( showFx, showFx.duration || "normal", function() {
						resetStyle( $show, showFx );
						self._trigger( "show", null, self._ui( clicked, $show[ 0 ] ) );
					});
			}
			: function( clicked, $show ) {
				$( clicked ).closest( "li" ).addClass( "ui-tabs-selected ui-state-active" );
				$show.removeClass( "ui-tabs-hide" );
				self._trigger( "show", null, self._ui( clicked, $show[ 0 ] ) );
			};

		// Hide a tab, $show is optional...
		var hideTab = hideFx
			? function( clicked, $hide ) {
				$hide.animate( hideFx, hideFx.duration || "normal", function() {
					self.lis.removeClass( "ui-tabs-selected ui-state-active" );
					$hide.addClass( "ui-tabs-hide" );
					resetStyle( $hide, hideFx );
					self.element.dequeue( "tabs" );
				});
			}
			: function( clicked, $hide, $show ) {
				self.lis.removeClass( "ui-tabs-selected ui-state-active" );
				$hide.addClass( "ui-tabs-hide" );
				self.element.dequeue( "tabs" );
			};

		// attach tab event handler, unbind to avoid duplicates from former tabifying...
		this.anchors.bind( o.event + ".tabs", function() {
			var el = this,
				$li = $(el).closest( "li" ),
				$hide = self.panels.filter( ":not(.ui-tabs-hide)" ),
				$show = self.element.find( self._sanitizeSelector( el.hash ) );

			// If tab is already selected and not collapsible or tab disabled or
			// or is already loading or click callback returns false stop here.
			// Check if click handler returns false last so that it is not executed
			// for a disabled or loading tab!
			if ( ( $li.hasClass( "ui-tabs-selected" ) && !o.collapsible) ||
				$li.hasClass( "ui-state-disabled" ) ||
				$li.hasClass( "ui-state-processing" ) ||
				self.panels.filter( ":animated" ).length ||
				self._trigger( "select", null, self._ui( this, $show[ 0 ] ) ) === false ) {
				this.blur();
				return false;
			}

			o.selected = self.anchors.index( this );

			self.abort();

			// if tab may be closed
			if ( o.collapsible ) {
				if ( $li.hasClass( "ui-tabs-selected" ) ) {
					o.selected = -1;

					if ( o.cookie ) {
						self._cookie( o.selected, o.cookie );
					}

					self.element.queue( "tabs", function() {
						hideTab( el, $hide );
					}).dequeue( "tabs" );

					this.blur();
					return false;
				} else if ( !$hide.length ) {
					if ( o.cookie ) {
						self._cookie( o.selected, o.cookie );
					}

					self.element.queue( "tabs", function() {
						showTab( el, $show );
					});

					// TODO make passing in node possible, see also http://dev.jqueryui.com/ticket/3171
					self.load( self.anchors.index( this ) );

					this.blur();
					return false;
				}
			}

			if ( o.cookie ) {
				self._cookie( o.selected, o.cookie );
			}

			// show new tab
			if ( $show.length ) {
				if ( $hide.length ) {
					self.element.queue( "tabs", function() {
						hideTab( el, $hide );
					});
				}
				self.element.queue( "tabs", function() {
					showTab( el, $show );
				});

				self.load( self.anchors.index( this ) );
			} else {
				throw "jQuery UI Tabs: Mismatching fragment identifier.";
			}

			// Prevent IE from keeping other link focussed when using the back button
			// and remove dotted border from clicked link. This is controlled via CSS
			// in modern browsers; blur() removes focus from address bar in Firefox
			// which can become a usability and annoying problem with tabs('rotate').
			if ( $.browser.msie ) {
				this.blur();
			}
		});

		// disable click in any case
		this.anchors.bind( "click.tabs", function(){
			return false;
		});
	},

    _getIndex: function( index ) {
		// meta-function to give users option to provide a href string instead of a numerical index.
		// also sanitizes numerical indexes to valid values.
		if ( typeof index == "string" ) {
			index = this.anchors.index( this.anchors.filter( "[href$='" + index + "']" ) );
		}

		return index;
	},

	destroy: function() {
		var o = this.options;

		this.abort();

		this.element
			.unbind( ".tabs" )
			.removeClass( "ui-tabs ui-widget ui-widget-content ui-corner-all ui-tabs-collapsible" )
			.removeData( "tabs" );

		this.list.removeClass( "ui-tabs-nav ui-helper-reset ui-helper-clearfix ui-widget-header ui-corner-all" );

		this.anchors.each(function() {
			var href = $.data( this, "href.tabs" );
			if ( href ) {
				this.href = href;
			}
			var $this = $( this ).unbind( ".tabs" );
			$.each( [ "href", "load", "cache" ], function( i, prefix ) {
				$this.removeData( prefix + ".tabs" );
			});
		});

		this.lis.unbind( ".tabs" ).add( this.panels ).each(function() {
			if ( $.data( this, "destroy.tabs" ) ) {
				$( this ).remove();
			} else {
				$( this ).removeClass([
					"ui-state-default",
					"ui-corner-top",
					"ui-tabs-selected",
					"ui-state-active",
					"ui-state-hover",
					"ui-state-focus",
					"ui-state-disabled",
					"ui-tabs-panel",
					"ui-widget-content",
					"ui-corner-bottom",
					"ui-tabs-hide"
				].join( " " ) );
			}
		});

		if ( o.cookie ) {
			this._cookie( null, o.cookie );
		}

		return this;
	},

	add: function( url, label, index ) {
		if ( index === undefined ) {
			index = this.anchors.length;
		}

		var self = this,
			o = this.options,
			$li = $( o.tabTemplate.replace( /#\{href\}/g, url ).replace( /#\{label\}/g, label ) ),
			id = !url.indexOf( "#" ) ? url.replace( "#", "" ) : this._tabId( $( "a", $li )[ 0 ] );

		$li.addClass( "ui-state-default ui-corner-top" ).data( "destroy.tabs", true );

		// try to find an existing element before creating a new one
		var $panel = self.element.find( "#" + id );
		if ( !$panel.length ) {
			$panel = $( o.panelTemplate )
				.attr( "id", id )
				.data( "destroy.tabs", true );
		}
		$panel.addClass( "ui-tabs-panel ui-widget-content ui-corner-bottom ui-tabs-hide" );

		if ( index >= this.lis.length ) {
			$li.appendTo( this.list );
			$panel.appendTo( this.list[ 0 ].parentNode );
		} else {
			$li.insertBefore( this.lis[ index ] );
			$panel.insertBefore( this.panels[ index ] );
		}

		o.disabled = $.map( o.disabled, function( n, i ) {
			return n >= index ? ++n : n;
		});

		this._tabify();

		if ( this.anchors.length == 1 ) {
			o.selected = 0;
			$li.addClass( "ui-tabs-selected ui-state-active" );
			$panel.removeClass( "ui-tabs-hide" );
			this.element.queue( "tabs", function() {
				self._trigger( "show", null, self._ui( self.anchors[ 0 ], self.panels[ 0 ] ) );
			});

			this.load( 0 );
		}

		this._trigger( "add", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		return this;
	},

	remove: function( index ) {
		index = this._getIndex( index );
		var o = this.options,
			$li = this.lis.eq( index ).remove(),
			$panel = this.panels.eq( index ).remove();

		// If selected tab was removed focus tab to the right or
		// in case the last tab was removed the tab to the left.
		if ( $li.hasClass( "ui-tabs-selected" ) && this.anchors.length > 1) {
			this.select( index + ( index + 1 < this.anchors.length ? 1 : -1 ) );
		}

		o.disabled = $.map(
			$.grep( o.disabled, function(n, i) {
				return n != index;
			}),
			function( n, i ) {
				return n >= index ? --n : n;
			});

		this._tabify();

		this._trigger( "remove", null, this._ui( $li.find( "a" )[ 0 ], $panel[ 0 ] ) );
		return this;
	},

	enable: function( index ) {
		index = this._getIndex( index );
		var o = this.options;
		if ( $.inArray( index, o.disabled ) == -1 ) {
			return;
		}

		this.lis.eq( index ).removeClass( "ui-state-disabled" );
		o.disabled = $.grep( o.disabled, function( n, i ) {
			return n != index;
		});

		this._trigger( "enable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		return this;
	},

	disable: function( index ) {
		index = this._getIndex( index );
		var self = this, o = this.options;
		// cannot disable already selected tab
		if ( index != o.selected ) {
			this.lis.eq( index ).addClass( "ui-state-disabled" );

			o.disabled.push( index );
			o.disabled.sort();

			this._trigger( "disable", null, this._ui( this.anchors[ index ], this.panels[ index ] ) );
		}

		return this;
	},

	select: function( index ) {
		index = this._getIndex( index );
		if ( index == -1 ) {
			if ( this.options.collapsible && this.options.selected != -1 ) {
				index = this.options.selected;
			} else {
				return this;
			}
		}
		this.anchors.eq( index ).trigger( this.options.event + ".tabs" );
		return this;
	},

	load: function( index ) {
		index = this._getIndex( index );
		var self = this,
			o = this.options,
			a = this.anchors.eq( index )[ 0 ],
			url = $.data( a, "load.tabs" );

		this.abort();

		// not remote or from cache
		if ( !url || this.element.queue( "tabs" ).length !== 0 && $.data( a, "cache.tabs" ) ) {
			this.element.dequeue( "tabs" );
			return;
		}

		// load remote from here on
		this.lis.eq( index ).addClass( "ui-state-processing" );

		if ( o.spinner ) {
			var span = $( "span", a );
			span.data( "label.tabs", span.html() ).html( o.spinner );
		}

		this.xhr = $.ajax( $.extend( {}, o.ajaxOptions, {
			url: url,
			success: function( r, s ) {
				self.element.find( self._sanitizeSelector( a.hash ) ).html( r );

				// take care of tab labels
				self._cleanup();

				if ( o.cache ) {
					$.data( a, "cache.tabs", true );
				}

				self._trigger( "load", null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
				try {
					o.ajaxOptions.success( r, s );
				}
				catch ( e ) {}
			},
			error: function( xhr, s, e ) {
				// take care of tab labels
				self._cleanup();

				self._trigger( "load", null, self._ui( self.anchors[ index ], self.panels[ index ] ) );
				try {
					// Passing index avoid a race condition when this method is
					// called after the user has selected another tab.
					// Pass the anchor that initiated this request allows
					// loadError to manipulate the tab content panel via $(a.hash)
					o.ajaxOptions.error( xhr, s, index, a );
				}
				catch ( e ) {}
			}
		} ) );

		// last, so that load event is fired before show...
		self.element.dequeue( "tabs" );

		return this;
	},

	abort: function() {
		// stop possibly running animations
		this.element.queue( [] );
		this.panels.stop( false, true );

		// "tabs" queue must not contain more than two elements,
		// which are the callbacks for the latest clicked tab...
		this.element.queue( "tabs", this.element.queue( "tabs" ).splice( -2, 2 ) );

		// terminate pending requests from other tabs
		if ( this.xhr ) {
			this.xhr.abort();
			delete this.xhr;
		}

		// take care of tab labels
		this._cleanup();
		return this;
	},

	url: function( index, url ) {
		this.anchors.eq( index ).removeData( "cache.tabs" ).data( "load.tabs", url );
		return this;
	},

	length: function() {
		return this.anchors.length;
	}
});

$.extend( $.ui.tabs, {
	version: "1.8.21"
});

/*
 * Tabs Extensions
 */

/*
 * Rotate
 */
$.extend( $.ui.tabs.prototype, {
	rotation: null,
	rotate: function( ms, continuing ) {
		var self = this,
			o = this.options;

		var rotate = self._rotate || ( self._rotate = function( e ) {
			clearTimeout( self.rotation );
			self.rotation = setTimeout(function() {
				var t = o.selected;
				self.select( ++t < self.anchors.length ? t : 0 );
			}, ms );
			
			if ( e ) {
				e.stopPropagation();
			}
		});

		var stop = self._unrotate || ( self._unrotate = !continuing
			? function(e) {
				if (e.clientX) { // in case of a true click
					self.rotate(null);
				}
			}
			: function( e ) {
				rotate();
			});

		// start rotation
		if ( ms ) {
			this.element.bind( "tabsshow", rotate );
			this.anchors.bind( o.event + ".tabs", stop );
			rotate();
		// stop rotation
		} else {
			clearTimeout( self.rotation );
			this.element.unbind( "tabsshow", rotate );
			this.anchors.unbind( o.event + ".tabs", stop );
			delete this._rotate;
			delete this._unrotate;
		}

		return this;
	}
});

})( jQuery );
/*!
 * jQuery UI Datepicker 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Datepicker
 *
 * Depends:
 *	jquery.ui.core.js
 */
(function( $, undefined ) {

$.extend($.ui, { datepicker: { version: "1.8.21" } });

var PROP_NAME = 'datepicker';
var dpuuid = new Date().getTime();
var instActive;

/* Date picker manager.
   Use the singleton instance of this class, $.datepicker, to interact with the date picker.
   Settings for (groups of) date pickers are maintained in an instance object,
   allowing multiple different settings on the same page. */

function Datepicker() {
	this.debug = false; // Change this to true to start debugging
	this._curInst = null; // The current instance in use
	this._keyEvent = false; // If the last event was a key event
	this._disabledInputs = []; // List of date picker inputs that have been disabled
	this._datepickerShowing = false; // True if the popup picker is showing , false if not
	this._inDialog = false; // True if showing within a "dialog", false if not
	this._mainDivId = 'ui-datepicker-div'; // The ID of the main datepicker division
	this._inlineClass = 'ui-datepicker-inline'; // The name of the inline marker class
	this._appendClass = 'ui-datepicker-append'; // The name of the append marker class
	this._triggerClass = 'ui-datepicker-trigger'; // The name of the trigger marker class
	this._dialogClass = 'ui-datepicker-dialog'; // The name of the dialog marker class
	this._disableClass = 'ui-datepicker-disabled'; // The name of the disabled covering marker class
	this._unselectableClass = 'ui-datepicker-unselectable'; // The name of the unselectable cell marker class
	this._currentClass = 'ui-datepicker-current-day'; // The name of the current day marker class
	this._dayOverClass = 'ui-datepicker-days-cell-over'; // The name of the day hover marker class
	this.regional = []; // Available regional settings, indexed by language code
	this.regional[''] = { // Default regional settings
		closeText: 'Done', // Display text for close link
		prevText: 'Prev', // Display text for previous month link
		nextText: 'Next', // Display text for next month link
		currentText: 'Today', // Display text for current month link
		monthNames: ['January','February','March','April','May','June',
			'July','August','September','October','November','December'], // Names of months for drop-down and formatting
		monthNamesShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'], // For formatting
		dayNames: ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], // For formatting
		dayNamesShort: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'], // For formatting
		dayNamesMin: ['Su','Mo','Tu','We','Th','Fr','Sa'], // Column headings for days starting at Sunday
		weekHeader: 'Wk', // Column header for week of the year
		dateFormat: 'mm/dd/yy', // See format options on parseDate
		firstDay: 0, // The first day of the week, Sun = 0, Mon = 1, ...
		isRTL: false, // True if right-to-left language, false if left-to-right
		showMonthAfterYear: false, // True if the year select precedes month, false for month then year
		yearSuffix: '' // Additional text to append to the year in the month headers
	};
	this._defaults = { // Global defaults for all the date picker instances
		showOn: 'focus', // 'focus' for popup on focus,
			// 'button' for trigger button, or 'both' for either
		showAnim: 'fadeIn', // Name of jQuery animation for popup
		showOptions: {}, // Options for enhanced animations
		defaultDate: null, // Used when field is blank: actual date,
			// +/-number for offset from today, null for today
		appendText: '', // Display text following the input box, e.g. showing the format
		buttonText: '...', // Text for trigger button
		buttonImage: '', // URL for trigger button image
		buttonImageOnly: false, // True if the image appears alone, false if it appears on a button
		hideIfNoPrevNext: false, // True to hide next/previous month links
			// if not applicable, false to just disable them
		navigationAsDateFormat: false, // True if date formatting applied to prev/today/next links
		gotoCurrent: false, // True if today link goes back to current selection instead
		changeMonth: false, // True if month can be selected directly, false if only prev/next
		changeYear: false, // True if year can be selected directly, false if only prev/next
		yearRange: 'c-10:c+10', // Range of years to display in drop-down,
			// either relative to today's year (-nn:+nn), relative to currently displayed year
			// (c-nn:c+nn), absolute (nnnn:nnnn), or a combination of the above (nnnn:-n)
		showOtherMonths: false, // True to show dates in other months, false to leave blank
		selectOtherMonths: false, // True to allow selection of dates in other months, false for unselectable
		showWeek: false, // True to show week of the year, false to not show it
		calculateWeek: this.iso8601Week, // How to calculate the week of the year,
			// takes a Date and returns the number of the week for it
		shortYearCutoff: '+10', // Short year values < this are in the current century,
			// > this are in the previous century,
			// string value starting with '+' for current year + value
		minDate: null, // The earliest selectable date, or null for no limit
		maxDate: null, // The latest selectable date, or null for no limit
		duration: 'fast', // Duration of display/closure
		beforeShowDay: null, // Function that takes a date and returns an array with
			// [0] = true if selectable, false if not, [1] = custom CSS class name(s) or '',
			// [2] = cell title (optional), e.g. $.datepicker.noWeekends
		beforeShow: null, // Function that takes an input field and
			// returns a set of custom settings for the date picker
		onSelect: null, // Define a callback function when a date is selected
		onChangeMonthYear: null, // Define a callback function when the month or year is changed
		onClose: null, // Define a callback function when the datepicker is closed
		numberOfMonths: 1, // Number of months to show at a time
		showCurrentAtPos: 0, // The position in multipe months at which to show the current month (starting at 0)
		stepMonths: 1, // Number of months to step back/forward
		stepBigMonths: 12, // Number of months to step back/forward for the big links
		altField: '', // Selector for an alternate field to store selected dates into
		altFormat: '', // The date format to use for the alternate field
		constrainInput: true, // The input is constrained by the current date format
		showButtonPanel: false, // True to show button panel, false to not show it
		autoSize: false, // True to size the input for the date format, false to leave as is
		disabled: false // The initial disabled state
	};
	$.extend(this._defaults, this.regional['']);
	this.dpDiv = bindHover($('<div id="' + this._mainDivId + '" class="ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>'));
}

$.extend(Datepicker.prototype, {
	/* Class name added to elements to indicate already configured with a date picker. */
	markerClassName: 'hasDatepicker',
	
	//Keep track of the maximum number of rows displayed (see #7043)
	maxRows: 4,

	/* Debug logging (if enabled). */
	log: function () {
		if (this.debug)
			console.log.apply('', arguments);
	},
	
	// TODO rename to "widget" when switching to widget factory
	_widgetDatepicker: function() {
		return this.dpDiv;
	},

	/* Override the default settings for all instances of the date picker.
	   @param  settings  object - the new settings to use as defaults (anonymous object)
	   @return the manager object */
	setDefaults: function(settings) {
		extendRemove(this._defaults, settings || {});
		return this;
	},

	/* Attach the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span
	   @param  settings  object - the new settings to use for this date picker instance (anonymous) */
	_attachDatepicker: function(target, settings) {
		// check for settings on the control itself - in namespace 'date:'
		var inlineSettings = null;
		for (var attrName in this._defaults) {
			var attrValue = target.getAttribute('date:' + attrName);
			if (attrValue) {
				inlineSettings = inlineSettings || {};
				try {
					inlineSettings[attrName] = eval(attrValue);
				} catch (err) {
					inlineSettings[attrName] = attrValue;
				}
			}
		}
		var nodeName = target.nodeName.toLowerCase();
		var inline = (nodeName == 'div' || nodeName == 'span');
		if (!target.id) {
			this.uuid += 1;
			target.id = 'dp' + this.uuid;
		}
		var inst = this._newInst($(target), inline);
		inst.settings = $.extend({}, settings || {}, inlineSettings || {});
		if (nodeName == 'input') {
			this._connectDatepicker(target, inst);
		} else if (inline) {
			this._inlineDatepicker(target, inst);
		}
	},

	/* Create a new instance object. */
	_newInst: function(target, inline) {
		var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
		return {id: id, input: target, // associated target
			selectedDay: 0, selectedMonth: 0, selectedYear: 0, // current selection
			drawMonth: 0, drawYear: 0, // month being drawn
			inline: inline, // is datepicker inline or not
			dpDiv: (!inline ? this.dpDiv : // presentation div
			bindHover($('<div class="' + this._inlineClass + ' ui-datepicker ui-widget ui-widget-content ui-helper-clearfix ui-corner-all"></div>')))};
	},

	/* Attach the date picker to an input field. */
	_connectDatepicker: function(target, inst) {
		var input = $(target);
		inst.append = $([]);
		inst.trigger = $([]);
		if (input.hasClass(this.markerClassName))
			return;
		this._attachments(input, inst);
		input.addClass(this.markerClassName).keydown(this._doKeyDown).
			keypress(this._doKeyPress).keyup(this._doKeyUp).
			bind("setData.datepicker", function(event, key, value) {
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key) {
				return this._get(inst, key);
			});
		this._autoSize(inst);
		$.data(target, PROP_NAME, inst);
		//If disabled option is true, disable the datepicker once it has been attached to the input (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
	},

	/* Make attachments based on settings. */
	_attachments: function(input, inst) {
		var appendText = this._get(inst, 'appendText');
		var isRTL = this._get(inst, 'isRTL');
		if (inst.append)
			inst.append.remove();
		if (appendText) {
			inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
			input[isRTL ? 'before' : 'after'](inst.append);
		}
		input.unbind('focus', this._showDatepicker);
		if (inst.trigger)
			inst.trigger.remove();
		var showOn = this._get(inst, 'showOn');
		if (showOn == 'focus' || showOn == 'both') // pop-up date picker when in the marked field
			input.focus(this._showDatepicker);
		if (showOn == 'button' || showOn == 'both') { // pop-up date picker when button clicked
			var buttonText = this._get(inst, 'buttonText');
			var buttonImage = this._get(inst, 'buttonImage');
			inst.trigger = $(this._get(inst, 'buttonImageOnly') ?
				$('<img/>').addClass(this._triggerClass).
					attr({ src: buttonImage, alt: buttonText, title: buttonText }) :
				$('<button type="button"></button>').addClass(this._triggerClass).
					html(buttonImage == '' ? buttonText : $('<img/>').attr(
					{ src:buttonImage, alt:buttonText, title:buttonText })));
			input[isRTL ? 'before' : 'after'](inst.trigger);
			inst.trigger.click(function() {
				if ($.datepicker._datepickerShowing && $.datepicker._lastInput == input[0])
					$.datepicker._hideDatepicker();
				else if ($.datepicker._datepickerShowing && $.datepicker._lastInput != input[0]) {
					$.datepicker._hideDatepicker(); 
					$.datepicker._showDatepicker(input[0]);
				} else
					$.datepicker._showDatepicker(input[0]);
				return false;
			});
		}
	},

	/* Apply the maximum length for the date format. */
	_autoSize: function(inst) {
		if (this._get(inst, 'autoSize') && !inst.inline) {
			var date = new Date(2009, 12 - 1, 20); // Ensure double digits
			var dateFormat = this._get(inst, 'dateFormat');
			if (dateFormat.match(/[DM]/)) {
				var findMax = function(names) {
					var max = 0;
					var maxI = 0;
					for (var i = 0; i < names.length; i++) {
						if (names[i].length > max) {
							max = names[i].length;
							maxI = i;
						}
					}
					return maxI;
				};
				date.setMonth(findMax(this._get(inst, (dateFormat.match(/MM/) ?
					'monthNames' : 'monthNamesShort'))));
				date.setDate(findMax(this._get(inst, (dateFormat.match(/DD/) ?
					'dayNames' : 'dayNamesShort'))) + 20 - date.getDay());
			}
			inst.input.attr('size', this._formatDate(inst, date).length);
		}
	},

	/* Attach an inline date picker to a div. */
	_inlineDatepicker: function(target, inst) {
		var divSpan = $(target);
		if (divSpan.hasClass(this.markerClassName))
			return;
		divSpan.addClass(this.markerClassName).append(inst.dpDiv).
			bind("setData.datepicker", function(event, key, value){
				inst.settings[key] = value;
			}).bind("getData.datepicker", function(event, key){
				return this._get(inst, key);
			});
		$.data(target, PROP_NAME, inst);
		this._setDate(inst, this._getDefaultDate(inst), true);
		this._updateDatepicker(inst);
		this._updateAlternate(inst);
		//If disabled option is true, disable the datepicker before showing it (see ticket #5665)
		if( inst.settings.disabled ) {
			this._disableDatepicker( target );
		}
		// Set display:block in place of inst.dpDiv.show() which won't work on disconnected elements
		// http://bugs.jqueryui.com/ticket/7552 - A Datepicker created on a detached div has zero height
		inst.dpDiv.css( "display", "block" );
	},

	/* Pop-up the date picker in a "dialog" box.
	   @param  input     element - ignored
	   @param  date      string or Date - the initial date to display
	   @param  onSelect  function - the function to call when a date is selected
	   @param  settings  object - update the dialog date picker instance's settings (anonymous object)
	   @param  pos       int[2] - coordinates for the dialog's position within the screen or
	                     event - with x/y coordinates or
	                     leave empty for default (screen centre)
	   @return the manager object */
	_dialogDatepicker: function(input, date, onSelect, settings, pos) {
		var inst = this._dialogInst; // internal instance
		if (!inst) {
			this.uuid += 1;
			var id = 'dp' + this.uuid;
			this._dialogInput = $('<input type="text" id="' + id +
				'" style="position: absolute; top: -100px; width: 0px; z-index: -10;"/>');
			this._dialogInput.keydown(this._doKeyDown);
			$('body').append(this._dialogInput);
			inst = this._dialogInst = this._newInst(this._dialogInput, false);
			inst.settings = {};
			$.data(this._dialogInput[0], PROP_NAME, inst);
		}
		extendRemove(inst.settings, settings || {});
		date = (date && date.constructor == Date ? this._formatDate(inst, date) : date);
		this._dialogInput.val(date);

		this._pos = (pos ? (pos.length ? pos : [pos.pageX, pos.pageY]) : null);
		if (!this._pos) {
			var browserWidth = document.documentElement.clientWidth;
			var browserHeight = document.documentElement.clientHeight;
			var scrollX = document.documentElement.scrollLeft || document.body.scrollLeft;
			var scrollY = document.documentElement.scrollTop || document.body.scrollTop;
			this._pos = // should use actual width/height below
				[(browserWidth / 2) - 100 + scrollX, (browserHeight / 2) - 150 + scrollY];
		}

		// move input on screen for focus, but hidden behind dialog
		this._dialogInput.css('left', (this._pos[0] + 20) + 'px').css('top', this._pos[1] + 'px');
		inst.settings.onSelect = onSelect;
		this._inDialog = true;
		this.dpDiv.addClass(this._dialogClass);
		this._showDatepicker(this._dialogInput[0]);
		if ($.blockUI)
			$.blockUI(this.dpDiv);
		$.data(this._dialogInput[0], PROP_NAME, inst);
		return this;
	},

	/* Detach a datepicker from its control.
	   @param  target    element - the target input field or division or span */
	_destroyDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		$.removeData(target, PROP_NAME);
		if (nodeName == 'input') {
            if (inst){
	    		inst.append.remove();
    			inst.trigger.remove();
            }
			$target.removeClass(this.markerClassName).
				unbind('focus', this._showDatepicker).
				unbind('keydown', this._doKeyDown).
				unbind('keypress', this._doKeyPress).
				unbind('keyup', this._doKeyUp);
		} else if (nodeName == 'div' || nodeName == 'span')
			$target.removeClass(this.markerClassName).empty();
	},

	/* Enable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_enableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = false;
			inst.trigger.filter('button').
				each(function() { this.disabled = false; }).end().
				filter('img').css({opacity: '1.0', cursor: ''});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().removeClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				removeAttr("disabled");
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
	},

	/* Disable the date picker to a jQuery selection.
	   @param  target    element - the target input field or division or span */
	_disableDatepicker: function(target) {
		var $target = $(target);
		var inst = $.data(target, PROP_NAME);
		if (!$target.hasClass(this.markerClassName)) {
			return;
		}
		var nodeName = target.nodeName.toLowerCase();
		if (nodeName == 'input') {
			target.disabled = true;
			inst.trigger.filter('button').
				each(function() { this.disabled = true; }).end().
				filter('img').css({opacity: '0.5', cursor: 'default'});
		}
		else if (nodeName == 'div' || nodeName == 'span') {
			var inline = $target.children('.' + this._inlineClass);
			inline.children().addClass('ui-state-disabled');
			inline.find("select.ui-datepicker-month, select.ui-datepicker-year").
				attr("disabled", "disabled");
		}
		this._disabledInputs = $.map(this._disabledInputs,
			function(value) { return (value == target ? null : value); }); // delete entry
		this._disabledInputs[this._disabledInputs.length] = target;
	},

	/* Is the first field in a jQuery collection disabled as a datepicker?
	   @param  target    element - the target input field or division or span
	   @return boolean - true if disabled, false if enabled */
	_isDisabledDatepicker: function(target) {
		if (!target) {
			return false;
		}
		for (var i = 0; i < this._disabledInputs.length; i++) {
			if (this._disabledInputs[i] == target)
				return true;
		}
		return false;
	},

	/* Retrieve the instance data for the target control.
	   @param  target  element - the target input field or division or span
	   @return  object - the associated instance data
	   @throws  error if a jQuery problem getting data */
	_getInst: function(target) {
		try {
			return $.data(target, PROP_NAME);
		}
		catch (err) {
			throw 'Missing instance data for this datepicker';
		}
	},

	/* Update or retrieve the settings for a date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span
	   @param  name    object - the new settings to update or
	                   string - the name of the setting to change or retrieve,
	                   when retrieving also 'all' for all instance settings or
	                   'defaults' for all global defaults
	   @param  value   any - the new value for the setting
	                   (omit if above is an object or to retrieve a value) */
	_optionDatepicker: function(target, name, value) {
		var inst = this._getInst(target);
		if (arguments.length == 2 && typeof name == 'string') {
			return (name == 'defaults' ? $.extend({}, $.datepicker._defaults) :
				(inst ? (name == 'all' ? $.extend({}, inst.settings) :
				this._get(inst, name)) : null));
		}
		var settings = name || {};
		if (typeof name == 'string') {
			settings = {};
			settings[name] = value;
		}
		if (inst) {
			if (this._curInst == inst) {
				this._hideDatepicker();
			}
			var date = this._getDateDatepicker(target, true);
			var minDate = this._getMinMaxDate(inst, 'min');
			var maxDate = this._getMinMaxDate(inst, 'max');
			extendRemove(inst.settings, settings);
			// reformat the old minDate/maxDate values if dateFormat changes and a new minDate/maxDate isn't provided
			if (minDate !== null && settings['dateFormat'] !== undefined && settings['minDate'] === undefined)
				inst.settings.minDate = this._formatDate(inst, minDate);
			if (maxDate !== null && settings['dateFormat'] !== undefined && settings['maxDate'] === undefined)
				inst.settings.maxDate = this._formatDate(inst, maxDate);
			this._attachments($(target), inst);
			this._autoSize(inst);
			this._setDate(inst, date);
			this._updateAlternate(inst);
			this._updateDatepicker(inst);
		}
	},

	// change method deprecated
	_changeDatepicker: function(target, name, value) {
		this._optionDatepicker(target, name, value);
	},

	/* Redraw the date picker attached to an input field or division.
	   @param  target  element - the target input field or division or span */
	_refreshDatepicker: function(target) {
		var inst = this._getInst(target);
		if (inst) {
			this._updateDatepicker(inst);
		}
	},

	/* Set the dates for a jQuery selection.
	   @param  target   element - the target input field or division or span
	   @param  date     Date - the new date */
	_setDateDatepicker: function(target, date) {
		var inst = this._getInst(target);
		if (inst) {
			this._setDate(inst, date);
			this._updateDatepicker(inst);
			this._updateAlternate(inst);
		}
	},

	/* Get the date(s) for the first entry in a jQuery selection.
	   @param  target     element - the target input field or division or span
	   @param  noDefault  boolean - true if no default date is to be used
	   @return Date - the current date */
	_getDateDatepicker: function(target, noDefault) {
		var inst = this._getInst(target);
		if (inst && !inst.inline)
			this._setDateFromField(inst, noDefault);
		return (inst ? this._getDate(inst) : null);
	},

	/* Handle keystrokes. */
	_doKeyDown: function(event) {
		var inst = $.datepicker._getInst(event.target);
		var handled = true;
		var isRTL = inst.dpDiv.is('.ui-datepicker-rtl');
		inst._keyEvent = true;
		if ($.datepicker._datepickerShowing)
			switch (event.keyCode) {
				case 9: $.datepicker._hideDatepicker();
						handled = false;
						break; // hide on tab out
				case 13: var sel = $('td.' + $.datepicker._dayOverClass + ':not(.' + 
									$.datepicker._currentClass + ')', inst.dpDiv);
						if (sel[0])
							$.datepicker._selectDay(event.target, inst.selectedMonth, inst.selectedYear, sel[0]);
							var onSelect = $.datepicker._get(inst, 'onSelect');
							if (onSelect) {
								var dateStr = $.datepicker._formatDate(inst);

								// trigger custom callback
								onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);
							}
						else
							$.datepicker._hideDatepicker();
						return false; // don't submit the form
						break; // select the value on enter
				case 27: $.datepicker._hideDatepicker();
						break; // hide on escape
				case 33: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							-$.datepicker._get(inst, 'stepBigMonths') :
							-$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // previous month/year on page up/+ ctrl
				case 34: $.datepicker._adjustDate(event.target, (event.ctrlKey ?
							+$.datepicker._get(inst, 'stepBigMonths') :
							+$.datepicker._get(inst, 'stepMonths')), 'M');
						break; // next month/year on page down/+ ctrl
				case 35: if (event.ctrlKey || event.metaKey) $.datepicker._clearDate(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // clear on ctrl or command +end
				case 36: if (event.ctrlKey || event.metaKey) $.datepicker._gotoToday(event.target);
						handled = event.ctrlKey || event.metaKey;
						break; // current on ctrl or command +home
				case 37: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? +1 : -1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// -1 day on ctrl or command +left
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									-$.datepicker._get(inst, 'stepBigMonths') :
									-$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +left on Mac
						break;
				case 38: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, -7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // -1 week on ctrl or command +up
				case 39: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, (isRTL ? -1 : +1), 'D');
						handled = event.ctrlKey || event.metaKey;
						// +1 day on ctrl or command +right
						if (event.originalEvent.altKey) $.datepicker._adjustDate(event.target, (event.ctrlKey ?
									+$.datepicker._get(inst, 'stepBigMonths') :
									+$.datepicker._get(inst, 'stepMonths')), 'M');
						// next month/year on alt +right
						break;
				case 40: if (event.ctrlKey || event.metaKey) $.datepicker._adjustDate(event.target, +7, 'D');
						handled = event.ctrlKey || event.metaKey;
						break; // +1 week on ctrl or command +down
				default: handled = false;
			}
		else if (event.keyCode == 36 && event.ctrlKey) // display the date picker on ctrl+home
			$.datepicker._showDatepicker(this);
		else {
			handled = false;
		}
		if (handled) {
			event.preventDefault();
			event.stopPropagation();
		}
	},

	/* Filter entered characters - based on date format. */
	_doKeyPress: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if ($.datepicker._get(inst, 'constrainInput')) {
			var chars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat'));
			var chr = String.fromCharCode(event.charCode == undefined ? event.keyCode : event.charCode);
			return event.ctrlKey || event.metaKey || (chr < ' ' || !chars || chars.indexOf(chr) > -1);
		}
	},

	/* Synchronise manual entry and field/alternate field. */
	_doKeyUp: function(event) {
		var inst = $.datepicker._getInst(event.target);
		if (inst.input.val() != inst.lastVal) {
			try {
				var date = $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					(inst.input ? inst.input.val() : null),
					$.datepicker._getFormatConfig(inst));
				if (date) { // only if valid
					$.datepicker._setDateFromField(inst);
					$.datepicker._updateAlternate(inst);
					$.datepicker._updateDatepicker(inst);
				}
			}
			catch (err) {
				$.datepicker.log(err);
			}
		}
		return true;
	},

	/* Pop-up the date picker for a given input field.
       If false returned from beforeShow event handler do not show. 
	   @param  input  element - the input field attached to the date picker or
	                  event - if triggered by focus */
	_showDatepicker: function(input) {
		input = input.target || input;
		if (input.nodeName.toLowerCase() != 'input') // find from button/image trigger
			input = $('input', input.parentNode)[0];
		if ($.datepicker._isDisabledDatepicker(input) || $.datepicker._lastInput == input) // already here
			return;
		var inst = $.datepicker._getInst(input);
		if ($.datepicker._curInst && $.datepicker._curInst != inst) {
			$.datepicker._curInst.dpDiv.stop(true, true);
			if ( inst && $.datepicker._datepickerShowing ) {
				$.datepicker._hideDatepicker( $.datepicker._curInst.input[0] );
			}
		}
		var beforeShow = $.datepicker._get(inst, 'beforeShow');
		var beforeShowSettings = beforeShow ? beforeShow.apply(input, [input, inst]) : {};
		if(beforeShowSettings === false){
            //false
			return;
		}
		extendRemove(inst.settings, beforeShowSettings);
		inst.lastVal = null;
		$.datepicker._lastInput = input;
		$.datepicker._setDateFromField(inst);
		if ($.datepicker._inDialog) // hide cursor
			input.value = '';
		if (!$.datepicker._pos) { // position below input
			$.datepicker._pos = $.datepicker._findPos(input);
			$.datepicker._pos[1] += input.offsetHeight; // add the height
		}
		var isFixed = false;
		$(input).parents().each(function() {
			isFixed |= $(this).css('position') == 'fixed';
			return !isFixed;
		});
		if (isFixed && $.browser.opera) { // correction for Opera when fixed and scrolled
			$.datepicker._pos[0] -= document.documentElement.scrollLeft;
			$.datepicker._pos[1] -= document.documentElement.scrollTop;
		}
		var offset = {left: $.datepicker._pos[0], top: $.datepicker._pos[1]};
		$.datepicker._pos = null;
		//to avoid flashes on Firefox
		inst.dpDiv.empty();
		// determine sizing offscreen
		inst.dpDiv.css({position: 'absolute', display: 'block', top: '-1000px'});
		$.datepicker._updateDatepicker(inst);
		// fix width for dynamic number of date pickers
		// and adjust position before showing
		offset = $.datepicker._checkOffset(inst, offset, isFixed);
		inst.dpDiv.css({position: ($.datepicker._inDialog && $.blockUI ?
			'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
			left: offset.left + 'px', top: offset.top + 'px'});
		if (!inst.inline) {
			var showAnim = $.datepicker._get(inst, 'showAnim');
			var duration = $.datepicker._get(inst, 'duration');
			var postProcess = function() {
				var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
				if( !! cover.length ){
					var borders = $.datepicker._getBorders(inst.dpDiv);
					cover.css({left: -borders[0], top: -borders[1],
						width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()});
				}
			};
			inst.dpDiv.zIndex($(input).zIndex()+1);
			$.datepicker._datepickerShowing = true;
			if ($.effects && $.effects[showAnim])
				inst.dpDiv.show(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
			if (!showAnim || !duration)
				postProcess();
			if (inst.input.is(':visible') && !inst.input.is(':disabled'))
				inst.input.focus();
			$.datepicker._curInst = inst;
		}
	},

	/* Generate the date picker content. */
	_updateDatepicker: function(inst) {
		var self = this;
		self.maxRows = 4; //Reset the max number of rows being displayed (see #7043)
		var borders = $.datepicker._getBorders(inst.dpDiv);
		instActive = inst; // for delegate hover events
		inst.dpDiv.empty().append(this._generateHTML(inst));
		var cover = inst.dpDiv.find('iframe.ui-datepicker-cover'); // IE6- only
		if( !!cover.length ){ //avoid call to outerXXXX() when not in IE6
			cover.css({left: -borders[0], top: -borders[1], width: inst.dpDiv.outerWidth(), height: inst.dpDiv.outerHeight()})
		}
		inst.dpDiv.find('.' + this._dayOverClass + ' a').mouseover();
		var numMonths = this._getNumberOfMonths(inst);
		var cols = numMonths[1];
		var width = 17;
		inst.dpDiv.removeClass('ui-datepicker-multi-2 ui-datepicker-multi-3 ui-datepicker-multi-4').width('');
		if (cols > 1)
			inst.dpDiv.addClass('ui-datepicker-multi-' + cols).css('width', (width * cols) + 'em');
		inst.dpDiv[(numMonths[0] != 1 || numMonths[1] != 1 ? 'add' : 'remove') +
			'Class']('ui-datepicker-multi');
		inst.dpDiv[(this._get(inst, 'isRTL') ? 'add' : 'remove') +
			'Class']('ui-datepicker-rtl');
		if (inst == $.datepicker._curInst && $.datepicker._datepickerShowing && inst.input &&
				// #6694 - don't focus the input if it's already focused
				// this breaks the change event in IE
				inst.input.is(':visible') && !inst.input.is(':disabled') && inst.input[0] != document.activeElement)
			inst.input.focus();
		// deffered render of the years select (to avoid flashes on Firefox) 
		if( inst.yearshtml ){
			var origyearshtml = inst.yearshtml;
			setTimeout(function(){
				//assure that inst.yearshtml didn't change.
				if( origyearshtml === inst.yearshtml && inst.yearshtml ){
					inst.dpDiv.find('select.ui-datepicker-year:first').replaceWith(inst.yearshtml);
				}
				origyearshtml = inst.yearshtml = null;
			}, 0);
		}
	},

	/* Retrieve the size of left and top borders for an element.
	   @param  elem  (jQuery object) the element of interest
	   @return  (number[2]) the left and top borders */
	_getBorders: function(elem) {
		var convert = function(value) {
			return {thin: 1, medium: 2, thick: 3}[value] || value;
		};
		return [parseFloat(convert(elem.css('border-left-width'))),
			parseFloat(convert(elem.css('border-top-width')))];
	},

	/* Check positioning to remain on screen. */
	_checkOffset: function(inst, offset, isFixed) {
		var dpWidth = inst.dpDiv.outerWidth();
		var dpHeight = inst.dpDiv.outerHeight();
		var inputWidth = inst.input ? inst.input.outerWidth() : 0;
		var inputHeight = inst.input ? inst.input.outerHeight() : 0;
		var viewWidth = document.documentElement.clientWidth + $(document).scrollLeft();
		var viewHeight = document.documentElement.clientHeight + $(document).scrollTop();

		offset.left -= (this._get(inst, 'isRTL') ? (dpWidth - inputWidth) : 0);
		offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
		offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

		// now check if datepicker is showing outside window viewport - move to a better place if so.
		offset.left -= Math.min(offset.left, (offset.left + dpWidth > viewWidth && viewWidth > dpWidth) ?
			Math.abs(offset.left + dpWidth - viewWidth) : 0);
		offset.top -= Math.min(offset.top, (offset.top + dpHeight > viewHeight && viewHeight > dpHeight) ?
			Math.abs(dpHeight + inputHeight) : 0);

		return offset;
	},

	/* Find an object's position on the screen. */
	_findPos: function(obj) {
		var inst = this._getInst(obj);
		var isRTL = this._get(inst, 'isRTL');
        while (obj && (obj.type == 'hidden' || obj.nodeType != 1 || $.expr.filters.hidden(obj))) {
            obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
        }
        var position = $(obj).offset();
	    return [position.left, position.top];
	},

	/* Hide the date picker from view.
	   @param  input  element - the input field attached to the date picker */
	_hideDatepicker: function(input) {
		var inst = this._curInst;
		if (!inst || (input && inst != $.data(input, PROP_NAME)))
			return;
		if (this._datepickerShowing) {
			var showAnim = this._get(inst, 'showAnim');
			var duration = this._get(inst, 'duration');
			var postProcess = function() {
				$.datepicker._tidyDialog(inst);
			};
			if ($.effects && $.effects[showAnim])
				inst.dpDiv.hide(showAnim, $.datepicker._get(inst, 'showOptions'), duration, postProcess);
			else
				inst.dpDiv[(showAnim == 'slideDown' ? 'slideUp' :
					(showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
			if (!showAnim)
				postProcess();
			this._datepickerShowing = false;
			var onClose = this._get(inst, 'onClose');
			if (onClose)
				onClose.apply((inst.input ? inst.input[0] : null),
					[(inst.input ? inst.input.val() : ''), inst]);
			this._lastInput = null;
			if (this._inDialog) {
				this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
				if ($.blockUI) {
					$.unblockUI();
					$('body').append(this.dpDiv);
				}
			}
			this._inDialog = false;
		}
	},

	/* Tidy up after a dialog display. */
	_tidyDialog: function(inst) {
		inst.dpDiv.removeClass(this._dialogClass).unbind('.ui-datepicker-calendar');
	},

	/* Close date picker if clicked elsewhere. */
	_checkExternalClick: function(event) {
		if (!$.datepicker._curInst)
			return;

		var $target = $(event.target),
			inst = $.datepicker._getInst($target[0]);

		if ( ( ( $target[0].id != $.datepicker._mainDivId &&
				$target.parents('#' + $.datepicker._mainDivId).length == 0 &&
				!$target.hasClass($.datepicker.markerClassName) &&
				!$target.closest("." + $.datepicker._triggerClass).length &&
				$.datepicker._datepickerShowing && !($.datepicker._inDialog && $.blockUI) ) ) ||
			( $target.hasClass($.datepicker.markerClassName) && $.datepicker._curInst != inst ) )
			$.datepicker._hideDatepicker();
	},

	/* Adjust one of the date sub-fields. */
	_adjustDate: function(id, offset, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._isDisabledDatepicker(target[0])) {
			return;
		}
		this._adjustInstDate(inst, offset +
			(period == 'M' ? this._get(inst, 'showCurrentAtPos') : 0), // undo positioning
			period);
		this._updateDatepicker(inst);
	},

	/* Action for current link. */
	_gotoToday: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		if (this._get(inst, 'gotoCurrent') && inst.currentDay) {
			inst.selectedDay = inst.currentDay;
			inst.drawMonth = inst.selectedMonth = inst.currentMonth;
			inst.drawYear = inst.selectedYear = inst.currentYear;
		}
		else {
			var date = new Date();
			inst.selectedDay = date.getDate();
			inst.drawMonth = inst.selectedMonth = date.getMonth();
			inst.drawYear = inst.selectedYear = date.getFullYear();
		}
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a new month/year. */
	_selectMonthYear: function(id, select, period) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		inst['selected' + (period == 'M' ? 'Month' : 'Year')] =
		inst['draw' + (period == 'M' ? 'Month' : 'Year')] =
			parseInt(select.options[select.selectedIndex].value,10);
		this._notifyChange(inst);
		this._adjustDate(target);
	},

	/* Action for selecting a day. */
	_selectDay: function(id, month, year, td) {
		var target = $(id);
		if ($(td).hasClass(this._unselectableClass) || this._isDisabledDatepicker(target[0])) {
			return;
		}
		var inst = this._getInst(target[0]);
		inst.selectedDay = inst.currentDay = $('a', td).html();
		inst.selectedMonth = inst.currentMonth = month;
		inst.selectedYear = inst.currentYear = year;
		this._selectDate(id, this._formatDate(inst,
			inst.currentDay, inst.currentMonth, inst.currentYear));
	},

	/* Erase the input field and hide the date picker. */
	_clearDate: function(id) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		this._selectDate(target, '');
	},

	/* Update the input field with the selected date. */
	_selectDate: function(id, dateStr) {
		var target = $(id);
		var inst = this._getInst(target[0]);
		dateStr = (dateStr != null ? dateStr : this._formatDate(inst));
		if (inst.input)
			inst.input.val(dateStr);
		this._updateAlternate(inst);
		var onSelect = this._get(inst, 'onSelect');
		if (onSelect)
			onSelect.apply((inst.input ? inst.input[0] : null), [dateStr, inst]);  // trigger custom callback
		else if (inst.input)
			inst.input.trigger('change'); // fire the change event
		if (inst.inline)
			this._updateDatepicker(inst);
		else {
			this._hideDatepicker();
			this._lastInput = inst.input[0];
			if (typeof(inst.input[0]) != 'object')
				inst.input.focus(); // restore focus
			this._lastInput = null;
		}
	},

	/* Update any alternate field to synchronise with the main field. */
	_updateAlternate: function(inst) {
		var altField = this._get(inst, 'altField');
		if (altField) { // update alternate field too
			var altFormat = this._get(inst, 'altFormat') || this._get(inst, 'dateFormat');
			var date = this._getDate(inst);
			var dateStr = this.formatDate(altFormat, date, this._getFormatConfig(inst));
			$(altField).each(function() { $(this).val(dateStr); });
		}
	},

	/* Set as beforeShowDay function to prevent selection of weekends.
	   @param  date  Date - the date to customise
	   @return [boolean, string] - is this date selectable?, what is its CSS class? */
	noWeekends: function(date) {
		var day = date.getDay();
		return [(day > 0 && day < 6), ''];
	},

	/* Set as calculateWeek to determine the week of the year based on the ISO 8601 definition.
	   @param  date  Date - the date to get the week for
	   @return  number - the number of the week within the year that contains this date */
	iso8601Week: function(date) {
		var checkDate = new Date(date.getTime());
		// Find Thursday of this week starting on Monday
		checkDate.setDate(checkDate.getDate() + 4 - (checkDate.getDay() || 7));
		var time = checkDate.getTime();
		checkDate.setMonth(0); // Compare with Jan 1
		checkDate.setDate(1);
		return Math.floor(Math.round((time - checkDate) / 86400000) / 7) + 1;
	},

	/* Parse a string value into a date object.
	   See formatDate below for the possible formats.

	   @param  format    string - the expected format of the date
	   @param  value     string - the date in the above format
	   @param  settings  Object - attributes include:
	                     shortYearCutoff  number - the cutoff year for determining the century (optional)
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  Date - the extracted date value or null if value is blank */
	parseDate: function (format, value, settings) {
		if (format == null || value == null)
			throw 'Invalid arguments';
		value = (typeof value == 'object' ? value.toString() : value + '');
		if (value == '')
			return null;
		var shortYearCutoff = (settings ? settings.shortYearCutoff : null) || this._defaults.shortYearCutoff;
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
				new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		var year = -1;
		var month = -1;
		var day = -1;
		var doy = -1;
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Extract a number from the string value
		var getNumber = function(match) {
			var isDoubled = lookAhead(match);
			var size = (match == '@' ? 14 : (match == '!' ? 20 :
				(match == 'y' && isDoubled ? 4 : (match == 'o' ? 3 : 2))));
			var digits = new RegExp('^\\d{1,' + size + '}');
			var num = value.substring(iValue).match(digits);
			if (!num)
				throw 'Missing number at position ' + iValue;
			iValue += num[0].length;
			return parseInt(num[0], 10);
		};
		// Extract a name from the string value and convert to an index
		var getName = function(match, shortNames, longNames) {
			var names = $.map(lookAhead(match) ? longNames : shortNames, function (v, k) {
				return [ [k, v] ];
			}).sort(function (a, b) {
				return -(a[1].length - b[1].length);
			});
			var index = -1;
			$.each(names, function (i, pair) {
				var name = pair[1];
				if (value.substr(iValue, name.length).toLowerCase() == name.toLowerCase()) {
					index = pair[0];
					iValue += name.length;
					return false;
				}
			});
			if (index != -1)
				return index + 1;
			else
				throw 'Unknown name at position ' + iValue;
		};
		// Confirm that a literal character matches the string value
		var checkLiteral = function() {
			if (value.charAt(iValue) != format.charAt(iFormat))
				throw 'Unexpected literal at position ' + iValue;
			iValue++;
		};
		var iValue = 0;
		for (var iFormat = 0; iFormat < format.length; iFormat++) {
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					checkLiteral();
			else
				switch (format.charAt(iFormat)) {
					case 'd':
						day = getNumber('d');
						break;
					case 'D':
						getName('D', dayNamesShort, dayNames);
						break;
					case 'o':
						doy = getNumber('o');
						break;
					case 'm':
						month = getNumber('m');
						break;
					case 'M':
						month = getName('M', monthNamesShort, monthNames);
						break;
					case 'y':
						year = getNumber('y');
						break;
					case '@':
						var date = new Date(getNumber('@'));
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case '!':
						var date = new Date((getNumber('!') - this._ticksTo1970) / 10000);
						year = date.getFullYear();
						month = date.getMonth() + 1;
						day = date.getDate();
						break;
					case "'":
						if (lookAhead("'"))
							checkLiteral();
						else
							literal = true;
						break;
					default:
						checkLiteral();
				}
		}
		if (iValue < value.length){
			throw "Extra/unparsed characters found in date: " + value.substring(iValue);
		}
		if (year == -1)
			year = new Date().getFullYear();
		else if (year < 100)
			year += new Date().getFullYear() - new Date().getFullYear() % 100 +
				(year <= shortYearCutoff ? 0 : -100);
		if (doy > -1) {
			month = 1;
			day = doy;
			do {
				var dim = this._getDaysInMonth(year, month - 1);
				if (day <= dim)
					break;
				month++;
				day -= dim;
			} while (true);
		}
		var date = this._daylightSavingAdjust(new Date(year, month - 1, day));
		if (date.getFullYear() != year || date.getMonth() + 1 != month || date.getDate() != day)
			throw 'Invalid date'; // E.g. 31/02/00
		return date;
	},

	/* Standard date formats. */
	ATOM: 'yy-mm-dd', // RFC 3339 (ISO 8601)
	COOKIE: 'D, dd M yy',
	ISO_8601: 'yy-mm-dd',
	RFC_822: 'D, d M y',
	RFC_850: 'DD, dd-M-y',
	RFC_1036: 'D, d M y',
	RFC_1123: 'D, d M yy',
	RFC_2822: 'D, d M yy',
	RSS: 'D, d M y', // RFC 822
	TICKS: '!',
	TIMESTAMP: '@',
	W3C: 'yy-mm-dd', // ISO 8601

	_ticksTo1970: (((1970 - 1) * 365 + Math.floor(1970 / 4) - Math.floor(1970 / 100) +
		Math.floor(1970 / 400)) * 24 * 60 * 60 * 10000000),

	/* Format a date object into a string value.
	   The format can be combinations of the following:
	   d  - day of month (no leading zero)
	   dd - day of month (two digit)
	   o  - day of year (no leading zeros)
	   oo - day of year (three digit)
	   D  - day name short
	   DD - day name long
	   m  - month of year (no leading zero)
	   mm - month of year (two digit)
	   M  - month name short
	   MM - month name long
	   y  - year (two digit)
	   yy - year (four digit)
	   @ - Unix timestamp (ms since 01/01/1970)
	   ! - Windows ticks (100ns since 01/01/0001)
	   '...' - literal text
	   '' - single quote

	   @param  format    string - the desired format of the date
	   @param  date      Date - the date value to format
	   @param  settings  Object - attributes include:
	                     dayNamesShort    string[7] - abbreviated names of the days from Sunday (optional)
	                     dayNames         string[7] - names of the days from Sunday (optional)
	                     monthNamesShort  string[12] - abbreviated names of the months (optional)
	                     monthNames       string[12] - names of the months (optional)
	   @return  string - the date in the above format */
	formatDate: function (format, date, settings) {
		if (!date)
			return '';
		var dayNamesShort = (settings ? settings.dayNamesShort : null) || this._defaults.dayNamesShort;
		var dayNames = (settings ? settings.dayNames : null) || this._defaults.dayNames;
		var monthNamesShort = (settings ? settings.monthNamesShort : null) || this._defaults.monthNamesShort;
		var monthNames = (settings ? settings.monthNames : null) || this._defaults.monthNames;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		// Format a number, with leading zero if necessary
		var formatNumber = function(match, value, len) {
			var num = '' + value;
			if (lookAhead(match))
				while (num.length < len)
					num = '0' + num;
			return num;
		};
		// Format a name, short or long as requested
		var formatName = function(match, value, shortNames, longNames) {
			return (lookAhead(match) ? longNames[value] : shortNames[value]);
		};
		var output = '';
		var literal = false;
		if (date)
			for (var iFormat = 0; iFormat < format.length; iFormat++) {
				if (literal)
					if (format.charAt(iFormat) == "'" && !lookAhead("'"))
						literal = false;
					else
						output += format.charAt(iFormat);
				else
					switch (format.charAt(iFormat)) {
						case 'd':
							output += formatNumber('d', date.getDate(), 2);
							break;
						case 'D':
							output += formatName('D', date.getDay(), dayNamesShort, dayNames);
							break;
						case 'o':
							output += formatNumber('o',
								Math.round((new Date(date.getFullYear(), date.getMonth(), date.getDate()).getTime() - new Date(date.getFullYear(), 0, 0).getTime()) / 86400000), 3);
							break;
						case 'm':
							output += formatNumber('m', date.getMonth() + 1, 2);
							break;
						case 'M':
							output += formatName('M', date.getMonth(), monthNamesShort, monthNames);
							break;
						case 'y':
							output += (lookAhead('y') ? date.getFullYear() :
								(date.getYear() % 100 < 10 ? '0' : '') + date.getYear() % 100);
							break;
						case '@':
							output += date.getTime();
							break;
						case '!':
							output += date.getTime() * 10000 + this._ticksTo1970;
							break;
						case "'":
							if (lookAhead("'"))
								output += "'";
							else
								literal = true;
							break;
						default:
							output += format.charAt(iFormat);
					}
			}
		return output;
	},

	/* Extract all possible characters from the date format. */
	_possibleChars: function (format) {
		var chars = '';
		var literal = false;
		// Check whether a format character is doubled
		var lookAhead = function(match) {
			var matches = (iFormat + 1 < format.length && format.charAt(iFormat + 1) == match);
			if (matches)
				iFormat++;
			return matches;
		};
		for (var iFormat = 0; iFormat < format.length; iFormat++)
			if (literal)
				if (format.charAt(iFormat) == "'" && !lookAhead("'"))
					literal = false;
				else
					chars += format.charAt(iFormat);
			else
				switch (format.charAt(iFormat)) {
					case 'd': case 'm': case 'y': case '@':
						chars += '0123456789';
						break;
					case 'D': case 'M':
						return null; // Accept anything
					case "'":
						if (lookAhead("'"))
							chars += "'";
						else
							literal = true;
						break;
					default:
						chars += format.charAt(iFormat);
				}
		return chars;
	},

	/* Get a setting value, defaulting if necessary. */
	_get: function(inst, name) {
		return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
	},

	/* Parse existing date and initialise date picker. */
	_setDateFromField: function(inst, noDefault) {
		if (inst.input.val() == inst.lastVal) {
			return;
		}
		var dateFormat = this._get(inst, 'dateFormat');
		var dates = inst.lastVal = inst.input ? inst.input.val() : null;
		var date, defaultDate;
		date = defaultDate = this._getDefaultDate(inst);
		var settings = this._getFormatConfig(inst);
		try {
			date = this.parseDate(dateFormat, dates, settings) || defaultDate;
		} catch (event) {
			this.log(event);
			dates = (noDefault ? '' : dates);
		}
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		inst.currentDay = (dates ? date.getDate() : 0);
		inst.currentMonth = (dates ? date.getMonth() : 0);
		inst.currentYear = (dates ? date.getFullYear() : 0);
		this._adjustInstDate(inst);
	},

	/* Retrieve the default date shown on opening. */
	_getDefaultDate: function(inst) {
		return this._restrictMinMax(inst,
			this._determineDate(inst, this._get(inst, 'defaultDate'), new Date()));
	},

	/* A date may be specified as an exact value or a relative one. */
	_determineDate: function(inst, date, defaultDate) {
		var offsetNumeric = function(offset) {
			var date = new Date();
			date.setDate(date.getDate() + offset);
			return date;
		};
		var offsetString = function(offset) {
			try {
				return $.datepicker.parseDate($.datepicker._get(inst, 'dateFormat'),
					offset, $.datepicker._getFormatConfig(inst));
			}
			catch (e) {
				// Ignore
			}
			var date = (offset.toLowerCase().match(/^c/) ?
				$.datepicker._getDate(inst) : null) || new Date();
			var year = date.getFullYear();
			var month = date.getMonth();
			var day = date.getDate();
			var pattern = /([+-]?[0-9]+)\s*(d|D|w|W|m|M|y|Y)?/g;
			var matches = pattern.exec(offset);
			while (matches) {
				switch (matches[2] || 'd') {
					case 'd' : case 'D' :
						day += parseInt(matches[1],10); break;
					case 'w' : case 'W' :
						day += parseInt(matches[1],10) * 7; break;
					case 'm' : case 'M' :
						month += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
					case 'y': case 'Y' :
						year += parseInt(matches[1],10);
						day = Math.min(day, $.datepicker._getDaysInMonth(year, month));
						break;
				}
				matches = pattern.exec(offset);
			}
			return new Date(year, month, day);
		};
		var newDate = (date == null || date === '' ? defaultDate : (typeof date == 'string' ? offsetString(date) :
			(typeof date == 'number' ? (isNaN(date) ? defaultDate : offsetNumeric(date)) : new Date(date.getTime()))));
		newDate = (newDate && newDate.toString() == 'Invalid Date' ? defaultDate : newDate);
		if (newDate) {
			newDate.setHours(0);
			newDate.setMinutes(0);
			newDate.setSeconds(0);
			newDate.setMilliseconds(0);
		}
		return this._daylightSavingAdjust(newDate);
	},

	/* Handle switch to/from daylight saving.
	   Hours may be non-zero on daylight saving cut-over:
	   > 12 when midnight changeover, but then cannot generate
	   midnight datetime, so jump to 1AM, otherwise reset.
	   @param  date  (Date) the date to check
	   @return  (Date) the corrected date */
	_daylightSavingAdjust: function(date) {
		if (!date) return null;
		date.setHours(date.getHours() > 12 ? date.getHours() + 2 : 0);
		return date;
	},

	/* Set the date(s) directly. */
	_setDate: function(inst, date, noChange) {
		var clear = !date;
		var origMonth = inst.selectedMonth;
		var origYear = inst.selectedYear;
		var newDate = this._restrictMinMax(inst, this._determineDate(inst, date, new Date()));
		inst.selectedDay = inst.currentDay = newDate.getDate();
		inst.drawMonth = inst.selectedMonth = inst.currentMonth = newDate.getMonth();
		inst.drawYear = inst.selectedYear = inst.currentYear = newDate.getFullYear();
		if ((origMonth != inst.selectedMonth || origYear != inst.selectedYear) && !noChange)
			this._notifyChange(inst);
		this._adjustInstDate(inst);
		if (inst.input) {
			inst.input.val(clear ? '' : this._formatDate(inst));
		}
	},

	/* Retrieve the date(s) directly. */
	_getDate: function(inst) {
		var startDate = (!inst.currentYear || (inst.input && inst.input.val() == '') ? null :
			this._daylightSavingAdjust(new Date(
			inst.currentYear, inst.currentMonth, inst.currentDay)));
			return startDate;
	},

	/* Generate the HTML for the current state of the date picker. */
	_generateHTML: function(inst) {
		var today = new Date();
		today = this._daylightSavingAdjust(
			new Date(today.getFullYear(), today.getMonth(), today.getDate())); // clear time
		var isRTL = this._get(inst, 'isRTL');
		var showButtonPanel = this._get(inst, 'showButtonPanel');
		var hideIfNoPrevNext = this._get(inst, 'hideIfNoPrevNext');
		var navigationAsDateFormat = this._get(inst, 'navigationAsDateFormat');
		var numMonths = this._getNumberOfMonths(inst);
		var showCurrentAtPos = this._get(inst, 'showCurrentAtPos');
		var stepMonths = this._get(inst, 'stepMonths');
		var isMultiMonth = (numMonths[0] != 1 || numMonths[1] != 1);
		var currentDate = this._daylightSavingAdjust((!inst.currentDay ? new Date(9999, 9, 9) :
			new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var drawMonth = inst.drawMonth - showCurrentAtPos;
		var drawYear = inst.drawYear;
		if (drawMonth < 0) {
			drawMonth += 12;
			drawYear--;
		}
		if (maxDate) {
			var maxDraw = this._daylightSavingAdjust(new Date(maxDate.getFullYear(),
				maxDate.getMonth() - (numMonths[0] * numMonths[1]) + 1, maxDate.getDate()));
			maxDraw = (minDate && maxDraw < minDate ? minDate : maxDraw);
			while (this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1)) > maxDraw) {
				drawMonth--;
				if (drawMonth < 0) {
					drawMonth = 11;
					drawYear--;
				}
			}
		}
		inst.drawMonth = drawMonth;
		inst.drawYear = drawYear;
		var prevText = this._get(inst, 'prevText');
		prevText = (!navigationAsDateFormat ? prevText : this.formatDate(prevText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth - stepMonths, 1)),
			this._getFormatConfig(inst)));
		var prev = (this._canAdjustMonth(inst, -1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-prev ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._adjustDate(\'#' + inst.id + '\', -' + stepMonths + ', \'M\');"' +
			' title="' + prevText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-prev ui-corner-all ui-state-disabled" title="'+ prevText +'"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'e' : 'w') + '">' + prevText + '</span></a>'));
		var nextText = this._get(inst, 'nextText');
		nextText = (!navigationAsDateFormat ? nextText : this.formatDate(nextText,
			this._daylightSavingAdjust(new Date(drawYear, drawMonth + stepMonths, 1)),
			this._getFormatConfig(inst)));
		var next = (this._canAdjustMonth(inst, +1, drawYear, drawMonth) ?
			'<a class="ui-datepicker-next ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._adjustDate(\'#' + inst.id + '\', +' + stepMonths + ', \'M\');"' +
			' title="' + nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>' :
			(hideIfNoPrevNext ? '' : '<a class="ui-datepicker-next ui-corner-all ui-state-disabled" title="'+ nextText + '"><span class="ui-icon ui-icon-circle-triangle-' + ( isRTL ? 'w' : 'e') + '">' + nextText + '</span></a>'));
		var currentText = this._get(inst, 'currentText');
		var gotoDate = (this._get(inst, 'gotoCurrent') && inst.currentDay ? currentDate : today);
		currentText = (!navigationAsDateFormat ? currentText :
			this.formatDate(currentText, gotoDate, this._getFormatConfig(inst)));
		var controls = (!inst.inline ? '<button type="button" class="ui-datepicker-close ui-state-default ui-priority-primary ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._hideDatepicker();">' + this._get(inst, 'closeText') + '</button>' : '');
		var buttonPanel = (showButtonPanel) ? '<div class="ui-datepicker-buttonpane ui-widget-content">' + (isRTL ? controls : '') +
			(this._isInRange(inst, gotoDate) ? '<button type="button" class="ui-datepicker-current ui-state-default ui-priority-secondary ui-corner-all" onclick="DP_jQuery_' + dpuuid +
			'.datepicker._gotoToday(\'#' + inst.id + '\');"' +
			'>' + currentText + '</button>' : '') + (isRTL ? '' : controls) + '</div>' : '';
		var firstDay = parseInt(this._get(inst, 'firstDay'),10);
		firstDay = (isNaN(firstDay) ? 0 : firstDay);
		var showWeek = this._get(inst, 'showWeek');
		var dayNames = this._get(inst, 'dayNames');
		var dayNamesShort = this._get(inst, 'dayNamesShort');
		var dayNamesMin = this._get(inst, 'dayNamesMin');
		var monthNames = this._get(inst, 'monthNames');
		var monthNamesShort = this._get(inst, 'monthNamesShort');
		var beforeShowDay = this._get(inst, 'beforeShowDay');
		var showOtherMonths = this._get(inst, 'showOtherMonths');
		var selectOtherMonths = this._get(inst, 'selectOtherMonths');
		var calculateWeek = this._get(inst, 'calculateWeek') || this.iso8601Week;
		var defaultDate = this._getDefaultDate(inst);
		var html = '';
		for (var row = 0; row < numMonths[0]; row++) {
			var group = '';
			this.maxRows = 4;
			for (var col = 0; col < numMonths[1]; col++) {
				var selectedDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, inst.selectedDay));
				var cornerClass = ' ui-corner-all';
				var calender = '';
				if (isMultiMonth) {
					calender += '<div class="ui-datepicker-group';
					if (numMonths[1] > 1)
						switch (col) {
							case 0: calender += ' ui-datepicker-group-first';
								cornerClass = ' ui-corner-' + (isRTL ? 'right' : 'left'); break;
							case numMonths[1]-1: calender += ' ui-datepicker-group-last';
								cornerClass = ' ui-corner-' + (isRTL ? 'left' : 'right'); break;
							default: calender += ' ui-datepicker-group-middle'; cornerClass = ''; break;
						}
					calender += '">';
				}
				calender += '<div class="ui-datepicker-header ui-widget-header ui-helper-clearfix' + cornerClass + '">' +
					(/all|left/.test(cornerClass) && row == 0 ? (isRTL ? next : prev) : '') +
					(/all|right/.test(cornerClass) && row == 0 ? (isRTL ? prev : next) : '') +
					this._generateMonthYearHeader(inst, drawMonth, drawYear, minDate, maxDate,
					row > 0 || col > 0, monthNames, monthNamesShort) + // draw month headers
					'</div><table class="ui-datepicker-calendar"><thead>' +
					'<tr>';
				var thead = (showWeek ? '<th class="ui-datepicker-week-col">' + this._get(inst, 'weekHeader') + '</th>' : '');
				for (var dow = 0; dow < 7; dow++) { // days of the week
					var day = (dow + firstDay) % 7;
					thead += '<th' + ((dow + firstDay + 6) % 7 >= 5 ? ' class="ui-datepicker-week-end"' : '') + '>' +
						'<span title="' + dayNames[day] + '">' + dayNamesMin[day] + '</span></th>';
				}
				calender += thead + '</tr></thead><tbody>';
				var daysInMonth = this._getDaysInMonth(drawYear, drawMonth);
				if (drawYear == inst.selectedYear && drawMonth == inst.selectedMonth)
					inst.selectedDay = Math.min(inst.selectedDay, daysInMonth);
				var leadDays = (this._getFirstDayOfMonth(drawYear, drawMonth) - firstDay + 7) % 7;
				var curRows = Math.ceil((leadDays + daysInMonth) / 7); // calculate the number of rows to generate
				var numRows = (isMultiMonth ? this.maxRows > curRows ? this.maxRows : curRows : curRows); //If multiple months, use the higher number of rows (see #7043)
				this.maxRows = numRows;
				var printDate = this._daylightSavingAdjust(new Date(drawYear, drawMonth, 1 - leadDays));
				for (var dRow = 0; dRow < numRows; dRow++) { // create date picker rows
					calender += '<tr>';
					var tbody = (!showWeek ? '' : '<td class="ui-datepicker-week-col">' +
						this._get(inst, 'calculateWeek')(printDate) + '</td>');
					for (var dow = 0; dow < 7; dow++) { // create date picker days
						var daySettings = (beforeShowDay ?
							beforeShowDay.apply((inst.input ? inst.input[0] : null), [printDate]) : [true, '']);
						var otherMonth = (printDate.getMonth() != drawMonth);
						var unselectable = (otherMonth && !selectOtherMonths) || !daySettings[0] ||
							(minDate && printDate < minDate) || (maxDate && printDate > maxDate);
						tbody += '<td class="' +
							((dow + firstDay + 6) % 7 >= 5 ? ' ui-datepicker-week-end' : '') + // highlight weekends
							(otherMonth ? ' ui-datepicker-other-month' : '') + // highlight days from other months
							((printDate.getTime() == selectedDate.getTime() && drawMonth == inst.selectedMonth && inst._keyEvent) || // user pressed key
							(defaultDate.getTime() == printDate.getTime() && defaultDate.getTime() == selectedDate.getTime()) ?
							// or defaultDate is current printedDate and defaultDate is selectedDate
							' ' + this._dayOverClass : '') + // highlight selected day
							(unselectable ? ' ' + this._unselectableClass + ' ui-state-disabled': '') +  // highlight unselectable days
							(otherMonth && !showOtherMonths ? '' : ' ' + daySettings[1] + // highlight custom dates
							(printDate.getTime() == currentDate.getTime() ? ' ' + this._currentClass : '') + // highlight selected day
							(printDate.getTime() == today.getTime() ? ' ui-datepicker-today' : '')) + '"' + // highlight today (if different)
							((!otherMonth || showOtherMonths) && daySettings[2] ? ' title="' + daySettings[2] + '"' : '') + // cell title
							(unselectable ? '' : ' onclick="DP_jQuery_' + dpuuid + '.datepicker._selectDay(\'#' +
							inst.id + '\',' + printDate.getMonth() + ',' + printDate.getFullYear() + ', this);return false;"') + '>' + // actions
							(otherMonth && !showOtherMonths ? '&#xa0;' : // display for other months
							(unselectable ? '<span class="ui-state-default">' + printDate.getDate() + '</span>' : '<a class="ui-state-default' +
							(printDate.getTime() == today.getTime() ? ' ui-state-highlight' : '') +
							(printDate.getTime() == currentDate.getTime() ? ' ui-state-active' : '') + // highlight selected day
							(otherMonth ? ' ui-priority-secondary' : '') + // distinguish dates from other months
							'" href="#">' + printDate.getDate() + '</a>')) + '</td>'; // display selectable date
						printDate.setDate(printDate.getDate() + 1);
						printDate = this._daylightSavingAdjust(printDate);
					}
					calender += tbody + '</tr>';
				}
				drawMonth++;
				if (drawMonth > 11) {
					drawMonth = 0;
					drawYear++;
				}
				calender += '</tbody></table>' + (isMultiMonth ? '</div>' + 
							((numMonths[0] > 0 && col == numMonths[1]-1) ? '<div class="ui-datepicker-row-break"></div>' : '') : '');
				group += calender;
			}
			html += group;
		}
		html += buttonPanel + ($.browser.msie && parseInt($.browser.version,10) < 7 && !inst.inline ?
			'<iframe src="javascript:false;" class="ui-datepicker-cover" frameborder="0"></iframe>' : '');
		inst._keyEvent = false;
		return html;
	},

	/* Generate the month and year header. */
	_generateMonthYearHeader: function(inst, drawMonth, drawYear, minDate, maxDate,
			secondary, monthNames, monthNamesShort) {
		var changeMonth = this._get(inst, 'changeMonth');
		var changeYear = this._get(inst, 'changeYear');
		var showMonthAfterYear = this._get(inst, 'showMonthAfterYear');
		var html = '<div class="ui-datepicker-title">';
		var monthHtml = '';
		// month selection
		if (secondary || !changeMonth)
			monthHtml += '<span class="ui-datepicker-month">' + monthNames[drawMonth] + '</span>';
		else {
			var inMinYear = (minDate && minDate.getFullYear() == drawYear);
			var inMaxYear = (maxDate && maxDate.getFullYear() == drawYear);
			monthHtml += '<select class="ui-datepicker-month" ' +
				'onchange="DP_jQuery_' + dpuuid + '.datepicker._selectMonthYear(\'#' + inst.id + '\', this, \'M\');" ' +
			 	'>';
			for (var month = 0; month < 12; month++) {
				if ((!inMinYear || month >= minDate.getMonth()) &&
						(!inMaxYear || month <= maxDate.getMonth()))
					monthHtml += '<option value="' + month + '"' +
						(month == drawMonth ? ' selected="selected"' : '') +
						'>' + monthNamesShort[month] + '</option>';
			}
			monthHtml += '</select>';
		}
		if (!showMonthAfterYear)
			html += monthHtml + (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '');
		// year selection
		if ( !inst.yearshtml ) {
			inst.yearshtml = '';
			if (secondary || !changeYear)
				html += '<span class="ui-datepicker-year">' + drawYear + '</span>';
			else {
				// determine range of years to display
				var years = this._get(inst, 'yearRange').split(':');
				var thisYear = new Date().getFullYear();
				var determineYear = function(value) {
					var year = (value.match(/c[+-].*/) ? drawYear + parseInt(value.substring(1), 10) :
						(value.match(/[+-].*/) ? thisYear + parseInt(value, 10) :
						parseInt(value, 10)));
					return (isNaN(year) ? thisYear : year);
				};
				var year = determineYear(years[0]);
				var endYear = Math.max(year, determineYear(years[1] || ''));
				year = (minDate ? Math.max(year, minDate.getFullYear()) : year);
				endYear = (maxDate ? Math.min(endYear, maxDate.getFullYear()) : endYear);
				inst.yearshtml += '<select class="ui-datepicker-year" ' +
					'onchange="DP_jQuery_' + dpuuid + '.datepicker._selectMonthYear(\'#' + inst.id + '\', this, \'Y\');" ' +
					'>';
				for (; year <= endYear; year++) {
					inst.yearshtml += '<option value="' + year + '"' +
						(year == drawYear ? ' selected="selected"' : '') +
						'>' + year + '</option>';
				}
				inst.yearshtml += '</select>';
				
				html += inst.yearshtml;
				inst.yearshtml = null;
			}
		}
		html += this._get(inst, 'yearSuffix');
		if (showMonthAfterYear)
			html += (secondary || !(changeMonth && changeYear) ? '&#xa0;' : '') + monthHtml;
		html += '</div>'; // Close datepicker_header
		return html;
	},

	/* Adjust one of the date sub-fields. */
	_adjustInstDate: function(inst, offset, period) {
		var year = inst.drawYear + (period == 'Y' ? offset : 0);
		var month = inst.drawMonth + (period == 'M' ? offset : 0);
		var day = Math.min(inst.selectedDay, this._getDaysInMonth(year, month)) +
			(period == 'D' ? offset : 0);
		var date = this._restrictMinMax(inst,
			this._daylightSavingAdjust(new Date(year, month, day)));
		inst.selectedDay = date.getDate();
		inst.drawMonth = inst.selectedMonth = date.getMonth();
		inst.drawYear = inst.selectedYear = date.getFullYear();
		if (period == 'M' || period == 'Y')
			this._notifyChange(inst);
	},

	/* Ensure a date is within any min/max bounds. */
	_restrictMinMax: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		var newDate = (minDate && date < minDate ? minDate : date);
		newDate = (maxDate && newDate > maxDate ? maxDate : newDate);
		return newDate;
	},

	/* Notify change of month/year. */
	_notifyChange: function(inst) {
		var onChange = this._get(inst, 'onChangeMonthYear');
		if (onChange)
			onChange.apply((inst.input ? inst.input[0] : null),
				[inst.selectedYear, inst.selectedMonth + 1, inst]);
	},

	/* Determine the number of months to show. */
	_getNumberOfMonths: function(inst) {
		var numMonths = this._get(inst, 'numberOfMonths');
		return (numMonths == null ? [1, 1] : (typeof numMonths == 'number' ? [1, numMonths] : numMonths));
	},

	/* Determine the current maximum date - ensure no time components are set. */
	_getMinMaxDate: function(inst, minMax) {
		return this._determineDate(inst, this._get(inst, minMax + 'Date'), null);
	},

	/* Find the number of days in a given month. */
	_getDaysInMonth: function(year, month) {
		return 32 - this._daylightSavingAdjust(new Date(year, month, 32)).getDate();
	},

	/* Find the day of the week of the first of a month. */
	_getFirstDayOfMonth: function(year, month) {
		return new Date(year, month, 1).getDay();
	},

	/* Determines if we should allow a "next/prev" month display change. */
	_canAdjustMonth: function(inst, offset, curYear, curMonth) {
		var numMonths = this._getNumberOfMonths(inst);
		var date = this._daylightSavingAdjust(new Date(curYear,
			curMonth + (offset < 0 ? offset : numMonths[0] * numMonths[1]), 1));
		if (offset < 0)
			date.setDate(this._getDaysInMonth(date.getFullYear(), date.getMonth()));
		return this._isInRange(inst, date);
	},

	/* Is the given date in the accepted range? */
	_isInRange: function(inst, date) {
		var minDate = this._getMinMaxDate(inst, 'min');
		var maxDate = this._getMinMaxDate(inst, 'max');
		return ((!minDate || date.getTime() >= minDate.getTime()) &&
			(!maxDate || date.getTime() <= maxDate.getTime()));
	},

	/* Provide the configuration settings for formatting/parsing. */
	_getFormatConfig: function(inst) {
		var shortYearCutoff = this._get(inst, 'shortYearCutoff');
		shortYearCutoff = (typeof shortYearCutoff != 'string' ? shortYearCutoff :
			new Date().getFullYear() % 100 + parseInt(shortYearCutoff, 10));
		return {shortYearCutoff: shortYearCutoff,
			dayNamesShort: this._get(inst, 'dayNamesShort'), dayNames: this._get(inst, 'dayNames'),
			monthNamesShort: this._get(inst, 'monthNamesShort'), monthNames: this._get(inst, 'monthNames')};
	},

	/* Format the given date for display. */
	_formatDate: function(inst, day, month, year) {
		if (!day) {
			inst.currentDay = inst.selectedDay;
			inst.currentMonth = inst.selectedMonth;
			inst.currentYear = inst.selectedYear;
		}
		var date = (day ? (typeof day == 'object' ? day :
			this._daylightSavingAdjust(new Date(year, month, day))) :
			this._daylightSavingAdjust(new Date(inst.currentYear, inst.currentMonth, inst.currentDay)));
		return this.formatDate(this._get(inst, 'dateFormat'), date, this._getFormatConfig(inst));
	}
});

/*
 * Bind hover events for datepicker elements.
 * Done via delegate so the binding only occurs once in the lifetime of the parent div.
 * Global instActive, set by _updateDatepicker allows the handlers to find their way back to the active picker.
 */ 
function bindHover(dpDiv) {
	var selector = 'button, .ui-datepicker-prev, .ui-datepicker-next, .ui-datepicker-calendar td a';
	return dpDiv.bind('mouseout', function(event) {
			var elem = $( event.target ).closest( selector );
			if ( !elem.length ) {
				return;
			}
			elem.removeClass( "ui-state-hover ui-datepicker-prev-hover ui-datepicker-next-hover" );
		})
		.bind('mouseover', function(event) {
			var elem = $( event.target ).closest( selector );
			if ($.datepicker._isDisabledDatepicker( instActive.inline ? dpDiv.parent()[0] : instActive.input[0]) ||
					!elem.length ) {
				return;
			}
			elem.parents('.ui-datepicker-calendar').find('a').removeClass('ui-state-hover');
			elem.addClass('ui-state-hover');
			if (elem.hasClass('ui-datepicker-prev')) elem.addClass('ui-datepicker-prev-hover');
			if (elem.hasClass('ui-datepicker-next')) elem.addClass('ui-datepicker-next-hover');
		});
}

/* jQuery extend now ignores nulls! */
function extendRemove(target, props) {
	$.extend(target, props);
	for (var name in props)
		if (props[name] == null || props[name] == undefined)
			target[name] = props[name];
	return target;
};

/* Determine whether an object is an array. */
function isArray(a) {
	return (a && (($.browser.safari && typeof a == 'object' && a.length) ||
		(a.constructor && a.constructor.toString().match(/\Array\(\)/))));
};

/* Invoke the datepicker functionality.
   @param  options  string - a command, optionally followed by additional parameters or
                    Object - settings for attaching new datepicker functionality
   @return  jQuery object */
$.fn.datepicker = function(options){
	
	/* Verify an empty collection wasn't passed - Fixes #6976 */
	if ( !this.length ) {
		return this;
	}
	
	/* Initialise the date picker. */
	if (!$.datepicker.initialized) {
		$(document).mousedown($.datepicker._checkExternalClick).
			find('body').append($.datepicker.dpDiv);
		$.datepicker.initialized = true;
	}

	var otherArgs = Array.prototype.slice.call(arguments, 1);
	if (typeof options == 'string' && (options == 'isDisabled' || options == 'getDate' || options == 'widget'))
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
		return $.datepicker['_' + options + 'Datepicker'].
			apply($.datepicker, [this[0]].concat(otherArgs));
	return this.each(function() {
		typeof options == 'string' ?
			$.datepicker['_' + options + 'Datepicker'].
				apply($.datepicker, [this].concat(otherArgs)) :
			$.datepicker._attachDatepicker(this, options);
	});
};

$.datepicker = new Datepicker(); // singleton instance
$.datepicker.initialized = false;
$.datepicker.uuid = new Date().getTime();
$.datepicker.version = "1.8.21";

// Workaround for #4055
// Add another global to avoid noConflict issues with inline event handlers
window['DP_jQuery_' + dpuuid] = $;

})(jQuery);
/*!
 * jQuery UI Progressbar 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Progressbar
 *
 * Depends:
 *   jquery.ui.core.js
 *   jquery.ui.widget.js
 */
(function( $, undefined ) {

$.widget( "ui.progressbar", {
	options: {
		value: 0,
		max: 100
	},

	min: 0,

	_create: function() {
		this.element
			.addClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.attr({
				role: "progressbar",
				"aria-valuemin": this.min,
				"aria-valuemax": this.options.max,
				"aria-valuenow": this._value()
			});

		this.valueDiv = $( "<div class='ui-progressbar-value ui-widget-header ui-corner-left'></div>" )
			.appendTo( this.element );

		this.oldValue = this._value();
		this._refreshValue();
	},

	destroy: function() {
		this.element
			.removeClass( "ui-progressbar ui-widget ui-widget-content ui-corner-all" )
			.removeAttr( "role" )
			.removeAttr( "aria-valuemin" )
			.removeAttr( "aria-valuemax" )
			.removeAttr( "aria-valuenow" );

		this.valueDiv.remove();

		$.Widget.prototype.destroy.apply( this, arguments );
	},

	value: function( newValue ) {
		if ( newValue === undefined ) {
			return this._value();
		}

		this._setOption( "value", newValue );
		return this;
	},

	_setOption: function( key, value ) {
		if ( key === "value" ) {
			this.options.value = value;
			this._refreshValue();
			if ( this._value() === this.options.max ) {
				this._trigger( "complete" );
			}
		}

		$.Widget.prototype._setOption.apply( this, arguments );
	},

	_value: function() {
		var val = this.options.value;
		// normalize invalid value
		if ( typeof val !== "number" ) {
			val = 0;
		}
		return Math.min( this.options.max, Math.max( this.min, val ) );
	},

	_percentage: function() {
		return 100 * this._value() / this.options.max;
	},

	_refreshValue: function() {
		var value = this.value();
		var percentage = this._percentage();

		if ( this.oldValue !== value ) {
			this.oldValue = value;
			this._trigger( "change" );
		}

		this.valueDiv
			.toggle( value > this.min )
			.toggleClass( "ui-corner-right", value === this.options.max )
			.width( percentage.toFixed(0) + "%" );
		this.element.attr( "aria-valuenow", value );
	}
});

$.extend( $.ui.progressbar, {
	version: "1.8.21"
});

})( jQuery );
/*!
 * jQuery UI Effects 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/
 */
;jQuery.effects || (function($, undefined) {

$.effects = {};



/******************************************************************************/
/****************************** COLOR ANIMATIONS ******************************/
/******************************************************************************/

// override the animation for color styles
$.each(['backgroundColor', 'borderBottomColor', 'borderLeftColor',
	'borderRightColor', 'borderTopColor', 'borderColor', 'color', 'outlineColor'],
function(i, attr) {
	$.fx.step[attr] = function(fx) {
		if (!fx.colorInit) {
			fx.start = getColor(fx.elem, attr);
			fx.end = getRGB(fx.end);
			fx.colorInit = true;
		}

		fx.elem.style[attr] = 'rgb(' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[0] - fx.start[0])) + fx.start[0], 10), 255), 0) + ',' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[1] - fx.start[1])) + fx.start[1], 10), 255), 0) + ',' +
			Math.max(Math.min(parseInt((fx.pos * (fx.end[2] - fx.start[2])) + fx.start[2], 10), 255), 0) + ')';
	};
});

// Color Conversion functions from highlightFade
// By Blair Mitchelmore
// http://jquery.offput.ca/highlightFade/

// Parse strings looking for color tuples [255,255,255]
function getRGB(color) {
		var result;

		// Check if we're already dealing with an array of colors
		if ( color && color.constructor == Array && color.length == 3 )
				return color;

		// Look for rgb(num,num,num)
		if (result = /rgb\(\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*,\s*([0-9]{1,3})\s*\)/.exec(color))
				return [parseInt(result[1],10), parseInt(result[2],10), parseInt(result[3],10)];

		// Look for rgb(num%,num%,num%)
		if (result = /rgb\(\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*,\s*([0-9]+(?:\.[0-9]+)?)\%\s*\)/.exec(color))
				return [parseFloat(result[1])*2.55, parseFloat(result[2])*2.55, parseFloat(result[3])*2.55];

		// Look for #a0b1c2
		if (result = /#([a-fA-F0-9]{2})([a-fA-F0-9]{2})([a-fA-F0-9]{2})/.exec(color))
				return [parseInt(result[1],16), parseInt(result[2],16), parseInt(result[3],16)];

		// Look for #fff
		if (result = /#([a-fA-F0-9])([a-fA-F0-9])([a-fA-F0-9])/.exec(color))
				return [parseInt(result[1]+result[1],16), parseInt(result[2]+result[2],16), parseInt(result[3]+result[3],16)];

		// Look for rgba(0, 0, 0, 0) == transparent in Safari 3
		if (result = /rgba\(0, 0, 0, 0\)/.exec(color))
				return colors['transparent'];

		// Otherwise, we're most likely dealing with a named color
		return colors[$.trim(color).toLowerCase()];
}

function getColor(elem, attr) {
		var color;

		do {
				color = $.curCSS(elem, attr);

				// Keep going until we find an element that has color, or we hit the body
				if ( color != '' && color != 'transparent' || $.nodeName(elem, "body") )
						break;

				attr = "backgroundColor";
		} while ( elem = elem.parentNode );

		return getRGB(color);
};

// Some named colors to work with
// From Interface by Stefan Petre
// http://interface.eyecon.ro/

var colors = {
	aqua:[0,255,255],
	azure:[240,255,255],
	beige:[245,245,220],
	black:[0,0,0],
	blue:[0,0,255],
	brown:[165,42,42],
	cyan:[0,255,255],
	darkblue:[0,0,139],
	darkcyan:[0,139,139],
	darkgrey:[169,169,169],
	darkgreen:[0,100,0],
	darkkhaki:[189,183,107],
	darkmagenta:[139,0,139],
	darkolivegreen:[85,107,47],
	darkorange:[255,140,0],
	darkorchid:[153,50,204],
	darkred:[139,0,0],
	darksalmon:[233,150,122],
	darkviolet:[148,0,211],
	fuchsia:[255,0,255],
	gold:[255,215,0],
	green:[0,128,0],
	indigo:[75,0,130],
	khaki:[240,230,140],
	lightblue:[173,216,230],
	lightcyan:[224,255,255],
	lightgreen:[144,238,144],
	lightgrey:[211,211,211],
	lightpink:[255,182,193],
	lightyellow:[255,255,224],
	lime:[0,255,0],
	magenta:[255,0,255],
	maroon:[128,0,0],
	navy:[0,0,128],
	olive:[128,128,0],
	orange:[255,165,0],
	pink:[255,192,203],
	purple:[128,0,128],
	violet:[128,0,128],
	red:[255,0,0],
	silver:[192,192,192],
	white:[255,255,255],
	yellow:[255,255,0],
	transparent: [255,255,255]
};



/******************************************************************************/
/****************************** CLASS ANIMATIONS ******************************/
/******************************************************************************/

var classAnimationActions = ['add', 'remove', 'toggle'],
	shorthandStyles = {
		border: 1,
		borderBottom: 1,
		borderColor: 1,
		borderLeft: 1,
		borderRight: 1,
		borderTop: 1,
		borderWidth: 1,
		margin: 1,
		padding: 1
	};

function getElementStyles() {
	var style = document.defaultView
			? document.defaultView.getComputedStyle(this, null)
			: this.currentStyle,
		newStyle = {},
		key,
		camelCase;

	// webkit enumerates style porperties
	if (style && style.length && style[0] && style[style[0]]) {
		var len = style.length;
		while (len--) {
			key = style[len];
			if (typeof style[key] == 'string') {
				camelCase = key.replace(/\-(\w)/g, function(all, letter){
					return letter.toUpperCase();
				});
				newStyle[camelCase] = style[key];
			}
		}
	} else {
		for (key in style) {
			if (typeof style[key] === 'string') {
				newStyle[key] = style[key];
			}
		}
	}
	
	return newStyle;
}

function filterStyles(styles) {
	var name, value;
	for (name in styles) {
		value = styles[name];
		if (
			// ignore null and undefined values
			value == null ||
			// ignore functions (when does this occur?)
			$.isFunction(value) ||
			// shorthand styles that need to be expanded
			name in shorthandStyles ||
			// ignore scrollbars (break in IE)
			(/scrollbar/).test(name) ||

			// only colors or values that can be converted to numbers
			(!(/color/i).test(name) && isNaN(parseFloat(value)))
		) {
			delete styles[name];
		}
	}
	
	return styles;
}

function styleDifference(oldStyle, newStyle) {
	var diff = { _: 0 }, // http://dev.jquery.com/ticket/5459
		name;

	for (name in newStyle) {
		if (oldStyle[name] != newStyle[name]) {
			diff[name] = newStyle[name];
		}
	}

	return diff;
}

$.effects.animateClass = function(value, duration, easing, callback) {
	if ($.isFunction(easing)) {
		callback = easing;
		easing = null;
	}

	return this.queue(function() {
		var that = $(this),
			originalStyleAttr = that.attr('style') || ' ',
			originalStyle = filterStyles(getElementStyles.call(this)),
			newStyle,
			className = that.attr('class') || "";

		$.each(classAnimationActions, function(i, action) {
			if (value[action]) {
				that[action + 'Class'](value[action]);
			}
		});
		newStyle = filterStyles(getElementStyles.call(this));
		that.attr('class', className);

		that.animate(styleDifference(originalStyle, newStyle), {
			queue: false,
			duration: duration,
			easing: easing,
			complete: function() {
				$.each(classAnimationActions, function(i, action) {
					if (value[action]) { that[action + 'Class'](value[action]); }
				});
				// work around bug in IE by clearing the cssText before setting it
				if (typeof that.attr('style') == 'object') {
					that.attr('style').cssText = '';
					that.attr('style').cssText = originalStyleAttr;
				} else {
					that.attr('style', originalStyleAttr);
				}
				if (callback) { callback.apply(this, arguments); }
				$.dequeue( this );
			}
		});
	});
};

$.fn.extend({
	_addClass: $.fn.addClass,
	addClass: function(classNames, speed, easing, callback) {
		return speed ? $.effects.animateClass.apply(this, [{ add: classNames },speed,easing,callback]) : this._addClass(classNames);
	},

	_removeClass: $.fn.removeClass,
	removeClass: function(classNames,speed,easing,callback) {
		return speed ? $.effects.animateClass.apply(this, [{ remove: classNames },speed,easing,callback]) : this._removeClass(classNames);
	},

	_toggleClass: $.fn.toggleClass,
	toggleClass: function(classNames, force, speed, easing, callback) {
		if ( typeof force == "boolean" || force === undefined ) {
			if ( !speed ) {
				// without speed parameter;
				return this._toggleClass(classNames, force);
			} else {
				return $.effects.animateClass.apply(this, [(force?{add:classNames}:{remove:classNames}),speed,easing,callback]);
			}
		} else {
			// without switch parameter;
			return $.effects.animateClass.apply(this, [{ toggle: classNames },force,speed,easing]);
		}
	},

	switchClass: function(remove,add,speed,easing,callback) {
		return $.effects.animateClass.apply(this, [{ add: add, remove: remove },speed,easing,callback]);
	}
});



/******************************************************************************/
/*********************************** EFFECTS **********************************/
/******************************************************************************/

$.extend($.effects, {
	version: "1.8.21",

	// Saves a set of properties in a data storage
	save: function(element, set) {
		for(var i=0; i < set.length; i++) {
			if(set[i] !== null) element.data("ec.storage."+set[i], element[0].style[set[i]]);
		}
	},

	// Restores a set of previously saved properties from a data storage
	restore: function(element, set) {
		for(var i=0; i < set.length; i++) {
			if(set[i] !== null) element.css(set[i], element.data("ec.storage."+set[i]));
		}
	},

	setMode: function(el, mode) {
		if (mode == 'toggle') mode = el.is(':hidden') ? 'show' : 'hide'; // Set for toggle
		return mode;
	},

	getBaseline: function(origin, original) { // Translates a [top,left] array into a baseline value
		// this should be a little more flexible in the future to handle a string & hash
		var y, x;
		switch (origin[0]) {
			case 'top': y = 0; break;
			case 'middle': y = 0.5; break;
			case 'bottom': y = 1; break;
			default: y = origin[0] / original.height;
		};
		switch (origin[1]) {
			case 'left': x = 0; break;
			case 'center': x = 0.5; break;
			case 'right': x = 1; break;
			default: x = origin[1] / original.width;
		};
		return {x: x, y: y};
	},

	// Wraps the element around a wrapper that copies position properties
	createWrapper: function(element) {

		// if the element is already wrapped, return it
		if (element.parent().is('.ui-effects-wrapper')) {
			return element.parent();
		}

		// wrap the element
		var props = {
				width: element.outerWidth(true),
				height: element.outerHeight(true),
				'float': element.css('float')
			},
			wrapper = $('<div></div>')
				.addClass('ui-effects-wrapper')
				.css({
					fontSize: '100%',
					background: 'transparent',
					border: 'none',
					margin: 0,
					padding: 0
				}),
			active = document.activeElement;

		// support: Firefox
		// Firefox incorrectly exposes anonymous content
		// https://bugzilla.mozilla.org/show_bug.cgi?id=561664
		try {
			active.id;
		} catch( e ) {
			active = document.body;
		}

		element.wrap( wrapper );

		// Fixes #7595 - Elements lose focus when wrapped.
		if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
			$( active ).focus();
		}
		
		wrapper = element.parent(); //Hotfix for jQuery 1.4 since some change in wrap() seems to actually loose the reference to the wrapped element

		// transfer positioning properties to the wrapper
		if (element.css('position') == 'static') {
			wrapper.css({ position: 'relative' });
			element.css({ position: 'relative' });
		} else {
			$.extend(props, {
				position: element.css('position'),
				zIndex: element.css('z-index')
			});
			$.each(['top', 'left', 'bottom', 'right'], function(i, pos) {
				props[pos] = element.css(pos);
				if (isNaN(parseInt(props[pos], 10))) {
					props[pos] = 'auto';
				}
			});
			element.css({position: 'relative', top: 0, left: 0, right: 'auto', bottom: 'auto' });
		}

		return wrapper.css(props).show();
	},

	removeWrapper: function(element) {
		var parent,
			active = document.activeElement;
		
		if (element.parent().is('.ui-effects-wrapper')) {
			parent = element.parent().replaceWith(element);
			// Fixes #7595 - Elements lose focus when wrapped.
			if ( element[ 0 ] === active || $.contains( element[ 0 ], active ) ) {
				$( active ).focus();
			}
			return parent;
		}
			
		return element;
	},

	setTransition: function(element, list, factor, value) {
		value = value || {};
		$.each(list, function(i, x){
			var unit = element.cssUnit(x);
			if (unit[0] > 0) value[x] = unit[0] * factor + unit[1];
		});
		return value;
	}
});


function _normalizeArguments(effect, options, speed, callback) {
	// shift params for method overloading
	if (typeof effect == 'object') {
		callback = options;
		speed = null;
		options = effect;
		effect = options.effect;
	}
	if ($.isFunction(options)) {
		callback = options;
		speed = null;
		options = {};
	}
        if (typeof options == 'number' || $.fx.speeds[options]) {
		callback = speed;
		speed = options;
		options = {};
	}
	if ($.isFunction(speed)) {
		callback = speed;
		speed = null;
	}

	options = options || {};

	speed = speed || options.duration;
	speed = $.fx.off ? 0 : typeof speed == 'number'
		? speed : speed in $.fx.speeds ? $.fx.speeds[speed] : $.fx.speeds._default;

	callback = callback || options.complete;

	return [effect, options, speed, callback];
}

function standardSpeed( speed ) {
	// valid standard speeds
	if ( !speed || typeof speed === "number" || $.fx.speeds[ speed ] ) {
		return true;
	}
	
	// invalid strings - treat as "normal" speed
	if ( typeof speed === "string" && !$.effects[ speed ] ) {
		return true;
	}
	
	return false;
}

$.fn.extend({
	effect: function(effect, options, speed, callback) {
		var args = _normalizeArguments.apply(this, arguments),
			// TODO: make effects take actual parameters instead of a hash
			args2 = {
				options: args[1],
				duration: args[2],
				callback: args[3]
			},
			mode = args2.options.mode,
			effectMethod = $.effects[effect];
		
		if ( $.fx.off || !effectMethod ) {
			// delegate to the original method (e.g., .show()) if possible
			if ( mode ) {
				return this[ mode ]( args2.duration, args2.callback );
			} else {
				return this.each(function() {
					if ( args2.callback ) {
						args2.callback.call( this );
					}
				});
			}
		}
		
		return effectMethod.call(this, args2);
	},

	_show: $.fn.show,
	show: function(speed) {
		if ( standardSpeed( speed ) ) {
			return this._show.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'show';
			return this.effect.apply(this, args);
		}
	},

	_hide: $.fn.hide,
	hide: function(speed) {
		if ( standardSpeed( speed ) ) {
			return this._hide.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'hide';
			return this.effect.apply(this, args);
		}
	},

	// jQuery core overloads toggle and creates _toggle
	__toggle: $.fn.toggle,
	toggle: function(speed) {
		if ( standardSpeed( speed ) || typeof speed === "boolean" || $.isFunction( speed ) ) {
			return this.__toggle.apply(this, arguments);
		} else {
			var args = _normalizeArguments.apply(this, arguments);
			args[1].mode = 'toggle';
			return this.effect.apply(this, args);
		}
	},

	// helper functions
	cssUnit: function(key) {
		var style = this.css(key), val = [];
		$.each( ['em','px','%','pt'], function(i, unit){
			if(style.indexOf(unit) > 0)
				val = [parseFloat(style), unit];
		});
		return val;
	}
});



/******************************************************************************/
/*********************************** EASING ***********************************/
/******************************************************************************/

/*
 * jQuery Easing v1.3 - http://gsgd.co.uk/sandbox/jquery/easing/
 *
 * Uses the built in easing capabilities added In jQuery 1.1
 * to offer multiple easing options
 *
 * TERMS OF USE - jQuery Easing
 *
 * Open source under the BSD License.
 *
 * Copyright 2008 George McGinley Smith
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
*/

// t: current time, b: begInnIng value, c: change In value, d: duration
$.easing.jswing = $.easing.swing;

$.extend($.easing,
{
	def: 'easeOutQuad',
	swing: function (x, t, b, c, d) {
		//alert($.easing.default);
		return $.easing[$.easing.def](x, t, b, c, d);
	},
	easeInQuad: function (x, t, b, c, d) {
		return c*(t/=d)*t + b;
	},
	easeOutQuad: function (x, t, b, c, d) {
		return -c *(t/=d)*(t-2) + b;
	},
	easeInOutQuad: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t + b;
		return -c/2 * ((--t)*(t-2) - 1) + b;
	},
	easeInCubic: function (x, t, b, c, d) {
		return c*(t/=d)*t*t + b;
	},
	easeOutCubic: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t + 1) + b;
	},
	easeInOutCubic: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t + b;
		return c/2*((t-=2)*t*t + 2) + b;
	},
	easeInQuart: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t + b;
	},
	easeOutQuart: function (x, t, b, c, d) {
		return -c * ((t=t/d-1)*t*t*t - 1) + b;
	},
	easeInOutQuart: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t + b;
		return -c/2 * ((t-=2)*t*t*t - 2) + b;
	},
	easeInQuint: function (x, t, b, c, d) {
		return c*(t/=d)*t*t*t*t + b;
	},
	easeOutQuint: function (x, t, b, c, d) {
		return c*((t=t/d-1)*t*t*t*t + 1) + b;
	},
	easeInOutQuint: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return c/2*t*t*t*t*t + b;
		return c/2*((t-=2)*t*t*t*t + 2) + b;
	},
	easeInSine: function (x, t, b, c, d) {
		return -c * Math.cos(t/d * (Math.PI/2)) + c + b;
	},
	easeOutSine: function (x, t, b, c, d) {
		return c * Math.sin(t/d * (Math.PI/2)) + b;
	},
	easeInOutSine: function (x, t, b, c, d) {
		return -c/2 * (Math.cos(Math.PI*t/d) - 1) + b;
	},
	easeInExpo: function (x, t, b, c, d) {
		return (t==0) ? b : c * Math.pow(2, 10 * (t/d - 1)) + b;
	},
	easeOutExpo: function (x, t, b, c, d) {
		return (t==d) ? b+c : c * (-Math.pow(2, -10 * t/d) + 1) + b;
	},
	easeInOutExpo: function (x, t, b, c, d) {
		if (t==0) return b;
		if (t==d) return b+c;
		if ((t/=d/2) < 1) return c/2 * Math.pow(2, 10 * (t - 1)) + b;
		return c/2 * (-Math.pow(2, -10 * --t) + 2) + b;
	},
	easeInCirc: function (x, t, b, c, d) {
		return -c * (Math.sqrt(1 - (t/=d)*t) - 1) + b;
	},
	easeOutCirc: function (x, t, b, c, d) {
		return c * Math.sqrt(1 - (t=t/d-1)*t) + b;
	},
	easeInOutCirc: function (x, t, b, c, d) {
		if ((t/=d/2) < 1) return -c/2 * (Math.sqrt(1 - t*t) - 1) + b;
		return c/2 * (Math.sqrt(1 - (t-=2)*t) + 1) + b;
	},
	easeInElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return -(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
	},
	easeOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d)==1) return b+c;  if (!p) p=d*.3;
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		return a*Math.pow(2,-10*t) * Math.sin( (t*d-s)*(2*Math.PI)/p ) + c + b;
	},
	easeInOutElastic: function (x, t, b, c, d) {
		var s=1.70158;var p=0;var a=c;
		if (t==0) return b;  if ((t/=d/2)==2) return b+c;  if (!p) p=d*(.3*1.5);
		if (a < Math.abs(c)) { a=c; var s=p/4; }
		else var s = p/(2*Math.PI) * Math.asin (c/a);
		if (t < 1) return -.5*(a*Math.pow(2,10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )) + b;
		return a*Math.pow(2,-10*(t-=1)) * Math.sin( (t*d-s)*(2*Math.PI)/p )*.5 + c + b;
	},
	easeInBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*(t/=d)*t*((s+1)*t - s) + b;
	},
	easeOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		return c*((t=t/d-1)*t*((s+1)*t + s) + 1) + b;
	},
	easeInOutBack: function (x, t, b, c, d, s) {
		if (s == undefined) s = 1.70158;
		if ((t/=d/2) < 1) return c/2*(t*t*(((s*=(1.525))+1)*t - s)) + b;
		return c/2*((t-=2)*t*(((s*=(1.525))+1)*t + s) + 2) + b;
	},
	easeInBounce: function (x, t, b, c, d) {
		return c - $.easing.easeOutBounce (x, d-t, 0, c, d) + b;
	},
	easeOutBounce: function (x, t, b, c, d) {
		if ((t/=d) < (1/2.75)) {
			return c*(7.5625*t*t) + b;
		} else if (t < (2/2.75)) {
			return c*(7.5625*(t-=(1.5/2.75))*t + .75) + b;
		} else if (t < (2.5/2.75)) {
			return c*(7.5625*(t-=(2.25/2.75))*t + .9375) + b;
		} else {
			return c*(7.5625*(t-=(2.625/2.75))*t + .984375) + b;
		}
	},
	easeInOutBounce: function (x, t, b, c, d) {
		if (t < d/2) return $.easing.easeInBounce (x, t*2, 0, c, d) * .5 + b;
		return $.easing.easeOutBounce (x, t*2-d, 0, c, d) * .5 + c*.5 + b;
	}
});

/*
 *
 * TERMS OF USE - EASING EQUATIONS
 *
 * Open source under the BSD License.
 *
 * Copyright 2001 Robert Penner
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification,
 * are permitted provided that the following conditions are met:
 *
 * Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 * Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * Neither the name of the author nor the names of contributors may be used to endorse
 * or promote products derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
 * GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
 * OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 */

})(jQuery);
/*!
 * jQuery UI Effects Blind 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Blind
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.blind = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var direction = o.options.direction || 'vertical'; // Default direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var ref = (direction == 'vertical') ? 'height' : 'width';
		var distance = (direction == 'vertical') ? wrapper.height() : wrapper.width();
		if(mode == 'show') wrapper.css(ref, 0); // Shift

		// Animation
		var animation = {};
		animation[ref] = mode == 'show' ? distance : 0;

		// Animate
		wrapper.animate(animation, o.duration, o.options.easing, function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Bounce 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Bounce
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.bounce = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var direction = o.options.direction || 'up'; // Default direction
		var distance = o.options.distance || 20; // Default distance
		var times = o.options.times || 5; // Default # of times
		var speed = o.duration || 250; // Default speed per bounce
		if (/show|hide/.test(mode)) props.push('opacity'); // Avoid touching opacity to prevent clearType and PNG issues in IE

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
		var distance = o.options.distance || (ref == 'top' ? el.outerHeight({margin:true}) / 3 : el.outerWidth({margin:true}) / 3);
		if (mode == 'show') el.css('opacity', 0).css(ref, motion == 'pos' ? -distance : distance); // Shift
		if (mode == 'hide') distance = distance / (times * 2);
		if (mode != 'hide') times--;

		// Animate
		if (mode == 'show') { // Show Bounce
			var animation = {opacity: 1};
			animation[ref] = (motion == 'pos' ? '+=' : '-=') + distance;
			el.animate(animation, speed / 2, o.options.easing);
			distance = distance / 2;
			times--;
		};
		for (var i = 0; i < times; i++) { // Bounces
			var animation1 = {}, animation2 = {};
			animation1[ref] = (motion == 'pos' ? '-=' : '+=') + distance;
			animation2[ref] = (motion == 'pos' ? '+=' : '-=') + distance;
			el.animate(animation1, speed / 2, o.options.easing).animate(animation2, speed / 2, o.options.easing);
			distance = (mode == 'hide') ? distance * 2 : distance / 2;
		};
		if (mode == 'hide') { // Last Bounce
			var animation = {opacity: 0};
			animation[ref] = (motion == 'pos' ? '-=' : '+=')  + distance;
			el.animate(animation, speed / 2, o.options.easing, function(){
				el.hide(); // Hide
				$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
				if(o.callback) o.callback.apply(this, arguments); // Callback
			});
		} else {
			var animation1 = {}, animation2 = {};
			animation1[ref] = (motion == 'pos' ? '-=' : '+=') + distance;
			animation2[ref] = (motion == 'pos' ? '+=' : '-=') + distance;
			el.animate(animation1, speed / 2, o.options.easing).animate(animation2, speed / 2, o.options.easing, function(){
				$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
				if(o.callback) o.callback.apply(this, arguments); // Callback
			});
		};
		el.queue('fx', function() { el.dequeue(); });
		el.dequeue();
	});

};

})(jQuery);
/*!
 * jQuery UI Effects Clip 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Clip
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.clip = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right','height','width'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var direction = o.options.direction || 'vertical'; // Default direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var animate = el[0].tagName == 'IMG' ? wrapper : el;
		var ref = {
			size: (direction == 'vertical') ? 'height' : 'width',
			position: (direction == 'vertical') ? 'top' : 'left'
		};
		var distance = (direction == 'vertical') ? animate.height() : animate.width();
		if(mode == 'show') { animate.css(ref.size, 0); animate.css(ref.position, distance / 2); } // Shift

		// Animation
		var animation = {};
		animation[ref.size] = mode == 'show' ? distance : 0;
		animation[ref.position] = mode == 'show' ? 0 : distance / 2;

		// Animate
		animate.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Drop 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Drop
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.drop = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right','opacity'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var direction = o.options.direction || 'left'; // Default Direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
		var distance = o.options.distance || (ref == 'top' ? el.outerHeight({margin:true}) / 2 : el.outerWidth({margin:true}) / 2);
		if (mode == 'show') el.css('opacity', 0).css(ref, motion == 'pos' ? -distance : distance); // Shift

		// Animation
		var animation = {opacity: mode == 'show' ? 1 : 0};
		animation[ref] = (mode == 'show' ? (motion == 'pos' ? '+=' : '-=') : (motion == 'pos' ? '-=' : '+=')) + distance;

		// Animate
		el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Explode 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Explode
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.explode = function(o) {

	return this.queue(function() {

	var rows = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3;
	var cells = o.options.pieces ? Math.round(Math.sqrt(o.options.pieces)) : 3;

	o.options.mode = o.options.mode == 'toggle' ? ($(this).is(':visible') ? 'hide' : 'show') : o.options.mode;
	var el = $(this).show().css('visibility', 'hidden');
	var offset = el.offset();

	//Substract the margins - not fixing the problem yet.
	offset.top -= parseInt(el.css("marginTop"),10) || 0;
	offset.left -= parseInt(el.css("marginLeft"),10) || 0;

	var width = el.outerWidth(true);
	var height = el.outerHeight(true);

	for(var i=0;i<rows;i++) { // =
		for(var j=0;j<cells;j++) { // ||
			el
				.clone()
				.appendTo('body')
				.wrap('<div></div>')
				.css({
					position: 'absolute',
					visibility: 'visible',
					left: -j*(width/cells),
					top: -i*(height/rows)
				})
				.parent()
				.addClass('ui-effects-explode')
				.css({
					position: 'absolute',
					overflow: 'hidden',
					width: width/cells,
					height: height/rows,
					left: offset.left + j*(width/cells) + (o.options.mode == 'show' ? (j-Math.floor(cells/2))*(width/cells) : 0),
					top: offset.top + i*(height/rows) + (o.options.mode == 'show' ? (i-Math.floor(rows/2))*(height/rows) : 0),
					opacity: o.options.mode == 'show' ? 0 : 1
				}).animate({
					left: offset.left + j*(width/cells) + (o.options.mode == 'show' ? 0 : (j-Math.floor(cells/2))*(width/cells)),
					top: offset.top + i*(height/rows) + (o.options.mode == 'show' ? 0 : (i-Math.floor(rows/2))*(height/rows)),
					opacity: o.options.mode == 'show' ? 1 : 0
				}, o.duration || 500);
		}
	}

	// Set a timeout, to call the callback approx. when the other animations have finished
	setTimeout(function() {

		o.options.mode == 'show' ? el.css({ visibility: 'visible' }) : el.css({ visibility: 'visible' }).hide();
				if(o.callback) o.callback.apply(el[0]); // Callback
				el.dequeue();

				$('div.ui-effects-explode').remove();

	}, o.duration || 500);


	});

};

})(jQuery);
/*!
 * jQuery UI Effects Fade 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fade
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.fade = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || 'hide');

		elem.animate({ opacity: mode }, {
			queue: false,
			duration: o.duration,
			easing: o.options.easing,
			complete: function() {
				(o.callback && o.callback.apply(this, arguments));
				elem.dequeue();
			}
		});
	});
};

})(jQuery);
/*!
 * jQuery UI Effects Fold 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Fold
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.fold = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'hide'); // Set Mode
		var size = o.options.size || 15; // Default fold size
		var horizFirst = !(!o.options.horizFirst); // Ensure a boolean value
		var duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2;

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		var wrapper = $.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var widthFirst = ((mode == 'show') != horizFirst);
		var ref = widthFirst ? ['width', 'height'] : ['height', 'width'];
		var distance = widthFirst ? [wrapper.width(), wrapper.height()] : [wrapper.height(), wrapper.width()];
		var percent = /([0-9]+)%/.exec(size);
		if(percent) size = parseInt(percent[1],10) / 100 * distance[mode == 'hide' ? 0 : 1];
		if(mode == 'show') wrapper.css(horizFirst ? {height: 0, width: size} : {height: size, width: 0}); // Shift

		// Animation
		var animation1 = {}, animation2 = {};
		animation1[ref[0]] = mode == 'show' ? distance[0] : size;
		animation2[ref[1]] = mode == 'show' ? distance[1] : 0;

		// Animate
		wrapper.animate(animation1, duration, o.options.easing)
		.animate(animation2, duration, o.options.easing, function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(el[0], arguments); // Callback
			el.dequeue();
		});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Highlight 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Highlight
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.highlight = function(o) {
	return this.queue(function() {
		var elem = $(this),
			props = ['backgroundImage', 'backgroundColor', 'opacity'],
			mode = $.effects.setMode(elem, o.options.mode || 'show'),
			animation = {
				backgroundColor: elem.css('backgroundColor')
			};

		if (mode == 'hide') {
			animation.opacity = 0;
		}

		$.effects.save(elem, props);
		elem
			.show()
			.css({
				backgroundImage: 'none',
				backgroundColor: o.options.color || '#ffff99'
			})
			.animate(animation, {
				queue: false,
				duration: o.duration,
				easing: o.options.easing,
				complete: function() {
					(mode == 'hide' && elem.hide());
					$.effects.restore(elem, props);
					(mode == 'show' && !$.support.opacity && this.style.removeAttribute('filter'));
					(o.callback && o.callback.apply(this, arguments));
					elem.dequeue();
				}
			});
	});
};

})(jQuery);
/*!
 * jQuery UI Effects Pulsate 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Pulsate
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.pulsate = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || 'show'),
			times = ((o.options.times || 5) * 2) - 1,
			duration = o.duration ? o.duration / 2 : $.fx.speeds._default / 2,
			isVisible = elem.is(':visible'),
			animateTo = 0;

		if (!isVisible) {
			elem.css('opacity', 0).show();
			animateTo = 1;
		}

		if ((mode == 'hide' && isVisible) || (mode == 'show' && !isVisible)) {
			times--;
		}

		for (var i = 0; i < times; i++) {
			elem.animate({ opacity: animateTo }, duration, o.options.easing);
			animateTo = (animateTo + 1) % 2;
		}

		elem.animate({ opacity: animateTo }, duration, o.options.easing, function() {
			if (animateTo == 0) {
				elem.hide();
			}
			(o.callback && o.callback.apply(this, arguments));
		});

		elem
			.queue('fx', function() { elem.dequeue(); })
			.dequeue();
	});
};

})(jQuery);
/*!
 * jQuery UI Effects Scale 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Scale
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.puff = function(o) {
	return this.queue(function() {
		var elem = $(this),
			mode = $.effects.setMode(elem, o.options.mode || 'hide'),
			percent = parseInt(o.options.percent, 10) || 150,
			factor = percent / 100,
			original = { height: elem.height(), width: elem.width() };

		$.extend(o.options, {
			fade: true,
			mode: mode,
			percent: mode == 'hide' ? percent : 100,
			from: mode == 'hide'
				? original
				: {
					height: original.height * factor,
					width: original.width * factor
				}
		});

		elem.effect('scale', o.options, o.duration, o.callback);
		elem.dequeue();
	});
};

$.effects.scale = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this);

		// Set options
		var options = $.extend(true, {}, o.options);
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var percent = parseInt(o.options.percent,10) || (parseInt(o.options.percent,10) == 0 ? 0 : (mode == 'hide' ? 0 : 100)); // Set default scaling percent
		var direction = o.options.direction || 'both'; // Set default axis
		var origin = o.options.origin; // The origin of the scaling
		if (mode != 'effect') { // Set default origin and restore for show/hide
			options.origin = origin || ['middle','center'];
			options.restore = true;
		}
		var original = {height: el.height(), width: el.width()}; // Save original
		el.from = o.options.from || (mode == 'show' ? {height: 0, width: 0} : original); // Default from state

		// Adjust
		var factor = { // Set scaling factor
			y: direction != 'horizontal' ? (percent / 100) : 1,
			x: direction != 'vertical' ? (percent / 100) : 1
		};
		el.to = {height: original.height * factor.y, width: original.width * factor.x}; // Set to state

		if (o.options.fade) { // Fade option to support puff
			if (mode == 'show') {el.from.opacity = 0; el.to.opacity = 1;};
			if (mode == 'hide') {el.from.opacity = 1; el.to.opacity = 0;};
		};

		// Animation
		options.from = el.from; options.to = el.to; options.mode = mode;

		// Animate
		el.effect('size', options, o.duration, o.callback);
		el.dequeue();
	});

};

$.effects.size = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right','width','height','overflow','opacity'];
		var props1 = ['position','top','bottom','left','right','overflow','opacity']; // Always restore
		var props2 = ['width','height','overflow']; // Copy for children
		var cProps = ['fontSize'];
		var vProps = ['borderTopWidth', 'borderBottomWidth', 'paddingTop', 'paddingBottom'];
		var hProps = ['borderLeftWidth', 'borderRightWidth', 'paddingLeft', 'paddingRight'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var restore = o.options.restore || false; // Default restore
		var scale = o.options.scale || 'both'; // Default scale mode
		var origin = o.options.origin; // The origin of the sizing
		var original = {height: el.height(), width: el.width()}; // Save original
		el.from = o.options.from || original; // Default from state
		el.to = o.options.to || original; // Default to state
		// Adjust
		if (origin) { // Calculate baseline shifts
			var baseline = $.effects.getBaseline(origin, original);
			el.from.top = (original.height - el.from.height) * baseline.y;
			el.from.left = (original.width - el.from.width) * baseline.x;
			el.to.top = (original.height - el.to.height) * baseline.y;
			el.to.left = (original.width - el.to.width) * baseline.x;
		};
		var factor = { // Set scaling factor
			from: {y: el.from.height / original.height, x: el.from.width / original.width},
			to: {y: el.to.height / original.height, x: el.to.width / original.width}
		};
		if (scale == 'box' || scale == 'both') { // Scale the css box
			if (factor.from.y != factor.to.y) { // Vertical props scaling
				props = props.concat(vProps);
				el.from = $.effects.setTransition(el, vProps, factor.from.y, el.from);
				el.to = $.effects.setTransition(el, vProps, factor.to.y, el.to);
			};
			if (factor.from.x != factor.to.x) { // Horizontal props scaling
				props = props.concat(hProps);
				el.from = $.effects.setTransition(el, hProps, factor.from.x, el.from);
				el.to = $.effects.setTransition(el, hProps, factor.to.x, el.to);
			};
		};
		if (scale == 'content' || scale == 'both') { // Scale the content
			if (factor.from.y != factor.to.y) { // Vertical props scaling
				props = props.concat(cProps);
				el.from = $.effects.setTransition(el, cProps, factor.from.y, el.from);
				el.to = $.effects.setTransition(el, cProps, factor.to.y, el.to);
			};
		};
		$.effects.save(el, restore ? props : props1); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		el.css('overflow','hidden').css(el.from); // Shift

		// Animate
		if (scale == 'content' || scale == 'both') { // Scale the children
			vProps = vProps.concat(['marginTop','marginBottom']).concat(cProps); // Add margins/font-size
			hProps = hProps.concat(['marginLeft','marginRight']); // Add margins
			props2 = props.concat(vProps).concat(hProps); // Concat
			el.find("*[width]").each(function(){
				var child = $(this);
				if (restore) $.effects.save(child, props2);
				var c_original = {height: child.height(), width: child.width()}; // Save original
				child.from = {height: c_original.height * factor.from.y, width: c_original.width * factor.from.x};
				child.to = {height: c_original.height * factor.to.y, width: c_original.width * factor.to.x};
				if (factor.from.y != factor.to.y) { // Vertical props scaling
					child.from = $.effects.setTransition(child, vProps, factor.from.y, child.from);
					child.to = $.effects.setTransition(child, vProps, factor.to.y, child.to);
				};
				if (factor.from.x != factor.to.x) { // Horizontal props scaling
					child.from = $.effects.setTransition(child, hProps, factor.from.x, child.from);
					child.to = $.effects.setTransition(child, hProps, factor.to.x, child.to);
				};
				child.css(child.from); // Shift children
				child.animate(child.to, o.duration, o.options.easing, function(){
					if (restore) $.effects.restore(child, props2); // Restore children
				}); // Animate children
			});
		};

		// Animate
		el.animate(el.to, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if (el.to.opacity === 0) {
				el.css('opacity', el.from.opacity);
			}
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, restore ? props : props1); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Shake 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Shake
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.shake = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'effect'); // Set Mode
		var direction = o.options.direction || 'left'; // Default direction
		var distance = o.options.distance || 20; // Default distance
		var times = o.options.times || 3; // Default # of times
		var speed = o.duration || o.options.duration || 140; // Default speed per shake

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';

		// Animation
		var animation = {}, animation1 = {}, animation2 = {};
		animation[ref] = (motion == 'pos' ? '-=' : '+=')  + distance;
		animation1[ref] = (motion == 'pos' ? '+=' : '-=')  + distance * 2;
		animation2[ref] = (motion == 'pos' ? '-=' : '+=')  + distance * 2;

		// Animate
		el.animate(animation, speed, o.options.easing);
		for (var i = 1; i < times; i++) { // Shakes
			el.animate(animation1, speed, o.options.easing).animate(animation2, speed, o.options.easing);
		};
		el.animate(animation1, speed, o.options.easing).
		animate(animation, speed / 2, o.options.easing, function(){ // Last shake
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
		});
		el.queue('fx', function() { el.dequeue(); });
		el.dequeue();
	});

};

})(jQuery);
/*!
 * jQuery UI Effects Slide 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Slide
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.slide = function(o) {

	return this.queue(function() {

		// Create element
		var el = $(this), props = ['position','top','bottom','left','right'];

		// Set options
		var mode = $.effects.setMode(el, o.options.mode || 'show'); // Set Mode
		var direction = o.options.direction || 'left'; // Default Direction

		// Adjust
		$.effects.save(el, props); el.show(); // Save & Show
		$.effects.createWrapper(el).css({overflow:'hidden'}); // Create Wrapper
		var ref = (direction == 'up' || direction == 'down') ? 'top' : 'left';
		var motion = (direction == 'up' || direction == 'left') ? 'pos' : 'neg';
		var distance = o.options.distance || (ref == 'top' ? el.outerHeight({margin:true}) : el.outerWidth({margin:true}));
		if (mode == 'show') el.css(ref, motion == 'pos' ? (isNaN(distance) ? "-" + distance : -distance) : distance); // Shift

		// Animation
		var animation = {};
		animation[ref] = (mode == 'show' ? (motion == 'pos' ? '+=' : '-=') : (motion == 'pos' ? '-=' : '+=')) + distance;

		// Animate
		el.animate(animation, { queue: false, duration: o.duration, easing: o.options.easing, complete: function() {
			if(mode == 'hide') el.hide(); // Hide
			$.effects.restore(el, props); $.effects.removeWrapper(el); // Restore
			if(o.callback) o.callback.apply(this, arguments); // Callback
			el.dequeue();
		}});

	});

};

})(jQuery);
/*!
 * jQuery UI Effects Transfer 1.8.21
 *
 * Copyright 2012, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Effects/Transfer
 *
 * Depends:
 *	jquery.effects.core.js
 */
(function( $, undefined ) {

$.effects.transfer = function(o) {
	return this.queue(function() {
		var elem = $(this),
			target = $(o.options.to),
			endPosition = target.offset(),
			animation = {
				top: endPosition.top,
				left: endPosition.left,
				height: target.innerHeight(),
				width: target.innerWidth()
			},
			startPosition = elem.offset(),
			transfer = $('<div class="ui-effects-transfer"></div>')
				.appendTo(document.body)
				.addClass(o.options.className)
				.css({
					top: startPosition.top,
					left: startPosition.left,
					height: elem.innerHeight(),
					width: elem.innerWidth(),
					position: 'absolute'
				})
				.animate(animation, o.duration, o.options.easing, function() {
					transfer.remove();
					(o.callback && o.callback.apply(elem[0], arguments));
					elem.dequeue();
				});
	});
};

})(jQuery);
/* Afrikaans initialisation for the jQuery UI date picker plugin. *//* Written by Renier Pretorius. */
jQuery(function (a) {
    a.datepicker.regional.af = {closeText:"Selekteer", prevText:"Vorige", nextText:"Volgende", currentText:"Vandag", monthNames:["Januarie", "Februarie", "Maart", "April", "Mei", "Junie", "Julie", "Augustus", "September", "Oktober", "November", "Desember"], monthNamesShort:["Jan", "Feb", "Mrt", "Apr", "Mei", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"], dayNames:["Sondag", "Maandag", "Dinsdag", "Woensdag", "Donderdag", "Vrydag", "Saterdag"], dayNamesShort:["Son", "Maa", "Din", "Woe", "Don", "Vry", "Sat"], dayNamesMin:["So", "Ma", "Di", "Wo", "Do", "Vr", "Sa"], weekHeader:"Wk", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.af)
}), jQuery(function (a) {
    a.datepicker.regional["ar-DZ"] = {closeText:"إغلاق", prevText:"&#x3c;السابق", nextText:"التالي&#x3e;", currentText:"اليوم", monthNames:["جانفي", "فيفري", "مارس", "أفريل", "ماي", "جوان", "جويلية", "أوت", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"], monthNamesShort:["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], dayNames:["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"], dayNamesShort:["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"], dayNamesMin:["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"], weekHeader:"أسبوع", dateFormat:"dd/mm/yy", firstDay:6, isRTL:!0, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional["ar-DZ"])
}), jQuery(function (a) {
    a.datepicker.regional.ar = {closeText:"إغلاق", prevText:"&#x3c;السابق", nextText:"التالي&#x3e;", currentText:"اليوم", monthNames:["كانون الثاني", "شباط", "آذار", "نيسان", "مايو", "حزيران", "تموز", "آب", "أيلول", "تشرين الأول", "تشرين الثاني", "كانون الأول"], monthNamesShort:["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], dayNames:["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"], dayNamesShort:["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"], dayNamesMin:["الأحد", "الاثنين", "الثلاثاء", "الأربعاء", "الخميس", "الجمعة", "السبت"], weekHeader:"أسبوع", dateFormat:"dd/mm/yy", firstDay:6, isRTL:!0, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.ar)
}), jQuery(function (a) {
    a.datepicker.regional.az = {closeText:"Bağla", prevText:"&#x3c;Geri", nextText:"İrəli&#x3e;", currentText:"Bugün", monthNames:["Yanvar", "Fevral", "Mart", "Aprel", "May", "İyun", "İyul", "Avqust", "Sentyabr", "Oktyabr", "Noyabr", "Dekabr"], monthNamesShort:["Yan", "Fev", "Mar", "Apr", "May", "İyun", "İyul", "Avq", "Sen", "Okt", "Noy", "Dek"], dayNames:["Bazar", "Bazar ertəsi", "Çərşənbə axşamı", "Çərşənbə", "Cümə axşamı", "Cümə", "Şənbə"], dayNamesShort:["B", "Be", "Ça", "Ç", "Ca", "C", "Ş"], dayNamesMin:["B", "B", "Ç", "С", "Ç", "C", "Ş"], weekHeader:"Hf", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.az)
}), jQuery(function (a) {
    a.datepicker.regional.bg = {closeText:"затвори", prevText:"&#x3c;назад", nextText:"напред&#x3e;", nextBigText:"&#x3e;&#x3e;", currentText:"днес", monthNames:["Януари", "Февруари", "Март", "Април", "Май", "Юни", "Юли", "Август", "Септември", "Октомври", "Ноември", "Декември"], monthNamesShort:["Яну", "Фев", "Мар", "Апр", "Май", "Юни", "Юли", "Авг", "Сеп", "Окт", "Нов", "Дек"], dayNames:["Неделя", "Понеделник", "Вторник", "Сряда", "Четвъртък", "Петък", "Събота"], dayNamesShort:["Нед", "Пон", "Вто", "Сря", "Чет", "Пет", "Съб"], dayNamesMin:["Не", "По", "Вт", "Ср", "Че", "Пе", "Съ"], weekHeader:"Wk", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.bg)
}), jQuery(function (a) {
    a.datepicker.regional.bs = {closeText:"Zatvori", prevText:"&#x3c;", nextText:"&#x3e;", currentText:"Danas", monthNames:["Januar", "Februar", "Mart", "April", "Maj", "Juni", "Juli", "August", "Septembar", "Oktobar", "Novembar", "Decembar"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"], dayNames:["Nedelja", "Ponedeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"], dayNamesShort:["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"], dayNamesMin:["Ne", "Po", "Ut", "Sr", "Če", "Pe", "Su"], weekHeader:"Wk", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.bs)
}), jQuery(function (a) {
    a.datepicker.regional.ca = {closeText:"Tancar", prevText:"&#x3c;Ant", nextText:"Seg&#x3e;", currentText:"Avui", monthNames:["Gener", "Febrer", "Mar&ccedil;", "Abril", "Maig", "Juny", "Juliol", "Agost", "Setembre", "Octubre", "Novembre", "Desembre"], monthNamesShort:["Gen", "Feb", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Des"], dayNames:["Diumenge", "Dilluns", "Dimarts", "Dimecres", "Dijous", "Divendres", "Dissabte"], dayNamesShort:["Dug", "Dln", "Dmt", "Dmc", "Djs", "Dvn", "Dsb"], dayNamesMin:["Dg", "Dl", "Dt", "Dc", "Dj", "Dv", "Ds"], weekHeader:"Sm", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.ca)
}), jQuery(function (a) {
    a.datepicker.regional.cs = {closeText:"Zavřít", prevText:"&#x3c;Dříve", nextText:"Později&#x3e;", currentText:"Nyní", monthNames:["leden", "únor", "březen", "duben", "květen", "červen", "červenec", "srpen", "září", "říjen", "listopad", "prosinec"], monthNamesShort:["led", "úno", "bře", "dub", "kvě", "čer", "čvc", "srp", "zář", "říj", "lis", "pro"], dayNames:["neděle", "pondělí", "úterý", "středa", "čtvrtek", "pátek", "sobota"], dayNamesShort:["ne", "po", "út", "st", "čt", "pá", "so"], dayNamesMin:["ne", "po", "út", "st", "čt", "pá", "so"], weekHeader:"Týd", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.cs)
}), jQuery(function (a) {
    a.datepicker.regional["cy-GB"] = {closeText:"Done", prevText:"Prev", nextText:"Next", currentText:"Today", monthNames:["Ionawr", "Chwefror", "Mawrth", "Ebrill", "Mai", "Mehefin", "Gorffennaf", "Awst", "Medi", "Hydref", "Tachwedd", "Rhagfyr"], monthNamesShort:["Ion", "Chw", "Maw", "Ebr", "Mai", "Meh", "Gor", "Aws", "Med", "Hyd", "Tac", "Rha"], dayNames:["Dydd Sul", "Dydd Llun", "Dydd Mawrth", "Dydd Mercher", "Dydd Iau", "Dydd Gwener", "Dydd Sadwrn"], dayNamesShort:["Sul", "Llu", "Maw", "Mer", "Iau", "Gwe", "Sad"], dayNamesMin:["Su", "Ll", "Ma", "Me", "Ia", "Gw", "Sa"], weekHeader:"Wy", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional["cy-GB"])
}), jQuery(function (a) {
    a.datepicker.regional.da = {closeText:"Luk", prevText:"&#x3c;Forrige", nextText:"Næste&#x3e;", currentText:"Idag", monthNames:["Januar", "Februar", "Marts", "April", "Maj", "Juni", "Juli", "August", "September", "Oktober", "November", "December"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"], dayNames:["Søndag", "Mandag", "Tirsdag", "Onsdag", "Torsdag", "Fredag", "Lørdag"], dayNamesShort:["Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"], dayNamesMin:["Sø", "Ma", "Ti", "On", "To", "Fr", "Lø"], weekHeader:"Uge", dateFormat:"dd-mm-yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.da)
}), jQuery(function (a) {
    a.datepicker.regional.de = {closeText:"schließen", prevText:"&#x3c;zurück", nextText:"Vor&#x3e;", currentText:"heute", monthNames:["Januar", "Februar", "März", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"], monthNamesShort:["Jan", "Feb", "Mär", "Apr", "Mai", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"], dayNames:["Sonntag", "Montag", "Dienstag", "Mittwoch", "Donnerstag", "Freitag", "Samstag"], dayNamesShort:["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"], dayNamesMin:["So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"], weekHeader:"Wo", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.de)
}), jQuery(function (a) {
    a.datepicker.regional.el = {closeText:"Κλείσιμο", prevText:"Προηγούμενος", nextText:"Επόμενος", currentText:"Τρέχων Μήνας", monthNames:["Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"], monthNamesShort:["Ιαν", "Φεβ", "Μαρ", "Απρ", "Μαι", "Ιουν", "Ιουλ", "Αυγ", "Σεπ", "Οκτ", "Νοε", "Δεκ"], dayNames:["Κυριακή", "Δευτέρα", "Τρίτη", "Τετάρτη", "Πέμπτη", "Παρασκευή", "Σάββατο"], dayNamesShort:["Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ"], dayNamesMin:["Κυ", "Δε", "Τρ", "Τε", "Πε", "Πα", "Σα"], weekHeader:"Εβδ", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.el)
}), jQuery(function (a) {
    a.datepicker.regional["en-AU"] = {closeText:"Done", prevText:"Prev", nextText:"Next", currentText:"Today", monthNames:["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dayNames:["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], dayNamesShort:["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], dayNamesMin:["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], weekHeader:"Wk", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional["en-AU"])
}), jQuery(function (a) {
    a.datepicker.regional["en-GB"] = {closeText:"Done", prevText:"Prev", nextText:"Next", currentText:"Today", monthNames:["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dayNames:["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], dayNamesShort:["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], dayNamesMin:["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], weekHeader:"Wk", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional["en-GB"])
}), jQuery(function (a) {
    a.datepicker.regional["en-NZ"] = {closeText:"Done", prevText:"Prev", nextText:"Next", currentText:"Today", monthNames:["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"], dayNames:["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"], dayNamesShort:["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"], dayNamesMin:["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"], weekHeader:"Wk", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional["en-NZ"])
}), jQuery(function (a) {
    a.datepicker.regional.eo = {closeText:"Fermi", prevText:"&lt;Anta", nextText:"Sekv&gt;", currentText:"Nuna", monthNames:["Januaro", "Februaro", "Marto", "Aprilo", "Majo", "Junio", "Julio", "Aŭgusto", "Septembro", "Oktobro", "Novembro", "Decembro"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aŭg", "Sep", "Okt", "Nov", "Dec"], dayNames:["Dimanĉo", "Lundo", "Mardo", "Merkredo", "Ĵaŭdo", "Vendredo", "Sabato"], dayNamesShort:["Dim", "Lun", "Mar", "Mer", "Ĵaŭ", "Ven", "Sab"], dayNamesMin:["Di", "Lu", "Ma", "Me", "Ĵa", "Ve", "Sa"], weekHeader:"Sb", dateFormat:"dd/mm/yy", firstDay:0, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.eo)
}), jQuery(function (a) {
    a.datepicker.regional.es = {closeText:"Cerrar", prevText:"&#x3c;Ant", nextText:"Sig&#x3e;", currentText:"Hoy", monthNames:["Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"], monthNamesShort:["Ene", "Feb", "Mar", "Abr", "May", "Jun", "Jul", "Ago", "Sep", "Oct", "Nov", "Dic"], dayNames:["Domingo", "Lunes", "Martes", "Mi&eacute;rcoles", "Jueves", "Viernes", "S&aacute;bado"], dayNamesShort:["Dom", "Lun", "Mar", "Mi&eacute;", "Juv", "Vie", "S&aacute;b"], dayNamesMin:["Do", "Lu", "Ma", "Mi", "Ju", "Vi", "S&aacute;"], weekHeader:"Sm", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.es)
}), jQuery(function (a) {
    a.datepicker.regional.et = {closeText:"Sulge", prevText:"Eelnev", nextText:"Järgnev", currentText:"Täna", monthNames:["Jaanuar", "Veebruar", "Märts", "Aprill", "Mai", "Juuni", "Juuli", "August", "September", "Oktoober", "November", "Detsember"], monthNamesShort:["Jaan", "Veebr", "Märts", "Apr", "Mai", "Juuni", "Juuli", "Aug", "Sept", "Okt", "Nov", "Dets"], dayNames:["Pühapäev", "Esmaspäev", "Teisipäev", "Kolmapäev", "Neljapäev", "Reede", "Laupäev"], dayNamesShort:["Pühap", "Esmasp", "Teisip", "Kolmap", "Neljap", "Reede", "Laup"], dayNamesMin:["P", "E", "T", "K", "N", "R", "L"], weekHeader:"Sm", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.et)
}), jQuery(function (a) {
    a.datepicker.regional.eu = {closeText:"Egina", prevText:"&#x3c;Aur", nextText:"Hur&#x3e;", currentText:"Gaur", monthNames:["Urtarrila", "Otsaila", "Martxoa", "Apirila", "Maiatza", "Ekaina", "Uztaila", "Abuztua", "Iraila", "Urria", "Azaroa", "Abendua"], monthNamesShort:["Urt", "Ots", "Mar", "Api", "Mai", "Eka", "Uzt", "Abu", "Ira", "Urr", "Aza", "Abe"], dayNames:["Igandea", "Astelehena", "Asteartea", "Asteazkena", "Osteguna", "Ostirala", "Larunbata"], dayNamesShort:["Iga", "Ast", "Ast", "Ast", "Ost", "Ost", "Lar"], dayNamesMin:["Ig", "As", "As", "As", "Os", "Os", "La"], weekHeader:"Wk", dateFormat:"yy/mm/dd", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.eu)
}), jQuery(function (a) {
    a.datepicker.regional.fa = {closeText:"بستن", prevText:"&#x3c;قبلي", nextText:"بعدي&#x3e;", currentText:"امروز", monthNames:["فروردين", "ارديبهشت", "خرداد", "تير", "مرداد", "شهريور", "مهر", "آبان", "آذر", "دي", "بهمن", "اسفند"], monthNamesShort:["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], dayNames:["يکشنبه", "دوشنبه", "سه‌شنبه", "چهارشنبه", "پنجشنبه", "جمعه", "شنبه"], dayNamesShort:["ي", "د", "س", "چ", "پ", "ج", "ش"], dayNamesMin:["ي", "د", "س", "چ", "پ", "ج", "ش"], weekHeader:"هف", dateFormat:"yy/mm/dd", firstDay:6, isRTL:!0, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.fa)
}), jQuery(function (a) {
    a.datepicker.regional.fi = {closeText:"Sulje", prevText:"&laquo;Edellinen", nextText:"Seuraava&raquo;", currentText:"T&auml;n&auml;&auml;n", monthNames:["Tammikuu", "Helmikuu", "Maaliskuu", "Huhtikuu", "Toukokuu", "Kes&auml;kuu", "Hein&auml;kuu", "Elokuu", "Syyskuu", "Lokakuu", "Marraskuu", "Joulukuu"], monthNamesShort:["Tammi", "Helmi", "Maalis", "Huhti", "Touko", "Kes&auml;", "Hein&auml;", "Elo", "Syys", "Loka", "Marras", "Joulu"], dayNamesShort:["Su", "Ma", "Ti", "Ke", "To", "Pe", "Su"], dayNames:["Sunnuntai", "Maanantai", "Tiistai", "Keskiviikko", "Torstai", "Perjantai", "Lauantai"], dayNamesMin:["Su", "Ma", "Ti", "Ke", "To", "Pe", "La"], weekHeader:"Vk", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.fi)
}), jQuery(function (a) {
    a.datepicker.regional.fo = {closeText:"Lat aftur", prevText:"&#x3c;Fyrra", nextText:"Næsta&#x3e;", currentText:"Í dag", monthNames:["Januar", "Februar", "Mars", "Apríl", "Mei", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Des"], dayNames:["Sunnudagur", "Mánadagur", "Týsdagur", "Mikudagur", "Hósdagur", "Fríggjadagur", "Leyardagur"], dayNamesShort:["Sun", "Mán", "Týs", "Mik", "Hós", "Frí", "Ley"], dayNamesMin:["Su", "Má", "Tý", "Mi", "Hó", "Fr", "Le"], weekHeader:"Vk", dateFormat:"dd-mm-yy", firstDay:0, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.fo)
}), jQuery(function (a) {
    a.datepicker.regional["fr-CH"] = {closeText:"Fermer", prevText:"&#x3c;Préc", nextText:"Suiv&#x3e;", currentText:"Courant", monthNames:["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"], monthNamesShort:["Jan", "Fév", "Mar", "Avr", "Mai", "Jun", "Jul", "Aoû", "Sep", "Oct", "Nov", "Déc"], dayNames:["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"], dayNamesShort:["Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"], dayNamesMin:["Di", "Lu", "Ma", "Me", "Je", "Ve", "Sa"], weekHeader:"Sm", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional["fr-CH"])
}), jQuery(function (a) {
    a.datepicker.regional.fr = {closeText:"Fermer", prevText:"Précédent", nextText:"Suivant", currentText:"Aujourd'hui", monthNames:["Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"], monthNamesShort:["Janv.", "Févr.", "Mars", "Avril", "Mai", "Juin", "Juil.", "Août", "Sept.", "Oct.", "Nov.", "Déc."], dayNames:["Dimanche", "Lundi", "Mardi", "Mercredi", "Jeudi", "Vendredi", "Samedi"], dayNamesShort:["Dim.", "Lun.", "Mar.", "Mer.", "Jeu.", "Ven.", "Sam."], dayNamesMin:["D", "L", "M", "M", "J", "V", "S"], weekHeader:"Sem.", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.fr)
}), jQuery(function (a) {
    a.datepicker.regional.gl = {closeText:"Pechar", prevText:"&#x3c;Ant", nextText:"Seg&#x3e;", currentText:"Hoxe", monthNames:["Xaneiro", "Febreiro", "Marzo", "Abril", "Maio", "Xuño", "Xullo", "Agosto", "Setembro", "Outubro", "Novembro", "Decembro"], monthNamesShort:["Xan", "Feb", "Mar", "Abr", "Mai", "Xuñ", "Xul", "Ago", "Set", "Out", "Nov", "Dec"], dayNames:["Domingo", "Luns", "Martes", "M&eacute;rcores", "Xoves", "Venres", "S&aacute;bado"], dayNamesShort:["Dom", "Lun", "Mar", "M&eacute;r", "Xov", "Ven", "S&aacute;b"], dayNamesMin:["Do", "Lu", "Ma", "M&eacute;", "Xo", "Ve", "S&aacute;"], weekHeader:"Sm", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.gl)
}), jQuery(function (a) {
    a.datepicker.regional.he = {closeText:"סגור", prevText:"&#x3c;הקודם", nextText:"הבא&#x3e;", currentText:"היום", monthNames:["ינואר", "פברואר", "מרץ", "אפריל", "מאי", "יוני", "יולי", "אוגוסט", "ספטמבר", "אוקטובר", "נובמבר", "דצמבר"], monthNamesShort:["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"], dayNames:["ראשון", "שני", "שלישי", "רביעי", "חמישי", "שישי", "שבת"], dayNamesShort:["א'", "ב'", "ג'", "ד'", "ה'", "ו'", "שבת"], dayNamesMin:["א'", "ב'", "ג'", "ד'", "ה'", "ו'", "שבת"], weekHeader:"Wk", dateFormat:"dd/mm/yy", firstDay:0, isRTL:!0, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.he)
}), jQuery(function (a) {
    a.datepicker.regional.hr = {closeText:"Zatvori", prevText:"&#x3c;", nextText:"&#x3e;", currentText:"Danas", monthNames:["Siječanj", "Veljača", "Ožujak", "Travanj", "Svibanj", "Lipanj", "Srpanj", "Kolovoz", "Rujan", "Listopad", "Studeni", "Prosinac"], monthNamesShort:["Sij", "Velj", "Ožu", "Tra", "Svi", "Lip", "Srp", "Kol", "Ruj", "Lis", "Stu", "Pro"], dayNames:["Nedjelja", "Ponedjeljak", "Utorak", "Srijeda", "Četvrtak", "Petak", "Subota"], dayNamesShort:["Ned", "Pon", "Uto", "Sri", "Čet", "Pet", "Sub"], dayNamesMin:["Ne", "Po", "Ut", "Sr", "Če", "Pe", "Su"], weekHeader:"Tje", dateFormat:"dd.mm.yy.", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.hr)
}), jQuery(function (a) {
    a.datepicker.regional.hu = {closeText:"bezár", prevText:"vissza", nextText:"előre", currentText:"ma", monthNames:["Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"], monthNamesShort:["Jan", "Feb", "Már", "Ápr", "Máj", "Jún", "Júl", "Aug", "Szep", "Okt", "Nov", "Dec"], dayNames:["Vasárnap", "Hétfő", "Kedd", "Szerda", "Csütörtök", "Péntek", "Szombat"], dayNamesShort:["Vas", "Hét", "Ked", "Sze", "Csü", "Pén", "Szo"], dayNamesMin:["V", "H", "K", "Sze", "Cs", "P", "Szo"], weekHeader:"Hét", dateFormat:"yy.mm.dd.", firstDay:1, isRTL:!1, showMonthAfterYear:!0, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.hu)
}), jQuery(function (a) {
    a.datepicker.regional.hy = {closeText:"Փակել", prevText:"&#x3c;Նախ.", nextText:"Հաջ.&#x3e;", currentText:"Այսօր", monthNames:["Հունվար", "Փետրվար", "Մարտ", "Ապրիլ", "Մայիս", "Հունիս", "Հուլիս", "Օգոստոս", "Սեպտեմբեր", "Հոկտեմբեր", "Նոյեմբեր", "Դեկտեմբեր"], monthNamesShort:["Հունվ", "Փետր", "Մարտ", "Ապր", "Մայիս", "Հունիս", "Հուլ", "Օգս", "Սեպ", "Հոկ", "Նոյ", "Դեկ"], dayNames:["կիրակի", "եկուշաբթի", "երեքշաբթի", "չորեքշաբթի", "հինգշաբթի", "ուրբաթ", "շաբաթ"], dayNamesShort:["կիր", "երկ", "երք", "չրք", "հնգ", "ուրբ", "շբթ"], dayNamesMin:["կիր", "երկ", "երք", "չրք", "հնգ", "ուրբ", "շբթ"], weekHeader:"ՇԲՏ", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.hy)
}), jQuery(function (a) {
    a.datepicker.regional.id = {closeText:"Tutup", prevText:"&#x3c;mundur", nextText:"maju&#x3e;", currentText:"hari ini", monthNames:["Januari", "Februari", "Maret", "April", "Mei", "Juni", "Juli", "Agustus", "September", "Oktober", "Nopember", "Desember"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Mei", "Jun", "Jul", "Agus", "Sep", "Okt", "Nop", "Des"], dayNames:["Minggu", "Senin", "Selasa", "Rabu", "Kamis", "Jumat", "Sabtu"], dayNamesShort:["Min", "Sen", "Sel", "Rab", "kam", "Jum", "Sab"], dayNamesMin:["Mg", "Sn", "Sl", "Rb", "Km", "jm", "Sb"], weekHeader:"Mg", dateFormat:"dd/mm/yy", firstDay:0, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.id)
}), jQuery(function (a) {
    a.datepicker.regional.is = {closeText:"Loka", prevText:"&#x3c; Fyrri", nextText:"N&aelig;sti &#x3e;", currentText:"&Iacute; dag", monthNames:["Jan&uacute;ar", "Febr&uacute;ar", "Mars", "Apr&iacute;l", "Ma&iacute", "J&uacute;n&iacute;", "J&uacute;l&iacute;", "&Aacute;g&uacute;st", "September", "Okt&oacute;ber", "N&oacute;vember", "Desember"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Ma&iacute;", "J&uacute;n", "J&uacute;l", "&Aacute;g&uacute;", "Sep", "Okt", "N&oacute;v", "Des"], dayNames:["Sunnudagur", "M&aacute;nudagur", "&THORN;ri&eth;judagur", "Mi&eth;vikudagur", "Fimmtudagur", "F&ouml;studagur", "Laugardagur"], dayNamesShort:["Sun", "M&aacute;n", "&THORN;ri", "Mi&eth;", "Fim", "F&ouml;s", "Lau"], dayNamesMin:["Su", "M&aacute;", "&THORN;r", "Mi", "Fi", "F&ouml;", "La"], weekHeader:"Vika", dateFormat:"dd/mm/yy", firstDay:0, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.is)
}), jQuery(function (a) {
    a.datepicker.regional.it = {closeText:"Chiudi", prevText:"&#x3c;Prec", nextText:"Succ&#x3e;", currentText:"Oggi", monthNames:["Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"], monthNamesShort:["Gen", "Feb", "Mar", "Apr", "Mag", "Giu", "Lug", "Ago", "Set", "Ott", "Nov", "Dic"], dayNames:["Domenica", "Luned&#236", "Marted&#236", "Mercoled&#236", "Gioved&#236", "Venerd&#236", "Sabato"], dayNamesShort:["Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"], dayNamesMin:["Do", "Lu", "Ma", "Me", "Gi", "Ve", "Sa"], weekHeader:"Sm", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.it)
}), jQuery(function (a) {
    a.datepicker.regional.ja = {closeText:"閉じる", prevText:"&#x3c;前", nextText:"次&#x3e;", currentText:"今日", monthNames:["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"], monthNamesShort:["1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"], dayNames:["日曜日", "月曜日", "火曜日", "水曜日", "木曜日", "金曜日", "土曜日"], dayNamesShort:["日", "月", "火", "水", "木", "金", "土"], dayNamesMin:["日", "月", "火", "水", "木", "金", "土"], weekHeader:"週", dateFormat:"yy/mm/dd", firstDay:0, isRTL:!1, showMonthAfterYear:!0, yearSuffix:"年"}, a.datepicker.setDefaults(a.datepicker.regional.ja)
}), jQuery(function (a) {
    a.datepicker.regional.kk = {closeText:"Жабу", prevText:"&#x3c;Алдыңғы", nextText:"Келесі&#x3e;", currentText:"Бүгін", monthNames:["Қаңтар", "Ақпан", "Наурыз", "Сәуір", "Мамыр", "Маусым", "Шілде", "Тамыз", "Қыркүйек", "Қазан", "Қараша", "Желтоқсан"], monthNamesShort:["Қаң", "Ақп", "Нау", "Сәу", "Мам", "Мау", "Шіл", "Там", "Қыр", "Қаз", "Қар", "Жел"], dayNames:["Жексенбі", "Дүйсенбі", "Сейсенбі", "Сәрсенбі", "Бейсенбі", "Жұма", "Сенбі"], dayNamesShort:["жкс", "дсн", "ссн", "срс", "бсн", "жма", "снб"], dayNamesMin:["Жк", "Дс", "Сс", "Ср", "Бс", "Жм", "Сн"], weekHeader:"Не", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.kk)
}), jQuery(function (a) {
    a.datepicker.regional.ko = {closeText:"닫기", prevText:"이전달", nextText:"다음달", currentText:"오늘", monthNames:["1월(JAN)", "2월(FEB)", "3월(MAR)", "4월(APR)", "5월(MAY)", "6월(JUN)", "7월(JUL)", "8월(AUG)", "9월(SEP)", "10월(OCT)", "11월(NOV)", "12월(DEC)"], monthNamesShort:["1월(JAN)", "2월(FEB)", "3월(MAR)", "4월(APR)", "5월(MAY)", "6월(JUN)", "7월(JUL)", "8월(AUG)", "9월(SEP)", "10월(OCT)", "11월(NOV)", "12월(DEC)"], dayNames:["일", "월", "화", "수", "목", "금", "토"], dayNamesShort:["일", "월", "화", "수", "목", "금", "토"], dayNamesMin:["일", "월", "화", "수", "목", "금", "토"], weekHeader:"Wk", dateFormat:"yy-mm-dd", firstDay:0, isRTL:!1, showMonthAfterYear:!1, yearSuffix:"년"}, a.datepicker.setDefaults(a.datepicker.regional.ko)
}), jQuery(function (a) {
    a.datepicker.regional.lb = {closeText:"Fäerdeg", prevText:"Zréck", nextText:"Weider", currentText:"Haut", monthNames:["Januar", "Februar", "Mäerz", "Abrëll", "Mee", "Juni", "Juli", "August", "September", "Oktober", "November", "Dezember"], monthNamesShort:["Jan", "Feb", "Mäe", "Abr", "Mee", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dez"], dayNames:["Sonndeg", "Méindeg", "Dënschdeg", "Mëttwoch", "Donneschdeg", "Freideg", "Samschdeg"], dayNamesShort:["Son", "Méi", "Dën", "Mët", "Don", "Fre", "Sam"], dayNamesMin:["So", "Mé", "Dë", "Më", "Do", "Fr", "Sa"], weekHeader:"W", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.lb)
}), jQuery(function (a) {
    a.datepicker.regional.lt = {closeText:"Uždaryti", prevText:"&#x3c;Atgal", nextText:"Pirmyn&#x3e;", currentText:"Šiandien", monthNames:["Sausis", "Vasaris", "Kovas", "Balandis", "Gegužė", "Birželis", "Liepa", "Rugpjūtis", "Rugsėjis", "Spalis", "Lapkritis", "Gruodis"], monthNamesShort:["Sau", "Vas", "Kov", "Bal", "Geg", "Bir", "Lie", "Rugp", "Rugs", "Spa", "Lap", "Gru"], dayNames:["sekmadienis", "pirmadienis", "antradienis", "trečiadienis", "ketvirtadienis", "penktadienis", "šeštadienis"], dayNamesShort:["sek", "pir", "ant", "tre", "ket", "pen", "šeš"], dayNamesMin:["Se", "Pr", "An", "Tr", "Ke", "Pe", "Še"], weekHeader:"Wk", dateFormat:"yy-mm-dd", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.lt)
}), jQuery(function (a) {
    a.datepicker.regional.lv = {closeText:"Aizvērt", prevText:"Iepr", nextText:"Nāka", currentText:"Šodien", monthNames:["Janvāris", "Februāris", "Marts", "Aprīlis", "Maijs", "Jūnijs", "Jūlijs", "Augusts", "Septembris", "Oktobris", "Novembris", "Decembris"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Mai", "Jūn", "Jūl", "Aug", "Sep", "Okt", "Nov", "Dec"], dayNames:["svētdiena", "pirmdiena", "otrdiena", "trešdiena", "ceturtdiena", "piektdiena", "sestdiena"], dayNamesShort:["svt", "prm", "otr", "tre", "ctr", "pkt", "sst"], dayNamesMin:["Sv", "Pr", "Ot", "Tr", "Ct", "Pk", "Ss"], weekHeader:"Nav", dateFormat:"dd-mm-yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.lv)
}), jQuery(function (a) {
    a.datepicker.regional.mk = {closeText:"Затвори", prevText:"&#x3C;", nextText:"&#x3E;", currentText:"Денес", monthNames:["Јануари", "Фебруари", "Март", "Април", "Мај", "Јуни", "Јули", "Август", "Септември", "Октомври", "Ноември", "Декември"], monthNamesShort:["Јан", "Феб", "Мар", "Апр", "Мај", "Јун", "Јул", "Авг", "Сеп", "Окт", "Ное", "Дек"], dayNames:["Недела", "Понеделник", "Вторник", "Среда", "Четврток", "Петок", "Сабота"], dayNamesShort:["Нед", "Пон", "Вто", "Сре", "Чет", "Пет", "Саб"], dayNamesMin:["Не", "По", "Вт", "Ср", "Че", "Пе", "Са"], weekHeader:"Сед", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.mk)
}), jQuery(function (a) {
    a.datepicker.regional.ml = {closeText:"ശരി", prevText:"മുന്നത്തെ", nextText:"അടുത്തത് ", currentText:"ഇന്ന്", monthNames:["ജനുവരി", "ഫെബ്രുവരി", "മാര്‍ച്ച്", "ഏപ്രില്‍", "മേയ്", "ജൂണ്‍", "ജൂലൈ", "ആഗസ്റ്റ്", "സെപ്റ്റംബര്‍", "ഒക്ടോബര്‍", "നവംബര്‍", "ഡിസംബര്‍"], monthNamesShort:["ജനു", "ഫെബ്", "മാര്‍", "ഏപ്രി", "മേയ്", "ജൂണ്‍", "ജൂലാ", "ആഗ", "സെപ്", "ഒക്ടോ", "നവം", "ഡിസ"], dayNames:["ഞായര്‍", "തിങ്കള്‍", "ചൊവ്വ", "ബുധന്‍", "വ്യാഴം", "വെള്ളി", "ശനി"], dayNamesShort:["ഞായ", "തിങ്ക", "ചൊവ്വ", "ബുധ", "വ്യാഴം", "വെള്ളി", "ശനി"], dayNamesMin:["ഞാ", "തി", "ചൊ", "ബു", "വ്യാ", "വെ", "ശ"], weekHeader:"ആ", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.ml)
}), jQuery(function (a) {
    a.datepicker.regional.ms = {closeText:"Tutup", prevText:"&#x3c;Sebelum", nextText:"Selepas&#x3e;", currentText:"hari ini", monthNames:["Januari", "Februari", "Mac", "April", "Mei", "Jun", "Julai", "Ogos", "September", "Oktober", "November", "Disember"], monthNamesShort:["Jan", "Feb", "Mac", "Apr", "Mei", "Jun", "Jul", "Ogo", "Sep", "Okt", "Nov", "Dis"], dayNames:["Ahad", "Isnin", "Selasa", "Rabu", "Khamis", "Jumaat", "Sabtu"], dayNamesShort:["Aha", "Isn", "Sel", "Rab", "kha", "Jum", "Sab"], dayNamesMin:["Ah", "Is", "Se", "Ra", "Kh", "Ju", "Sa"], weekHeader:"Mg", dateFormat:"dd/mm/yy", firstDay:0, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.ms)
}), jQuery(function (a) {
    a.datepicker.regional["nl-BE"] = {closeText:"Sluiten", prevText:"←", nextText:"→", currentText:"Vandaag", monthNames:["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"], monthNamesShort:["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"], dayNames:["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"], dayNamesShort:["zon", "maa", "din", "woe", "don", "vri", "zat"], dayNamesMin:["zo", "ma", "di", "wo", "do", "vr", "za"], weekHeader:"Wk", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional["nl-BE"])
}), jQuery(function (a) {
    a.datepicker.regional.nl = {closeText:"Sluiten", prevText:"←", nextText:"→", currentText:"Vandaag", monthNames:["januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"], monthNamesShort:["jan", "feb", "mrt", "apr", "mei", "jun", "jul", "aug", "sep", "okt", "nov", "dec"], dayNames:["zondag", "maandag", "dinsdag", "woensdag", "donderdag", "vrijdag", "zaterdag"], dayNamesShort:["zon", "maa", "din", "woe", "don", "vri", "zat"], dayNamesMin:["zo", "ma", "di", "wo", "do", "vr", "za"], weekHeader:"Wk", dateFormat:"dd-mm-yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.nl)
}), jQuery(function (a) {
    a.datepicker.regional.no = {closeText:"Lukk", prevText:"&laquo;Forrige", nextText:"Neste&raquo;", currentText:"I dag", monthNames:["januar", "februar", "mars", "april", "mai", "juni", "juli", "august", "september", "oktober", "november", "desember"], monthNamesShort:["jan", "feb", "mar", "apr", "mai", "jun", "jul", "aug", "sep", "okt", "nov", "des"], dayNamesShort:["søn", "man", "tir", "ons", "tor", "fre", "lør"], dayNames:["søndag", "mandag", "tirsdag", "onsdag", "torsdag", "fredag", "lørdag"], dayNamesMin:["sø", "ma", "ti", "on", "to", "fr", "lø"], weekHeader:"Uke", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.no)
}), jQuery(function (a) {
    a.datepicker.regional.pl = {closeText:"Zamknij", prevText:"&#x3c;Poprzedni", nextText:"Następny&#x3e;", currentText:"Dziś", monthNames:["Styczeń", "Luty", "Marzec", "Kwiecień", "Maj", "Czerwiec", "Lipiec", "Sierpień", "Wrzesień", "Październik", "Listopad", "Grudzień"], monthNamesShort:["Sty", "Lu", "Mar", "Kw", "Maj", "Cze", "Lip", "Sie", "Wrz", "Pa", "Lis", "Gru"], dayNames:["Niedziela", "Poniedziałek", "Wtorek", "Środa", "Czwartek", "Piątek", "Sobota"], dayNamesShort:["Nie", "Pn", "Wt", "Śr", "Czw", "Pt", "So"], dayNamesMin:["N", "Pn", "Wt", "Śr", "Cz", "Pt", "So"], weekHeader:"Tydz", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.pl)
}), jQuery(function (a) {
    a.datepicker.regional["pt-BR"] = {closeText:"Fechar", prevText:"&#x3c;Anterior", nextText:"Pr&oacute;ximo&#x3e;", currentText:"Hoje", monthNames:["Janeiro", "Fevereiro", "Mar&ccedil;o", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], monthNamesShort:["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"], dayNames:["Domingo", "Segunda-feira", "Ter&ccedil;a-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "S&aacute;bado"], dayNamesShort:["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S&aacute;b"], dayNamesMin:["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S&aacute;b"], weekHeader:"Sm", dateFormat:"dd/mm/yy", firstDay:0, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional["pt-BR"])
}), jQuery(function (a) {
    a.datepicker.regional.pt = {closeText:"Fechar", prevText:"&#x3c;Anterior", nextText:"Seguinte", currentText:"Hoje", monthNames:["Janeiro", "Fevereiro", "Mar&ccedil;o", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"], monthNamesShort:["Jan", "Fev", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Out", "Nov", "Dez"], dayNames:["Domingo", "Segunda-feira", "Ter&ccedil;a-feira", "Quarta-feira", "Quinta-feira", "Sexta-feira", "S&aacute;bado"], dayNamesShort:["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S&aacute;b"], dayNamesMin:["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "S&aacute;b"], weekHeader:"Sem", dateFormat:"dd/mm/yy", firstDay:0, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.pt)
}), jQuery(function (a) {
    a.datepicker.regional.rm = {closeText:"Serrar", prevText:"&#x3c;Suandant", nextText:"Precedent&#x3e;", currentText:"Actual", monthNames:["Schaner", "Favrer", "Mars", "Avrigl", "Matg", "Zercladur", "Fanadur", "Avust", "Settember", "October"
        , "November", "December"], monthNamesShort:["Scha", "Fev", "Mar", "Avr", "Matg", "Zer", "Fan", "Avu", "Sett", "Oct", "Nov", "Dec"], dayNames:["Dumengia", "Glindesdi", "Mardi", "Mesemna", "Gievgia", "Venderdi", "Sonda"], dayNamesShort:["Dum", "Gli", "Mar", "Mes", "Gie", "Ven", "Som"], dayNamesMin:["Du", "Gl", "Ma", "Me", "Gi", "Ve", "So"], weekHeader:"emna", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.rm)
}), jQuery(function (a) {
    a.datepicker.regional.ro = {closeText:"Închide", prevText:"&laquo; Luna precedentă", nextText:"Luna următoare &raquo;", currentText:"Azi", monthNames:["Ianuarie", "Februarie", "Martie", "Aprilie", "Mai", "Iunie", "Iulie", "August", "Septembrie", "Octombrie", "Noiembrie", "Decembrie"], monthNamesShort:["Ian", "Feb", "Mar", "Apr", "Mai", "Iun", "Iul", "Aug", "Sep", "Oct", "Nov", "Dec"], dayNames:["Duminică", "Luni", "Marţi", "Miercuri", "Joi", "Vineri", "Sâmbătă"], dayNamesShort:["Dum", "Lun", "Mar", "Mie", "Joi", "Vin", "Sâm"], dayNamesMin:["Du", "Lu", "Ma", "Mi", "Jo", "Vi", "Sâ"], weekHeader:"Săpt", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.ro)
}), jQuery(function (a) {
    a.datepicker.regional.ru = {closeText:"Закрыть", prevText:"&#x3c;Пред", nextText:"След&#x3e;", currentText:"Сегодня", monthNames:["Январь", "Февраль", "Март", "Апрель", "Май", "Июнь", "Июль", "Август", "Сентябрь", "Октябрь", "Ноябрь", "Декабрь"], monthNamesShort:["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"], dayNames:["воскресенье", "понедельник", "вторник", "среда", "четверг", "пятница", "суббота"], dayNamesShort:["вск", "пнд", "втр", "срд", "чтв", "птн", "сбт"], dayNamesMin:["Вс", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"], weekHeader:"Нед", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.ru)
}), jQuery(function (a) {
    a.datepicker.regional.sk = {closeText:"Zavrieť", prevText:"&#x3c;Predchádzajúci", nextText:"Nasledujúci&#x3e;", currentText:"Dnes", monthNames:["Január", "Február", "Marec", "Apríl", "Máj", "Jún", "Júl", "August", "September", "Október", "November", "December"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Máj", "Jún", "Júl", "Aug", "Sep", "Okt", "Nov", "Dec"], dayNames:["Nedeľa", "Pondelok", "Utorok", "Streda", "Štvrtok", "Piatok", "Sobota"], dayNamesShort:["Ned", "Pon", "Uto", "Str", "Štv", "Pia", "Sob"], dayNamesMin:["Ne", "Po", "Ut", "St", "Št", "Pia", "So"], weekHeader:"Ty", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.sk)
}), jQuery(function (a) {
    a.datepicker.regional.sl = {closeText:"Zapri", prevText:"&lt;Prej&#x161;nji", nextText:"Naslednji&gt;", currentText:"Trenutni", monthNames:["Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"], dayNames:["Nedelja", "Ponedeljek", "Torek", "Sreda", "&#x10C;etrtek", "Petek", "Sobota"], dayNamesShort:["Ned", "Pon", "Tor", "Sre", "&#x10C;et", "Pet", "Sob"], dayNamesMin:["Ne", "Po", "To", "Sr", "&#x10C;e", "Pe", "So"], weekHeader:"Teden", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.sl)
}), jQuery(function (a) {
    a.datepicker.regional.sq = {closeText:"mbylle", prevText:"&#x3c;mbrapa", nextText:"Përpara&#x3e;", currentText:"sot", monthNames:["Janar", "Shkurt", "Mars", "Prill", "Maj", "Qershor", "Korrik", "Gusht", "Shtator", "Tetor", "Nëntor", "Dhjetor"], monthNamesShort:["Jan", "Shk", "Mar", "Pri", "Maj", "Qer", "Kor", "Gus", "Sht", "Tet", "Nën", "Dhj"], dayNames:["E Diel", "E Hënë", "E Martë", "E Mërkurë", "E Enjte", "E Premte", "E Shtune"], dayNamesShort:["Di", "Hë", "Ma", "Më", "En", "Pr", "Sh"], dayNamesMin:["Di", "Hë", "Ma", "Më", "En", "Pr", "Sh"], weekHeader:"Ja", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.sq)
}), jQuery(function (a) {
    a.datepicker.regional["sr-SR"] = {closeText:"Zatvori", prevText:"&#x3c;", nextText:"&#x3e;", currentText:"Danas", monthNames:["Januar", "Februar", "Mart", "April", "Maj", "Jun", "Jul", "Avgust", "Septembar", "Oktobar", "Novembar", "Decembar"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Avg", "Sep", "Okt", "Nov", "Dec"], dayNames:["Nedelja", "Ponedeljak", "Utorak", "Sreda", "Četvrtak", "Petak", "Subota"], dayNamesShort:["Ned", "Pon", "Uto", "Sre", "Čet", "Pet", "Sub"], dayNamesMin:["Ne", "Po", "Ut", "Sr", "Če", "Pe", "Su"], weekHeader:"Sed", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional["sr-SR"])
}), jQuery(function (a) {
    a.datepicker.regional.sr = {closeText:"Затвори", prevText:"&#x3c;", nextText:"&#x3e;", currentText:"Данас", monthNames:["Јануар", "Фебруар", "Март", "Април", "Мај", "Јун", "Јул", "Август", "Септембар", "Октобар", "Новембар", "Децембар"], monthNamesShort:["Јан", "Феб", "Мар", "Апр", "Мај", "Јун", "Јул", "Авг", "Сеп", "Окт", "Нов", "Дец"], dayNames:["Недеља", "Понедељак", "Уторак", "Среда", "Четвртак", "Петак", "Субота"], dayNamesShort:["Нед", "Пон", "Уто", "Сре", "Чет", "Пет", "Суб"], dayNamesMin:["Не", "По", "Ут", "Ср", "Че", "Пе", "Су"], weekHeader:"Сед", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.sr)
}), jQuery(function (a) {
    a.datepicker.regional.sv = {closeText:"Stäng", prevText:"&laquo;Förra", nextText:"Nästa&raquo;", currentText:"Idag", monthNames:["Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September", "Oktober", "November", "December"], monthNamesShort:["Jan", "Feb", "Mar", "Apr", "Maj", "Jun", "Jul", "Aug", "Sep", "Okt", "Nov", "Dec"], dayNamesShort:["Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"], dayNames:["Söndag", "Måndag", "Tisdag", "Onsdag", "Torsdag", "Fredag", "Lördag"], dayNamesMin:["Sö", "Må", "Ti", "On", "To", "Fr", "Lö"], weekHeader:"Ve", dateFormat:"yy-mm-dd", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.sv)
}), jQuery(function (a) {
    a.datepicker.regional.ta = {closeText:"மூடு", prevText:"முன்னையது", nextText:"அடுத்தது", currentText:"இன்று", monthNames:["தை", "மாசி", "பங்குனி", "சித்திரை", "வைகாசி", "ஆனி", "ஆடி", "ஆவணி", "புரட்டாசி", "ஐப்பசி", "கார்த்திகை", "மார்கழி"], monthNamesShort:["தை", "மாசி", "பங்", "சித்", "வைகா", "ஆனி", "ஆடி", "ஆவ", "புர", "ஐப்", "கார்", "மார்"], dayNames:["ஞாயிற்றுக்கிழமை", "திங்கட்கிழமை", "செவ்வாய்க்கிழமை", "புதன்கிழமை", "வியாழக்கிழமை", "வெள்ளிக்கிழமை", "சனிக்கிழமை"], dayNamesShort:["ஞாயிறு", "திங்கள்", "செவ்வாய்", "புதன்", "வியாழன்", "வெள்ளி", "சனி"], dayNamesMin:["ஞா", "தி", "செ", "பு", "வி", "வெ", "ச"], weekHeader:"Не", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.ta)
}), jQuery(function (a) {
    a.datepicker.regional.th = {closeText:"ปิด", prevText:"&laquo;&nbsp;ย้อน", nextText:"ถัดไป&nbsp;&raquo;", currentText:"วันนี้", monthNames:["มกราคม", "กุมภาพันธ์", "มีนาคม", "เมษายน", "พฤษภาคม", "มิถุนายน", "กรกฎาคม", "สิงหาคม", "กันยายน", "ตุลาคม", "พฤศจิกายน", "ธันวาคม"], monthNamesShort:["ม.ค.", "ก.พ.", "มี.ค.", "เม.ย.", "พ.ค.", "มิ.ย.", "ก.ค.", "ส.ค.", "ก.ย.", "ต.ค.", "พ.ย.", "ธ.ค."], dayNames:["อาทิตย์", "จันทร์", "อังคาร", "พุธ", "พฤหัสบดี", "ศุกร์", "เสาร์"], dayNamesShort:["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."], dayNamesMin:["อา.", "จ.", "อ.", "พ.", "พฤ.", "ศ.", "ส."], weekHeader:"Wk", dateFormat:"dd/mm/yy", firstDay:0, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.th)
}), jQuery(function (a) {
    a.datepicker.regional.tj = {closeText:"Идома", prevText:"&#x3c;Қафо", nextText:"Пеш&#x3e;", currentText:"Имрӯз", monthNames:["Январ", "Феврал", "Март", "Апрел", "Май", "Июн", "Июл", "Август", "Сентябр", "Октябр", "Ноябр", "Декабр"], monthNamesShort:["Янв", "Фев", "Мар", "Апр", "Май", "Июн", "Июл", "Авг", "Сен", "Окт", "Ноя", "Дек"], dayNames:["якшанбе", "душанбе", "сешанбе", "чоршанбе", "панҷшанбе", "ҷумъа", "шанбе"], dayNamesShort:["якш", "душ", "сеш", "чор", "пан", "ҷум", "шан"], dayNamesMin:["Як", "Дш", "Сш", "Чш", "Пш", "Ҷм", "Шн"], weekHeader:"Хф", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.tj)
}), jQuery(function (a) {
    a.datepicker.regional.tr = {closeText:"kapat", prevText:"&#x3c;geri", nextText:"ileri&#x3e", currentText:"bugün", monthNames:["Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"], monthNamesShort:["Oca", "Şub", "Mar", "Nis", "May", "Haz", "Tem", "Ağu", "Eyl", "Eki", "Kas", "Ara"], dayNames:["Pazar", "Pazartesi", "Salı", "Çarşamba", "Perşembe", "Cuma", "Cumartesi"], dayNamesShort:["Pz", "Pt", "Sa", "Ça", "Pe", "Cu", "Ct"], dayNamesMin:["Pz", "Pt", "Sa", "Ça", "Pe", "Cu", "Ct"], weekHeader:"Hf", dateFormat:"dd.mm.yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.tr)
}), jQuery(function (a) {
    a.datepicker.regional.uk = {closeText:"Закрити", prevText:"&#x3c;", nextText:"&#x3e;", currentText:"Сьогодні", monthNames:["Січень", "Лютий", "Березень", "Квітень", "Травень", "Червень", "Липень", "Серпень", "Вересень", "Жовтень", "Листопад", "Грудень"], monthNamesShort:["Січ", "Лют", "Бер", "Кві", "Тра", "Чер", "Лип", "Сер", "Вер", "Жов", "Лис", "Гру"], dayNames:["неділя", "понеділок", "вівторок", "середа", "четвер", "п’ятниця", "субота"], dayNamesShort:["нед", "пнд", "вів", "срд", "чтв", "птн", "сбт"], dayNamesMin:["Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"], weekHeader:"Тиж", dateFormat:"dd/mm/yy", firstDay:1, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.uk)
}), jQuery(function (a) {
    a.datepicker.regional.vi = {closeText:"Đóng", prevText:"&#x3c;Trước", nextText:"Tiếp&#x3e;", currentText:"Hôm nay", monthNames:["Tháng Một", "Tháng Hai", "Tháng Ba", "Tháng Tư", "Tháng Năm", "Tháng Sáu", "Tháng Bảy", "Tháng Tám", "Tháng Chín", "Tháng Mười", "Tháng Mười Một", "Tháng Mười Hai"], monthNamesShort:["Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"], dayNames:["Chủ Nhật", "Thứ Hai", "Thứ Ba", "Thứ Tư", "Thứ Năm", "Thứ Sáu", "Thứ Bảy"], dayNamesShort:["CN", "T2", "T3", "T4", "T5", "T6", "T7"], dayNamesMin:["CN", "T2", "T3", "T4", "T5", "T6", "T7"], weekHeader:"Tu", dateFormat:"dd/mm/yy", firstDay:0, isRTL:!1, showMonthAfterYear:!1, yearSuffix:""}, a.datepicker.setDefaults(a.datepicker.regional.vi)
}), jQuery(function (a) {
    a.datepicker.regional["zh-CN"] = {closeText:"关闭", prevText:"&#x3c;上月", nextText:"下月&#x3e;", currentText:"今天", monthNames:["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"], monthNamesShort:["一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二"], dayNames:["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"], dayNamesShort:["周日", "周一", "周二", "周三", "周四", "周五", "周六"], dayNamesMin:["日", "一", "二", "三", "四", "五", "六"], weekHeader:"周", dateFormat:"yy-mm-dd", firstDay:1, isRTL:!1, showMonthAfterYear:!0, yearSuffix:"年"}, a.datepicker.setDefaults(a.datepicker.regional["zh-CN"])
}), jQuery(function (a) {
    a.datepicker.regional["zh-HK"] = {closeText:"關閉", prevText:"&#x3c;上月", nextText:"下月&#x3e;", currentText:"今天", monthNames:["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"], monthNamesShort:["一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二"], dayNames:["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"], dayNamesShort:["周日", "周一", "周二", "周三", "周四", "周五", "周六"], dayNamesMin:["日", "一", "二", "三", "四", "五", "六"], weekHeader:"周", dateFormat:"dd-mm-yy", firstDay:0, isRTL:!1, showMonthAfterYear:!0, yearSuffix:"年"}, a.datepicker.setDefaults(a.datepicker.regional["zh-HK"])
}), jQuery(function (a) {
    a.datepicker.regional["zh-TW"] = {closeText:"關閉", prevText:"&#x3c;上月", nextText:"下月&#x3e;", currentText:"今天", monthNames:["一月", "二月", "三月", "四月", "五月", "六月", "七月", "八月", "九月", "十月", "十一月", "十二月"], monthNamesShort:["一", "二", "三", "四", "五", "六", "七", "八", "九", "十", "十一", "十二"], dayNames:["星期日", "星期一", "星期二", "星期三", "星期四", "星期五", "星期六"], dayNamesShort:["周日", "周一", "周二", "周三", "周四", "周五", "周六"], dayNamesMin:["日", "一", "二", "三", "四", "五", "六"], weekHeader:"周", dateFormat:"yy/mm/dd", firstDay:1, isRTL:!1, showMonthAfterYear:!0, yearSuffix:"年"}, a.datepicker.setDefaults(a.datepicker.regional["zh-TW"])
});/*!
 * jQuery contextMenu - Plugin for simple contextMenu handling
 *
 * Version: git-master
 *
 * Authors: Rodney Rehm, Addy Osmani (patches for FF)
 * Web: http://medialize.github.com/jQuery-contextMenu/
 *
 * Licensed under
 *   MIT License http://www.opensource.org/licenses/mit-license
 *   GPL v3 http://opensource.org/licenses/GPL-3.0
 *
 */

(function($, undefined){

    // TODO: -
        // ARIA stuff: menuitem, menuitemcheckbox und menuitemradio
        // create <menu> structure if $.support[htmlCommand || htmlMenuitem] and !opt.disableNative

// determine html5 compatibility
$.support.htmlMenuitem = ('HTMLMenuItemElement' in window);
$.support.htmlCommand = ('HTMLCommandElement' in window);
$.support.eventSelectstart = ("onselectstart" in document.documentElement);
/* // should the need arise, test for css user-select
$.support.cssUserSelect = (function(){
    var t = false,
        e = document.createElement('div');

    $.each('Moz|Webkit|Khtml|O|ms|Icab|'.split('|'), function(i, prefix) {
        var propCC = prefix + (prefix ? 'U' : 'u') + 'serSelect',
            prop = (prefix ? ('-' + prefix.toLowerCase() + '-') : '') + 'user-select';

        e.style.cssText = prop + ': text;';
        if (e.style[propCC] == 'text') {
            t = true;
            return false;
        }

        return true;
    });

    return t;
})();
*/

if (!$.ui || !$.ui.widget) {
    // duck punch $.cleanData like jQueryUI does to get that remove event
    // https://github.com/jquery/jquery-ui/blob/master/ui/jquery.ui.widget.js#L16-24
    var _cleanData = $.cleanData;
    $.cleanData = function( elems ) {
        for ( var i = 0, elem; (elem = elems[i]) != null; i++ ) {
            try {
                $( elem ).triggerHandler( "remove" );
                // http://bugs.jquery.com/ticket/8235
            } catch( e ) {}
        }
        _cleanData( elems );
    };
}

var // currently active contextMenu trigger
    $currentTrigger = null,
    // is contextMenu initialized with at least one menu?
    initialized = false,
    // window handle
    $win = $(window),
    // number of registered menus
    counter = 0,
    // mapping selector to namespace
    namespaces = {},
    // mapping namespace to options
    menus = {},
    // custom command type handlers
    types = {},
    // default values
    defaults = {
        // selector of contextMenu trigger
        selector: null,
        // where to append the menu to
        appendTo: null,
        // method to trigger context menu ["right", "left", "hover"]
        trigger: "right",
        // hide menu when mouse leaves trigger / menu elements
        autoHide: false,
        // ms to wait before showing a hover-triggered context menu
        delay: 200,
        // flag denoting if a second trigger should simply move (true) or rebuild (false) an open menu
        // as long as the trigger happened on one of the trigger-element's child nodes
        reposition: true,
        // determine position to show menu at
        determinePosition: function($menu) {
            // position to the lower middle of the trigger element
            if ($.ui && $.ui.position) {
                // .position() is provided as a jQuery UI utility
                // (...and it won't work on hidden elements)
                $menu.css('display', 'block').position({
                    my: "center top",
                    at: "center bottom",
                    of: this,
                    offset: "0 5",
                    collision: "fit"
                }).css('display', 'none');
            } else {
                // determine contextMenu position
                var offset = this.offset();
                offset.top += this.outerHeight();
                offset.left += this.outerWidth() / 2 - $menu.outerWidth() / 2;
                $menu.css(offset);
            }
        },
        // position menu
        position: function(opt, x, y) {
            var $this = this,
                offset;
            // determine contextMenu position
            if (!x && !y) {
                opt.determinePosition.call(this, opt.$menu);
                return;
            } else if (x === "maintain" && y === "maintain") {
                // x and y must not be changed (after re-show on command click)
                offset = opt.$menu.position();
            } else {
                // x and y are given (by mouse event)
                offset = {top: y, left: x};
            }

            // correct offset if viewport demands it
            var bottom = $win.scrollTop() + $win.height(),
                right = $win.scrollLeft() + $win.width(),
                height = opt.$menu.height(),
                width = opt.$menu.width();

            if (offset.top + height > bottom) {
                offset.top -= height;
            }

            if (offset.left + width > right) {
                offset.left -= width;
            }

            opt.$menu.css(offset);
        },
        // position the sub-menu
        positionSubmenu: function($menu) {
            if ($.ui && $.ui.position) {
                // .position() is provided as a jQuery UI utility
                // (...and it won't work on hidden elements)
                $menu.css('display', 'block').position({
                    my: "left top",
                    at: "right top",
                    of: this,
                    collision: "flipfit fit"
                }).css('display', '');
            } else {
                // determine contextMenu position
                var offset = {
                    top: 0,
                    left: this.outerWidth()
                };
                $menu.css(offset);
            }
        },
        // offset to add to zIndex
        zIndex: 1,
        // show hide animation settings
        animation: {
            duration: 50,
            show: 'slideDown',
            hide: 'slideUp'
        },
        // events
        events: {
            show: $.noop,
            hide: $.noop
        },
        // default callback
        callback: null,
        // list of contextMenu items
        items: {}
    },
    // mouse position for hover activation
    hoveract = {
        timer: null,
        pageX: null,
        pageY: null
    },
    // determine zIndex
    zindex = function($t) {
        var zin = 0,
            $tt = $t;

        while (true) {
            zin = Math.max(zin, parseInt($tt.css('z-index'), 10) || 0);
            $tt = $tt.parent();
            if (!$tt || !$tt.length || "html body".indexOf($tt.prop('nodeName').toLowerCase()) > -1 ) {
                break;
            }
        }

        return zin;
    },
    // event handlers
    handle = {
        // abort anything
        abortevent: function(e){
            e.preventDefault();
            e.stopImmediatePropagation();
        },

        // contextmenu show dispatcher
        contextmenu: function(e) {
            var $this = $(this);

            // disable actual context-menu
            e.preventDefault();
            e.stopImmediatePropagation();

            // abort native-triggered events unless we're triggering on right click
            if (e.data.trigger != 'right' && e.originalEvent) {
                return;
            }

            // abort event if menu is visible for this trigger
            if ($this.hasClass('context-menu-active')) {
                return;
            }

            if (!$this.hasClass('context-menu-disabled')) {
                // theoretically need to fire a show event at <menu>
                // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#context-menus
                // var evt = jQuery.Event("show", { data: data, pageX: e.pageX, pageY: e.pageY, relatedTarget: this });
                // e.data.$menu.trigger(evt);

                $currentTrigger = $this;
                if (e.data.build) {
                    var built = e.data.build($currentTrigger, e);
                    // abort if build() returned false
                    if (built === false) {
                        return;
                    }

                    // dynamically build menu on invocation
                    e.data = $.extend(true, {}, defaults, e.data, built || {});

                    // abort if there are no items to display
                    if (!e.data.items || $.isEmptyObject(e.data.items)) {
                        // Note: jQuery captures and ignores errors from event handlers
                        if (window.console) {
                            (console.error || console.log)("No items specified to show in contextMenu");
                        }

                        throw new Error('No Items specified');
                    }

                    // backreference for custom command type creation
                    e.data.$trigger = $currentTrigger;

                    op.create(e.data);
                }
                // show menu
                op.show.call($this, e.data, e.pageX, e.pageY);
            }
        },
        // contextMenu left-click trigger
        click: function(e) {
            e.preventDefault();
            e.stopImmediatePropagation();
            $(this).trigger($.Event("contextmenu", { data: e.data, pageX: e.pageX, pageY: e.pageY }));
        },
        // contextMenu right-click trigger
        mousedown: function(e) {
            // register mouse down
            var $this = $(this);

            // hide any previous menus
            if ($currentTrigger && $currentTrigger.length && !$currentTrigger.is($this)) {
                $currentTrigger.data('contextMenu').$menu.trigger('contextmenu:hide');
            }

            // activate on right click
            if (e.button == 2) {
                $currentTrigger = $this.data('contextMenuActive', true);
            }
        },
        // contextMenu right-click trigger
        mouseup: function(e) {
            // show menu
            var $this = $(this);
            if ($this.data('contextMenuActive') && $currentTrigger && $currentTrigger.length && $currentTrigger.is($this) && !$this.hasClass('context-menu-disabled')) {
                e.preventDefault();
                e.stopImmediatePropagation();
                $currentTrigger = $this;
                $this.trigger($.Event("contextmenu", { data: e.data, pageX: e.pageX, pageY: e.pageY }));
            }

            $this.removeData('contextMenuActive');
        },
        // contextMenu hover trigger
        mouseenter: function(e) {
            var $this = $(this),
                $related = $(e.relatedTarget),
                $document = $(document);

            // abort if we're coming from a menu
            if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                return;
            }

            // abort if a menu is shown
            if ($currentTrigger && $currentTrigger.length) {
                return;
            }

            hoveract.pageX = e.pageX;
            hoveract.pageY = e.pageY;
            hoveract.data = e.data;
            $document.on('mousemove.contextMenuShow', handle.mousemove);
            hoveract.timer = setTimeout(function() {
                hoveract.timer = null;
                $document.off('mousemove.contextMenuShow');
                $currentTrigger = $this;
                $this.trigger($.Event("contextmenu", { data: hoveract.data, pageX: hoveract.pageX, pageY: hoveract.pageY }));
            }, e.data.delay );
        },
        // contextMenu hover trigger
        mousemove: function(e) {
            hoveract.pageX = e.pageX;
            hoveract.pageY = e.pageY;
        },
        // contextMenu hover trigger
        mouseleave: function(e) {
            // abort if we're leaving for a menu
            var $related = $(e.relatedTarget);
            if ($related.is('.context-menu-list') || $related.closest('.context-menu-list').length) {
                return;
            }

            try {
                clearTimeout(hoveract.timer);
            } catch(e) {}

            hoveract.timer = null;
        },

        // click on layer to hide contextMenu
        layerClick: function(e) {
            var $this = $(this),
                root = $this.data('contextMenuRoot'),
                mouseup = false,
                button = e.button,
                x = e.pageX,
                y = e.pageY,
                target,
                offset,
                selectors;

            e.preventDefault();
            e.stopImmediatePropagation();

            setTimeout(function() {
                var $window, hideshow, possibleTarget;
                var triggerAction = ((root.trigger == 'left' && button === 0) || (root.trigger == 'right' && button === 2));

                // find the element that would've been clicked, wasn't the layer in the way
                if (document.elementFromPoint) {
                    root.$layer.hide();
                    target = document.elementFromPoint(x - $win.scrollLeft(), y - $win.scrollTop());
                    root.$layer.show();
                }

                if (root.reposition && triggerAction) {
                    if (document.elementFromPoint) {
                        if (root.$trigger.is(target) || root.$trigger.has(target).length) {
                            root.position.call(root.$trigger, root, x, y);
                            return;
                        }
                    } else {
                        offset = root.$trigger.offset();
                        $window = $(window);
                        // while this looks kinda awful, it's the best way to avoid
                        // unnecessarily calculating any positions
                        offset.top += $window.scrollTop();
                        if (offset.top <= e.pageY) {
                            offset.left += $window.scrollLeft();
                            if (offset.left <= e.pageX) {
                                offset.bottom = offset.top + root.$trigger.outerHeight();
                                if (offset.bottom >= e.pageY) {
                                    offset.right = offset.left + root.$trigger.outerWidth();
                                    if (offset.right >= e.pageX) {
                                        // reposition
                                        root.position.call(root.$trigger, root, x, y);
                                        return;
                                    }
                                }
                            }
                        }
                    }
                }

                if (target && triggerAction) {
                    root.$trigger.one('contextmenu:hidden', function() {
                        $(target).contextMenu({x: x, y: y});
                    });
                }

                root.$menu.trigger('contextmenu:hide');
            }, 50);
        },
        // key handled :hover
        keyStop: function(e, opt) {
            if (!opt.isInput) {
                e.preventDefault();
            }

            e.stopPropagation();
        },
        key: function(e) {
            var opt = $currentTrigger.data('contextMenu') || {};

            switch (e.keyCode) {
                case 9:
                case 38: // up
                    handle.keyStop(e, opt);
                    // if keyCode is [38 (up)] or [9 (tab) with shift]
                    if (opt.isInput) {
                        if (e.keyCode == 9 && e.shiftKey) {
                            e.preventDefault();
                            opt.$selected && opt.$selected.find('input, textarea, select').blur();
                            opt.$menu.trigger('prevcommand');
                            return;
                        } else if (e.keyCode == 38 && opt.$selected.find('input, textarea, select').prop('type') == 'checkbox') {
                            // checkboxes don't capture this key
                            e.preventDefault();
                            return;
                        }
                    } else if (e.keyCode != 9 || e.shiftKey) {
                        opt.$menu.trigger('prevcommand');
                        return;
                    }
                    // omitting break;

                // case 9: // tab - reached through omitted break;
                case 40: // down
                    handle.keyStop(e, opt);
                    if (opt.isInput) {
                        if (e.keyCode == 9) {
                            e.preventDefault();
                            opt.$selected && opt.$selected.find('input, textarea, select').blur();
                            opt.$menu.trigger('nextcommand');
                            return;
                        } else if (e.keyCode == 40 && opt.$selected.find('input, textarea, select').prop('type') == 'checkbox') {
                            // checkboxes don't capture this key
                            e.preventDefault();
                            return;
                        }
                    } else {
                        opt.$menu.trigger('nextcommand');
                        return;
                    }
                    break;

                case 37: // left
                    handle.keyStop(e, opt);
                    if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                        break;
                    }

                    if (!opt.$selected.parent().hasClass('context-menu-root')) {
                        var $parent = opt.$selected.parent().parent();
                        opt.$selected.trigger('contextmenu:blur');
                        opt.$selected = $parent;
                        return;
                    }
                    break;

                case 39: // right
                    handle.keyStop(e, opt);
                    if (opt.isInput || !opt.$selected || !opt.$selected.length) {
                        break;
                    }

                    var itemdata = opt.$selected.data('contextMenu') || {};
                    if (itemdata.$menu && opt.$selected.hasClass('context-menu-submenu')) {
                        opt.$selected = null;
                        itemdata.$selected = null;
                        itemdata.$menu.trigger('nextcommand');
                        return;
                    }
                    break;

                case 35: // end
                case 36: // home
                    if (opt.$selected && opt.$selected.find('input, textarea, select').length) {
                        return;
                    } else {
                        (opt.$selected && opt.$selected.parent() || opt.$menu)
                            .children(':not(.disabled, .not-selectable)')[e.keyCode == 36 ? 'first' : 'last']()
                            .trigger('contextmenu:focus');
                        e.preventDefault();
                        return;
                    }
                    break;

                case 13: // enter
                    handle.keyStop(e, opt);
                    if (opt.isInput) {
                        if (opt.$selected && !opt.$selected.is('textarea, select')) {
                            e.preventDefault();
                            return;
                        }
                        break;
                    }
                    opt.$selected && opt.$selected.trigger('mouseup');
                    return;

                case 32: // space
                case 33: // page up
                case 34: // page down
                    // prevent browser from scrolling down while menu is visible
                    handle.keyStop(e, opt);
                    return;

                case 27: // esc
                    handle.keyStop(e, opt);
                    opt.$menu.trigger('contextmenu:hide');
                    return;

                default: // 0-9, a-z
                    var k = (String.fromCharCode(e.keyCode)).toUpperCase();
                    if (opt.accesskeys[k]) {
                        // according to the specs accesskeys must be invoked immediately
                        opt.accesskeys[k].$node.trigger(opt.accesskeys[k].$menu
                            ? 'contextmenu:focus'
                            : 'mouseup'
                        );
                        return;
                    }
                    break;
            }
            // pass event to selected item,
            // stop propagation to avoid endless recursion
            e.stopPropagation();
            opt.$selected && opt.$selected.trigger(e);
        },

        // select previous possible command in menu
        prevItem: function(e) {
            e.stopPropagation();
            var opt = $(this).data('contextMenu') || {};

            // obtain currently selected menu
            if (opt.$selected) {
                var $s = opt.$selected;
                opt = opt.$selected.parent().data('contextMenu') || {};
                opt.$selected = $s;
            }

            var $children = opt.$menu.children(),
                $prev = !opt.$selected || !opt.$selected.prev().length ? $children.last() : opt.$selected.prev(),
                $round = $prev;

            // skip disabled
            while ($prev.hasClass('disabled') || $prev.hasClass('not-selectable')) {
                if ($prev.prev().length) {
                    $prev = $prev.prev();
                } else {
                    $prev = $children.last();
                }
                if ($prev.is($round)) {
                    // break endless loop
                    return;
                }
            }

            // leave current
            if (opt.$selected) {
                handle.itemMouseleave.call(opt.$selected.get(0), e);
            }

            // activate next
            handle.itemMouseenter.call($prev.get(0), e);

            // focus input
            var $input = $prev.find('input, textarea, select');
            if ($input.length) {
                $input.focus();
            }
        },
        // select next possible command in menu
        nextItem: function(e) {
            e.stopPropagation();
            var opt = $(this).data('contextMenu') || {};

            // obtain currently selected menu
            if (opt.$selected) {
                var $s = opt.$selected;
                opt = opt.$selected.parent().data('contextMenu') || {};
                opt.$selected = $s;
            }

            var $children = opt.$menu.children(),
                $next = !opt.$selected || !opt.$selected.next().length ? $children.first() : opt.$selected.next(),
                $round = $next;

            // skip disabled
            while ($next.hasClass('disabled') || $next.hasClass('not-selectable')) {
                if ($next.next().length) {
                    $next = $next.next();
                } else {
                    $next = $children.first();
                }
                if ($next.is($round)) {
                    // break endless loop
                    return;
                }
            }

            // leave current
            if (opt.$selected) {
                handle.itemMouseleave.call(opt.$selected.get(0), e);
            }

            // activate next
            handle.itemMouseenter.call($next.get(0), e);

            // focus input
            var $input = $next.find('input, textarea, select');
            if ($input.length) {
                $input.focus();
            }
        },

        // flag that we're inside an input so the key handler can act accordingly
        focusInput: function(e) {
            var $this = $(this).closest('.context-menu-item'),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            root.$selected = opt.$selected = $this;
            root.isInput = opt.isInput = true;
        },
        // flag that we're inside an input so the key handler can act accordingly
        blurInput: function(e) {
            var $this = $(this).closest('.context-menu-item'),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            root.isInput = opt.isInput = false;
        },

        // :hover on menu
        menuMouseenter: function(e) {
            var root = $(this).data().contextMenuRoot;
            root.hovering = true;
        },
        // :hover on menu
        menuMouseleave: function(e) {
            var root = $(this).data().contextMenuRoot;
            if (root.$layer && root.$layer.is(e.relatedTarget)) {
                root.hovering = false;
            }
        },

        // :hover done manually so key handling is possible
        itemMouseenter: function(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            root.hovering = true;

            // abort if we're re-entering
            if (e && root.$layer && root.$layer.is(e.relatedTarget)) {
                e.preventDefault();
                e.stopImmediatePropagation();
            }

            // make sure only one item is selected
            (opt.$menu ? opt : root).$menu
                .children('.hover').trigger('contextmenu:blur');

            if ($this.hasClass('disabled') || $this.hasClass('not-selectable')) {
                opt.$selected = null;
                return;
            }

            $this.trigger('contextmenu:focus');
        },
        // :hover done manually so key handling is possible
        itemMouseleave: function(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            if (root !== opt && root.$layer && root.$layer.is(e.relatedTarget)) {
                root.$selected && root.$selected.trigger('contextmenu:blur');
                e.preventDefault();
                e.stopImmediatePropagation();
                root.$selected = opt.$selected = opt.$node;
                return;
            }

            $this.trigger('contextmenu:blur');
        },
        // contextMenu item click
        itemClick: function(e) {
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot,
                key = data.contextMenuKey,
                callback;

            // abort if the key is unknown or disabled or is a menu
            if (!opt.items[key] || $this.is('.disabled, .context-menu-submenu, .context-menu-separator, .not-selectable')) {
                return;
            }

            e.preventDefault();
            e.stopImmediatePropagation();

            if ($.isFunction(root.callbacks[key]) && Object.prototype.hasOwnProperty.call(root.callbacks, key)) {
                // item-specific callback
                callback = root.callbacks[key];
            } else if ($.isFunction(root.callback)) {
                // default callback
                callback = root.callback;
            } else {
                // no callback, no action
                return;
            }

            // hide menu if callback doesn't stop that
            if (callback.call(root.$trigger, key, root, this) !== false) {
                root.$menu.trigger('contextmenu:hide');
            } else if (root.$menu.parent().length) {
                op.update.call(root.$trigger, root);
            }
        },
        // ignore click events on input elements
        inputClick: function(e) {
            e.stopImmediatePropagation();
        },

        // hide <menu>
        hideMenu: function(e, data) {
            var root = $(this).data('contextMenuRoot');
            op.hide.call(root.$trigger, root, data && data.force);
        },
        // focus <command>
        focusItem: function(e) {
            e.stopPropagation();
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            $this.addClass('hover')
                .siblings('.hover').trigger('contextmenu:blur');

            // remember selected
            opt.$selected = root.$selected = $this;

            // position sub-menu - do after show so dumb $.ui.position can keep up
            if (opt.$node) {
                root.positionSubmenu.call(opt.$node, opt.$menu);
            }
        },
        // blur <command>
        blurItem: function(e) {
            e.stopPropagation();
            var $this = $(this),
                data = $this.data(),
                opt = data.contextMenu,
                root = data.contextMenuRoot;

            $this.removeClass('hover');
            opt.$selected = null;
        }
    },
    // operations
    op = {
        show: function(opt, x, y) {
            var $trigger = $(this),
                offset,
                css = {};

            // hide any open menus
            $('#context-menu-layer').trigger('mousedown');

            // backreference for callbacks
            opt.$trigger = $trigger;

            // show event
            if (opt.events.show.call($trigger, opt) === false) {
                $currentTrigger = null;
                return;
            }

            // create or update context menu
            op.update.call($trigger, opt);

            // position menu
            opt.position.call($trigger, opt, x, y);

            // make sure we're in front
            if (opt.zIndex) {
                css.zIndex = zindex($trigger) + opt.zIndex;
            }

            // add layer
            op.layer.call(opt.$menu, opt, css.zIndex);

            // adjust sub-menu zIndexes
            opt.$menu.find('ul').css('zIndex', css.zIndex + 1);

            // position and show context menu
            opt.$menu.css( css )[opt.animation.show](opt.animation.duration, function() {
                $trigger.trigger('contextmenu:visible');
            });
            // make options available and set state
            $trigger
                .data('contextMenu', opt)
                .addClass("context-menu-active");

            // register key handler
            $(document).off('keydown.contextMenu').on('keydown.contextMenu', handle.key);
            // register autoHide handler
            if (opt.autoHide) {
                // mouse position handler
                $(document).on('mousemove.contextMenuAutoHide', function(e) {
                    // need to capture the offset on mousemove,
                    // since the page might've been scrolled since activation
                    var pos = $trigger.offset();
                    pos.right = pos.left + $trigger.outerWidth();
                    pos.bottom = pos.top + $trigger.outerHeight();

                    if (opt.$layer && !opt.hovering && (!(e.pageX >= pos.left && e.pageX <= pos.right) || !(e.pageY >= pos.top && e.pageY <= pos.bottom))) {
                        // if mouse in menu...
                        opt.$menu.trigger('contextmenu:hide');
                    }
                });
            }
        },
        hide: function(opt, force) {
            var $trigger = $(this);
            if (!opt) {
                opt = $trigger.data('contextMenu') || {};
            }

            // hide event
            if (!force && opt.events && opt.events.hide.call($trigger, opt) === false) {
                return;
            }

            // remove options and revert state
            $trigger
                .removeData('contextMenu')
                .removeClass("context-menu-active");

            if (opt.$layer) {
                // keep layer for a bit so the contextmenu event can be aborted properly by opera
                setTimeout((function($layer) {
                    return function(){
                        $layer.remove();
                    };
                })(opt.$layer), 10);

                try {
                    delete opt.$layer;
                } catch(e) {
                    opt.$layer = null;
                }
            }

            // remove handle
            $currentTrigger = null;
            // remove selected
            opt.$menu.find('.hover').trigger('contextmenu:blur');
            opt.$selected = null;
            // unregister key and mouse handlers
            //$(document).off('.contextMenuAutoHide keydown.contextMenu'); // http://bugs.jquery.com/ticket/10705
            $(document).off('.contextMenuAutoHide').off('keydown.contextMenu');
            // hide menu
            opt.$menu && opt.$menu[opt.animation.hide](opt.animation.duration, function (){
                // tear down dynamically built menu after animation is completed.
                if (opt.build) {
                    opt.$menu.remove();
                    $.each(opt, function(key, value) {
                        switch (key) {
                            case 'ns':
                            case 'selector':
                            case 'build':
                            case 'trigger':
                                return true;

                            default:
                                opt[key] = undefined;
                                try {
                                    delete opt[key];
                                } catch (e) {}
                                return true;
                        }
                    });
                }

                setTimeout(function() {
                    $trigger.trigger('contextmenu:hidden');
                }, 10);
            });
        },
        create: function(opt, root) {
            if (root === undefined) {
                root = opt;
            }
            // create contextMenu
            opt.$menu = $('<ul class="context-menu-list"></ul>').addClass(opt.className || "").data({
                'contextMenu': opt,
                'contextMenuRoot': root
            });

            $.each(['callbacks', 'commands', 'inputs'], function(i,k){
                opt[k] = {};
                if (!root[k]) {
                    root[k] = {};
                }
            });

            root.accesskeys || (root.accesskeys = {});

            // create contextMenu items
            $.each(opt.items, function(key, item){
                var $t = $('<li class="context-menu-item"></li>').addClass(item.className || ""),
                    $label = null,
                    $input = null;

                // iOS needs to see a click-event bound to an element to actually
                // have the TouchEvents infrastructure trigger the click event
                $t.on('click', $.noop);

                item.$node = $t.data({
                    'contextMenu': opt,
                    'contextMenuRoot': root,
                    'contextMenuKey': key
                });

                // register accesskey
                // NOTE: the accesskey attribute should be applicable to any element, but Safari5 and Chrome13 still can't do that
                if (item.accesskey) {
                    var aks = splitAccesskey(item.accesskey);
                    for (var i=0, ak; ak = aks[i]; i++) {
                        if (!root.accesskeys[ak]) {
                            root.accesskeys[ak] = item;
                            item._name = item.name.replace(new RegExp('(' + ak + ')', 'i'), '<span class="context-menu-accesskey">$1</span>');
                            break;
                        }
                    }
                }

                if (typeof item == "string") {
                    $t.addClass('context-menu-separator not-selectable');
                } else if (item.type && types[item.type]) {
                    // run custom type handler
                    types[item.type].call($t, item, opt, root);
                    // register commands
                    $.each([opt, root], function(i,k){
                        k.commands[key] = item;
                        if ($.isFunction(item.callback)) {
                            k.callbacks[key] = item.callback;
                        }
                    });
                } else {
                    // add label for input
                    if (item.type == 'html') {
                        $t.addClass('context-menu-html not-selectable');
                    } else if (item.type) {
                        $label = $('<label></label>').appendTo($t);
                        $('<span></span>').html(item._name || item.name).appendTo($label);
                        $t.addClass('context-menu-input');
                        opt.hasTypes = true;
                        $.each([opt, root], function(i,k){
                            k.commands[key] = item;
                            k.inputs[key] = item;
                        });
                    } else if (item.items) {
                        item.type = 'sub';
                    }

                    switch (item.type) {
                        case 'text':
                            $input = $('<input type="text" value="1" name="" value="">')
                                .attr('name', 'context-menu-input-' + key)
                                .val(item.value || "")
                                .appendTo($label);
                            break;

                        case 'textarea':
                            $input = $('<textarea name=""></textarea>')
                                .attr('name', 'context-menu-input-' + key)
                                .val(item.value || "")
                                .appendTo($label);

                            if (item.height) {
                                $input.height(item.height);
                            }
                            break;

                        case 'checkbox':
                            $input = $('<input type="checkbox" value="1" name="" value="">')
                                .attr('name', 'context-menu-input-' + key)
                                .val(item.value || "")
                                .prop("checked", !!item.selected)
                                .prependTo($label);
                            break;

                        case 'radio':
                            $input = $('<input type="radio" value="1" name="" value="">')
                                .attr('name', 'context-menu-input-' + item.radio)
                                .val(item.value || "")
                                .prop("checked", !!item.selected)
                                .prependTo($label);
                            break;

                        case 'select':
                            $input = $('<select name="">')
                                .attr('name', 'context-menu-input-' + key)
                                .appendTo($label);
                            if (item.options) {
                                $.each(item.options, function(value, text) {
                                    $('<option></option>').val(value).text(text).appendTo($input);
                                });
                                $input.val(item.selected);
                            }
                            break;

                        case 'sub':
                            // FIXME: shouldn't this .html() be a .text()?
                            $('<span></span>').html(item._name || item.name).appendTo($t);
                            item.appendTo = item.$node;
                            op.create(item, root);
                            $t.data('contextMenu', item).addClass('context-menu-submenu');
                            item.callback = null;
                            break;

                        case 'html':
                            $(item.html).appendTo($t);
                            break;

                        default:
                            $.each([opt, root], function(i,k){
                                k.commands[key] = item;
                                if ($.isFunction(item.callback)) {
                                    k.callbacks[key] = item.callback;
                                }
                            });
                            // FIXME: shouldn't this .html() be a .text()?
                            $('<span></span>').html(item._name || item.name || "").appendTo($t);
                            break;
                    }

                    // disable key listener in <input>
                    if (item.type && item.type != 'sub' && item.type != 'html') {
                        $input
                            .on('focus', handle.focusInput)
                            .on('blur', handle.blurInput);

                        if (item.events) {
                            $input.on(item.events, opt);
                        }
                    }

                    // add icons
                    if (item.icon) {
                        $t.addClass("icon icon-" + item.icon);
                    }
                }

                // cache contained elements
                item.$input = $input;
                item.$label = $label;

                // attach item to menu
                $t.appendTo(opt.$menu);

                // Disable text selection
                if (!opt.hasTypes && $.support.eventSelectstart) {
                    // browsers support user-select: none,
                    // IE has a special event for text-selection
                    // browsers supporting neither will not be preventing text-selection
                    $t.on('selectstart.disableTextSelect', handle.abortevent);
                }
            });
            // attach contextMenu to <body> (to bypass any possible overflow:hidden issues on parents of the trigger element)
            if (!opt.$node) {
                opt.$menu.css('display', 'none').addClass('context-menu-root');
            }
            opt.$menu.appendTo(opt.appendTo || document.body);
        },
        resize: function($menu, nested) {
            // determine widths of submenus, as CSS won't grow them automatically
            // position:absolute within position:absolute; min-width:100; max-width:200; results in width: 100;
            // kinda sucks hard...

            // determine width of absolutely positioned element
            $menu.css({position: 'absolute', display: 'block'});
            // don't apply yet, because that would break nested elements' widths
            // add a pixel to circumvent word-break issue in IE9 - #80
            $menu.data('width', Math.ceil($menu.width()) + 1);
            // reset styles so they allow nested elements to grow/shrink naturally
            $menu.css({
                position: 'static',
                minWidth: '0px',
                maxWidth: '100000px'
            });
            // identify width of nested menus
            $menu.find('> li > ul').each(function() {
                op.resize($(this), true);
            });
            // reset and apply changes in the end because nested
            // elements' widths wouldn't be calculatable otherwise
            if (!nested) {
                $menu.find('ul').andSelf().css({
                    position: '',
                    display: '',
                    minWidth: '',
                    maxWidth: ''
                }).width(function() {
                    return $(this).data('width');
                });
            }
        },
        update: function(opt, root) {
            var $trigger = this;
            if (root === undefined) {
                root = opt;
                op.resize(opt.$menu);
            }
            // re-check disabled for each item
            opt.$menu.children().each(function(){
                var $item = $(this),
                    key = $item.data('contextMenuKey'),
                    item = opt.items[key],
                    disabled = ($.isFunction(item.disabled) && item.disabled.call($trigger, key, root)) || item.disabled === true;

                // dis- / enable item
                $item[disabled ? 'addClass' : 'removeClass']('disabled');

                if (item.type) {
                    // dis- / enable input elements
                    $item.find('input, select, textarea').prop('disabled', disabled);

                    // update input states
                    switch (item.type) {
                        case 'text':
                        case 'textarea':
                            item.$input.val(item.value || "");
                            break;

                        case 'checkbox':
                        case 'radio':
                            item.$input.val(item.value || "").prop('checked', !!item.selected);
                            break;

                        case 'select':
                            item.$input.val(item.selected || "");
                            break;
                    }
                }

                if (item.$menu) {
                    // update sub-menu
                    op.update.call($trigger, item, root);
                }
            });
        },
        layer: function(opt, zIndex) {
            // add transparent layer for click area
            // filter and background for Internet Explorer, Issue #23
            var $layer = opt.$layer = $('<div id="context-menu-layer" style="position:fixed; z-index:' + zIndex + '; top:0; left:0; opacity: 0; filter: alpha(opacity=0); background-color: #000;"></div>')
                .css({height: $win.height(), width: $win.width(), display: 'block'})
                .data('contextMenuRoot', opt)
                .insertBefore(this)
                .on('contextmenu', handle.abortevent)
                .on('mousedown', handle.layerClick);

            // IE6 doesn't know position:fixed;
            if (!$.support.fixedPosition) {
                $layer.css({
                    'position' : 'absolute',
                    'height' : $(document).height()
                });
            }

            return $layer;
        }
    };

// split accesskey according to http://www.whatwg.org/specs/web-apps/current-work/multipage/editing.html#assigned-access-key
function splitAccesskey(val) {
    var t = val.split(/\s+/),
        keys = [];

    for (var i=0, k; k = t[i]; i++) {
        k = k[0].toUpperCase(); // first character only
        // theoretically non-accessible characters should be ignored, but different systems, different keyboard layouts, ... screw it.
        // a map to look up already used access keys would be nice
        keys.push(k);
    }

    return keys;
}

// handle contextMenu triggers
$.fn.contextMenu = function(operation) {
    if (operation === undefined) {
        this.first().trigger('contextmenu');
    } else if (operation.x && operation.y) {
        this.first().trigger($.Event("contextmenu", {pageX: operation.x, pageY: operation.y}));
    } else if (operation === "hide") {
        var $menu = this.data('contextMenu').$menu;
        $menu && $menu.trigger('contextmenu:hide');
    } else if (operation === "destroy") {
        $.contextMenu("destroy", {context: this});
    } else if ($.isPlainObject(operation)) {
        operation.context = this;
        $.contextMenu("create", operation);
    } else if (operation) {
        this.removeClass('context-menu-disabled');
    } else if (!operation) {
        this.addClass('context-menu-disabled');
    }

    return this;
};

// manage contextMenu instances
$.contextMenu = function(operation, options) {
    if (typeof operation != 'string') {
        options = operation;
        operation = 'create';
    }

    if (typeof options == 'string') {
        options = {selector: options};
    } else if (options === undefined) {
        options = {};
    }

    // merge with default options
    var o = $.extend(true, {}, defaults, options || {});
    var $document = $(document);
    var $context = $document;
    var _hasContext = false;

    if (!o.context || !o.context.length) {
        o.context = document;
    } else {
        // you never know what they throw at you...
        $context = $(o.context).first();
        o.context = $context.get(0);
        _hasContext = o.context !== document;
    }

    switch (operation) {
        case 'create':
            // no selector no joy
            if (!o.selector) {
                throw new Error('No selector specified');
            }
            // make sure internal classes are not bound to
            if (o.selector.match(/.context-menu-(list|item|input)($|\s)/)) {
                throw new Error('Cannot bind to selector "' + o.selector + '" as it contains a reserved className');
            }
            if (!o.build && (!o.items || $.isEmptyObject(o.items))) {
                throw new Error('No Items specified');
            }
            counter ++;
            o.ns = '.contextMenu' + counter;
            if (!_hasContext) {
                namespaces[o.selector] = o.ns;
            }
            menus[o.ns] = o;

            // default to right click
            if (!o.trigger) {
                o.trigger = 'right';
            }

            if (!initialized) {
                // make sure item click is registered first
                $document
                    .on({
                        'contextmenu:hide.contextMenu': handle.hideMenu,
                        'prevcommand.contextMenu': handle.prevItem,
                        'nextcommand.contextMenu': handle.nextItem,
                        'contextmenu.contextMenu': handle.abortevent,
                        'mouseenter.contextMenu': handle.menuMouseenter,
                        'mouseleave.contextMenu': handle.menuMouseleave
                    }, '.context-menu-list')
                    .on('mouseup.contextMenu', '.context-menu-input', handle.inputClick)
                    .on({
                        'mouseup.contextMenu': handle.itemClick,
                        'contextmenu:focus.contextMenu': handle.focusItem,
                        'contextmenu:blur.contextMenu': handle.blurItem,
                        'contextmenu.contextMenu': handle.abortevent,
                        'mouseenter.contextMenu': handle.itemMouseenter,
                        'mouseleave.contextMenu': handle.itemMouseleave
                    }, '.context-menu-item');

                initialized = true;
            }

            // engage native contextmenu event
            $context
                .on('contextmenu' + o.ns, o.selector, o, handle.contextmenu);

            if (_hasContext) {
                // add remove hook, just in case
                $context.on('remove' + o.ns, function() {
                    $(this).contextMenu("destroy");
                });
            }

            switch (o.trigger) {
                case 'hover':
                        $context
                            .on('mouseenter' + o.ns, o.selector, o, handle.mouseenter)
                            .on('mouseleave' + o.ns, o.selector, o, handle.mouseleave);
                    break;

                case 'left':
                        $context.on('click' + o.ns, o.selector, o, handle.click);
                    break;
                /*
                default:
                    // http://www.quirksmode.org/dom/events/contextmenu.html
                    $document
                        .on('mousedown' + o.ns, o.selector, o, handle.mousedown)
                        .on('mouseup' + o.ns, o.selector, o, handle.mouseup);
                    break;
                */
            }

            // create menu
            if (!o.build) {
                op.create(o);
            }
            break;

        case 'destroy':
            var $visibleMenu;
            if (_hasContext) {
                // get proper options
                var context = o.context;
                $.each(menus, function(ns, o) {
                    if (o.context !== context) {
                        return true;
                    }

                    $visibleMenu = $('.context-menu-list').filter(':visible');
                    if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is($(o.context).find(o.selector))) {
                        $visibleMenu.trigger('contextmenu:hide', {force: true});
                    }

                    try {
                        if (menus[o.ns].$menu) {
                            menus[o.ns].$menu.remove();
                        }

                        delete menus[o.ns];
                    } catch(e) {
                        menus[o.ns] = null;
                    }

                    $(o.context).off(o.ns);

                    return true;
                });
            } else if (!o.selector) {
                $document.off('.contextMenu .contextMenuAutoHide');
                $.each(menus, function(ns, o) {
                    $(o.context).off(o.ns);
                });

                namespaces = {};
                menus = {};
                counter = 0;
                initialized = false;

                $('#context-menu-layer, .context-menu-list').remove();
            } else if (namespaces[o.selector]) {
                $visibleMenu = $('.context-menu-list').filter(':visible');
                if ($visibleMenu.length && $visibleMenu.data().contextMenuRoot.$trigger.is(o.selector)) {
                    $visibleMenu.trigger('contextmenu:hide', {force: true});
                }

                try {
                    if (menus[namespaces[o.selector]].$menu) {
                        menus[namespaces[o.selector]].$menu.remove();
                    }

                    delete menus[namespaces[o.selector]];
                } catch(e) {
                    menus[namespaces[o.selector]] = null;
                }

                $document.off(namespaces[o.selector]);
            }
            break;

        case 'html5':
            // if <command> or <menuitem> are not handled by the browser,
            // or options was a bool true,
            // initialize $.contextMenu for them
            if ((!$.support.htmlCommand && !$.support.htmlMenuitem) || (typeof options == "boolean" && options)) {
                $('menu[type="context"]').each(function() {
                    if (this.id) {
                        $.contextMenu({
                            selector: '[contextmenu=' + this.id +']',
                            items: $.contextMenu.fromMenu(this)
                        });
                    }
                }).css('display', 'none');
            }
            break;

        default:
            throw new Error('Unknown operation "' + operation + '"');
    }

    return this;
};

// import values into <input> commands
$.contextMenu.setInputValues = function(opt, data) {
    if (data === undefined) {
        data = {};
    }

    $.each(opt.inputs, function(key, item) {
        switch (item.type) {
            case 'text':
            case 'textarea':
                item.value = data[key] || "";
                break;

            case 'checkbox':
                item.selected = data[key] ? true : false;
                break;

            case 'radio':
                item.selected = (data[item.radio] || "") == item.value ? true : false;
                break;

            case 'select':
                item.selected = data[key] || "";
                break;
        }
    });
};

// export values from <input> commands
$.contextMenu.getInputValues = function(opt, data) {
    if (data === undefined) {
        data = {};
    }

    $.each(opt.inputs, function(key, item) {
        switch (item.type) {
            case 'text':
            case 'textarea':
            case 'select':
                data[key] = item.$input.val();
                break;

            case 'checkbox':
                data[key] = item.$input.prop('checked');
                break;

            case 'radio':
                if (item.$input.prop('checked')) {
                    data[item.radio] = item.value;
                }
                break;
        }
    });

    return data;
};

// find <label for="xyz">
function inputLabel(node) {
    return (node.id && $('label[for="'+ node.id +'"]').val()) || node.name;
}

// convert <menu> to items object
function menuChildren(items, $children, counter) {
    if (!counter) {
        counter = 0;
    }

    $children.each(function() {
        var $node = $(this),
            node = this,
            nodeName = this.nodeName.toLowerCase(),
            label,
            item;

        // extract <label><input>
        if (nodeName == 'label' && $node.find('input, textarea, select').length) {
            label = $node.text();
            $node = $node.children().first();
            node = $node.get(0);
            nodeName = node.nodeName.toLowerCase();
        }

        /*
         * <menu> accepts flow-content as children. that means <embed>, <canvas> and such are valid menu items.
         * Not being the sadistic kind, $.contextMenu only accepts:
         * <command>, <menuitem>, <hr>, <span>, <p> <input [text, radio, checkbox]>, <textarea>, <select> and of course <menu>.
         * Everything else will be imported as an html node, which is not interfaced with contextMenu.
         */

        // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#concept-command
        switch (nodeName) {
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/interactive-elements.html#the-menu-element
            case 'menu':
                item = {name: $node.attr('label'), items: {}};
                counter = menuChildren(item.items, $node.children(), counter);
                break;

            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-a-element-to-define-a-command
            case 'a':
            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-button-element-to-define-a-command
            case 'button':
                item = {
                    name: $node.text(),
                    disabled: !!$node.attr('disabled'),
                    callback: (function(){ return function(){ $node.click(); }; })()
                };
                break;

            // http://www.whatwg.org/specs/web-apps/current-work/multipage/commands.html#using-the-command-element-to-define-a-command

            case 'menuitem':
            case 'command':
                switch ($node.attr('type')) {
                    case undefined:
                    case 'command':
                    case 'menuitem':
                        item = {
                            name: $node.attr('label'),
                            disabled: !!$node.attr('disabled'),
                            callback: (function(){ return function(){ $node.click(); }; })()
                        };
                        break;

                    case 'checkbox':
                        item = {
                            type: 'checkbox',
                            disabled: !!$node.attr('disabled'),
                            name: $node.attr('label'),
                            selected: !!$node.attr('checked')
                        };
                        break;

                    case 'radio':
                        item = {
                            type: 'radio',
                            disabled: !!$node.attr('disabled'),
                            name: $node.attr('label'),
                            radio: $node.attr('radiogroup'),
                            value: $node.attr('id'),
                            selected: !!$node.attr('checked')
                        };
                        break;

                    default:
                        item = undefined;
                }
                break;

            case 'hr':
                item = '-------';
                break;

            case 'input':
                switch ($node.attr('type')) {
                    case 'text':
                        item = {
                            type: 'text',
                            name: label || inputLabel(node),
                            disabled: !!$node.attr('disabled'),
                            value: $node.val()
                        };
                        break;

                    case 'checkbox':
                        item = {
                            type: 'checkbox',
                            name: label || inputLabel(node),
                            disabled: !!$node.attr('disabled'),
                            selected: !!$node.attr('checked')
                        };
                        break;

                    case 'radio':
                        item = {
                            type: 'radio',
                            name: label || inputLabel(node),
                            disabled: !!$node.attr('disabled'),
                            radio: !!$node.attr('name'),
                            value: $node.val(),
                            selected: !!$node.attr('checked')
                        };
                        break;

                    default:
                        item = undefined;
                        break;
                }
                break;

            case 'select':
                item = {
                    type: 'select',
                    name: label || inputLabel(node),
                    disabled: !!$node.attr('disabled'),
                    selected: $node.val(),
                    options: {}
                };
                $node.children().each(function(){
                    item.options[this.value] = $(this).text();
                });
                break;

            case 'textarea':
                item = {
                    type: 'textarea',
                    name: label || inputLabel(node),
                    disabled: !!$node.attr('disabled'),
                    value: $node.val()
                };
                break;

            case 'label':
                break;

            default:
                item = {type: 'html', html: $node.clone(true)};
                break;
        }

        if (item) {
            counter++;
            items['key' + counter] = item;
        }
    });

    return counter;
}

// convert html5 menu
$.contextMenu.fromMenu = function(element) {
    var $this = $(element),
        items = {};

    menuChildren(items, $this.children());

    return items;
};

// make defaults accessible
$.contextMenu.defaults = defaults;
$.contextMenu.types = types;
// export internal functions - undocumented, for hacking only!
$.contextMenu.handle = handle;
$.contextMenu.op = op;
$.contextMenu.menus = menus;

})(jQuery);
/*!
 * jQuery Cookie Plugin v1.3.1
 * https://github.com/carhartl/jquery-cookie
 *
 * Copyright 2013 Klaus Hartl
 * Released under the MIT license
 */
(function ($, document, undefined) {

	var pluses = /\+/g;

	function raw(s) {
		return s;
	}

	function decoded(s) {
		return unRfc2068(decodeURIComponent(s.replace(pluses, ' ')));
	}

	function unRfc2068(value) {
		if (value.indexOf('"') === 0) {
			// This is a quoted cookie as according to RFC2068, unescape
			value = value.slice(1, -1).replace(/\\"/g, '"').replace(/\\\\/g, '\\');
		}
		return value;
	}

	function fromJSON(value) {
		return config.json ? JSON.parse(value) : value;
	}

	var config = $.cookie = function (key, value, options) {

		// write
		if (value !== undefined) {
			options = $.extend({}, config.defaults, options);

			if (value === null) {
				options.expires = -1;
			}

			if (typeof options.expires === 'number') {
				var days = options.expires, t = options.expires = new Date();
				t.setDate(t.getDate() + days);
			}

			value = config.json ? JSON.stringify(value) : String(value);

			return (document.cookie = [
				encodeURIComponent(key), '=', config.raw ? value : encodeURIComponent(value),
				options.expires ? '; expires=' + options.expires.toUTCString() : '', // use expires attribute, max-age is not supported by IE
				options.path    ? '; path=' + options.path : '',
				options.domain  ? '; domain=' + options.domain : '',
				options.secure  ? '; secure' : ''
			].join(''));
		}

		// read
		var decode = config.raw ? raw : decoded;
		var cookies = document.cookie.split('; ');
		var result = key ? null : {};
		for (var i = 0, l = cookies.length; i < l; i++) {
			var parts = cookies[i].split('=');
			var name = decode(parts.shift());
			var cookie = decode(parts.join('='));

			if (key && key === name) {
				result = fromJSON(cookie);
				break;
			}

			if (!key) {
				result[name] = fromJSON(cookie);
			}
		}

		return result;
	};

	config.defaults = {};

	$.removeCookie = function (key, options) {
		if ($.cookie(key) !== null) {
			$.cookie(key, null, options);
			return true;
		}
		return false;
	};

})(jQuery, document);
/*
* File:        jquery.dataTables.editable.js
* Version:     1.3.
* Author:      Jovan Popovic 
* 
* Copyright 2010-2011 Jovan Popovic, all rights reserved.
*
* This source file is free software, under either the GPL v2 license or a
* BSD style license, as supplied with this software.
* 
* This source file is distributed in the hope that it will be useful, but 
* WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
* or FITNESS FOR A PARTICULAR PURPOSE. 
* 
* Parameters:
* @sUpdateURL                   	String      URL of the server-side page used for updating cell. Default value is "UpdateData".
* @sAddURL                      	String      URL of the server-side page used for adding new row. Default value is "AddData".
* @sDeleteURL                   	String      URL of the server-side page used to delete row by id. Default value is "DeleteData".
* @fnShowError                  	Function    function(message, action){...}  used to show error message. Action value can be "update", "add" or "delete".
* @sAddNewRowFormId             	String      Id of the form for adding new row. Default id is "formAddNewRow".
* @oAddNewRowFormOptions            Object	    Options that will be set to the "Add new row" dialog
* @sAddNewRowButtonId           	String      Id of the button for adding new row. Default id is "btnAddNewRow".
* @oAddNewRowButtonOptions		    Object	    Options that will be set to the "Add new" button
* @sAddNewRowOkButtonId         	String      Id of the OK button placed in add new row dialog. Default value is "btnAddNewRowOk".
* @oAddNewRowOkButtonOptions		Object	    Options that will be set to the Ok button in the "Add new row" form
* @sAddNewRowCancelButtonId     	String      Id of the Cancel button placed in add new row dialog. Default value is "btnAddNewRowCancel".
* @oAddNewRowCancelButtonOptions	Object	    Options that will be set to the Cancel button in the "Add new row" form
* @sDeleteRowButtonId           	String      Id of the button for adding new row. Default id is "btnDeleteRow".
* @oDeleteRowButtonOptions		    Object	    Options that will be set to the Delete button
* @sSelectedRowClass            	String      Class that will be associated to the selected row. Default class is "row_selected".
* @sReadOnlyCellClass           	String      Class of the cells that should not be editable. Default value is "read_only".
* @sAddDeleteToolbarSelector    	String      Selector used to identify place where add and delete buttons should be placed. Default value is ".add_delete_toolbar".
* @fnStartProcessingMode        	Function    function(){...} called when AJAX call is started. Use this function to add "Please wait..." message  when some button is pressed.
* @fnEndProcessingMode          	Function    function(){...} called when AJAX call is ended. Use this function to close "Please wait..." message.
* @aoColumns                    	Array       Array of the JEditable settings that will be applied on the columns
* @sAddHttpMethod               	String      Method used for the Add AJAX request (default is 'POST')
* @sDeleteHttpMethod            	String      Method used for the Delete AJAX request (default is 'POST')
* @fnOnDeleting                 	Function    function(tr, id, fnDeleteRow){...} Function called before row is deleted.
                                                    tr isJQuery object encapsulating row that will be deleted
                                                    id is an id of the record that will be deleted.
                                                    fnDeleteRow(id) callback function that should be called to delete row with id
                                                    returns true if plugin should continue with deleting row, false will abort delete.
* @fnOnDeleted                  	Function    function(status){...} Function called after delete action. Status can be "success" or "failure"
* @fnOnAdding                   	Function    function(){...} Function called before row is added.
                                                    returns true if plugin should continue with adding row, false will abort add.
* @fnOnNewRowPosted			        Function    function(data) Function that can override default function that is called when server-side sAddURL returns result
                                                    You can use this function to add different behaviour when server-side page returns result
* @fnOnAdded                    	Function    function(status){...} Function called after delete action. Status can be "success" or "failure"
* @fnOnEditing                  	Function    function(input){...} Function called before cell is updated.
                                                    input JQuery object wrapping the inut element used for editing value in the cell.
                                                    returns true if plugin should continue with sending AJAX request, false will abort update.
* @fnOnEdited                   	Function    function(status){...} Function called after edit action. Status can be "success" or "failure"
* @sEditorHeight                	String      Default height of the cell editors
* @sEditorWidth                 	String      Default width of the cell editors
* @oDeleteParameters                Object      Additonal objects added to the DELETE Ajax request
* @sIDToken                         String      Token in the add new row dialog that will be replaced with a returned id of the record that is created
*/
(function ($) {

    $.fn.makeEditable = function (options) {

        var iDisplayStart = 0;

        ///Utility function used to determine id of the cell
        //By default it is assumed that id is placed as an id attribute of <tr> that that surround the cell (<td> tag). E.g.:
        //<tr id="17">
        //  <td>...</td><td>...</td><td>...</td><td>...</td>
        //</tr>
        function fnGetCellID(cell) {
            return properties.fnGetRowID($(cell.parentNode));
        }

        ///Utility function used to set id of the new row
        //It is assumed that id is placed as an id attribute of <tr> that that surround the cell (<td> tag). E.g.:
        //<tr id="17">
        //  <td>...</td><td>...</td><td>...</td><td>...</td>
        //</tr>
        function _fnSetRowIDInAttribute(row, id) {
            row.attr("id", id);
        }

        //Utility function used to get id of the row
        //It is assumed that id is placed as an id attribute of <tr> that that surround the cell (<td> tag). E.g.:
        //<tr id="17">
        //  <td>...</td><td>...</td><td>...</td><td>...</td>
        //</tr>
        function _fnGetRowIDFromAttribute(row) {
            return row.attr("id");
        }

        //Utility function used to set id of the new row
        //It is assumed that id is placed as an id attribute of <tr> that that surround the cell (<td> tag). E.g.:
        //<tr>
        //  <td>17</td><td>...</td><td>...</td><td>...</td>
        //</tr>
        function _fnSetRowIDInFirstCell(row, id) {
            $("td:first", row).html(id);
        }

        //Utility function used to get id of the row
        //It is assumed that id is placed as an id attribute of <tr> that that surround the cell (<td> tag). E.g.:
        //<tr>
        //  <td>17</td><td>...</td><td>...</td><td>...</td>
        //</tr>
        function _fnGetRowIDFromFirstCell(row) {
            return $("td:first", row).html();
        }

        //Reference to the DataTable object
        var oTable;
        //Refences to the buttons used for manipulating table data
        var oAddNewRowButton, oDeleteRowButton, oConfirmRowAddingButton, oCancelRowAddingButton;
        //Reference to the form used for adding new data
        var oAddNewRowForm;

        //Plugin options
        var properties;

        /// Utility function that shows an error message
        ///@param errorText - text that should be shown
        ///@param action - action that was executed when error occured e.g. "update", "delete", or "add"
        function fnShowError(errorText, action) {
            alert(errorText);
        }

        //Utility function that put the table into the "Processing" state
        function fnStartProcessingMode() {
            if (oTable.fnSettings().oFeatures.bProcessing) {
                $(".dataTables_processing").css('visibility', 'visible');
            }
        }

        //Utility function that put the table in the normal state
        function fnEndProcessingMode() {
            if (oTable.fnSettings().oFeatures.bProcessing) {
                $(".dataTables_processing").css('visibility', 'hidden');
            }
        }

        var sOldValue, sNewCellValue, sNewCellDislayValue;
        //Utility function used to apply editable plugin on table cells
        function _fnApplyEditable(aoNodes) {
            if (properties.bDisableEditing)
                return;
            var oDefaultEditableSettings = {
                event: 'dblclick',
                "callback": function (sValue, settings) {
                    properties.fnEndProcessingMode();
                    var status = "";
                    if (sNewCellValue == sValue) {
                        var aPos = oTable.fnGetPosition(this);
                        oTable.fnUpdate(sNewCellDisplayValue, aPos[0], aPos[2]);
                        status = "success";
                    } else {
                        var aPos = oTable.fnGetPosition(this);
                        oTable.fnUpdate(sOldValue, aPos[0], aPos[2]);
                        properties.fnShowError(sValue, "update");
                        status = "failure";
                    }

                    properties.fnOnEdited(status, sOldValue, sNewCellDisplayValue, aPos[0], aPos[1], aPos[2]);
                    if (settings.fnOnCellUpdated != null) {
                        settings.fnOnCellUpdated(status, sValue, settings);
                    }
                    _fnSetDisplayStart();

                },
                "onsubmit": function (settings, original) {
                    var input = $("input,select,textarea", this);
                    sOldValue = original.revert;
                    sNewCellValue = $("input,select,textarea", $(this)).val();
                    if (input.length == 1) {
                        var oEditElement = input[0];
                        if (oEditElement.nodeName.toLowerCase() == "select" || oEditElement.tagName.toLowerCase() == "select")
                            sNewCellDisplayValue = $("option:selected", oEditElement).text(); //For select list use selected text instead of value for displaying in table
                        else
                            sNewCellDisplayValue = sNewCellValue;
                    }

                    if (!properties.fnOnEditing(input))
                        return false;
                    var x = settings;
                    if (settings.cssclass != null) {
                        input.addClass(settings.cssclass);
                        if (!input.valid() || 0 == input.valid())
                            return false;
                        else
                            return true;
                    }
                },
                "submitdata": function (value, settings) {
                    iDisplayStart = _fnGetDisplayStart();
                    properties.fnStartProcessingMode();
                    var id = fnGetCellID(this);
                    var rowId = oTable.fnGetPosition(this)[0];
                    var columnPosition = oTable.fnGetPosition(this)[1];
                    var columnId = oTable.fnGetPosition(this)[2];
                    var sColumnName = oTable.fnSettings().aoColumns[columnId].sName;
                    if (sColumnName == null || sColumnName == "")
                        sColumnName = oTable.fnSettings().aoColumns[columnId].sTitle;
                    return {
                        "id": id,
                        "rowId": rowId,
                        "columnPosition": columnPosition,
                        "columnId": columnId,
                        "columnName": sColumnName
                    };
                },
                "onerror": function () {
                    properties.fnEndProcessingMode();
                    properties.fnShowError("Cell cannot be updated(Server error)", "update");
                    properties.fnOnEdited("failure");
                },
                "height": properties.sEditorHeight,
                "width": properties.sEditorWidth
            };

            var cells = null;
            if (properties.aoColumns != null) {
                for (var i = 0; i < properties.aoColumns.length; i++) {
                    if (properties.aoColumns[i] != null) {
                        cells = $("td:nth-child(" + (i + 1) + ")", aoNodes);
                        var oColumnSettings = oDefaultEditableSettings;
                        oColumnSettings = $.extend({}, oDefaultEditableSettings, properties.aoColumns[i]);
                        var sUpdateURL = properties.sUpdateURL;
                        try {
                            if (oColumnSettings.sUpdateURL != null)
                                sUpdateURL = oColumnSettings.sUpdateURL;
                        } catch (ex) {
                        }
                        cells.editable(sUpdateURL, oColumnSettings);
                    }


                }
            } else {
                cells = $('td:not(.' + properties.sReadOnlyCellClass + ')', aoNodes);
                cells.editable(properties.sUpdateURL, oDefaultEditableSettings);

            }

        }

        //Called when user confirm that he want to add new record
        function _fnOnRowAdding(event) {
            if (properties.fnOnAdding()) {
                if (oAddNewRowForm.valid()) {
                    iDisplayStart = _fnGetDisplayStart();
                    properties.fnStartProcessingMode();
                    var params = oAddNewRowForm.serialize();
                    $.ajax({ 'url': properties.sAddURL,
                        'data': params,
                        'type': properties.sAddHttpMethod,
                        "dataType": "text",
                        success: _fnOnRowAdded,
                        error: function (response) {
                            properties.fnEndProcessingMode();
                            properties.fnShowError(response.responseText, "add");
                            properties.fnOnAdded("failure");
                        }
                    });
                }
            }
            event.stopPropagation();
            event.preventDefault();
        }

        function _fnOnNewRowPosted(data) {

            return true;

        }
        ///Event handler called when a new row is added and response is returned from server
        function _fnOnRowAdded(data) {
            properties.fnEndProcessingMode();

            if (properties.fnOnNewRowPosted(data)) {

                var oSettings = oTable.fnSettings();
                var iColumnCount = oSettings.aoColumns.length;
                var values = new Array();

                $("input:text[rel],input:radio[rel][checked],input:hidden[rel],select[rel],textarea[rel],span.datafield[rel]", oAddNewRowForm).each(function () {
                    var rel = $(this).attr("rel");
                    var sCellValue = "";
                    if (rel >= iColumnCount)
                        properties.fnShowError("In the add form is placed input element with the name '" + $(this).attr("name") + "' with the 'rel' attribute that must be less than a column count - " + iColumnCount, "add");
                    else {
                        if (this.nodeName.toLowerCase() == "select" || this.tagName.toLowerCase() == "select")
                            sCellValue = $("option:selected", this).text();
                        else if (this.nodeName.toLowerCase() == "span" || this.tagName.toLowerCase() == "span")
                            sCellValue = $(this).html();
                        else
                            sCellValue = this.value;

                        sCellValue = sCellValue.replace(properties.sIDToken, data);
                        values[rel] = sCellValue;
                    }
                });

                //Add values from the form into the table
                var rtn = oTable.fnAddData(values);
                var oTRAdded = oTable.fnGetNodes(rtn);
                //Apply editable plugin on the cells of the table
                _fnApplyEditable(oTRAdded);
                //add id returned by server page as an TR id attribute
                properties.fnSetRowID($(oTRAdded), data);
                //Close the dialog
                oAddNewRowForm.dialog('close');
                $(oAddNewRowForm)[0].reset();
                $(".error", $(oAddNewRowForm)).html("");

                _fnSetDisplayStart();
                properties.fnOnAdded("success");
            }
        }

        //Called when user cancels adding new record in the popup dialog
        function _fnOnCancelRowAdding(event) {
            //Clear the validation messages and reset form
            $(oAddNewRowForm).validate().resetForm();  // Clears the validation errors
            $(oAddNewRowForm)[0].reset();

            $(".error", $(oAddNewRowForm)).html("");
            $(".error", $(oAddNewRowForm)).hide();  // Hides the error element

            //Close the dialog
            oAddNewRowForm.dialog('close');
            event.stopPropagation();
            event.preventDefault();
        }



        function _fnDisableDeleteButton() {
            if (properties.oDeleteRowButtonOptions != null) {
                //oDeleteRowButton.disable();
                oDeleteRowButton.button("option", "disabled", true);
            } else {
                oDeleteRowButton.attr("disabled", "true");
            }
        }

        function _fnEnableDeleteButton() {
            if (properties.oDeleteRowButtonOptions != null) {
                //oDeleteRowButton.enable();
                oDeleteRowButton.button("option", "disabled", false);
            } else {
                oDeleteRowButton.removeAttr("disabled");
            }
        }

        function _fnDeleteRow(id, sDeleteURL) {
            var sURL = sDeleteURL;
            if (sDeleteURL == null)
                sURL = properties.sDeleteURL;
            properties.fnStartProcessingMode();
            var data = $.extend(properties.oDeleteParameters, { "id": id });
            $.ajax({ 'url': sURL,
                'type': properties.sDeleteHttpMethod,
                'data': data,
                "success": _fnOnRowDeleted,
                "dataType": "text",
                "error": function (response) {
                    properties.fnEndProcessingMode();
                    properties.fnShowError(response.responseText, "delete");
                    properties.fnOnDeleted("failure");

                }
            });
        }

        //Called when user deletes a row
        function _fnOnRowDelete(event) {
            iDisplayStart = _fnGetDisplayStart();
            if ($('tr.' + properties.sSelectedRowClass + ' td', oTable).length == 0) {
                //oDeleteRowButton.attr("disabled", "true");
                _fnDisableDeleteButton();
                return;
            }
            var id = fnGetCellID($('tr.' + properties.sSelectedRowClass + ' td', oTable)[0]);
            if (properties.fnOnDeleting($('tr.' + properties.sSelectedRowClass, oTable), id, _fnDeleteRow)) {
                _fnDeleteRow(id);
            }
        }

        //Called when record is deleted on the server
        function _fnOnRowDeleted(response) {
            properties.fnEndProcessingMode();
            var oTRSelected = $('tr.' + properties.sSelectedRowClass, oTable)[0];
            if (response == "ok" || response == "") {
                oTable.fnDeleteRow(oTRSelected);
                //oDeleteRowButton.attr("disabled", "true");
                _fnDisableDeleteButton();
                _fnSetDisplayStart();
                properties.fnOnDeleted("success");
            }
            else {
                properties.fnShowError(response, "delete");
                properties.fnOnDeleted("failure");
            }
        }

        //Called before row is deleted
        //Returning false will abort delete
        /*
        * Function called before row is deleted
        * @param    tr  JQuery wrapped around the TR tag that will be deleted
        * @param    id  id of the record that wil be deleted
        * @return   true if plugin should continue with deleting row, false will abort delete.
        */
        function fnOnDeleting(tr, id, fnDeleteRow) {
            return confirm("Are you sure that you want to delete this record?"); ;
        }

        /* Function called after delete action
        * @param    result  string 
        *           "success" if row is actually deleted 
        *           "failure" if delete failed
        * @return   void
        */
        function fnOnDeleted(result) { }

        function fnOnEditing(input) { return true; }
        function fnOnEdited(result, sOldValue, sNewValue, iRowIndex, iColumnIndex, iRealColumnIndex) {

        }

        function fnOnAdding() { return true; }
        function fnOnAdded(result) { }

        var oSettings;
        function _fnGetDisplayStart() {
            return oSettings._iDisplayStart;
        }

        function _fnSetDisplayStart() {
            if (oSettings.oFeatures.bServerSide === false) {
                oSettings._iDisplayStart = iDisplayStart;
                oSettings.oApi._fnCalculateEnd(oSettings);
                //draw the 'current' page
                oSettings.oApi._fnDraw(oSettings);
            }
        }


        oTable = this;

        var defaults = {

            sUpdateURL: "UpdateData",
            sAddURL: "AddData",
            sDeleteURL: "DeleteData",
            sAddNewRowFormId: "formAddNewRow",
            oAddNewRowFormOptions: { autoOpen: false, modal: true },
            sAddNewRowButtonId: "btnAddNewRow",
            oAddNewRowButtonOptions: null,
            sAddNewRowOkButtonId: "btnAddNewRowOk",
            sAddNewRowCancelButtonId: "btnAddNewRowCancel",
            oAddNewRowOkButtonOptions: { label: "Ok" },
            oAddNewRowCancelButtonOptions: { label: "Cancel" },
            sDeleteRowButtonId: "btnDeleteRow",
            oDeleteRowButtonOptions: null,
            sSelectedRowClass: "row_selected",
            sReadOnlyCellClass: "read_only",
            sAddDeleteToolbarSelector: ".add_delete_toolbar",
            fnShowError: fnShowError,
            fnStartProcessingMode: fnStartProcessingMode,
            fnEndProcessingMode: fnEndProcessingMode,
            aoColumns: null,
            fnOnDeleting: fnOnDeleting,
            fnOnDeleted: fnOnDeleted,
            fnOnAdding: fnOnAdding,
            fnOnNewRowPosted: _fnOnNewRowPosted,
            fnOnAdded: fnOnAdded,
            fnOnEditing: fnOnEditing,
            fnOnEdited: fnOnEdited,
            sAddHttpMethod: 'POST',
            sDeleteHttpMethod: 'POST',
            fnGetRowID: _fnGetRowIDFromAttribute,
            fnSetRowID: _fnSetRowIDInAttribute,
            sEditorHeight: "100%",
            sEditorWidth: "100%",
            bDisableEditing: false,
            oDeleteParameters: {},
            sIDToken: "DATAROWID"

        };

        properties = $.extend(defaults, options);
        oSettings = oTable.fnSettings();

        return this.each(function () {

            if (oTable.fnSettings().sAjaxSource != null) {
                oTable.fnSettings().aoDrawCallback.push({
                    "fn": function () {
                        //Apply jEditable plugin on the table cells
                        _fnApplyEditable(oTable.fnGetNodes());
                        $(oTable.fnGetNodes()).each(function () {
                            var position = oTable.fnGetPosition(this);
                            var id = oTable.fnGetData(position)[0];
                            properties.fnSetRowID($(this), id);
                        }
                        );
                    },
                    "sName": "fnApplyEditable"
                });

            } else {
                //Apply jEditable plugin on the table cells
                _fnApplyEditable(oTable.fnGetNodes());
            }

            //Setup form to open in dialog
            oAddNewRowForm = $("#" + properties.sAddNewRowFormId);
            if (oAddNewRowForm.length != 0) {
                if (properties.oAddNewRowFormOptions != null) {
                    properties.oAddNewRowFormOptions.autoOpen = false;
                } else {
                    properties.oAddNewRowFormOptions = { autoOpen: false };
                }
                oAddNewRowForm.dialog(properties.oAddNewRowFormOptions);

                //Add button click handler on the "Add new row" button
                oAddNewRowButton = $("#" + properties.sAddNewRowButtonId);
                if (oAddNewRowButton.length != 0) {
                    oAddNewRowButton.click(function () {
                        oAddNewRowForm.dialog('open');
                    });
                } else {
                    if ($(properties.sAddDeleteToolbarSelector).length == 0) {
                        throw "Cannot find a button with an id '" + properties.sAddNewRowButtonId + "', od placeholder with an id '" + properties.sAddDeleteToolbarSelector + "' that should be used for adding new row although form for adding new record is specified";
                    } else {
                        oAddNewRowButton = null; //It will be auto-generated later
                    }
                }

                //Prevent Submit handler
                if (oAddNewRowForm[0].nodeName.toLowerCase() == "form") {
                    oAddNewRowForm.unbind('submit');
                    oAddNewRowForm.submit(function (event) {
                        _fnOnRowAdding(event);
                        return false;
                    });
                } else {
                    $("form", oAddNewRowForm[0]).unbind('submit');
                    $("form", oAddNewRowForm[0]).submit(function (event) {
                        _fnOnRowAdding(event);
                        return false;
                    });
                }

                // array to add default buttons to
                var aAddNewRowFormButtons = [];

                oConfirmRowAddingButton = $("#" + properties.sAddNewRowOkButtonId, oAddNewRowForm);
                if (oConfirmRowAddingButton.length == 0) {
                    //If someone forgotten to set the button text
                    if (properties.oAddNewRowOkButtonOptions.text == null
                        || properties.oAddNewRowOkButtonOptions.text == "") {
                        properties.oAddNewRowOkButtonOptions.text = "Ok";
                    }
                    properties.oAddNewRowOkButtonOptions.click = _fnOnRowAdding;
                    properties.oAddNewRowOkButtonOptions.id = properties.sAddNewRowOkButtonId;
                    // push the add button onto the array
                    aAddNewRowFormButtons.push(properties.oAddNewRowOkButtonOptions);
                } else {
                    oConfirmRowAddingButton.click(_fnOnRowAdding);
                }

                oCancelRowAddingButton = $("#" + properties.sAddNewRowCancelButtonId);
                if (oCancelRowAddingButton.length == 0) {
                    //If someone forgotten to the button text
                    if (properties.oAddNewRowCancelButtonOptions.text == null
                        || properties.oAddNewRowCancelButtonOptions.text == "") {
                        properties.oAddNewRowCancelButtonOptions.text = "Cancel";
                    }
                    properties.oAddNewRowCancelButtonOptions.click = _fnOnCancelRowAdding;
                    properties.oAddNewRowCancelButtonOptions.id = properties.sAddNewRowCancelButtonId;
                    // push the cancel button onto the array
                    aAddNewRowFormButtons.push(properties.oAddNewRowCancelButtonOptions);
                } else {
                    oCancelRowAddingButton.click(_fnOnCancelRowAdding);
                }
                // if the array contains elements, add them to the dialog
                if (aAddNewRowFormButtons.length > 0) {
                    oAddNewRowForm.dialog('option', 'buttons', aAddNewRowFormButtons);
                }
                //Issue: It cannot find it with this call:
                //oConfirmRowAddingButton = $("#" + properties.sAddNewRowOkButtonId, oAddNewRowForm);
                //oCancelRowAddingButton = $("#" + properties.sAddNewRowCancelButtonId, oAddNewRowForm);
                oConfirmRowAddingButton = $("#" + properties.sAddNewRowOkButtonId);
                oCancelRowAddingButton = $("#" + properties.sAddNewRowCancelButtonId);
            } else {
                oAddNewRowForm = null;
            }

            //Set the click handler on the "Delete selected row" button
            oDeleteRowButton = $('#' + properties.sDeleteRowButtonId);
            if (oDeleteRowButton.length != 0)
                oDeleteRowButton.click(_fnOnRowDelete);
            else {
                oDeleteRowButton = null;
            }

            //If an add and delete buttons does not exists but Add-delete toolbar is specificed
            //Autogenerate these buttons
            oAddDeleteToolbar = $(properties.sAddDeleteToolbarSelector);
            if (oAddDeleteToolbar.length != 0) {
                if (oAddNewRowButton == null && properties.sAddNewRowButtonId != ""
                    && oAddNewRowForm != null) {
                    oAddDeleteToolbar.append("<button id='" + properties.sAddNewRowButtonId + "' class='add_row'>Add</button>");
                    oAddNewRowButton = $("#" + properties.sAddNewRowButtonId);
                    oAddNewRowButton.click(function () { oAddNewRowForm.dialog('open'); });
                }
                if (oDeleteRowButton == null && properties.sDeleteRowButtonId != "") {
                    oAddDeleteToolbar.append("<button id='" + properties.sDeleteRowButtonId + "' class='delete_row'>Delete</button>");
                    oDeleteRowButton = $("#" + properties.sDeleteRowButtonId);
                    oDeleteRowButton.click(_fnOnRowDelete);
                }
            }

            //If delete button exists disable it until some row is selected
            if (oDeleteRowButton != null) {
                if (properties.oDeleteRowButtonOptions != null) {
                    oDeleteRowButton.button(properties.oDeleteRowButtonOptions);
                }
                _fnDisableDeleteButton();
            }

            //If add button exists convert it to the JQuery-ui button
            if (oAddNewRowButton != null) {
                if (properties.oAddNewRowButtonOptions != null) {
                    oAddNewRowButton.button(properties.oAddNewRowButtonOptions);
                }
            }


            //If form ok button exists convert it to the JQuery-ui button
            if (oConfirmRowAddingButton != null) {
                if (properties.oAddNewRowOkButtonOptions != null) {
                    oConfirmRowAddingButton.button(properties.oAddNewRowOkButtonOptions);
                }
            }

            //If form cancel button exists convert it to the JQuery-ui button
            if (oCancelRowAddingButton != null) {
                if (properties.oAddNewRowCancelButtonOptions != null) {
                    oCancelRowAddingButton.button(properties.oAddNewRowCancelButtonOptions);
                }
            }

            //Add handler to the inline delete buttons
            $(".table-action-deletelink", oTable).live("click", function (e) {

                    e.preventDefault();
                    e.stopPropagation();
                    var sURL = $(this).attr("href");

                    if (sURL == null || sURL == "")
                        sURL = properties.sDeleteURL;

                    iDisplayStart = _fnGetDisplayStart();
                    var oTD = ($(this).parents('td'))[0];
                    var oTR = ($(this).parents('tr'))[0];

                    $(oTR).addClass(properties.sSelectedRowClass);

                    var id = fnGetCellID(oTD);
                    if (properties.fnOnDeleting(oTD, id, _fnDeleteRow)) {
                        _fnDeleteRow(id, sURL);
                    }


                }
            );

            //Set selected class on row that is clicked
            //Enable delete button if row is selected, disable delete button if selected class is removed
            $("tbody", oTable).click(function (event) {
                if ($(event.target.parentNode).hasClass(properties.sSelectedRowClass)) {
                    $(event.target.parentNode).removeClass(properties.sSelectedRowClass);
                    if (oDeleteRowButton != null) {
                        _fnDisableDeleteButton();
                    }
                } else {
                    $(oTable.fnSettings().aoData).each(function () {
                        $(this.nTr).removeClass(properties.sSelectedRowClass);
                    });
                    $(event.target.parentNode).addClass(properties.sSelectedRowClass);
                    if (oDeleteRowButton != null) {
                        _fnEnableDeleteButton();
                    }
                }
            });



        });
    };
})(jQuery);/**
 * @summary     DataTables
 * @description Paginate, search and sort HTML tables
 * @version     1.9.0
 * @file        jquery.dataTables.js
 * @author      Allan Jardine (www.sprymedia.co.uk)
 * @contact     www.sprymedia.co.uk/contact
 *
 * @copyright Copyright 2008-2012 Allan Jardine, all rights reserved.
 *
 * This source file is free software, under either the GPL v2 license or a
 * BSD style license, available at:
 *   http://datatables.net/license_gpl2
 *   http://datatables.net/license_bsd
 * 
 * This source file is distributed in the hope that it will be useful, but 
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. See the license files for details.
 * 
 * For details please refer to: http://www.datatables.net
 */

/*jslint evil: true, undef: true, browser: true */
/*globals $, jQuery,_fnExternApiFunc,_fnInitialise,_fnInitComplete,_fnLanguageCompat,_fnAddColumn,_fnColumnOptions,_fnAddData,_fnCreateTr,_fnGatherData,_fnBuildHead,_fnDrawHead,_fnDraw,_fnReDraw,_fnAjaxUpdate,_fnAjaxParameters,_fnAjaxUpdateDraw,_fnServerParams,_fnAddOptionsHtml,_fnFeatureHtmlTable,_fnScrollDraw,_fnAdjustColumnSizing,_fnFeatureHtmlFilter,_fnFilterComplete,_fnFilterCustom,_fnFilterColumn,_fnFilter,_fnBuildSearchArray,_fnBuildSearchRow,_fnFilterCreateSearch,_fnDataToSearch,_fnSort,_fnSortAttachListener,_fnSortingClasses,_fnFeatureHtmlPaginate,_fnPageChange,_fnFeatureHtmlInfo,_fnUpdateInfo,_fnFeatureHtmlLength,_fnFeatureHtmlProcessing,_fnProcessingDisplay,_fnVisibleToColumnIndex,_fnColumnIndexToVisible,_fnNodeToDataIndex,_fnVisbleColumns,_fnCalculateEnd,_fnConvertToWidth,_fnCalculateColumnWidths,_fnScrollingWidthAdjust,_fnGetWidestNode,_fnGetMaxLenString,_fnStringToCss,_fnDetectType,_fnSettingsFromNode,_fnGetDataMaster,_fnGetTrNodes,_fnGetTdNodes,_fnEscapeRegex,_fnDeleteIndex,_fnReOrderIndex,_fnColumnOrdering,_fnLog,_fnClearTable,_fnSaveState,_fnLoadState,_fnCreateCookie,_fnReadCookie,_fnDetectHeader,_fnGetUniqueThs,_fnScrollBarWidth,_fnApplyToChildren,_fnMap,_fnGetRowData,_fnGetCellData,_fnSetCellData,_fnGetObjectDataFn,_fnSetObjectDataFn,_fnApplyColumnDefs,_fnBindAction,_fnCallbackReg,_fnCallbackFire,_fnJsonString,_fnRender,_fnNodeToColumnIndex*/

(/** @lends <global> */function($, window, document, undefined) {
	/** 
	 * DataTables is a plug-in for the jQuery Javascript library. It is a 
	 * highly flexible tool, based upon the foundations of progressive 
	 * enhancement, which will add advanced interaction controls to any 
	 * HTML table. For a full list of features please refer to
	 * <a href="http://datatables.net">DataTables.net</a>.
	 *
	 * Note that the <i>DataTable</i> object is not a global variable but is
	 * aliased to <i>jQuery.fn.DataTable</i> and <i>jQuery.fn.dataTable</i> through which 
	 * it may be  accessed.
	 *
	 *  @class
	 *  @param {object} [oInit={}] Configuration object for DataTables. Options
	 *    are defined by {@link DataTable.defaults}
	 *  @requires jQuery 1.3+
	 * 
	 *  @example
	 *    // Basic initialisation
	 *    $(document).ready( function {
	 *      $('#example').dataTable();
	 *    } );
	 *  
	 *  @example
	 *    // Initialisation with configuration options - in this case, disable
	 *    // pagination and sorting.
	 *    $(document).ready( function {
	 *      $('#example').dataTable( {
	 *        "bPaginate": false,
	 *        "bSort": false 
	 *      } );
	 *    } );
	 */
	var DataTable = function( oInit )
	{
		
		
		/**
		 * Add a column to the list used for the table with default values
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nTh The th element for this column
		 *  @memberof DataTable#oApi
		 */
		function _fnAddColumn( oSettings, nTh )
		{
			var oDefaults = DataTable.defaults.columns;
			var iCol = oSettings.aoColumns.length;
			var oCol = $.extend( {}, DataTable.models.oColumn, oDefaults, {
				"sSortingClass": oSettings.oClasses.sSortable,
				"sSortingClassJUI": oSettings.oClasses.sSortJUI,
				"nTh": nTh ? nTh : document.createElement('th'),
				"sTitle":    oDefaults.sTitle    ? oDefaults.sTitle    : nTh ? nTh.innerHTML : '',
				"aDataSort": oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
				"mDataProp": oDefaults.mDataProp ? oDefaults.oDefaults : iCol
			} );
			oSettings.aoColumns.push( oCol );
			
			/* Add a column specific filter */
			if ( oSettings.aoPreSearchCols[ iCol ] === undefined || oSettings.aoPreSearchCols[ iCol ] === null )
			{
				oSettings.aoPreSearchCols[ iCol ] = $.extend( {}, DataTable.models.oSearch );
			}
			else
			{
				var oPre = oSettings.aoPreSearchCols[ iCol ];
				
				/* Don't require that the user must specify bRegex, bSmart or bCaseInsensitive */
				if ( oPre.bRegex === undefined )
				{
					oPre.bRegex = true;
				}
				
				if ( oPre.bSmart === undefined )
				{
					oPre.bSmart = true;
				}
				
				if ( oPre.bCaseInsensitive === undefined )
				{
					oPre.bCaseInsensitive = true;
				}
			}
			
			/* Use the column options function to initialise classes etc */
			_fnColumnOptions( oSettings, iCol, null );
		}
		
		
		/**
		 * Apply options for a column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iCol column index to consider
		 *  @param {object} oOptions object with sType, bVisible and bSearchable
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnOptions( oSettings, iCol, oOptions )
		{
			var oCol = oSettings.aoColumns[ iCol ];
			
			/* User specified column options */
			if ( oOptions !== undefined && oOptions !== null )
			{
				if ( oOptions.sType !== undefined )
				{
					oCol.sType = oOptions.sType;
					oCol._bAutoType = false;
				}
				
				$.extend( oCol, oOptions );
				_fnMap( oCol, oOptions, "sWidth", "sWidthOrig" );
		
				/* iDataSort to be applied (backwards compatibility), but aDataSort will take
				 * priority if defined
				 */
				if ( oOptions.iDataSort !== undefined )
				{
					oCol.aDataSort = [ oOptions.iDataSort ];
				}
				_fnMap( oCol, oOptions, "aDataSort" );
			}
		
			/* Cache the data get and set functions for speed */
			oCol.fnGetData = _fnGetObjectDataFn( oCol.mDataProp );
			oCol.fnSetData = _fnSetObjectDataFn( oCol.mDataProp );
			
			/* Feature sorting overrides column specific when off */
			if ( !oSettings.oFeatures.bSort )
			{
				oCol.bSortable = false;
			}
			
			/* Check that the class assignment is correct for sorting */
			if ( !oCol.bSortable ||
				 ($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1) )
			{
				oCol.sSortingClass = oSettings.oClasses.sSortableNone;
				oCol.sSortingClassJUI = "";
			}
			else if ( oCol.bSortable ||
			          ($.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) == -1) )
			{
			  oCol.sSortingClass = oSettings.oClasses.sSortable;
			  oCol.sSortingClassJUI = oSettings.oClasses.sSortJUI;
			}
			else if ( $.inArray('asc', oCol.asSorting) != -1 && $.inArray('desc', oCol.asSorting) == -1 )
			{
				oCol.sSortingClass = oSettings.oClasses.sSortableAsc;
				oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIAscAllowed;
			}
			else if ( $.inArray('asc', oCol.asSorting) == -1 && $.inArray('desc', oCol.asSorting) != -1 )
			{
				oCol.sSortingClass = oSettings.oClasses.sSortableDesc;
				oCol.sSortingClassJUI = oSettings.oClasses.sSortJUIDescAllowed;
			}
		}
		
		
		/**
		 * Adjust the table column widths for new data. Note: you would probably want to 
		 * do a redraw after calling this function!
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnAdjustColumnSizing ( oSettings )
		{
			/* Not interested in doing column width calculation if autowidth is disabled */
			if ( oSettings.oFeatures.bAutoWidth === false )
			{
				return false;
			}
			
			_fnCalculateColumnWidths( oSettings );
			for ( var i=0 , iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				oSettings.aoColumns[i].nTh.style.width = oSettings.aoColumns[i].sWidth;
			}
		}
		
		
		/**
		 * Covert the index of a visible column to the index in the data array (take account
		 * of hidden columns)
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iMatch Visible column index to lookup
		 *  @returns {int} i the data index
		 *  @memberof DataTable#oApi
		 */
		function _fnVisibleToColumnIndex( oSettings, iMatch )
		{
			var iColumn = -1;
			
			for ( var i=0 ; i<oSettings.aoColumns.length ; i++ )
			{
				if ( oSettings.aoColumns[i].bVisible === true )
				{
					iColumn++;
				}
				
				if ( iColumn == iMatch )
				{
					return i;
				}
			}
			
			return null;
		}
		
		
		/**
		 * Covert the index of an index in the data array and convert it to the visible
		 *   column index (take account of hidden columns)
		 *  @param {int} iMatch Column index to lookup
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {int} i the data index
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnIndexToVisible( oSettings, iMatch )
		{
			var iVisible = -1;
			for ( var i=0 ; i<oSettings.aoColumns.length ; i++ )
			{
				if ( oSettings.aoColumns[i].bVisible === true )
				{
					iVisible++;
				}
				
				if ( i == iMatch )
				{
					return oSettings.aoColumns[i].bVisible === true ? iVisible : null;
				}
			}
			
			return null;
		}
		
		
		/**
		 * Get the number of visible columns
		 *  @returns {int} i the number of visible columns
		 *  @param {object} oS dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnVisbleColumns( oS )
		{
			var iVis = 0;
			for ( var i=0 ; i<oS.aoColumns.length ; i++ )
			{
				if ( oS.aoColumns[i].bVisible === true )
				{
					iVis++;
				}
			}
			return iVis;
		}
		
		
		/**
		 * Get the sort type based on an input string
		 *  @param {string} sData data we wish to know the type of
		 *  @returns {string} type (defaults to 'string' if no type can be detected)
		 *  @memberof DataTable#oApi
		 */
		function _fnDetectType( sData )
		{
			var aTypes = DataTable.ext.aTypes;
			var iLen = aTypes.length;
			
			for ( var i=0 ; i<iLen ; i++ )
			{
				var sType = aTypes[i]( sData );
				if ( sType !== null )
				{
					return sType;
				}
			}
			
			return 'string';
		}
		
		
		/**
		 * Figure out how to reorder a display list
		 *  @param {object} oSettings dataTables settings object
		 *  @returns array {int} aiReturn index list for reordering
		 *  @memberof DataTable#oApi
		 */
		function _fnReOrderIndex ( oSettings, sColumns )
		{
			var aColumns = sColumns.split(',');
			var aiReturn = [];
			
			for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				for ( var j=0 ; j<iLen ; j++ )
				{
					if ( oSettings.aoColumns[i].sName == aColumns[j] )
					{
						aiReturn.push( j );
						break;
					}
				}
			}
			
			return aiReturn;
		}
		
		
		/**
		 * Get the column ordering that DataTables expects
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {string} comma separated list of names
		 *  @memberof DataTable#oApi
		 */
		function _fnColumnOrdering ( oSettings )
		{
			var sNames = '';
			for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				sNames += oSettings.aoColumns[i].sName+',';
			}
			if ( sNames.length == iLen )
			{
				return "";
			}
			return sNames.slice(0, -1);
		}
		
		
		/**
		 * Take the column definitions and static columns arrays and calculate how
		 * they relate to column indexes. The callback function will then apply the
		 * definition found for a column to a suitable configuration object.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aoColDefs The aoColumnDefs array that is to be applied
		 *  @param {array} aoCols The aoColumns array that defines columns individually
		 *  @param {function} fn Callback function - takes two parameters, the calculated
		 *    column index and the definition for that column.
		 *  @memberof DataTable#oApi
		 */
		function _fnApplyColumnDefs( oSettings, aoColDefs, aoCols, fn )
		{
			var i, iLen, j, jLen, k, kLen;
		
			// Column definitions with aTargets
			if ( aoColDefs )
			{
				/* Loop over the definitions array - loop in reverse so first instance has priority */
				for ( i=aoColDefs.length-1 ; i>=0 ; i-- )
				{
					/* Each definition can target multiple columns, as it is an array */
					var aTargets = aoColDefs[i].aTargets;
					if ( !$.isArray( aTargets ) )
					{
						_fnLog( oSettings, 1, 'aTargets must be an array of targets, not a '+(typeof aTargets) );
					}
		
					for ( j=0, jLen=aTargets.length ; j<jLen ; j++ )
					{
						if ( typeof aTargets[j] === 'number' && aTargets[j] >= 0 )
						{
							/* Add columns that we don't yet know about */
							while( oSettings.aoColumns.length <= aTargets[j] )
							{
								_fnAddColumn( oSettings );
							}
		
							/* Integer, basic index */
							fn( aTargets[j], aoColDefs[i] );
						}
						else if ( typeof aTargets[j] === 'number' && aTargets[j] < 0 )
						{
							/* Negative integer, right to left column counting */
							fn( oSettings.aoColumns.length+aTargets[j], aoColDefs[i] );
						}
						else if ( typeof aTargets[j] === 'string' )
						{
							/* Class name matching on TH element */
							for ( k=0, kLen=oSettings.aoColumns.length ; k<kLen ; k++ )
							{
								if ( aTargets[j] == "_all" ||
								     $(oSettings.aoColumns[k].nTh).hasClass( aTargets[j] ) )
								{
									fn( k, aoColDefs[i] );
								}
							}
						}
					}
				}
			}
		
			// Statically defined columns array
			if ( aoCols )
			{
				for ( i=0, iLen=aoCols.length ; i<iLen ; i++ )
				{
					fn( i, aoCols[i] );
				}
			}
		}
		
		
		
		/**
		 * Add a data array to the table, creating DOM node etc. This is the parallel to 
		 * _fnGatherData, but for adding rows from a Javascript source, rather than a
		 * DOM source.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aData data array to be added
		 *  @returns {int} >=0 if successful (index of new aoData entry), -1 if failed
		 *  @memberof DataTable#oApi
		 */
		function _fnAddData ( oSettings, aDataSupplied )
		{
			var oCol;
			
			/* Take an independent copy of the data source so we can bash it about as we wish */
			var aDataIn = ($.isArray(aDataSupplied)) ?
				aDataSupplied.slice() :
				$.extend( true, {}, aDataSupplied );
			
			/* Create the object for storing information about this new row */
			var iRow = oSettings.aoData.length;
			var oData = $.extend( true, {}, DataTable.models.oRow, {
				"_aData": aDataIn
			} );
			oSettings.aoData.push( oData );
		
			/* Create the cells */
			var nTd, sThisType;
			for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				oCol = oSettings.aoColumns[i];
		
				/* Use rendered data for filtering/sorting */
				if ( typeof oCol.fnRender === 'function' && oCol.bUseRendered && oCol.mDataProp !== null )
				{
					_fnSetCellData( oSettings, iRow, i, _fnRender(oSettings, iRow, i) );
				}
				
				/* See if we should auto-detect the column type */
				if ( oCol._bAutoType && oCol.sType != 'string' )
				{
					/* Attempt to auto detect the type - same as _fnGatherData() */
					var sVarType = _fnGetCellData( oSettings, iRow, i, 'type' );
					if ( sVarType !== null && sVarType !== '' )
					{
						sThisType = _fnDetectType( sVarType );
						if ( oCol.sType === null )
						{
							oCol.sType = sThisType;
						}
						else if ( oCol.sType != sThisType && oCol.sType != "html" )
						{
							/* String is always the 'fallback' option */
							oCol.sType = 'string';
						}
					}
				}
			}
			
			/* Add to the display array */
			oSettings.aiDisplayMaster.push( iRow );
		
			/* Create the DOM imformation */
			if ( !oSettings.oFeatures.bDeferRender )
			{
				_fnCreateTr( oSettings, iRow );
			}
		
			return iRow;
		}
		
		
		/**
		 * Read in the data from the target table from the DOM
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnGatherData( oSettings )
		{
			var iLoop, i, iLen, j, jLen, jInner,
			 	nTds, nTrs, nTd, aLocalData, iThisIndex,
				iRow, iRows, iColumn, iColumns, sNodeName,
				oCol, oData;
			
			/*
			 * Process by row first
			 * Add the data object for the whole table - storing the tr node. Note - no point in getting
			 * DOM based data if we are going to go and replace it with Ajax source data.
			 */
			if ( oSettings.bDeferLoading || oSettings.sAjaxSource === null )
			{
				nTrs = oSettings.nTBody.childNodes;
				for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
				{
					if ( nTrs[i].nodeName.toUpperCase() == "TR" )
					{
						iThisIndex = oSettings.aoData.length;
						nTrs[i]._DT_RowIndex = iThisIndex;
						oSettings.aoData.push( $.extend( true, {}, DataTable.models.oRow, {
							"nTr": nTrs[i]
						} ) );
						
						oSettings.aiDisplayMaster.push( iThisIndex );
						nTds = nTrs[i].childNodes;
						jInner = 0;
						
						for ( j=0, jLen=nTds.length ; j<jLen ; j++ )
						{
							sNodeName = nTds[j].nodeName.toUpperCase();
							if ( sNodeName == "TD" || sNodeName == "TH" )
							{
								_fnSetCellData( oSettings, iThisIndex, jInner, $.trim(nTds[j].innerHTML) );
								jInner++;
							}
						}
					}
				}
			}
			
			/* Gather in the TD elements of the Table - note that this is basically the same as
			 * fnGetTdNodes, but that function takes account of hidden columns, which we haven't yet
			 * setup!
			 */
			nTrs = _fnGetTrNodes( oSettings );
			nTds = [];
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				for ( j=0, jLen=nTrs[i].childNodes.length ; j<jLen ; j++ )
				{
					nTd = nTrs[i].childNodes[j];
					sNodeName = nTd.nodeName.toUpperCase();
					if ( sNodeName == "TD" || sNodeName == "TH" )
					{
						nTds.push( nTd );
					}
				}
			}
			
			/* Now process by column */
			for ( iColumn=0, iColumns=oSettings.aoColumns.length ; iColumn<iColumns ; iColumn++ )
			{
				oCol = oSettings.aoColumns[iColumn];
		
				/* Get the title of the column - unless there is a user set one */
				if ( oCol.sTitle === null )
				{
					oCol.sTitle = oCol.nTh.innerHTML;
				}
				
				var
					bAutoType = oCol._bAutoType,
					bRender = typeof oCol.fnRender === 'function',
					bClass = oCol.sClass !== null,
					bVisible = oCol.bVisible,
					nCell, sThisType, sRendered, sValType;
				
				/* A single loop to rule them all (and be more efficient) */
				if ( bAutoType || bRender || bClass || !bVisible )
				{
					for ( iRow=0, iRows=oSettings.aoData.length ; iRow<iRows ; iRow++ )
					{
						oData = oSettings.aoData[iRow];
						nCell = nTds[ (iRow*iColumns) + iColumn ];
						
						/* Type detection */
						if ( bAutoType && oCol.sType != 'string' )
						{
							sValType = _fnGetCellData( oSettings, iRow, iColumn, 'type' );
							if ( sValType !== '' )
							{
								sThisType = _fnDetectType( sValType );
								if ( oCol.sType === null )
								{
									oCol.sType = sThisType;
								}
								else if ( oCol.sType != sThisType && 
								          oCol.sType != "html" )
								{
									/* String is always the 'fallback' option */
									oCol.sType = 'string';
								}
							}
						}
		
						if ( typeof oCol.mDataProp === 'function' )
						{
							nCell.innerHTML = _fnGetCellData( oSettings, iRow, iColumn, 'display' );
						}
						
						/* Rendering */
						if ( bRender )
						{
							sRendered = _fnRender( oSettings, iRow, iColumn );
							nCell.innerHTML = sRendered;
							if ( oCol.bUseRendered )
							{
								/* Use the rendered data for filtering/sorting */
								_fnSetCellData( oSettings, iRow, iColumn, sRendered );
							}
						}
						
						/* Classes */
						if ( bClass )
						{
							nCell.className += ' '+oCol.sClass;
						}
						
						/* Column visability */
						if ( !bVisible )
						{
							oData._anHidden[iColumn] = nCell;
							nCell.parentNode.removeChild( nCell );
						}
						else
						{
							oData._anHidden[iColumn] = null;
						}
		
						if ( oCol.fnCreatedCell )
						{
							oCol.fnCreatedCell.call( oSettings.oInstance,
								nCell, _fnGetCellData( oSettings, iRow, iColumn, 'display' ), oData._aData, iRow, iColumn
							);
						}
					}
				}
			}
		
			/* Row created callbacks */
			if ( oSettings.aoRowCreatedCallback.length !== 0 )
			{
				for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
				{
					oData = oSettings.aoData[i];
					_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [oData.nTr, oData._aData, i] );
				}
			}
		}
		
		
		/**
		 * Take a TR element and convert it to an index in aoData
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} n the TR element to find
		 *  @returns {int} index if the node is found, null if not
		 *  @memberof DataTable#oApi
		 */
		function _fnNodeToDataIndex( oSettings, n )
		{
			return (n._DT_RowIndex!==undefined) ? n._DT_RowIndex : null;
		}
		
		
		/**
		 * Take a TD element and convert it into a column data index (not the visible index)
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow The row number the TD/TH can be found in
		 *  @param {node} n The TD/TH element to find
		 *  @returns {int} index if the node is found, -1 if not
		 *  @memberof DataTable#oApi
		 */
		function _fnNodeToColumnIndex( oSettings, iRow, n )
		{
			var anCells = _fnGetTdNodes( oSettings, iRow );
		
			for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				if ( anCells[i] === n )
				{
					return i;
				}
			}
			return -1;
		}
		
		
		/**
		 * Get an array of data for a given row from the internal data cache
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow aoData row id
		 *  @param {string} sSpecific data get type ('type' 'filter' 'sort')
		 *  @returns {array} Data array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetRowData( oSettings, iRow, sSpecific )
		{
			var out = [];
			for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				out.push( _fnGetCellData( oSettings, iRow, i, sSpecific ) );
			}
			return out;
		}
		
		
		/**
		 * Get the data for a given cell from the internal cache, taking into account data mapping
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow aoData row id
		 *  @param {int} iCol Column index
		 *  @param {string} sSpecific data get type ('display', 'type' 'filter' 'sort')
		 *  @returns {*} Cell data
		 *  @memberof DataTable#oApi
		 */
		function _fnGetCellData( oSettings, iRow, iCol, sSpecific )
		{
			var sData;
			var oCol = oSettings.aoColumns[iCol];
			var oData = oSettings.aoData[iRow]._aData;
		
			if ( (sData=oCol.fnGetData( oData, sSpecific )) === undefined )
			{
				if ( oSettings.iDrawError != oSettings.iDraw && oCol.sDefaultContent === null )
				{
					_fnLog( oSettings, 0, "Requested unknown parameter '"+oCol.mDataProp+
						"' from the data source for row "+iRow );
					oSettings.iDrawError = oSettings.iDraw;
				}
				return oCol.sDefaultContent;
			}
		
			/* When the data source is null, we can use default column data */
			if ( sData === null && oCol.sDefaultContent !== null )
			{
				sData = oCol.sDefaultContent;
			}
			else if ( typeof sData === 'function' )
			{
				/* If the data source is a function, then we run it and use the return */
				return sData();
			}
		
			if ( sSpecific == 'display' && sData === null )
			{
				return '';
			}
			return sData;
		}
		
		
		/**
		 * Set the value for a specific cell, into the internal data cache
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow aoData row id
		 *  @param {int} iCol Column index
		 *  @param {*} val Value to set
		 *  @memberof DataTable#oApi
		 */
		function _fnSetCellData( oSettings, iRow, iCol, val )
		{
			var oCol = oSettings.aoColumns[iCol];
			var oData = oSettings.aoData[iRow]._aData;
		
			oCol.fnSetData( oData, val );
		}
		
		
		/**
		 * Return a function that can be used to get data from a source object, taking
		 * into account the ability to use nested objects as a source
		 *  @param {string|int|function} mSource The data source for the object
		 *  @returns {function} Data get function
		 *  @memberof DataTable#oApi
		 */
		function _fnGetObjectDataFn( mSource )
		{
			if ( mSource === null )
			{
				/* Give an empty string for rendering / sorting etc */
				return function (data, type) {
					return null;
				};
			}
			else if ( typeof mSource === 'function' )
			{
				return function (data, type) {
					return mSource( data, type );
				};
			}
			else if ( typeof mSource === 'string' && mSource.indexOf('.') != -1 )
			{
				/* If there is a . in the source string then the data source is in a 
				 * nested object so we loop over the data for each level to get the next
				 * level down. On each loop we test for undefined, and if found immediatly
				 * return. This allows entire objects to be missing and sDefaultContent to
				 * be used if defined, rather than throwing an error
				 */
				var a = mSource.split('.');
				return function (data, type) {
					for ( var i=0, iLen=a.length ; i<iLen ; i++ )
					{
						data = data[ a[i] ];
						if ( data === undefined )
						{
							return undefined;
						}
					}
					return data;
				};
			}
			else
			{
				/* Array or flat object mapping */
				return function (data, type) {
					return data[mSource];	
				};
			}
		}
		
		
		/**
		 * Return a function that can be used to set data from a source object, taking
		 * into account the ability to use nested objects as a source
		 *  @param {string|int|function} mSource The data source for the object
		 *  @returns {function} Data set function
		 *  @memberof DataTable#oApi
		 */
		function _fnSetObjectDataFn( mSource )
		{
			if ( mSource === null )
			{
				/* Nothing to do when the data source is null */
				return function (data, val) {};
			}
			else if ( typeof mSource === 'function' )
			{
				return function (data, val) {
					mSource( data, 'set', val );
				};
			}
			else if ( typeof mSource === 'string' && mSource.indexOf('.') != -1 )
			{
				/* Like the get, we need to get data from a nested object.  */
				var a = mSource.split('.');
				return function (data, val) {
					for ( var i=0, iLen=a.length-1 ; i<iLen ; i++ )
					{
						data = data[ a[i] ];
					}
					data[ a[a.length-1] ] = val;
				};
			}
			else
			{
				/* Array or flat object mapping */
				return function (data, val) {
					data[mSource] = val;	
				};
			}
		}
		
		
		/**
		 * Return an array with the full table data
		 *  @param {object} oSettings dataTables settings object
		 *  @returns array {array} aData Master data array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetDataMaster ( oSettings )
		{
			var aData = [];
			var iLen = oSettings.aoData.length;
			for ( var i=0 ; i<iLen; i++ )
			{
				aData.push( oSettings.aoData[i]._aData );
			}
			return aData;
		}
		
		
		/**
		 * Nuke the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnClearTable( oSettings )
		{
			oSettings.aoData.splice( 0, oSettings.aoData.length );
			oSettings.aiDisplayMaster.splice( 0, oSettings.aiDisplayMaster.length );
			oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length );
			_fnCalculateEnd( oSettings );
		}
		
		
		 /**
		 * Take an array of integers (index array) and remove a target integer (value - not 
		 * the key!)
		 *  @param {array} a Index array to target
		 *  @param {int} iTarget value to find
		 *  @memberof DataTable#oApi
		 */
		function _fnDeleteIndex( a, iTarget )
		{
			var iTargetIndex = -1;
			
			for ( var i=0, iLen=a.length ; i<iLen ; i++ )
			{
				if ( a[i] == iTarget )
				{
					iTargetIndex = i;
				}
				else if ( a[i] > iTarget )
				{
					a[i]--;
				}
			}
			
			if ( iTargetIndex != -1 )
			{
				a.splice( iTargetIndex, 1 );
			}
		}
		
		
		 /**
		 * Call the developer defined fnRender function for a given cell (row/column) with
		 * the required parameters and return the result.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow aoData index for the row
		 *  @param {int} iCol aoColumns index for the column
		 *  @returns {*} Return of the developer's fnRender function
		 *  @memberof DataTable#oApi
		 */
		function _fnRender( oSettings, iRow, iCol )
		{
			var oCol = oSettings.aoColumns[iCol];
		
			return oCol.fnRender( {
				"iDataRow":    iRow,
				"iDataColumn": iCol,
				"oSettings":   oSettings,
				"aData":       oSettings.aoData[iRow]._aData,
				"mDataProp":   oCol.mDataProp
			}, _fnGetCellData(oSettings, iRow, iCol, 'display') );
		}
		
		
		/**
		 * Create a new TR element (and it's TD children) for a row
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iRow Row to consider
		 *  @memberof DataTable#oApi
		 */
		function _fnCreateTr ( oSettings, iRow )
		{
			var oData = oSettings.aoData[iRow];
			var nTd;
		
			if ( oData.nTr === null )
			{
				oData.nTr = document.createElement('tr');
		
				/* Use a private property on the node to allow reserve mapping from the node
				 * to the aoData array for fast look up
				 */
				oData.nTr._DT_RowIndex = iRow;
		
				/* Special parameters can be given by the data source to be used on the row */
				if ( oData._aData.DT_RowId )
				{
					oData.nTr.id = oData._aData.DT_RowId;
				}
		
				if ( oData._aData.DT_RowClass )
				{
					$(oData.nTr).addClass( oData._aData.DT_RowClass );
				}
		
				/* Process each column */
				for ( var i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					var oCol = oSettings.aoColumns[i];
					nTd = document.createElement('td');
		
					/* Render if needed - if bUseRendered is true then we already have the rendered
					 * value in the data source - so can just use that
					 */
					nTd.innerHTML = (typeof oCol.fnRender === 'function' && (!oCol.bUseRendered || oCol.mDataProp === null)) ?
						_fnRender( oSettings, iRow, i ) :
						_fnGetCellData( oSettings, iRow, i, 'display' );
				
					/* Add user defined class */
					if ( oCol.sClass !== null )
					{
						nTd.className = oCol.sClass;
					}
					
					if ( oCol.bVisible )
					{
						oData.nTr.appendChild( nTd );
						oData._anHidden[i] = null;
					}
					else
					{
						oData._anHidden[i] = nTd;
					}
		
					if ( oCol.fnCreatedCell )
					{
						oCol.fnCreatedCell.call( oSettings.oInstance,
							nTd, _fnGetCellData( oSettings, iRow, i, 'display' ), oData._aData, iRow, i
						);
					}
				}
		
				_fnCallbackFire( oSettings, 'aoRowCreatedCallback', null, [oData.nTr, oData._aData, iRow] );
			}
		}
		
		
		/**
		 * Create the HTML header for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnBuildHead( oSettings )
		{
			var i, nTh, iLen, j, jLen;
			var iThs = oSettings.nTHead.getElementsByTagName('th').length;
			var iCorrector = 0;
			var jqChildren;
			
			/* If there is a header in place - then use it - otherwise it's going to get nuked... */
			if ( iThs !== 0 )
			{
				/* We've got a thead from the DOM, so remove hidden columns and apply width to vis cols */
				for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					nTh = oSettings.aoColumns[i].nTh;
					nTh.setAttribute('role', 'columnheader');
					if ( oSettings.aoColumns[i].bSortable )
					{
						nTh.setAttribute('tabindex', oSettings.iTabIndex);
						nTh.setAttribute('aria-controls', oSettings.sTableId);
					}
		
					if ( oSettings.aoColumns[i].sClass !== null )
					{
						$(nTh).addClass( oSettings.aoColumns[i].sClass );
					}
					
					/* Set the title of the column if it is user defined (not what was auto detected) */
					if ( oSettings.aoColumns[i].sTitle != nTh.innerHTML )
					{
						nTh.innerHTML = oSettings.aoColumns[i].sTitle;
					}
				}
			}
			else
			{
				/* We don't have a header in the DOM - so we are going to have to create one */
				var nTr = document.createElement( "tr" );
				
				for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					nTh = oSettings.aoColumns[i].nTh;
					nTh.innerHTML = oSettings.aoColumns[i].sTitle;
					nTh.setAttribute('tabindex', '0');
					
					if ( oSettings.aoColumns[i].sClass !== null )
					{
						$(nTh).addClass( oSettings.aoColumns[i].sClass );
					}
					
					nTr.appendChild( nTh );
				}
				$(oSettings.nTHead).html( '' )[0].appendChild( nTr );
				_fnDetectHeader( oSettings.aoHeader, oSettings.nTHead );
			}
			
			/* ARIA role for the rows */	
			$(oSettings.nTHead).children('tr').attr('role', 'row');
			
			/* Add the extra markup needed by jQuery UI's themes */
			if ( oSettings.bJUI )
			{
				for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					nTh = oSettings.aoColumns[i].nTh;
					
					var nDiv = document.createElement('div');
					nDiv.className = oSettings.oClasses.sSortJUIWrapper;
					$(nTh).contents().appendTo(nDiv);
					
					var nSpan = document.createElement('span');
					nSpan.className = oSettings.oClasses.sSortIcon;
					nDiv.appendChild( nSpan );
					nTh.appendChild( nDiv );
				}
			}
			
			if ( oSettings.oFeatures.bSort )
			{
				for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
				{
					if ( oSettings.aoColumns[i].bSortable !== false )
					{
						_fnSortAttachListener( oSettings, oSettings.aoColumns[i].nTh, i );
					}
					else
					{
						$(oSettings.aoColumns[i].nTh).addClass( oSettings.oClasses.sSortableNone );
					}
				}
			}
			
			/* Deal with the footer - add classes if required */
			if ( oSettings.oClasses.sFooterTH !== "" )
			{
				$(oSettings.nTFoot).children('tr').children('th').addClass( oSettings.oClasses.sFooterTH );
			}
			
			/* Cache the footer elements */
			if ( oSettings.nTFoot !== null )
			{
				var anCells = _fnGetUniqueThs( oSettings, null, oSettings.aoFooter );
				for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
				{
					if ( anCells[i] )
					{
						oSettings.aoColumns[i].nTf = anCells[i];
						if ( oSettings.aoColumns[i].sClass )
						{
							$(anCells[i]).addClass( oSettings.aoColumns[i].sClass );
						}
					}
				}
			}
		}
		
		
		/**
		 * Draw the header (or footer) element based on the column visibility states. The
		 * methodology here is to use the layout array from _fnDetectHeader, modified for
		 * the instantaneous column visibility, to construct the new layout. The grid is
		 * traversed over cell at a time in a rows x columns grid fashion, although each 
		 * cell insert can cover multiple elements in the grid - which is tracks using the
		 * aApplied array. Cell inserts in the grid will only occur where there isn't
		 * already a cell in that position.
		 *  @param {object} oSettings dataTables settings object
		 *  @param array {objects} aoSource Layout array from _fnDetectHeader
		 *  @param {boolean} [bIncludeHidden=false] If true then include the hidden columns in the calc, 
		 *  @memberof DataTable#oApi
		 */
		function _fnDrawHead( oSettings, aoSource, bIncludeHidden )
		{
			var i, iLen, j, jLen, k, kLen, n, nLocalTr;
			var aoLocal = [];
			var aApplied = [];
			var iColumns = oSettings.aoColumns.length;
			var iRowspan, iColspan;
		
			if (  bIncludeHidden === undefined )
			{
				bIncludeHidden = false;
			}
		
			/* Make a copy of the master layout array, but without the visible columns in it */
			for ( i=0, iLen=aoSource.length ; i<iLen ; i++ )
			{
				aoLocal[i] = aoSource[i].slice();
				aoLocal[i].nTr = aoSource[i].nTr;
		
				/* Remove any columns which are currently hidden */
				for ( j=iColumns-1 ; j>=0 ; j-- )
				{
					if ( !oSettings.aoColumns[j].bVisible && !bIncludeHidden )
					{
						aoLocal[i].splice( j, 1 );
					}
				}
		
				/* Prep the applied array - it needs an element for each row */
				aApplied.push( [] );
			}
		
			for ( i=0, iLen=aoLocal.length ; i<iLen ; i++ )
			{
				nLocalTr = aoLocal[i].nTr;
				
				/* All cells are going to be replaced, so empty out the row */
				if ( nLocalTr )
				{
					while( (n = nLocalTr.firstChild) )
					{
						nLocalTr.removeChild( n );
					}
				}
		
				for ( j=0, jLen=aoLocal[i].length ; j<jLen ; j++ )
				{
					iRowspan = 1;
					iColspan = 1;
		
					/* Check to see if there is already a cell (row/colspan) covering our target
					 * insert point. If there is, then there is nothing to do.
					 */
					if ( aApplied[i][j] === undefined )
					{
						nLocalTr.appendChild( aoLocal[i][j].cell );
						aApplied[i][j] = 1;
		
						/* Expand the cell to cover as many rows as needed */
						while ( aoLocal[i+iRowspan] !== undefined &&
						        aoLocal[i][j].cell == aoLocal[i+iRowspan][j].cell )
						{
							aApplied[i+iRowspan][j] = 1;
							iRowspan++;
						}
		
						/* Expand the cell to cover as many columns as needed */
						while ( aoLocal[i][j+iColspan] !== undefined &&
						        aoLocal[i][j].cell == aoLocal[i][j+iColspan].cell )
						{
							/* Must update the applied array over the rows for the columns */
							for ( k=0 ; k<iRowspan ; k++ )
							{
								aApplied[i+k][j+iColspan] = 1;
							}
							iColspan++;
						}
		
						/* Do the actual expansion in the DOM */
						aoLocal[i][j].cell.rowSpan = iRowspan;
						aoLocal[i][j].cell.colSpan = iColspan;
					}
				}
			}
		}
		
		
		/**
		 * Insert the required TR nodes into the table for display
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnDraw( oSettings )
		{
			var i, iLen, n;
			var anRows = [];
			var iRowCount = 0;
			var iStripes = oSettings.asStripeClasses.length;
			var iOpenRows = oSettings.aoOpenRows.length;
			
			/* Provide a pre-callback function which can be used to cancel the draw is false is returned */
			var aPreDraw = _fnCallbackFire( oSettings, 'aoPreDrawCallback', 'preDraw', [oSettings] );
			if ( $.inArray( false, aPreDraw ) !== -1 )
			{
				return;
			}
			
			oSettings.bDrawing = true;
			
			/* Check and see if we have an initial draw position from state saving */
			if ( oSettings.iInitDisplayStart !== undefined && oSettings.iInitDisplayStart != -1 )
			{
				if ( oSettings.oFeatures.bServerSide )
				{
					oSettings._iDisplayStart = oSettings.iInitDisplayStart;
				}
				else
				{
					oSettings._iDisplayStart = (oSettings.iInitDisplayStart >= oSettings.fnRecordsDisplay()) ?
						0 : oSettings.iInitDisplayStart;
				}
				oSettings.iInitDisplayStart = -1;
				_fnCalculateEnd( oSettings );
			}
			
			/* Server-side processing draw intercept */
			if ( oSettings.bDeferLoading )
			{
				oSettings.bDeferLoading = false;
				oSettings.iDraw++;
			}
			else if ( !oSettings.oFeatures.bServerSide )
			{
				oSettings.iDraw++;
			}
			else if ( !oSettings.bDestroying && !_fnAjaxUpdate( oSettings ) )
			{
				return;
			}
			
			if ( oSettings.aiDisplay.length !== 0 )
			{
				var iStart = oSettings._iDisplayStart;
				var iEnd = oSettings._iDisplayEnd;
				
				if ( oSettings.oFeatures.bServerSide )
				{
					iStart = 0;
					iEnd = oSettings.aoData.length;
				}
				
				for ( var j=iStart ; j<iEnd ; j++ )
				{
					var aoData = oSettings.aoData[ oSettings.aiDisplay[j] ];
					if ( aoData.nTr === null )
					{
						_fnCreateTr( oSettings, oSettings.aiDisplay[j] );
					}
		
					var nRow = aoData.nTr;
					
					/* Remove the old striping classes and then add the new one */
					if ( iStripes !== 0 )
					{
						var sStripe = oSettings.asStripeClasses[ iRowCount % iStripes ];
						if ( aoData._sRowStripe != sStripe )
						{
							$(nRow).removeClass( aoData._sRowStripe ).addClass( sStripe );
							aoData._sRowStripe = sStripe;
						}
					}
					
					/* Row callback functions - might want to manipule the row */
					_fnCallbackFire( oSettings, 'aoRowCallback', null, 
						[nRow, oSettings.aoData[ oSettings.aiDisplay[j] ]._aData, iRowCount, j] );
					
					anRows.push( nRow );
					iRowCount++;
					
					/* If there is an open row - and it is attached to this parent - attach it on redraw */
					if ( iOpenRows !== 0 )
					{
						for ( var k=0 ; k<iOpenRows ; k++ )
						{
							if ( nRow == oSettings.aoOpenRows[k].nParent )
							{
								anRows.push( oSettings.aoOpenRows[k].nTr );
								break;
							}
						}
					}
				}
			}
			else
			{
				/* Table is empty - create a row with an empty message in it */
				anRows[ 0 ] = document.createElement( 'tr' );
				
				if ( oSettings.asStripeClasses[0] )
				{
					anRows[ 0 ].className = oSettings.asStripeClasses[0];
				}
		
				var sZero = oSettings.oLanguage.sZeroRecords.replace(
					'_MAX_', oSettings.fnFormatNumber(oSettings.fnRecordsTotal()) );
				if ( oSettings.iDraw == 1 && oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide )
				{
					sZero = oSettings.oLanguage.sLoadingRecords;
				}
				else if ( oSettings.oLanguage.sEmptyTable && oSettings.fnRecordsTotal() === 0 )
				{
					sZero = oSettings.oLanguage.sEmptyTable;
				}
		
				var nTd = document.createElement( 'td' );
				nTd.setAttribute( 'valign', "top" );
				nTd.colSpan = _fnVisbleColumns( oSettings );
				nTd.className = oSettings.oClasses.sRowEmpty;
				nTd.innerHTML = sZero;
				
				anRows[ iRowCount ].appendChild( nTd );
			}
			
			/* Header and footer callbacks */
			_fnCallbackFire( oSettings, 'aoHeaderCallback', 'header', [ $(oSettings.nTHead).children('tr')[0], 
				_fnGetDataMaster( oSettings ), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay ] );
			
			_fnCallbackFire( oSettings, 'aoFooterCallback', 'footer', [ $(oSettings.nTFoot).children('tr')[0], 
				_fnGetDataMaster( oSettings ), oSettings._iDisplayStart, oSettings.fnDisplayEnd(), oSettings.aiDisplay ] );
			
			/* 
			 * Need to remove any old row from the display - note we can't just empty the tbody using
			 * $().html('') since this will unbind the jQuery event handlers (even although the node 
			 * still exists!) - equally we can't use innerHTML, since IE throws an exception.
			 */
			var
				nAddFrag = document.createDocumentFragment(),
				nRemoveFrag = document.createDocumentFragment(),
				nBodyPar, nTrs;
			
			if ( oSettings.nTBody )
			{
				nBodyPar = oSettings.nTBody.parentNode;
				nRemoveFrag.appendChild( oSettings.nTBody );
				
				/* When doing infinite scrolling, only remove child rows when sorting, filtering or start
				 * up. When not infinite scroll, always do it.
				 */
				if ( !oSettings.oScroll.bInfinite || !oSettings._bInitComplete ||
				 	oSettings.bSorted || oSettings.bFiltered )
				{
					while( (n = oSettings.nTBody.firstChild) )
					{
						oSettings.nTBody.removeChild( n );
					}
				}
				
				/* Put the draw table into the dom */
				for ( i=0, iLen=anRows.length ; i<iLen ; i++ )
				{
					nAddFrag.appendChild( anRows[i] );
				}
				
				oSettings.nTBody.appendChild( nAddFrag );
				if ( nBodyPar !== null )
				{
					nBodyPar.appendChild( oSettings.nTBody );
				}
			}
			
			/* Call all required callback functions for the end of a draw */
			_fnCallbackFire( oSettings, 'aoDrawCallback', 'draw', [oSettings] );
			
			/* Draw is complete, sorting and filtering must be as well */
			oSettings.bSorted = false;
			oSettings.bFiltered = false;
			oSettings.bDrawing = false;
			
			if ( oSettings.oFeatures.bServerSide )
			{
				_fnProcessingDisplay( oSettings, false );
				if ( !oSettings._bInitComplete )
				{
					_fnInitComplete( oSettings );
				}
			}
		}
		
		
		/**
		 * Redraw the table - taking account of the various features which are enabled
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnReDraw( oSettings )
		{
			if ( oSettings.oFeatures.bSort )
			{
				/* Sorting will refilter and draw for us */
				_fnSort( oSettings, oSettings.oPreviousSearch );
			}
			else if ( oSettings.oFeatures.bFilter )
			{
				/* Filtering will redraw for us */
				_fnFilterComplete( oSettings, oSettings.oPreviousSearch );
			}
			else
			{
				_fnCalculateEnd( oSettings );
				_fnDraw( oSettings );
			}
		}
		
		
		/**
		 * Add the options to the page HTML for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnAddOptionsHtml ( oSettings )
		{
			/*
			 * Create a temporary, empty, div which we can later on replace with what we have generated
			 * we do it this way to rendering the 'options' html offline - speed :-)
			 */
			var nHolding = $('<div></div>')[0];
			oSettings.nTable.parentNode.insertBefore( nHolding, oSettings.nTable );
			
			/* 
			 * All DataTables are wrapped in a div
			 */
			oSettings.nTableWrapper = $('<div id="'+oSettings.sTableId+'_wrapper" class="'+oSettings.oClasses.sWrapper+'" role="grid"></div>')[0];
			oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
		
			/* Track where we want to insert the option */
			var nInsertNode = oSettings.nTableWrapper;
			
			/* Loop over the user set positioning and place the elements as needed */
			var aDom = oSettings.sDom.split('');
			var nTmp, iPushFeature, cOption, nNewNode, cNext, sAttr, j;
			for ( var i=0 ; i<aDom.length ; i++ )
			{
				iPushFeature = 0;
				cOption = aDom[i];
				
				if ( cOption == '<' )
				{
					/* New container div */
					nNewNode = $('<div></div>')[0];
					
					/* Check to see if we should append an id and/or a class name to the container */
					cNext = aDom[i+1];
					if ( cNext == "'" || cNext == '"' )
					{
						sAttr = "";
						j = 2;
						while ( aDom[i+j] != cNext )
						{
							sAttr += aDom[i+j];
							j++;
						}
						
						/* Replace jQuery UI constants */
						if ( sAttr == "H" )
						{
							sAttr = "fg-toolbar ui-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix";
						}
						else if ( sAttr == "F" )
						{
							sAttr = "fg-toolbar ui-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix";
						}
						
						/* The attribute can be in the format of "#id.class", "#id" or "class" This logic
						 * breaks the string into parts and applies them as needed
						 */
						if ( sAttr.indexOf('.') != -1 )
						{
							var aSplit = sAttr.split('.');
							nNewNode.id = aSplit[0].substr(1, aSplit[0].length-1);
							nNewNode.className = aSplit[1];
						}
						else if ( sAttr.charAt(0) == "#" )
						{
							nNewNode.id = sAttr.substr(1, sAttr.length-1);
						}
						else
						{
							nNewNode.className = sAttr;
						}
						
						i += j; /* Move along the position array */
					}
					
					nInsertNode.appendChild( nNewNode );
					nInsertNode = nNewNode;
				}
				else if ( cOption == '>' )
				{
					/* End container div */
					nInsertNode = nInsertNode.parentNode;
				}
				else if ( cOption == 'l' && oSettings.oFeatures.bPaginate && oSettings.oFeatures.bLengthChange )
				{
					/* Length */
					nTmp = _fnFeatureHtmlLength( oSettings );
					iPushFeature = 1;
				}
				else if ( cOption == 'f' && oSettings.oFeatures.bFilter )
				{
					/* Filter */
					nTmp = _fnFeatureHtmlFilter( oSettings );
					iPushFeature = 1;
				}
				else if ( cOption == 'r' && oSettings.oFeatures.bProcessing )
				{
					/* pRocessing */
					nTmp = _fnFeatureHtmlProcessing( oSettings );
					iPushFeature = 1;
				}
				else if ( cOption == 't' )
				{
					/* Table */
					nTmp = _fnFeatureHtmlTable( oSettings );
					iPushFeature = 1;
				}
				else if ( cOption ==  'i' && oSettings.oFeatures.bInfo )
				{
					/* Info */
					nTmp = _fnFeatureHtmlInfo( oSettings );
					iPushFeature = 1;
				}
				else if ( cOption == 'p' && oSettings.oFeatures.bPaginate )
				{
					/* Pagination */
					nTmp = _fnFeatureHtmlPaginate( oSettings );
					iPushFeature = 1;
				}
				else if ( DataTable.ext.aoFeatures.length !== 0 )
				{
					/* Plug-in features */
					var aoFeatures = DataTable.ext.aoFeatures;
					for ( var k=0, kLen=aoFeatures.length ; k<kLen ; k++ )
					{
						if ( cOption == aoFeatures[k].cFeature )
						{
							nTmp = aoFeatures[k].fnInit( oSettings );
							if ( nTmp )
							{
								iPushFeature = 1;
							}
							break;
						}
					}
				}
				
				/* Add to the 2D features array */
				if ( iPushFeature == 1 && nTmp !== null )
				{
					if ( typeof oSettings.aanFeatures[cOption] !== 'object' )
					{
						oSettings.aanFeatures[cOption] = [];
					}
					oSettings.aanFeatures[cOption].push( nTmp );
					nInsertNode.appendChild( nTmp );
				}
			}
			
			/* Built our DOM structure - replace the holding div with what we want */
			nHolding.parentNode.replaceChild( oSettings.nTableWrapper, nHolding );
		}
		
		
		/**
		 * Use the DOM source to create up an array of header cells. The idea here is to
		 * create a layout grid (array) of rows x columns, which contains a reference
		 * to the cell that that point in the grid (regardless of col/rowspan), such that
		 * any column / row could be removed and the new grid constructed
		 *  @param array {object} aLayout Array to store the calculated layout in
		 *  @param {node} nThead The header/footer element for the table
		 *  @memberof DataTable#oApi
		 */
		function _fnDetectHeader ( aLayout, nThead )
		{
			var nTrs = $(nThead).children('tr');
			var nCell;
			var i, j, k, l, iLen, jLen, iColShifted;
			var fnShiftCol = function ( a, i, j ) {
				while ( a[i][j] ) {
					j++;
				}
				return j;
			};
		
			aLayout.splice( 0, aLayout.length );
			
			/* We know how many rows there are in the layout - so prep it */
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				aLayout.push( [] );
			}
			
			/* Calculate a layout array */
			for ( i=0, iLen=nTrs.length ; i<iLen ; i++ )
			{
				var iColumn = 0;
				
				/* For every cell in the row... */
				for ( j=0, jLen=nTrs[i].childNodes.length ; j<jLen ; j++ )
				{
					nCell = nTrs[i].childNodes[j];
		
					if ( nCell.nodeName.toUpperCase() == "TD" ||
					     nCell.nodeName.toUpperCase() == "TH" )
					{
						/* Get the col and rowspan attributes from the DOM and sanitise them */
						var iColspan = nCell.getAttribute('colspan') * 1;
						var iRowspan = nCell.getAttribute('rowspan') * 1;
						iColspan = (!iColspan || iColspan===0 || iColspan===1) ? 1 : iColspan;
						iRowspan = (!iRowspan || iRowspan===0 || iRowspan===1) ? 1 : iRowspan;
		
						/* There might be colspan cells already in this row, so shift our target 
						 * accordingly
						 */
						iColShifted = fnShiftCol( aLayout, i, iColumn );
						
						/* If there is col / rowspan, copy the information into the layout grid */
						for ( l=0 ; l<iColspan ; l++ )
						{
							for ( k=0 ; k<iRowspan ; k++ )
							{
								aLayout[i+k][iColShifted+l] = {
									"cell": nCell,
									"unique": iColspan == 1 ? true : false
								};
								aLayout[i+k].nTr = nTrs[i];
							}
						}
					}
				}
			}
		}
		
		
		/**
		 * Get an array of unique th elements, one for each column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nHeader automatically detect the layout from this node - optional
		 *  @param {array} aLayout thead/tfoot layout from _fnDetectHeader - optional
		 *  @returns array {node} aReturn list of unique ths
		 *  @memberof DataTable#oApi
		 */
		function _fnGetUniqueThs ( oSettings, nHeader, aLayout )
		{
			var aReturn = [];
			if ( !aLayout )
			{
				aLayout = oSettings.aoHeader;
				if ( nHeader )
				{
					aLayout = [];
					_fnDetectHeader( aLayout, nHeader );
				}
			}
		
			for ( var i=0, iLen=aLayout.length ; i<iLen ; i++ )
			{
				for ( var j=0, jLen=aLayout[i].length ; j<jLen ; j++ )
				{
					if ( aLayout[i][j].unique && 
						 (!aReturn[j] || !oSettings.bSortCellsTop) )
					{
						aReturn[j] = aLayout[i][j].cell;
					}
				}
			}
			
			return aReturn;
		}
		
		
		
		/**
		 * Update the table using an Ajax call
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {boolean} Block the table drawing or not
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxUpdate( oSettings )
		{
			if ( oSettings.bAjaxDataGet )
			{
				oSettings.iDraw++;
				_fnProcessingDisplay( oSettings, true );
				var iColumns = oSettings.aoColumns.length;
				var aoData = _fnAjaxParameters( oSettings );
				_fnServerParams( oSettings, aoData );
				
				oSettings.fnServerData.call( oSettings.oInstance, oSettings.sAjaxSource, aoData,
					function(json) {
						_fnAjaxUpdateDraw( oSettings, json );
					}, oSettings );
				return false;
			}
			else
			{
				return true;
			}
		}
		
		
		/**
		 * Build up the parameters in an object needed for a server-side processing request
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {bool} block the table drawing or not
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxParameters( oSettings )
		{
			var iColumns = oSettings.aoColumns.length;
			var aoData = [], mDataProp;
			var i;
			
			aoData.push( { "name": "sEcho",          "value": oSettings.iDraw } );
			aoData.push( { "name": "iColumns",       "value": iColumns } );
			aoData.push( { "name": "sColumns",       "value": _fnColumnOrdering(oSettings) } );
			aoData.push( { "name": "iDisplayStart",  "value": oSettings._iDisplayStart } );
			aoData.push( { "name": "iDisplayLength", "value": oSettings.oFeatures.bPaginate !== false ?
				oSettings._iDisplayLength : -1 } );
				
			for ( i=0 ; i<iColumns ; i++ )
			{
			  mDataProp = oSettings.aoColumns[i].mDataProp;
				aoData.push( { "name": "mDataProp_"+i, "value": typeof(mDataProp)==="function" ? 'function' : mDataProp } );
			}
			
			/* Filtering */
			if ( oSettings.oFeatures.bFilter !== false )
			{
				aoData.push( { "name": "sSearch", "value": oSettings.oPreviousSearch.sSearch } );
				aoData.push( { "name": "bRegex",  "value": oSettings.oPreviousSearch.bRegex } );
				for ( i=0 ; i<iColumns ; i++ )
				{
					aoData.push( { "name": "sSearch_"+i,     "value": oSettings.aoPreSearchCols[i].sSearch } );
					aoData.push( { "name": "bRegex_"+i,      "value": oSettings.aoPreSearchCols[i].bRegex } );
					aoData.push( { "name": "bSearchable_"+i, "value": oSettings.aoColumns[i].bSearchable } );
				}
			}
			
			/* Sorting */
			if ( oSettings.oFeatures.bSort !== false )
			{
				var iFixed = oSettings.aaSortingFixed !== null ? oSettings.aaSortingFixed.length : 0;
				var iUser = oSettings.aaSorting.length;
				aoData.push( { "name": "iSortingCols",   "value": iFixed+iUser } );
				for ( i=0 ; i<iFixed ; i++ )
				{
					aoData.push( { "name": "iSortCol_"+i,  "value": oSettings.aaSortingFixed[i][0] } );
					aoData.push( { "name": "sSortDir_"+i,  "value": oSettings.aaSortingFixed[i][1] } );
				}
				
				for ( i=0 ; i<iUser ; i++ )
				{
					aoData.push( { "name": "iSortCol_"+(i+iFixed),  "value": oSettings.aaSorting[i][0] } );
					aoData.push( { "name": "sSortDir_"+(i+iFixed),  "value": oSettings.aaSorting[i][1] } );
				}
				
				for ( i=0 ; i<iColumns ; i++ )
				{
					aoData.push( { "name": "bSortable_"+i,  "value": oSettings.aoColumns[i].bSortable } );
				}
			}
			
			return aoData;
		}
		
		
		/**
		 * Add Ajax parameters from plugins
		 *  @param {object} oSettings dataTables settings object
		 *  @param array {objects} aoData name/value pairs to send to the server
		 *  @memberof DataTable#oApi
		 */
		function _fnServerParams( oSettings, aoData )
		{
			_fnCallbackFire( oSettings, 'aoServerParams', 'serverParams', [aoData] );
		}
		
		
		/**
		 * Data the data from the server (nuking the old) and redraw the table
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} json json data return from the server.
		 *  @param {string} json.sEcho Tracking flag for DataTables to match requests
		 *  @param {int} json.iTotalRecords Number of records in the data set, not accounting for filtering
		 *  @param {int} json.iTotalDisplayRecords Number of records in the data set, accounting for filtering
		 *  @param {array} json.aaData The data to display on this page
		 *  @param {string} [json.sColumns] Column ordering (sName, comma separated)
		 *  @memberof DataTable#oApi
		 */
		function _fnAjaxUpdateDraw ( oSettings, json )
		{
			if ( json.sEcho !== undefined )
			{
				/* Protect against old returns over-writing a new one. Possible when you get
				 * very fast interaction, and later queires are completed much faster
				 */
				if ( json.sEcho*1 < oSettings.iDraw )
				{
					return;
				}
				else
				{
					oSettings.iDraw = json.sEcho * 1;
				}
			}
			
			if ( !oSettings.oScroll.bInfinite ||
				   (oSettings.oScroll.bInfinite && (oSettings.bSorted || oSettings.bFiltered)) )
			{
				_fnClearTable( oSettings );
			}
			oSettings._iRecordsTotal = parseInt(json.iTotalRecords, 10);
			oSettings._iRecordsDisplay = parseInt(json.iTotalDisplayRecords, 10);
			
			/* Determine if reordering is required */
			var sOrdering = _fnColumnOrdering(oSettings);
			var bReOrder = (json.sColumns !== undefined && sOrdering !== "" && json.sColumns != sOrdering );
			var aiIndex;
			if ( bReOrder )
			{
				aiIndex = _fnReOrderIndex( oSettings, json.sColumns );
			}
			
			var aData = _fnGetObjectDataFn( oSettings.sAjaxDataProp )( json );
			for ( var i=0, iLen=aData.length ; i<iLen ; i++ )
			{
				if ( bReOrder )
				{
					/* If we need to re-order, then create a new array with the correct order and add it */
					var aDataSorted = [];
					for ( var j=0, jLen=oSettings.aoColumns.length ; j<jLen ; j++ )
					{
						aDataSorted.push( aData[i][ aiIndex[j] ] );
					}
					_fnAddData( oSettings, aDataSorted );
				}
				else
				{
					/* No re-order required, sever got it "right" - just straight add */
					_fnAddData( oSettings, aData[i] );
				}
			}
			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
			oSettings.bAjaxDataGet = false;
			_fnDraw( oSettings );
			oSettings.bAjaxDataGet = true;
			_fnProcessingDisplay( oSettings, false );
		}
		
		
		
		/**
		 * Generate the node required for filtering text
		 *  @returns {node} Filter control element
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlFilter ( oSettings )
		{
			var oPreviousSearch = oSettings.oPreviousSearch;
			
			var sSearchStr = oSettings.oLanguage.sSearch;
			sSearchStr = (sSearchStr.indexOf('_INPUT_') !== -1) ?
			  sSearchStr.replace('_INPUT_', '<input type="text" />') :
			  sSearchStr==="" ? '<input type="text" />' : sSearchStr+' <input type="text" />';
			
			var nFilter = document.createElement( 'div' );
			nFilter.className = oSettings.oClasses.sFilter;
			nFilter.innerHTML = '<label>'+sSearchStr+'</label>';
			if ( !oSettings.aanFeatures.f )
			{
				nFilter.id = oSettings.sTableId+'_filter';
			}
			
			var jqFilter = $("input", nFilter);
			jqFilter.val( oPreviousSearch.sSearch.replace('"','&quot;') );
			jqFilter.bind( 'keyup.DT', function(e) {
				/* Update all other filter input elements for the new display */
				var n = oSettings.aanFeatures.f;
				for ( var i=0, iLen=n.length ; i<iLen ; i++ )
				{
					if ( n[i] != $(this).parents('div.dataTables_filter')[0] )
					{
						$('input', n[i]).val( this.value );
					}
				}
				
				/* Now do the filter */
				if ( this.value != oPreviousSearch.sSearch )
				{
					_fnFilterComplete( oSettings, { 
						"sSearch": this.value, 
						"bRegex": oPreviousSearch.bRegex,
						"bSmart": oPreviousSearch.bSmart ,
						"bCaseInsensitive": oPreviousSearch.bCaseInsensitive 
					} );
				}
			} );
		
			jqFilter
				.attr('aria-controls', oSettings.sTableId)
				.bind( 'keypress.DT', function(e) {
					/* Prevent form submission */
					if ( e.keyCode == 13 )
					{
						return false;
					}
				}
			);
			
			return nFilter;
		}
		
		
		/**
		 * Filter the table using both the global filter and column based filtering
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} oSearch search information
		 *  @param {int} [iForce] force a research of the master array (1) or not (undefined or 0)
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterComplete ( oSettings, oInput, iForce )
		{
			var oPrevSearch = oSettings.oPreviousSearch;
			var aoPrevSearch = oSettings.aoPreSearchCols;
			var fnSaveFilter = function ( oFilter ) {
				/* Save the filtering values */
				oPrevSearch.sSearch = oFilter.sSearch;
				oPrevSearch.bRegex = oFilter.bRegex;
				oPrevSearch.bSmart = oFilter.bSmart;
				oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive;
			};
		
			/* In server-side processing all filtering is done by the server, so no point hanging around here */
			if ( !oSettings.oFeatures.bServerSide )
			{
				/* Global filter */
				_fnFilter( oSettings, oInput.sSearch, iForce, oInput.bRegex, oInput.bSmart, oInput.bCaseInsensitive );
				fnSaveFilter( oInput );
		
				/* Now do the individual column filter */
				for ( var i=0 ; i<oSettings.aoPreSearchCols.length ; i++ )
				{
					_fnFilterColumn( oSettings, aoPrevSearch[i].sSearch, i, aoPrevSearch[i].bRegex, 
						aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive );
				}
				
				/* Custom filtering */
				_fnFilterCustom( oSettings );
			}
			else
			{
				fnSaveFilter( oInput );
			}
			
			/* Tell the draw function we have been filtering */
			oSettings.bFiltered = true;
			$(oSettings.oInstance).trigger('filter', oSettings);
			
			/* Redraw the table */
			oSettings._iDisplayStart = 0;
			_fnCalculateEnd( oSettings );
			_fnDraw( oSettings );
			
			/* Rebuild search array 'offline' */
			_fnBuildSearchArray( oSettings, 0 );
		}
		
		
		/**
		 * Apply custom filtering functions
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterCustom( oSettings )
		{
			var afnFilters = DataTable.ext.afnFiltering;
			for ( var i=0, iLen=afnFilters.length ; i<iLen ; i++ )
			{
				var iCorrector = 0;
				for ( var j=0, jLen=oSettings.aiDisplay.length ; j<jLen ; j++ )
				{
					var iDisIndex = oSettings.aiDisplay[j-iCorrector];
					
					/* Check if we should use this row based on the filtering function */
					if ( !afnFilters[i]( oSettings, _fnGetRowData( oSettings, iDisIndex, 'filter' ), iDisIndex ) )
					{
						oSettings.aiDisplay.splice( j-iCorrector, 1 );
						iCorrector++;
					}
				}
			}
		}
		
		
		/**
		 * Filter the table on a per-column basis
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sInput string to filter on
		 *  @param {int} iColumn column to filter
		 *  @param {bool} bRegex treat search string as a regular expression or not
		 *  @param {bool} bSmart use smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterColumn ( oSettings, sInput, iColumn, bRegex, bSmart, bCaseInsensitive )
		{
			if ( sInput === "" )
			{
				return;
			}
			
			var iIndexCorrector = 0;
			var rpSearch = _fnFilterCreateSearch( sInput, bRegex, bSmart, bCaseInsensitive );
			
			for ( var i=oSettings.aiDisplay.length-1 ; i>=0 ; i-- )
			{
				var sData = _fnDataToSearch( _fnGetCellData( oSettings, oSettings.aiDisplay[i], iColumn, 'filter' ),
					oSettings.aoColumns[iColumn].sType );
				if ( ! rpSearch.test( sData ) )
				{
					oSettings.aiDisplay.splice( i, 1 );
					iIndexCorrector++;
				}
			}
		}
		
		
		/**
		 * Filter the data table based on user input and draw the table
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sInput string to filter on
		 *  @param {int} iForce optional - force a research of the master array (1) or not (undefined or 0)
		 *  @param {bool} bRegex treat as a regular expression or not
		 *  @param {bool} bSmart perform smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
		 *  @memberof DataTable#oApi
		 */
		function _fnFilter( oSettings, sInput, iForce, bRegex, bSmart, bCaseInsensitive )
		{
			var i;
			var rpSearch = _fnFilterCreateSearch( sInput, bRegex, bSmart, bCaseInsensitive );
			var oPrevSearch = oSettings.oPreviousSearch;
			
			/* Check if we are forcing or not - optional parameter */
			if ( !iForce )
			{
				iForce = 0;
			}
			
			/* Need to take account of custom filtering functions - always filter */
			if ( DataTable.ext.afnFiltering.length !== 0 )
			{
				iForce = 1;
			}
			
			/*
			 * If the input is blank - we want the full data set
			 */
			if ( sInput.length <= 0 )
			{
				oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length);
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			}
			else
			{
				/*
				 * We are starting a new search or the new search string is smaller 
				 * then the old one (i.e. delete). Search from the master array
			 	 */
				if ( oSettings.aiDisplay.length == oSettings.aiDisplayMaster.length ||
					   oPrevSearch.sSearch.length > sInput.length || iForce == 1 ||
					   sInput.indexOf(oPrevSearch.sSearch) !== 0 )
				{
					/* Nuke the old display array - we are going to rebuild it */
					oSettings.aiDisplay.splice( 0, oSettings.aiDisplay.length);
					
					/* Force a rebuild of the search array */
					_fnBuildSearchArray( oSettings, 1 );
					
					/* Search through all records to populate the search array
					 * The the oSettings.aiDisplayMaster and asDataSearch arrays have 1 to 1 
					 * mapping
					 */
					for ( i=0 ; i<oSettings.aiDisplayMaster.length ; i++ )
					{
						if ( rpSearch.test(oSettings.asDataSearch[i]) )
						{
							oSettings.aiDisplay.push( oSettings.aiDisplayMaster[i] );
						}
					}
			  }
			  else
				{
			  	/* Using old search array - refine it - do it this way for speed
			  	 * Don't have to search the whole master array again
					 */
			  	var iIndexCorrector = 0;
			  	
			  	/* Search the current results */
			  	for ( i=0 ; i<oSettings.asDataSearch.length ; i++ )
					{
			  		if ( ! rpSearch.test(oSettings.asDataSearch[i]) )
						{
			  			oSettings.aiDisplay.splice( i-iIndexCorrector, 1 );
			  			iIndexCorrector++;
			  		}
			  	}
			  }
			}
		}
		
		
		/**
		 * Create an array which can be quickly search through
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iMaster use the master data array - optional
		 *  @memberof DataTable#oApi
		 */
		function _fnBuildSearchArray ( oSettings, iMaster )
		{
			if ( !oSettings.oFeatures.bServerSide )
			{
				/* Clear out the old data */
				oSettings.asDataSearch.splice( 0, oSettings.asDataSearch.length );
				
				var aArray = (iMaster && iMaster===1) ?
				 	oSettings.aiDisplayMaster : oSettings.aiDisplay;
				
				for ( var i=0, iLen=aArray.length ; i<iLen ; i++ )
				{
					oSettings.asDataSearch[i] = _fnBuildSearchRow( oSettings,
						_fnGetRowData( oSettings, aArray[i], 'filter' ) );
				}
			}
		}
		
		
		/**
		 * Create a searchable string from a single data row
		 *  @param {object} oSettings dataTables settings object
		 *  @param {array} aData Row data array to use for the data to search
		 *  @memberof DataTable#oApi
		 */
		function _fnBuildSearchRow( oSettings, aData )
		{
			var sSearch = '';
			if ( oSettings.__nTmpFilter === undefined )
			{
				oSettings.__nTmpFilter = document.createElement('div');
			}
			var nTmp = oSettings.__nTmpFilter;
			
			for ( var j=0, jLen=oSettings.aoColumns.length ; j<jLen ; j++ )
			{
				if ( oSettings.aoColumns[j].bSearchable )
				{
					var sData = aData[j];
					sSearch += _fnDataToSearch( sData, oSettings.aoColumns[j].sType )+'  ';
				}
			}
			
			/* If it looks like there is an HTML entity in the string, attempt to decode it */
			if ( sSearch.indexOf('&') !== -1 )
			{
				nTmp.innerHTML = sSearch;
				sSearch = nTmp.textContent ? nTmp.textContent : nTmp.innerText;
				
				/* IE and Opera appear to put an newline where there is a <br> tag - remove it */
				sSearch = sSearch.replace(/\n/g," ").replace(/\r/g,"");
			}
			
			return sSearch;
		}
		
		/**
		 * Build a regular expression object suitable for searching a table
		 *  @param {string} sSearch string to search for
		 *  @param {bool} bRegex treat as a regular expression or not
		 *  @param {bool} bSmart perform smart filtering or not
		 *  @param {bool} bCaseInsensitive Do case insenstive matching or not
		 *  @returns {RegExp} constructed object
		 *  @memberof DataTable#oApi
		 */
		function _fnFilterCreateSearch( sSearch, bRegex, bSmart, bCaseInsensitive )
		{
			var asSearch, sRegExpString;
			
			if ( bSmart )
			{
				/* Generate the regular expression to use. Something along the lines of:
				 * ^(?=.*?\bone\b)(?=.*?\btwo\b)(?=.*?\bthree\b).*$
				 */
				asSearch = bRegex ? sSearch.split( ' ' ) : _fnEscapeRegex( sSearch ).split( ' ' );
				sRegExpString = '^(?=.*?'+asSearch.join( ')(?=.*?' )+').*$';
				return new RegExp( sRegExpString, bCaseInsensitive ? "i" : "" );
			}
			else
			{
				sSearch = bRegex ? sSearch : _fnEscapeRegex( sSearch );
				return new RegExp( sSearch, bCaseInsensitive ? "i" : "" );
			}
		}
		
		
		/**
		 * Convert raw data into something that the user can search on
		 *  @param {string} sData data to be modified
		 *  @param {string} sType data type
		 *  @returns {string} search string
		 *  @memberof DataTable#oApi
		 */
		function _fnDataToSearch ( sData, sType )
		{
			if ( typeof DataTable.ext.ofnSearch[sType] === "function" )
			{
				return DataTable.ext.ofnSearch[sType]( sData );
			}
			else if ( sType == "html" )
			{
				return sData.replace(/[\r\n]/g," ").replace( /<.*?>/g, "" );
			}
			else if ( typeof sData === "string" )
			{
				return sData.replace(/[\r\n]/g," ");
			}
			else if ( sData === null )
			{
				return '';
			}
			return sData;
		}
		
		
		/**
		 * scape a string stuch that it can be used in a regular expression
		 *  @param {string} sVal string to escape
		 *  @returns {string} escaped string
		 *  @memberof DataTable#oApi
		 */
		function _fnEscapeRegex ( sVal )
		{
			var acEscape = [ '/', '.', '*', '+', '?', '|', '(', ')', '[', ']', '{', '}', '\\', '$', '^' ];
			var reReplace = new RegExp( '(\\' + acEscape.join('|\\') + ')', 'g' );
			return sVal.replace(reReplace, '\\$1');
		}
		
		
		
		/**
		 * Generate the node required for the info display
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Information element
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlInfo ( oSettings )
		{
			var nInfo = document.createElement( 'div' );
			nInfo.className = oSettings.oClasses.sInfo;
			
			/* Actions that are to be taken once only for this feature */
			if ( !oSettings.aanFeatures.i )
			{
				/* Add draw callback */
				oSettings.aoDrawCallback.push( {
					"fn": _fnUpdateInfo,
					"sName": "information"
				} );
				
				/* Add id */
				nInfo.id = oSettings.sTableId+'_info';
			}
			oSettings.nTable.setAttribute( 'aria-describedby', oSettings.sTableId+'_info' );
			
			return nInfo;
		}
		
		
		/**
		 * Update the information elements in the display
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnUpdateInfo ( oSettings )
		{
			/* Show information about the table */
			if ( !oSettings.oFeatures.bInfo || oSettings.aanFeatures.i.length === 0 )
			{
				return;
			}
			
			var
				iStart = oSettings._iDisplayStart+1, iEnd = oSettings.fnDisplayEnd(),
				iMax = oSettings.fnRecordsTotal(), iTotal = oSettings.fnRecordsDisplay(),
				sStart = oSettings.fnFormatNumber( iStart ), sEnd = oSettings.fnFormatNumber( iEnd ),
				sMax = oSettings.fnFormatNumber( iMax ), sTotal = oSettings.fnFormatNumber( iTotal ),
				sOut;
			
			/* When infinite scrolling, we are always starting at 1. _iDisplayStart is used only
			 * internally
			 */
			if ( oSettings.oScroll.bInfinite )
			{
				sStart = oSettings.fnFormatNumber( 1 );
			}
			
			if ( oSettings.fnRecordsDisplay() === 0 && 
				   oSettings.fnRecordsDisplay() == oSettings.fnRecordsTotal() )
			{
				/* Empty record set */
				sOut = oSettings.oLanguage.sInfoEmpty+ oSettings.oLanguage.sInfoPostFix;
			}
			else if ( oSettings.fnRecordsDisplay() === 0 )
			{
				/* Rmpty record set after filtering */
				sOut = oSettings.oLanguage.sInfoEmpty +' '+ 
					oSettings.oLanguage.sInfoFiltered.replace('_MAX_', sMax)+
						oSettings.oLanguage.sInfoPostFix;
			}
			else if ( oSettings.fnRecordsDisplay() == oSettings.fnRecordsTotal() )
			{
				/* Normal record set */
				sOut = oSettings.oLanguage.sInfo.
						replace('_START_', sStart).
						replace('_END_',   sEnd).
						replace('_TOTAL_', sTotal)+ 
					oSettings.oLanguage.sInfoPostFix;
			}
			else
			{
				/* Record set after filtering */
				sOut = oSettings.oLanguage.sInfo.
						replace('_START_', sStart).
						replace('_END_',   sEnd).
						replace('_TOTAL_', sTotal) +' '+ 
					oSettings.oLanguage.sInfoFiltered.replace('_MAX_', 
						oSettings.fnFormatNumber(oSettings.fnRecordsTotal()))+ 
					oSettings.oLanguage.sInfoPostFix;
			}
			
			if ( oSettings.oLanguage.fnInfoCallback !== null )
			{
				sOut = oSettings.oLanguage.fnInfoCallback.call( oSettings.oInstance, 
					oSettings, iStart, iEnd, iMax, iTotal, sOut );
			}
			
			var n = oSettings.aanFeatures.i;
			for ( var i=0, iLen=n.length ; i<iLen ; i++ )
			{
				$(n[i]).html( sOut );
			}
		}
		
		
		
		/**
		 * Draw the table for the first time, adding all required features
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnInitialise ( oSettings )
		{
			var i, iLen, iAjaxStart=oSettings.iInitDisplayStart;
			
			/* Ensure that the table data is fully initialised */
			if ( oSettings.bInitialised === false )
			{
				setTimeout( function(){ _fnInitialise( oSettings ); }, 200 );
				return;
			}
			
			/* Show the display HTML options */
			_fnAddOptionsHtml( oSettings );
			
			/* Build and draw the header / footer for the table */
			_fnBuildHead( oSettings );
			_fnDrawHead( oSettings, oSettings.aoHeader );
			if ( oSettings.nTFoot )
			{
				_fnDrawHead( oSettings, oSettings.aoFooter );
			}
		
			/* Okay to show that something is going on now */
			_fnProcessingDisplay( oSettings, true );
			
			/* Calculate sizes for columns */
			if ( oSettings.oFeatures.bAutoWidth )
			{
				_fnCalculateColumnWidths( oSettings );
			}
			
			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				if ( oSettings.aoColumns[i].sWidth !== null )
				{
					oSettings.aoColumns[i].nTh.style.width = _fnStringToCss( oSettings.aoColumns[i].sWidth );
				}
			}
			
			/* If there is default sorting required - let's do it. The sort function will do the
			 * drawing for us. Otherwise we draw the table regardless of the Ajax source - this allows
			 * the table to look initialised for Ajax sourcing data (show 'loading' message possibly)
			 */
			if ( oSettings.oFeatures.bSort )
			{
				_fnSort( oSettings );
			}
			else if ( oSettings.oFeatures.bFilter )
			{
				_fnFilterComplete( oSettings, oSettings.oPreviousSearch );
			}
			else
			{
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
				_fnCalculateEnd( oSettings );
				_fnDraw( oSettings );
			}
			
			/* if there is an ajax source load the data */
			if ( oSettings.sAjaxSource !== null && !oSettings.oFeatures.bServerSide )
			{
				var aoData = [];
				_fnServerParams( oSettings, aoData );
				oSettings.fnServerData.call( oSettings.oInstance, oSettings.sAjaxSource, aoData, function(json) {
					var aData = (oSettings.sAjaxDataProp !== "") ?
					 	_fnGetObjectDataFn( oSettings.sAjaxDataProp )(json) : json;
		
					/* Got the data - add it to the table */
					for ( i=0 ; i<aData.length ; i++ )
					{
						_fnAddData( oSettings, aData[i] );
					}
					
					/* Reset the init display for cookie saving. We've already done a filter, and
					 * therefore cleared it before. So we need to make it appear 'fresh'
					 */
					oSettings.iInitDisplayStart = iAjaxStart;
					
					if ( oSettings.oFeatures.bSort )
					{
						_fnSort( oSettings );
					}
					else
					{
						oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
						_fnCalculateEnd( oSettings );
						_fnDraw( oSettings );
					}
					
					_fnProcessingDisplay( oSettings, false );
					_fnInitComplete( oSettings, json );
				}, oSettings );
				return;
			}
			
			/* Server-side processing initialisation complete is done at the end of _fnDraw */
			if ( !oSettings.oFeatures.bServerSide )
			{
				_fnProcessingDisplay( oSettings, false );
				_fnInitComplete( oSettings );
			}
		}
		
		
		/**
		 * Draw the table for the first time, adding all required features
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} [json] JSON from the server that completed the table, if using Ajax source
		 *    with client-side processing (optional)
		 *  @memberof DataTable#oApi
		 */
		function _fnInitComplete ( oSettings, json )
		{
			oSettings._bInitComplete = true;
			_fnCallbackFire( oSettings, 'aoInitComplete', 'init', [oSettings, json] );
		}
		
		
		/**
		 * Language compatibility - when certain options are given, and others aren't, we
		 * need to duplicate the values over, in order to provide backwards compatibility
		 * with older language files.
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnLanguageCompat( oLanguage )
		{
			/* Backwards compatibility - if there is no sEmptyTable given, then use the same as
			 * sZeroRecords - assuming that is given.
			 */
			if ( !oLanguage.sEmptyTable && oLanguage.sZeroRecords )
			{
				_fnMap( oLanguage, oLanguage, 'sZeroRecords', 'sEmptyTable' );
			}
		
			/* Likewise with loading records */
			if ( !oLanguage.sLoadingRecords && oLanguage.sZeroRecords )
			{
				_fnMap( oLanguage, oLanguage, 'sZeroRecords', 'sLoadingRecords' );
			}
		}
		
		
		
		/**
		 * Generate the node required for user display length changing
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Display length feature node
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlLength ( oSettings )
		{
			if ( oSettings.oScroll.bInfinite )
			{
				return null;
			}
			
			/* This can be overruled by not using the _MENU_ var/macro in the language variable */
			var sName = 'name="'+oSettings.sTableId+'_length"';
			var sStdMenu = '<select size="1" '+sName+'>';
			var i, iLen;
			var aLengthMenu = oSettings.aLengthMenu;
			
			if ( aLengthMenu.length == 2 && typeof aLengthMenu[0] === 'object' && 
					typeof aLengthMenu[1] === 'object' )
			{
				for ( i=0, iLen=aLengthMenu[0].length ; i<iLen ; i++ )
				{
					sStdMenu += '<option value="'+aLengthMenu[0][i]+'">'+aLengthMenu[1][i]+'</option>';
				}
			}
			else
			{
				for ( i=0, iLen=aLengthMenu.length ; i<iLen ; i++ )
				{
					sStdMenu += '<option value="'+aLengthMenu[i]+'">'+aLengthMenu[i]+'</option>';
				}
			}
			sStdMenu += '</select>';
			
			var nLength = document.createElement( 'div' );
			if ( !oSettings.aanFeatures.l )
			{
				nLength.id = oSettings.sTableId+'_length';
			}
			nLength.className = oSettings.oClasses.sLength;
			nLength.innerHTML = '<label>'+oSettings.oLanguage.sLengthMenu.replace( '_MENU_', sStdMenu )+'</label>';
			
			/*
			 * Set the length to the current display length - thanks to Andrea Pavlovic for this fix,
			 * and Stefan Skopnik for fixing the fix!
			 */
			$('select option[value="'+oSettings._iDisplayLength+'"]', nLength).attr("selected", true);
			
			$('select', nLength).bind( 'change.DT', function(e) {
				var iVal = $(this).val();
				
				/* Update all other length options for the new display */
				var n = oSettings.aanFeatures.l;
				for ( i=0, iLen=n.length ; i<iLen ; i++ )
				{
					if ( n[i] != this.parentNode )
					{
						$('select', n[i]).val( iVal );
					}
				}
				
				/* Redraw the table */
				oSettings._iDisplayLength = parseInt(iVal, 10);
				_fnCalculateEnd( oSettings );
				
				/* If we have space to show extra rows (backing up from the end point - then do so */
				if ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() )
				{
					oSettings._iDisplayStart = oSettings.fnDisplayEnd() - oSettings._iDisplayLength;
					if ( oSettings._iDisplayStart < 0 )
					{
						oSettings._iDisplayStart = 0;
					}
				}
				
				if ( oSettings._iDisplayLength == -1 )
				{
					oSettings._iDisplayStart = 0;
				}
				
				_fnDraw( oSettings );
			} );
		
		
			$('select', nLength).attr('aria-controls', oSettings.sTableId);
			
			return nLength;
		}
		
		
		/**
		 * Rcalculate the end point based on the start point
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnCalculateEnd( oSettings )
		{
			if ( oSettings.oFeatures.bPaginate === false )
			{
				oSettings._iDisplayEnd = oSettings.aiDisplay.length;
			}
			else
			{
				/* Set the end point of the display - based on how many elements there are
				 * still to display
				 */
				if ( oSettings._iDisplayStart + oSettings._iDisplayLength > oSettings.aiDisplay.length ||
					   oSettings._iDisplayLength == -1 )
				{
					oSettings._iDisplayEnd = oSettings.aiDisplay.length;
				}
				else
				{
					oSettings._iDisplayEnd = oSettings._iDisplayStart + oSettings._iDisplayLength;
				}
			}
		}
		
		
		
		/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
		 * Note that most of the paging logic is done in 
		 * DataTable.ext.oPagination
		 */
		
		/**
		 * Generate the node required for default pagination
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Pagination feature node
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlPaginate ( oSettings )
		{
			if ( oSettings.oScroll.bInfinite )
			{
				return null;
			}
			
			var nPaginate = document.createElement( 'div' );
			nPaginate.className = oSettings.oClasses.sPaging+oSettings.sPaginationType;
			
			DataTable.ext.oPagination[ oSettings.sPaginationType ].fnInit( oSettings, nPaginate, 
				function( oSettings ) {
					_fnCalculateEnd( oSettings );
					_fnDraw( oSettings );
				}
			);
			
			/* Add a draw callback for the pagination on first instance, to update the paging display */
			if ( !oSettings.aanFeatures.p )
			{
				oSettings.aoDrawCallback.push( {
					"fn": function( oSettings ) {
						DataTable.ext.oPagination[ oSettings.sPaginationType ].fnUpdate( oSettings, function( oSettings ) {
							_fnCalculateEnd( oSettings );
							_fnDraw( oSettings );
						} );
					},
					"sName": "pagination"
				} );
			}
			return nPaginate;
		}
		
		
		/**
		 * Alter the display settings to change the page
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
		 *    or page number to jump to (integer)
		 *  @returns {bool} true page has changed, false - no change (no effect) eg 'first' on page 1
		 *  @memberof DataTable#oApi
		 */
		function _fnPageChange ( oSettings, mAction )
		{
			var iOldStart = oSettings._iDisplayStart;
			
			if ( typeof mAction === "number" )
			{
				oSettings._iDisplayStart = mAction * oSettings._iDisplayLength;
				if ( oSettings._iDisplayStart > oSettings.fnRecordsDisplay() )
				{
					oSettings._iDisplayStart = 0;
				}
			}
			else if ( mAction == "first" )
			{
				oSettings._iDisplayStart = 0;
			}
			else if ( mAction == "previous" )
			{
				oSettings._iDisplayStart = oSettings._iDisplayLength>=0 ?
					oSettings._iDisplayStart - oSettings._iDisplayLength :
					0;
				
				/* Correct for underrun */
				if ( oSettings._iDisplayStart < 0 )
				{
				  oSettings._iDisplayStart = 0;
				}
			}
			else if ( mAction == "next" )
			{
				if ( oSettings._iDisplayLength >= 0 )
				{
					/* Make sure we are not over running the display array */
					if ( oSettings._iDisplayStart + oSettings._iDisplayLength < oSettings.fnRecordsDisplay() )
					{
						oSettings._iDisplayStart += oSettings._iDisplayLength;
					}
				}
				else
				{
					oSettings._iDisplayStart = 0;
				}
			}
			else if ( mAction == "last" )
			{
				if ( oSettings._iDisplayLength >= 0 )
				{
					var iPages = parseInt( (oSettings.fnRecordsDisplay()-1) / oSettings._iDisplayLength, 10 ) + 1;
					oSettings._iDisplayStart = (iPages-1) * oSettings._iDisplayLength;
				}
				else
				{
					oSettings._iDisplayStart = 0;
				}
			}
			else
			{
				_fnLog( oSettings, 0, "Unknown paging action: "+mAction );
			}
			$(oSettings.oInstance).trigger('page', oSettings);
			
			return iOldStart != oSettings._iDisplayStart;
		}
		
		
		
		/**
		 * Generate the node required for the processing node
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Processing element
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlProcessing ( oSettings )
		{
			var nProcessing = document.createElement( 'div' );
			
			if ( !oSettings.aanFeatures.r )
			{
				nProcessing.id = oSettings.sTableId+'_processing';
			}
			nProcessing.innerHTML = oSettings.oLanguage.sProcessing;
			nProcessing.className = oSettings.oClasses.sProcessing;
			oSettings.nTable.parentNode.insertBefore( nProcessing, oSettings.nTable );
			
			return nProcessing;
		}
		
		
		/**
		 * Display or hide the processing indicator
		 *  @param {object} oSettings dataTables settings object
		 *  @param {bool} bShow Show the processing indicator (true) or not (false)
		 *  @memberof DataTable#oApi
		 */
		function _fnProcessingDisplay ( oSettings, bShow )
		{
			if ( oSettings.oFeatures.bProcessing )
			{
				var an = oSettings.aanFeatures.r;
				for ( var i=0, iLen=an.length ; i<iLen ; i++ )
				{
					an[i].style.visibility = bShow ? "visible" : "hidden";
				}
			}
		
			$(oSettings.oInstance).trigger('processing', [oSettings, bShow]);
		}
		
		
		
		/**
		 * Add any control elements for the table - specifically scrolling
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {node} Node to add to the DOM
		 *  @memberof DataTable#oApi
		 */
		function _fnFeatureHtmlTable ( oSettings )
		{
			/* Check if scrolling is enabled or not - if not then leave the DOM unaltered */
			if ( oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "" )
			{
				return oSettings.nTable;
			}
			
			/*
			 * The HTML structure that we want to generate in this function is:
			 *  div - nScroller
			 *    div - nScrollHead
			 *      div - nScrollHeadInner
			 *        table - nScrollHeadTable
			 *          thead - nThead
			 *    div - nScrollBody
			 *      table - oSettings.nTable
			 *        thead - nTheadSize
			 *        tbody - nTbody
			 *    div - nScrollFoot
			 *      div - nScrollFootInner
			 *        table - nScrollFootTable
			 *          tfoot - nTfoot
			 */
			var
			 	nScroller = document.createElement('div'),
			 	nScrollHead = document.createElement('div'),
			 	nScrollHeadInner = document.createElement('div'),
			 	nScrollBody = document.createElement('div'),
			 	nScrollFoot = document.createElement('div'),
			 	nScrollFootInner = document.createElement('div'),
			 	nScrollHeadTable = oSettings.nTable.cloneNode(false),
			 	nScrollFootTable = oSettings.nTable.cloneNode(false),
				nThead = oSettings.nTable.getElementsByTagName('thead')[0],
			 	nTfoot = oSettings.nTable.getElementsByTagName('tfoot').length === 0 ? null : 
					oSettings.nTable.getElementsByTagName('tfoot')[0],
				oClasses = oSettings.oClasses;
			
			nScrollHead.appendChild( nScrollHeadInner );
			nScrollFoot.appendChild( nScrollFootInner );
			nScrollBody.appendChild( oSettings.nTable );
			nScroller.appendChild( nScrollHead );
			nScroller.appendChild( nScrollBody );
			nScrollHeadInner.appendChild( nScrollHeadTable );
			nScrollHeadTable.appendChild( nThead );
			if ( nTfoot !== null )
			{
				nScroller.appendChild( nScrollFoot );
				nScrollFootInner.appendChild( nScrollFootTable );
				nScrollFootTable.appendChild( nTfoot );
			}
			
			nScroller.className = oClasses.sScrollWrapper;
			nScrollHead.className = oClasses.sScrollHead;
			nScrollHeadInner.className = oClasses.sScrollHeadInner;
			nScrollBody.className = oClasses.sScrollBody;
			nScrollFoot.className = oClasses.sScrollFoot;
			nScrollFootInner.className = oClasses.sScrollFootInner;
			
			if ( oSettings.oScroll.bAutoCss )
			{
				nScrollHead.style.overflow = "hidden";
				nScrollHead.style.position = "relative";
				nScrollFoot.style.overflow = "hidden";
				nScrollBody.style.overflow = "auto";
			}
			
			nScrollHead.style.border = "0";
			nScrollHead.style.width = "100%";
			nScrollFoot.style.border = "0";
			nScrollHeadInner.style.width = "150%"; /* will be overwritten */
			
			/* Modify attributes to respect the clones */
			nScrollHeadTable.removeAttribute('id');
			nScrollHeadTable.style.marginLeft = "0";
			oSettings.nTable.style.marginLeft = "0";
			if ( nTfoot !== null )
			{
				nScrollFootTable.removeAttribute('id');
				nScrollFootTable.style.marginLeft = "0";
			}
			
			/* Move any caption elements from the body to the header */
			var nCaptions = $(oSettings.nTable).children('caption');
			for ( var i=0, iLen=nCaptions.length ; i<iLen ; i++ )
			{
				nScrollHeadTable.appendChild( nCaptions[i] );
			}
			
			/*
			 * Sizing
			 */
			/* When xscrolling add the width and a scroller to move the header with the body */
			if ( oSettings.oScroll.sX !== "" )
			{
				nScrollHead.style.width = _fnStringToCss( oSettings.oScroll.sX );
				nScrollBody.style.width = _fnStringToCss( oSettings.oScroll.sX );
				
				if ( nTfoot !== null )
				{
					nScrollFoot.style.width = _fnStringToCss( oSettings.oScroll.sX );	
				}
				
				/* When the body is scrolled, then we also want to scroll the headers */
				$(nScrollBody).scroll( function (e) {
					nScrollHead.scrollLeft = this.scrollLeft;
					
					if ( nTfoot !== null )
					{
						nScrollFoot.scrollLeft = this.scrollLeft;
					}
				} );
			}
			
			/* When yscrolling, add the height */
			if ( oSettings.oScroll.sY !== "" )
			{
				nScrollBody.style.height = _fnStringToCss( oSettings.oScroll.sY );
			}
			
			/* Redraw - align columns across the tables */
			oSettings.aoDrawCallback.push( {
				"fn": _fnScrollDraw,
				"sName": "scrolling"
			} );
			
			/* Infinite scrolling event handlers */
			if ( oSettings.oScroll.bInfinite )
			{
				$(nScrollBody).scroll( function() {
					/* Use a blocker to stop scrolling from loading more data while other data is still loading */
					if ( !oSettings.bDrawing && $(this).scrollTop() !== 0 )
					{
						/* Check if we should load the next data set */
						if ( $(this).scrollTop() + $(this).height() > 
							$(oSettings.nTable).height() - oSettings.oScroll.iLoadGap )
						{
							/* Only do the redraw if we have to - we might be at the end of the data */
							if ( oSettings.fnDisplayEnd() < oSettings.fnRecordsDisplay() )
							{
								_fnPageChange( oSettings, 'next' );
								_fnCalculateEnd( oSettings );
								_fnDraw( oSettings );
							}
						}
					}
				} );
			}
			
			oSettings.nScrollHead = nScrollHead;
			oSettings.nScrollFoot = nScrollFoot;
			
			return nScroller;
		}
		
		
		/**
		 * Update the various tables for resizing. It's a bit of a pig this function, but
		 * basically the idea to:
		 *   1. Re-create the table inside the scrolling div
		 *   2. Take live measurements from the DOM
		 *   3. Apply the measurements
		 *   4. Clean up
		 *  @param {object} o dataTables settings object
		 *  @returns {node} Node to add to the DOM
		 *  @memberof DataTable#oApi
		 */
		function _fnScrollDraw ( o )
		{
			var
				nScrollHeadInner = o.nScrollHead.getElementsByTagName('div')[0],
				nScrollHeadTable = nScrollHeadInner.getElementsByTagName('table')[0],
				nScrollBody = o.nTable.parentNode,
				i, iLen, j, jLen, anHeadToSize, anHeadSizers, anFootSizers, anFootToSize, oStyle, iVis,
				iWidth, aApplied=[], iSanityWidth,
				nScrollFootInner = (o.nTFoot !== null) ? o.nScrollFoot.getElementsByTagName('div')[0] : null,
				nScrollFootTable = (o.nTFoot !== null) ? nScrollFootInner.getElementsByTagName('table')[0] : null,
				ie67 = $.browser.msie && $.browser.version <= 7;
			
			/*
			 * 1. Re-create the table inside the scrolling div
			 */
			
			/* Remove the old minimised thead and tfoot elements in the inner table */
			var nTheadSize = o.nTable.getElementsByTagName('thead');
			if ( nTheadSize.length > 0 )
			{
				o.nTable.removeChild( nTheadSize[0] );
			}
			
			var nTfootSize;
			if ( o.nTFoot !== null )
			{
				/* Remove the old minimised footer element in the cloned header */
				nTfootSize = o.nTable.getElementsByTagName('tfoot');
				if ( nTfootSize.length > 0 )
				{
					o.nTable.removeChild( nTfootSize[0] );
				}
			}
			
			/* Clone the current header and footer elements and then place it into the inner table */
			nTheadSize = o.nTHead.cloneNode(true);
			o.nTable.insertBefore( nTheadSize, o.nTable.childNodes[0] );
			
			if ( o.nTFoot !== null )
			{
				nTfootSize = o.nTFoot.cloneNode(true);
				o.nTable.insertBefore( nTfootSize, o.nTable.childNodes[1] );
			}
			
			/*
			 * 2. Take live measurements from the DOM - do not alter the DOM itself!
			 */
			
			/* Remove old sizing and apply the calculated column widths
			 * Get the unique column headers in the newly created (cloned) header. We want to apply the
			 * calclated sizes to this header
			 */
			if ( o.oScroll.sX === "" )
			{
				nScrollBody.style.width = '100%';
				nScrollHeadInner.parentNode.style.width = '100%';
			}
			
			var nThs = _fnGetUniqueThs( o, nTheadSize );
			for ( i=0, iLen=nThs.length ; i<iLen ; i++ )
			{
				iVis = _fnVisibleToColumnIndex( o, i );
				nThs[i].style.width = o.aoColumns[iVis].sWidth;
			}
			
			if ( o.nTFoot !== null )
			{
				_fnApplyToChildren( function(n) {
					n.style.width = "";
				}, nTfootSize.getElementsByTagName('tr') );
			}
			
			/* Size the table as a whole */
			iSanityWidth = $(o.nTable).outerWidth();
			if ( o.oScroll.sX === "" )
			{
				/* No x scrolling */
				o.nTable.style.width = "100%";
				
				/* I know this is rubbish - but IE7 will make the width of the table when 100% include
				 * the scrollbar - which is shouldn't. When there is a scrollbar we need to take this
				 * into account.
				 */
				if ( ie67 && ($('tbody', nScrollBody).height() > nScrollBody.offsetHeight || 
					$(nScrollBody).css('overflow-y') == "scroll")  )
				{
					o.nTable.style.width = _fnStringToCss( $(o.nTable).outerWidth()-o.oScroll.iBarWidth );
				}
			}
			else
			{
				if ( o.oScroll.sXInner !== "" )
				{
					/* x scroll inner has been given - use it */
					o.nTable.style.width = _fnStringToCss(o.oScroll.sXInner);
				}
				else if ( iSanityWidth == $(nScrollBody).width() &&
				   $(nScrollBody).height() < $(o.nTable).height() )
				{
					/* There is y-scrolling - try to take account of the y scroll bar */
					o.nTable.style.width = _fnStringToCss( iSanityWidth-o.oScroll.iBarWidth );
					if ( $(o.nTable).outerWidth() > iSanityWidth-o.oScroll.iBarWidth )
					{
						/* Not possible to take account of it */
						o.nTable.style.width = _fnStringToCss( iSanityWidth );
					}
				}
				else
				{
					/* All else fails */
					o.nTable.style.width = _fnStringToCss( iSanityWidth );
				}
			}
			
			/* Recalculate the sanity width - now that we've applied the required width, before it was
			 * a temporary variable. This is required because the column width calculation is done
			 * before this table DOM is created.
			 */
			iSanityWidth = $(o.nTable).outerWidth();
			
			/* We want the hidden header to have zero height, so remove padding and borders. Then
			 * set the width based on the real headers
			 */
			anHeadToSize = o.nTHead.getElementsByTagName('tr');
			anHeadSizers = nTheadSize.getElementsByTagName('tr');
			
			_fnApplyToChildren( function(nSizer, nToSize) {
				oStyle = nSizer.style;
				oStyle.paddingTop = "0";
				oStyle.paddingBottom = "0";
				oStyle.borderTopWidth = "0";
				oStyle.borderBottomWidth = "0";
				oStyle.height = 0;
				
				iWidth = $(nSizer).width();
				nToSize.style.width = _fnStringToCss( iWidth );
				aApplied.push( iWidth );
			}, anHeadSizers, anHeadToSize );
			$(anHeadSizers).height(0);
			
			if ( o.nTFoot !== null )
			{
				/* Clone the current footer and then place it into the body table as a "hidden header" */
				anFootSizers = nTfootSize.getElementsByTagName('tr');
				anFootToSize = o.nTFoot.getElementsByTagName('tr');
				
				_fnApplyToChildren( function(nSizer, nToSize) {
					oStyle = nSizer.style;
					oStyle.paddingTop = "0";
					oStyle.paddingBottom = "0";
					oStyle.borderTopWidth = "0";
					oStyle.borderBottomWidth = "0";
					oStyle.height = 0;
					
					iWidth = $(nSizer).width();
					nToSize.style.width = _fnStringToCss( iWidth );
					aApplied.push( iWidth );
				}, anFootSizers, anFootToSize );
				$(anFootSizers).height(0);
			}
			
			/*
			 * 3. Apply the measurements
			 */
			
			/* "Hide" the header and footer that we used for the sizing. We want to also fix their width
			 * to what they currently are
			 */
			_fnApplyToChildren( function(nSizer) {
				nSizer.innerHTML = "";
				nSizer.style.width = _fnStringToCss( aApplied.shift() );
			}, anHeadSizers );
			
			if ( o.nTFoot !== null )
			{
				_fnApplyToChildren( function(nSizer) {
					nSizer.innerHTML = "";
					nSizer.style.width = _fnStringToCss( aApplied.shift() );
				}, anFootSizers );
			}
			
			/* Sanity check that the table is of a sensible width. If not then we are going to get
			 * misalignment - try to prevent this by not allowing the table to shrink below its min width
			 */
			if ( $(o.nTable).outerWidth() < iSanityWidth )
			{
				/* The min width depends upon if we have a vertical scrollbar visible or not */
				var iCorrection = ((nScrollBody.scrollHeight > nScrollBody.offsetHeight || 
					$(nScrollBody).css('overflow-y') == "scroll")) ?
						iSanityWidth+o.oScroll.iBarWidth : iSanityWidth;
				
				/* IE6/7 are a law unto themselves... */
				if ( ie67 && (nScrollBody.scrollHeight > 
					nScrollBody.offsetHeight || $(nScrollBody).css('overflow-y') == "scroll")  )
				{
					o.nTable.style.width = _fnStringToCss( iCorrection-o.oScroll.iBarWidth );
				}
				
				/* Apply the calculated minimum width to the table wrappers */
				nScrollBody.style.width = _fnStringToCss( iCorrection );
				nScrollHeadInner.parentNode.style.width = _fnStringToCss( iCorrection );
				
				if ( o.nTFoot !== null )
				{
					nScrollFootInner.parentNode.style.width = _fnStringToCss( iCorrection );
				}
				
				/* And give the user a warning that we've stopped the table getting too small */
				if ( o.oScroll.sX === "" )
				{
					_fnLog( o, 1, "The table cannot fit into the current element which will cause column"+
						" misalignment. The table has been drawn at its minimum possible width." );
				}
				else if ( o.oScroll.sXInner !== "" )
				{
					_fnLog( o, 1, "The table cannot fit into the current element which will cause column"+
						" misalignment. Increase the sScrollXInner value or remove it to allow automatic"+
						" calculation" );
				}
			}
			else
			{
				nScrollBody.style.width = _fnStringToCss( '100%' );
				nScrollHeadInner.parentNode.style.width = _fnStringToCss( '100%' );
				
				if ( o.nTFoot !== null )
				{
					nScrollFootInner.parentNode.style.width = _fnStringToCss( '100%' );
				}
			}
			
			
			/*
			 * 4. Clean up
			 */
			if ( o.oScroll.sY === "" )
			{
				/* IE7< puts a vertical scrollbar in place (when it shouldn't be) due to subtracting
				 * the scrollbar height from the visible display, rather than adding it on. We need to
				 * set the height in order to sort this. Don't want to do it in any other browsers.
				 */
				if ( ie67 )
				{
					nScrollBody.style.height = _fnStringToCss( o.nTable.offsetHeight+o.oScroll.iBarWidth );
				}
			}
			
			if ( o.oScroll.sY !== "" && o.oScroll.bCollapse )
			{
				nScrollBody.style.height = _fnStringToCss( o.oScroll.sY );
				
				var iExtra = (o.oScroll.sX !== "" && o.nTable.offsetWidth > nScrollBody.offsetWidth) ?
				 	o.oScroll.iBarWidth : 0;
				if ( o.nTable.offsetHeight < nScrollBody.offsetHeight )
				{
					nScrollBody.style.height = _fnStringToCss( $(o.nTable).height()+iExtra );
				}
			}
			
			/* Finally set the width's of the header and footer tables */
			var iOuterWidth = $(o.nTable).outerWidth();
			nScrollHeadTable.style.width = _fnStringToCss( iOuterWidth );
			nScrollHeadInner.style.width = _fnStringToCss( iOuterWidth );
			
			if ( o.nTFoot !== null )
			{
				nScrollFootInner.style.width = _fnStringToCss( o.nTable.offsetWidth );
				nScrollFootTable.style.width = _fnStringToCss( o.nTable.offsetWidth );
			}
			
			/* If sorting or filtering has occurred, jump the scrolling back to the top */
			if ( o.bSorted || o.bFiltered )
			{
				nScrollBody.scrollTop = 0;
			}
		}
		
		
		/**
		 * Apply a given function to the display child nodes of an element array (typically
		 * TD children of TR rows
		 *  @param {function} fn Method to apply to the objects
		 *  @param array {nodes} an1 List of elements to look through for display children
		 *  @param array {nodes} an2 Another list (identical structure to the first) - optional
		 *  @memberof DataTable#oApi
		 */
		function _fnApplyToChildren( fn, an1, an2 )
		{
			for ( var i=0, iLen=an1.length ; i<iLen ; i++ )
			{
				for ( var j=0, jLen=an1[i].childNodes.length ; j<jLen ; j++ )
				{
					if ( an1[i].childNodes[j].nodeType == 1 )
					{
						if ( an2 )
						{
							fn( an1[i].childNodes[j], an2[i].childNodes[j] );
						}
						else
						{
							fn( an1[i].childNodes[j] );
						}
					}
				}
			}
		}
		
		
		
		/**
		 * Convert a CSS unit width to pixels (e.g. 2em)
		 *  @param {string} sWidth width to be converted
		 *  @param {node} nParent parent to get the with for (required for relative widths) - optional
		 *  @returns {int} iWidth width in pixels
		 *  @memberof DataTable#oApi
		 */
		function _fnConvertToWidth ( sWidth, nParent )
		{
			if ( !sWidth || sWidth === null || sWidth === '' )
			{
				return 0;
			}
			
			if ( !nParent )
			{
				nParent = document.getElementsByTagName('body')[0];
			}
			
			var iWidth;
			var nTmp = document.createElement( "div" );
			nTmp.style.width = _fnStringToCss( sWidth );
			
			nParent.appendChild( nTmp );
			iWidth = nTmp.offsetWidth;
			nParent.removeChild( nTmp );
			
			return ( iWidth );
		}
		
		
		/**
		 * Calculate the width of columns for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnCalculateColumnWidths ( oSettings )
		{
			var iTableWidth = oSettings.nTable.offsetWidth;
			var iUserInputs = 0;
			var iTmpWidth;
			var iVisibleColumns = 0;
			var iColums = oSettings.aoColumns.length;
			var i, iIndex, iCorrector, iWidth;
			var oHeaders = $('th', oSettings.nTHead);
			var widthAttr = oSettings.nTable.getAttribute('width');
			
			/* Convert any user input sizes into pixel sizes */
			for ( i=0 ; i<iColums ; i++ )
			{
				if ( oSettings.aoColumns[i].bVisible )
				{
					iVisibleColumns++;
					
					if ( oSettings.aoColumns[i].sWidth !== null )
					{
						iTmpWidth = _fnConvertToWidth( oSettings.aoColumns[i].sWidthOrig, 
							oSettings.nTable.parentNode );
						if ( iTmpWidth !== null )
						{
							oSettings.aoColumns[i].sWidth = _fnStringToCss( iTmpWidth );
						}
							
						iUserInputs++;
					}
				}
			}
			
			/* If the number of columns in the DOM equals the number that we have to process in 
			 * DataTables, then we can use the offsets that are created by the web-browser. No custom 
			 * sizes can be set in order for this to happen, nor scrolling used
			 */
			if ( iColums == oHeaders.length && iUserInputs === 0 && iVisibleColumns == iColums &&
				oSettings.oScroll.sX === "" && oSettings.oScroll.sY === "" )
			{
				for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
				{
					iTmpWidth = $(oHeaders[i]).width();
					if ( iTmpWidth !== null )
					{
						oSettings.aoColumns[i].sWidth = _fnStringToCss( iTmpWidth );
					}
				}
			}
			else
			{
				/* Otherwise we are going to have to do some calculations to get the width of each column.
				 * Construct a 1 row table with the widest node in the data, and any user defined widths,
				 * then insert it into the DOM and allow the browser to do all the hard work of
				 * calculating table widths.
				 */
				var
					nCalcTmp = oSettings.nTable.cloneNode( false ),
					nTheadClone = oSettings.nTHead.cloneNode(true),
					nBody = document.createElement( 'tbody' ),
					nTr = document.createElement( 'tr' ),
					nDivSizing;
				
				nCalcTmp.removeAttribute( "id" );
				nCalcTmp.appendChild( nTheadClone );
				if ( oSettings.nTFoot !== null )
				{
					nCalcTmp.appendChild( oSettings.nTFoot.cloneNode(true) );
					_fnApplyToChildren( function(n) {
						n.style.width = "";
					}, nCalcTmp.getElementsByTagName('tr') );
				}
				
				nCalcTmp.appendChild( nBody );
				nBody.appendChild( nTr );
				
				/* Remove any sizing that was previously applied by the styles */
				var jqColSizing = $('thead th', nCalcTmp);
				if ( jqColSizing.length === 0 )
				{
					jqColSizing = $('tbody tr:eq(0)>td', nCalcTmp);
				}
		
				/* Apply custom sizing to the cloned header */
				var nThs = _fnGetUniqueThs( oSettings, nTheadClone );
				iCorrector = 0;
				for ( i=0 ; i<iColums ; i++ )
				{
					var oColumn = oSettings.aoColumns[i];
					if ( oColumn.bVisible && oColumn.sWidthOrig !== null && oColumn.sWidthOrig !== "" )
					{
						nThs[i-iCorrector].style.width = _fnStringToCss( oColumn.sWidthOrig );
					}
					else if ( oColumn.bVisible )
					{
						nThs[i-iCorrector].style.width = "";
					}
					else
					{
						iCorrector++;
					}
				}
		
				/* Find the biggest td for each column and put it into the table */
				for ( i=0 ; i<iColums ; i++ )
				{
					if ( oSettings.aoColumns[i].bVisible )
					{
						var nTd = _fnGetWidestNode( oSettings, i );
						if ( nTd !== null )
						{
							nTd = nTd.cloneNode(true);
							if ( oSettings.aoColumns[i].sContentPadding !== "" )
							{
								nTd.innerHTML += oSettings.aoColumns[i].sContentPadding;
							}
							nTr.appendChild( nTd );
						}
					}
				}
				
				/* Build the table and 'display' it */
				var nWrapper = oSettings.nTable.parentNode;
				nWrapper.appendChild( nCalcTmp );
				
				/* When scrolling (X or Y) we want to set the width of the table as appropriate. However,
				 * when not scrolling leave the table width as it is. This results in slightly different,
				 * but I think correct behaviour
				 */
				if ( oSettings.oScroll.sX !== "" && oSettings.oScroll.sXInner !== "" )
				{
					nCalcTmp.style.width = _fnStringToCss(oSettings.oScroll.sXInner);
				}
				else if ( oSettings.oScroll.sX !== "" )
				{
					nCalcTmp.style.width = "";
					if ( $(nCalcTmp).width() < nWrapper.offsetWidth )
					{
						nCalcTmp.style.width = _fnStringToCss( nWrapper.offsetWidth );
					}
				}
				else if ( oSettings.oScroll.sY !== "" )
				{
					nCalcTmp.style.width = _fnStringToCss( nWrapper.offsetWidth );
				}
				else if ( widthAttr )
				{
					nCalcTmp.style.width = _fnStringToCss( widthAttr );
				}
				nCalcTmp.style.visibility = "hidden";
				
				/* Scrolling considerations */
				_fnScrollingWidthAdjust( oSettings, nCalcTmp );
				
				/* Read the width's calculated by the browser and store them for use by the caller. We
				 * first of all try to use the elements in the body, but it is possible that there are
				 * no elements there, under which circumstances we use the header elements
				 */
				var oNodes = $("tbody tr:eq(0)", nCalcTmp).children();
				if ( oNodes.length === 0 )
				{
					oNodes = _fnGetUniqueThs( oSettings, $('thead', nCalcTmp)[0] );
				}
		
				/* Browsers need a bit of a hand when a width is assigned to any columns when 
				 * x-scrolling as they tend to collapse the table to the min-width, even if
				 * we sent the column widths. So we need to keep track of what the table width
				 * should be by summing the user given values, and the automatic values
				 */
				if ( oSettings.oScroll.sX !== "" )
				{
					var iTotal = 0;
					iCorrector = 0;
					for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
					{
						if ( oSettings.aoColumns[i].bVisible )
						{
							if ( oSettings.aoColumns[i].sWidthOrig === null )
							{
								iTotal += $(oNodes[iCorrector]).outerWidth();
							}
							else
							{
								iTotal += parseInt(oSettings.aoColumns[i].sWidth.replace('px',''), 10) +
									($(oNodes[iCorrector]).outerWidth() - $(oNodes[iCorrector]).width());
							}
							iCorrector++;
						}
					}
					
					nCalcTmp.style.width = _fnStringToCss( iTotal );
					oSettings.nTable.style.width = _fnStringToCss( iTotal );
				}
		
				iCorrector = 0;
				for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
				{
					if ( oSettings.aoColumns[i].bVisible )
					{
						iWidth = $(oNodes[iCorrector]).width();
						if ( iWidth !== null && iWidth > 0 )
						{
							oSettings.aoColumns[i].sWidth = _fnStringToCss( iWidth );
						}
						iCorrector++;
					}
				}
		
				var cssWidth = $(nCalcTmp).css('width');
				oSettings.nTable.style.width = (cssWidth.indexOf('%') !== -1) ?
				    cssWidth : _fnStringToCss( $(nCalcTmp).outerWidth() );
				nCalcTmp.parentNode.removeChild( nCalcTmp );
			}
		
			if ( widthAttr )
			{
				oSettings.nTable.style.width = _fnStringToCss( widthAttr );
			}
		}
		
		
		/**
		 * Adjust a table's width to take account of scrolling
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} n table node
		 *  @memberof DataTable#oApi
		 */
		function _fnScrollingWidthAdjust ( oSettings, n )
		{
			if ( oSettings.oScroll.sX === "" && oSettings.oScroll.sY !== "" )
			{
				/* When y-scrolling only, we want to remove the width of the scroll bar so the table
				 * + scroll bar will fit into the area avaialble.
				 */
				var iOrigWidth = $(n).width();
				n.style.width = _fnStringToCss( $(n).outerWidth()-oSettings.oScroll.iBarWidth );
			}
			else if ( oSettings.oScroll.sX !== "" )
			{
				/* When x-scrolling both ways, fix the table at it's current size, without adjusting */
				n.style.width = _fnStringToCss( $(n).outerWidth() );
			}
		}
		
		
		/**
		 * Get the widest node
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iCol column of interest
		 *  @returns {string} max strlens for each column
		 *  @memberof DataTable#oApi
		 */
		function _fnGetWidestNode( oSettings, iCol )
		{
			var iMaxIndex = _fnGetMaxLenString( oSettings, iCol );
			if ( iMaxIndex < 0 )
			{
				return null;
			}
		
			if ( oSettings.aoData[iMaxIndex].nTr === null )
			{
				var n = document.createElement('td');
				n.innerHTML = _fnGetCellData( oSettings, iMaxIndex, iCol, '' );
				return n;
			}
			return _fnGetTdNodes(oSettings, iMaxIndex)[iCol];
		}
		
		
		/**
		 * Get the maximum strlen for each data column
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iCol column of interest
		 *  @returns {string} max strlens for each column
		 *  @memberof DataTable#oApi
		 */
		function _fnGetMaxLenString( oSettings, iCol )
		{
			var iMax = -1;
			var iMaxIndex = -1;
			
			for ( var i=0 ; i<oSettings.aoData.length ; i++ )
			{
				var s = _fnGetCellData( oSettings, i, iCol, 'display' )+"";
				s = s.replace( /<.*?>/g, "" );
				if ( s.length > iMax )
				{
					iMax = s.length;
					iMaxIndex = i;
				}
			}
			
			return iMaxIndex;
		}
		
		
		/**
		 * Append a CSS unit (only if required) to a string
		 *  @param {array} aArray1 first array
		 *  @param {array} aArray2 second array
		 *  @returns {int} 0 if match, 1 if length is different, 2 if no match
		 *  @memberof DataTable#oApi
		 */
		function _fnStringToCss( s )
		{
			if ( s === null )
			{
				return "0px";
			}
			
			if ( typeof s == 'number' )
			{
				if ( s < 0 )
				{
					return "0px";
				}
				return s+"px";
			}
			
			/* Check if the last character is not 0-9 */
			var c = s.charCodeAt( s.length-1 );
			if (c < 0x30 || c > 0x39)
			{
				return s;
			}
			return s+"px";
		}
		
		
		/**
		 * Get the width of a scroll bar in this browser being used
		 *  @returns {int} width in pixels
		 *  @memberof DataTable#oApi
		 */
		function _fnScrollBarWidth ()
		{  
			var inner = document.createElement('p');
			var style = inner.style;
			style.width = "100%";
			style.height = "200px";
			style.padding = "0px";
			
			var outer = document.createElement('div');
			style = outer.style;
			style.position = "absolute";
			style.top = "0px";
			style.left = "0px";
			style.visibility = "hidden";
			style.width = "200px";
			style.height = "150px";
			style.padding = "0px";
			style.overflow = "hidden";
			outer.appendChild(inner);
			
			document.body.appendChild(outer);
			var w1 = inner.offsetWidth;
			outer.style.overflow = 'scroll';
			var w2 = inner.offsetWidth;
			if ( w1 == w2 )
			{
				w2 = outer.clientWidth;
			}
			
			document.body.removeChild(outer);
			return (w1 - w2);  
		}
		
		
		
		/**
		 * Change the order of the table
		 *  @param {object} oSettings dataTables settings object
		 *  @param {bool} bApplyClasses optional - should we apply classes or not
		 *  @memberof DataTable#oApi
		 */
		function _fnSort ( oSettings, bApplyClasses )
		{
			var
				i, iLen, j, jLen, k, kLen,
				sDataType, nTh,
				aaSort = [],
			 	aiOrig = [],
				oSort = DataTable.ext.oSort,
				aoData = oSettings.aoData,
				aoColumns = oSettings.aoColumns,
				oAria = oSettings.oLanguage.oAria;
			
			/* No sorting required if server-side or no sorting array */
			if ( !oSettings.oFeatures.bServerSide && 
				(oSettings.aaSorting.length !== 0 || oSettings.aaSortingFixed !== null) )
			{
				if ( oSettings.aaSortingFixed !== null )
				{
					aaSort = oSettings.aaSortingFixed.concat( oSettings.aaSorting );
				}
				else
				{
					aaSort = oSettings.aaSorting.slice();
				}
				
				/* If there is a sorting data type, and a fuction belonging to it, then we need to
				 * get the data from the developer's function and apply it for this column
				 */
				for ( i=0 ; i<aaSort.length ; i++ )
				{
					var iColumn = aaSort[i][0];
					var iVisColumn = _fnColumnIndexToVisible( oSettings, iColumn );
					sDataType = oSettings.aoColumns[ iColumn ].sSortDataType;
					if ( DataTable.ext.afnSortData[sDataType] )
					{
						var aData = DataTable.ext.afnSortData[sDataType]( oSettings, iColumn, iVisColumn );
						for ( j=0, jLen=aoData.length ; j<jLen ; j++ )
						{
							_fnSetCellData( oSettings, j, iColumn, aData[j] );
						}
					}
				}
				
				/* Create a value - key array of the current row positions such that we can use their
				 * current position during the sort, if values match, in order to perform stable sorting
				 */
				for ( i=0, iLen=oSettings.aiDisplayMaster.length ; i<iLen ; i++ )
				{
					aiOrig[ oSettings.aiDisplayMaster[i] ] = i;
				}
		
				/* Build an internal data array which is specific to the sort, so we can get and prep
				 * the data to be sorted only once, rather than needing to do it every time the sorting
				 * function runs. This make the sorting function a very simple comparison
				 */
				var iSortLen = aaSort.length;
				var fnSortFormat, aDataSort;
				for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
				{
					for ( j=0 ; j<iSortLen ; j++ )
					{
						aDataSort = aoColumns[ aaSort[j][0] ].aDataSort;
		
						for ( k=0, kLen=aDataSort.length ; k<kLen ; k++ )
						{
							sDataType = aoColumns[ aDataSort[k] ].sType;
							fnSortFormat = oSort[ (sDataType ? sDataType : 'string')+"-pre" ];
							
							aoData[i]._aSortData[ aDataSort[k] ] = fnSortFormat ?
								fnSortFormat( _fnGetCellData( oSettings, i, aDataSort[k], 'sort' ) ) :
								_fnGetCellData( oSettings, i, aDataSort[k], 'sort' );
						}
					}
				}
				
				/* Do the sort - here we want multi-column sorting based on a given data source (column)
				 * and sorting function (from oSort) in a certain direction. It's reasonably complex to
				 * follow on it's own, but this is what we want (example two column sorting):
				 *  fnLocalSorting = function(a,b){
				 *  	var iTest;
				 *  	iTest = oSort['string-asc']('data11', 'data12');
				 *  	if (iTest !== 0)
				 *  		return iTest;
				 *    iTest = oSort['numeric-desc']('data21', 'data22');
				 *    if (iTest !== 0)
				 *  		return iTest;
				 *  	return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
				 *  }
				 * Basically we have a test for each sorting column, if the data in that column is equal,
				 * test the next column. If all columns match, then we use a numeric sort on the row 
				 * positions in the original data array to provide a stable sort.
				 */
				oSettings.aiDisplayMaster.sort( function ( a, b ) {
					var k, l, lLen, iTest, aDataSort, sDataType;
					for ( k=0 ; k<iSortLen ; k++ )
					{
						aDataSort = aoColumns[ aaSort[k][0] ].aDataSort;
		
						for ( l=0, lLen=aDataSort.length ; l<lLen ; l++ )
						{
							sDataType = aoColumns[ aDataSort[l] ].sType;
							
							iTest = oSort[ (sDataType ? sDataType : 'string')+"-"+aaSort[k][1] ](
								aoData[a]._aSortData[ aDataSort[l] ],
								aoData[b]._aSortData[ aDataSort[l] ]
							);
						
							if ( iTest !== 0 )
							{
								return iTest;
							}
						}
					}
					
					return oSort['numeric-asc']( aiOrig[a], aiOrig[b] );
				} );
			}
			
			/* Alter the sorting classes to take account of the changes */
			if ( (bApplyClasses === undefined || bApplyClasses) && !oSettings.oFeatures.bDeferRender )
			{
				_fnSortingClasses( oSettings );
			}
		
			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				nTh = aoColumns[i].nTh;
				nTh.removeAttribute('aria-sort');
				nTh.removeAttribute('aria-label');
				
				/* In ARIA only the first sorting column can be marked as sorting - no multi-sort option */
				if ( aoColumns[i].bSortable )
				{
					if ( aaSort.length > 0 && aaSort[0][0] == i )
					{
						nTh.setAttribute('aria-sort', aaSort[0][1]=="asc" ? "ascending" : "descending" );
						
						var nextSort = (aoColumns[i].asSorting[ aaSort[0][2]+1 ]) ? 
							aoColumns[i].asSorting[ aaSort[0][2]+1 ] : aoColumns[i].asSorting[0];
						nTh.setAttribute('aria-label', aoColumns[i].sTitle+
							(nextSort=="asc" ? oAria.sSortAscending : oAria.sSortDescending) );
					}
					else
					{
						nTh.setAttribute('aria-label', aoColumns[i].sTitle+
							(aoColumns[i].asSorting[0]=="asc" ? oAria.sSortAscending : oAria.sSortDescending) );
					}
				}
				else
				{
					nTh.setAttribute('aria-label', aoColumns[i].sTitle);
				}
			}
			
			/* Tell the draw function that we have sorted the data */
			oSettings.bSorted = true;
			$(oSettings.oInstance).trigger('sort', oSettings);
			
			/* Copy the master data into the draw array and re-draw */
			if ( oSettings.oFeatures.bFilter )
			{
				/* _fnFilter() will redraw the table for us */
				_fnFilterComplete( oSettings, oSettings.oPreviousSearch, 1 );
			}
			else
			{
				oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
				oSettings._iDisplayStart = 0; /* reset display back to page 0 */
				_fnCalculateEnd( oSettings );
				_fnDraw( oSettings );
			}
		}
		
		
		/**
		 * Attach a sort handler (click) to a node
		 *  @param {object} oSettings dataTables settings object
		 *  @param {node} nNode node to attach the handler to
		 *  @param {int} iDataIndex column sorting index
		 *  @param {function} [fnCallback] callback function
		 *  @memberof DataTable#oApi
		 */
		function _fnSortAttachListener ( oSettings, nNode, iDataIndex, fnCallback )
		{
			_fnBindAction( nNode, {}, function (e) {
				/* If the column is not sortable - don't to anything */
				if ( oSettings.aoColumns[iDataIndex].bSortable === false )
				{
					return;
				}
				
				/*
				 * This is a little bit odd I admit... I declare a temporary function inside the scope of
				 * _fnBuildHead and the click handler in order that the code presented here can be used 
				 * twice - once for when bProcessing is enabled, and another time for when it is 
				 * disabled, as we need to perform slightly different actions.
				 *   Basically the issue here is that the Javascript engine in modern browsers don't 
				 * appear to allow the rendering engine to update the display while it is still excuting
				 * it's thread (well - it does but only after long intervals). This means that the 
				 * 'processing' display doesn't appear for a table sort. To break the js thread up a bit
				 * I force an execution break by using setTimeout - but this breaks the expected 
				 * thread continuation for the end-developer's point of view (their code would execute
				 * too early), so we on;y do it when we absolutely have to.
				 */
				var fnInnerSorting = function () {
					var iColumn, iNextSort;
					
					/* If the shift key is pressed then we are multipe column sorting */
					if ( e.shiftKey )
					{
						/* Are we already doing some kind of sort on this column? */
						var bFound = false;
						for ( var i=0 ; i<oSettings.aaSorting.length ; i++ )
						{
							if ( oSettings.aaSorting[i][0] == iDataIndex )
							{
								bFound = true;
								iColumn = oSettings.aaSorting[i][0];
								iNextSort = oSettings.aaSorting[i][2]+1;
								
								if ( !oSettings.aoColumns[iColumn].asSorting[iNextSort] )
								{
									/* Reached the end of the sorting options, remove from multi-col sort */
									oSettings.aaSorting.splice( i, 1 );
								}
								else
								{
									/* Move onto next sorting direction */
									oSettings.aaSorting[i][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
									oSettings.aaSorting[i][2] = iNextSort;
								}
								break;
							}
						}
						
						/* No sort yet - add it in */
						if ( bFound === false )
						{
							oSettings.aaSorting.push( [ iDataIndex, 
								oSettings.aoColumns[iDataIndex].asSorting[0], 0 ] );
						}
					}
					else
					{
						/* If no shift key then single column sort */
						if ( oSettings.aaSorting.length == 1 && oSettings.aaSorting[0][0] == iDataIndex )
						{
							iColumn = oSettings.aaSorting[0][0];
							iNextSort = oSettings.aaSorting[0][2]+1;
							if ( !oSettings.aoColumns[iColumn].asSorting[iNextSort] )
							{
								iNextSort = 0;
							}
							oSettings.aaSorting[0][1] = oSettings.aoColumns[iColumn].asSorting[iNextSort];
							oSettings.aaSorting[0][2] = iNextSort;
						}
						else
						{
							oSettings.aaSorting.splice( 0, oSettings.aaSorting.length );
							oSettings.aaSorting.push( [ iDataIndex, 
								oSettings.aoColumns[iDataIndex].asSorting[0], 0 ] );
						}
					}
					
					/* Run the sort */
					_fnSort( oSettings );
				}; /* /fnInnerSorting */
				
				if ( !oSettings.oFeatures.bProcessing )
				{
					fnInnerSorting();
				}
				else
				{
					_fnProcessingDisplay( oSettings, true );
					setTimeout( function() {
						fnInnerSorting();
						if ( !oSettings.oFeatures.bServerSide )
						{
							_fnProcessingDisplay( oSettings, false );
						}
					}, 0 );
				}
				
				/* Call the user specified callback function - used for async user interaction */
				if ( typeof fnCallback == 'function' )
				{
					fnCallback( oSettings );
				}
			} );
		}
		
		
		/**
		 * Set the sorting classes on the header, Note: it is safe to call this function 
		 * when bSort and bSortClasses are false
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnSortingClasses( oSettings )
		{
			var i, iLen, j, jLen, iFound;
			var aaSort, sClass;
			var iColumns = oSettings.aoColumns.length;
			var oClasses = oSettings.oClasses;
			
			for ( i=0 ; i<iColumns ; i++ )
			{
				if ( oSettings.aoColumns[i].bSortable )
				{
					$(oSettings.aoColumns[i].nTh).removeClass( oClasses.sSortAsc +" "+ oClasses.sSortDesc +
						" "+ oSettings.aoColumns[i].sSortingClass );
				}
			}
			
			if ( oSettings.aaSortingFixed !== null )
			{
				aaSort = oSettings.aaSortingFixed.concat( oSettings.aaSorting );
			}
			else
			{
				aaSort = oSettings.aaSorting.slice();
			}
			
			/* Apply the required classes to the header */
			for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
			{
				if ( oSettings.aoColumns[i].bSortable )
				{
					sClass = oSettings.aoColumns[i].sSortingClass;
					iFound = -1;
					for ( j=0 ; j<aaSort.length ; j++ )
					{
						if ( aaSort[j][0] == i )
						{
							sClass = ( aaSort[j][1] == "asc" ) ?
								oClasses.sSortAsc : oClasses.sSortDesc;
							iFound = j;
							break;
						}
					}
					$(oSettings.aoColumns[i].nTh).addClass( sClass );
					
					if ( oSettings.bJUI )
					{
						/* jQuery UI uses extra markup */
						var jqSpan = $("span."+oClasses.sSortIcon,  oSettings.aoColumns[i].nTh);
						jqSpan.removeClass(oClasses.sSortJUIAsc +" "+ oClasses.sSortJUIDesc +" "+ 
							oClasses.sSortJUI +" "+ oClasses.sSortJUIAscAllowed +" "+ oClasses.sSortJUIDescAllowed );
						
						var sSpanClass;
						if ( iFound == -1 )
						{
						 	sSpanClass = oSettings.aoColumns[i].sSortingClassJUI;
						}
						else if ( aaSort[iFound][1] == "asc" )
						{
							sSpanClass = oClasses.sSortJUIAsc;
						}
						else
						{
							sSpanClass = oClasses.sSortJUIDesc;
						}
						
						jqSpan.addClass( sSpanClass );
					}
				}
				else
				{
					/* No sorting on this column, so add the base class. This will have been assigned by
					 * _fnAddColumn
					 */
					$(oSettings.aoColumns[i].nTh).addClass( oSettings.aoColumns[i].sSortingClass );
				}
			}
			
			/* 
			 * Apply the required classes to the table body
			 * Note that this is given as a feature switch since it can significantly slow down a sort
			 * on large data sets (adding and removing of classes is always slow at the best of times..)
			 * Further to this, note that this code is admitadly fairly ugly. It could be made a lot 
			 * simpiler using jQuery selectors and add/removeClass, but that is significantly slower
			 * (on the order of 5 times slower) - hence the direct DOM manipulation here.
			 * Note that for defered drawing we do use jQuery - the reason being that taking the first
			 * row found to see if the whole column needs processed can miss classes since the first
			 * column might be new.
			 */
			sClass = oClasses.sSortColumn;
			
			if ( oSettings.oFeatures.bSort && oSettings.oFeatures.bSortClasses )
			{
				var nTds = _fnGetTdNodes( oSettings );
		
				/* Remove the old classes */
				if ( oSettings.oFeatures.bDeferRender )
				{
					$(nTds).removeClass(sClass+'1 '+sClass+'2 '+sClass+'3');
				}
				else if ( nTds.length >= iColumns )
				{
					for ( i=0 ; i<iColumns ; i++ )
					{
						if ( nTds[i].className.indexOf(sClass+"1") != -1 )
						{
							for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
							{
								nTds[(iColumns*j)+i].className = 
									$.trim( nTds[(iColumns*j)+i].className.replace( sClass+"1", "" ) );
							}
						}
						else if ( nTds[i].className.indexOf(sClass+"2") != -1 )
						{
							for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
							{
								nTds[(iColumns*j)+i].className = 
									$.trim( nTds[(iColumns*j)+i].className.replace( sClass+"2", "" ) );
							}
						}
						else if ( nTds[i].className.indexOf(sClass+"3") != -1 )
						{
							for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
							{
								nTds[(iColumns*j)+i].className = 
									$.trim( nTds[(iColumns*j)+i].className.replace( " "+sClass+"3", "" ) );
							}
						}
					}
				}
				
				/* Add the new classes to the table */
				var iClass = 1, iTargetCol;
				for ( i=0 ; i<aaSort.length ; i++ )
				{
					iTargetCol = parseInt( aaSort[i][0], 10 );
					for ( j=0, jLen=(nTds.length/iColumns) ; j<jLen ; j++ )
					{
						nTds[(iColumns*j)+iTargetCol].className += " "+sClass+iClass;
					}
					
					if ( iClass < 3 )
					{
						iClass++;
					}
				}
			}
		}
		
		
		
		/**
		 * Save the state of a table in a cookie such that the page can be reloaded
		 *  @param {object} oSettings dataTables settings object
		 *  @memberof DataTable#oApi
		 */
		function _fnSaveState ( oSettings )
		{
			if ( !oSettings.oFeatures.bStateSave || oSettings.bDestroying )
			{
				return;
			}
		
			/* Store the interesting variables */
			var i, iLen, bInfinite=oSettings.oScroll.bInfinite;
			var oState = {
				"iCreate":      new Date().getTime(),
				"iStart":       (bInfinite ? 0 : oSettings._iDisplayStart),
				"iEnd":         (bInfinite ? oSettings._iDisplayLength : oSettings._iDisplayEnd),
				"iLength":      oSettings._iDisplayLength,
				"aaSorting":    $.extend( true, [], oSettings.aaSorting ),
				"oSearch":      $.extend( true, {}, oSettings.oPreviousSearch ),
				"aoSearchCols": $.extend( true, [], oSettings.aoPreSearchCols ),
				"abVisCols":    []
			};
		
			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				oState.abVisCols.push( oSettings.aoColumns[i].bVisible );
			}
		
			_fnCallbackFire( oSettings, "aoStateSaveParams", 'stateSaveParams', [oSettings, oState] );
			
			oSettings.fnStateSave.call( oSettings.oInstance, oSettings, oState );
		}
		
		
		/**
		 * Attempt to load a saved table state from a cookie
		 *  @param {object} oSettings dataTables settings object
		 *  @param {object} oInit DataTables init object so we can override settings
		 *  @memberof DataTable#oApi
		 */
		function _fnLoadState ( oSettings, oInit )
		{
			if ( !oSettings.oFeatures.bStateSave )
			{
				return;
			}
		
			var oData = oSettings.fnStateLoad.call( oSettings.oInstance, oSettings );
			if ( !oData )
			{
				return;
			}
			
			/* Allow custom and plug-in manipulation functions to alter the saved data set and
			 * cancelling of loading by returning false
			 */
			var abStateLoad = _fnCallbackFire( oSettings, 'aoStateLoadParams', 'stateLoadParams', [oSettings, oData] );
			if ( $.inArray( false, abStateLoad ) !== -1 )
			{
				return;
			}
			
			/* Store the saved state so it might be accessed at any time */
			oSettings.oLoadedState = $.extend( true, {}, oData );
			
			/* Restore key features */
			oSettings._iDisplayStart    = oData.iStart;
			oSettings.iInitDisplayStart = oData.iStart;
			oSettings._iDisplayEnd      = oData.iEnd;
			oSettings._iDisplayLength   = oData.iLength;
			oSettings.aaSorting         = oData.aaSorting.slice();
			oSettings.saved_aaSorting   = oData.aaSorting.slice();
			
			/* Search filtering  */
			$.extend( oSettings.oPreviousSearch, oData.oSearch );
			$.extend( true, oSettings.aoPreSearchCols, oData.aoSearchCols );
			
			/* Column visibility state
			 * Pass back visibiliy settings to the init handler, but to do not here override
			 * the init object that the user might have passed in
			 */
			oInit.saved_aoColumns = [];
			for ( var i=0 ; i<oData.abVisCols.length ; i++ )
			{
				oInit.saved_aoColumns[i] = {};
				oInit.saved_aoColumns[i].bVisible = oData.abVisCols[i];
			}
		
			_fnCallbackFire( oSettings, 'aoStateLoaded', 'stateLoaded', [oSettings, oData] );
		}
		
		
		/**
		 * Create a new cookie with a value to store the state of a table
		 *  @param {string} sName name of the cookie to create
		 *  @param {string} sValue the value the cookie should take
		 *  @param {int} iSecs duration of the cookie
		 *  @param {string} sBaseName sName is made up of the base + file name - this is the base
		 *  @param {function} fnCallback User definable function to modify the cookie
		 *  @memberof DataTable#oApi
		 */
		function _fnCreateCookie ( sName, sValue, iSecs, sBaseName, fnCallback )
		{
			var date = new Date();
			date.setTime( date.getTime()+(iSecs*1000) );
			
			/* 
			 * Shocking but true - it would appear IE has major issues with having the path not having
			 * a trailing slash on it. We need the cookie to be available based on the path, so we
			 * have to append the file name to the cookie name. Appalling. Thanks to vex for adding the
			 * patch to use at least some of the path
			 */
			var aParts = window.location.pathname.split('/');
			var sNameFile = sName + '_' + aParts.pop().replace(/[\/:]/g,"").toLowerCase();
			var sFullCookie, oData;
			
			if ( fnCallback !== null )
			{
				oData = (typeof $.parseJSON === 'function') ? 
					$.parseJSON( sValue ) : eval( '('+sValue+')' );
				sFullCookie = fnCallback( sNameFile, oData, date.toGMTString(),
					aParts.join('/')+"/" );
			}
			else
			{
				sFullCookie = sNameFile + "=" + encodeURIComponent(sValue) +
					"; expires=" + date.toGMTString() +"; path=" + aParts.join('/')+"/";
			}
			
			/* Are we going to go over the cookie limit of 4KiB? If so, try to delete a cookies
			 * belonging to DataTables. This is FAR from bullet proof
			 */
			var sOldName="", iOldTime=9999999999999;
			var iLength = _fnReadCookie( sNameFile )!==null ? document.cookie.length : 
				sFullCookie.length + document.cookie.length;
			
			if ( iLength+10 > 4096 ) /* Magic 10 for padding */
			{
				var aCookies =document.cookie.split(';');
				for ( var i=0, iLen=aCookies.length ; i<iLen ; i++ )
				{
					if ( aCookies[i].indexOf( sBaseName ) != -1 )
					{
						/* It's a DataTables cookie, so eval it and check the time stamp */
						var aSplitCookie = aCookies[i].split('=');
						try { oData = eval( '('+decodeURIComponent(aSplitCookie[1])+')' ); }
						catch( e ) { continue; }
						
						if ( oData.iCreate && oData.iCreate < iOldTime )
						{
							sOldName = aSplitCookie[0];
							iOldTime = oData.iCreate;
						}
					}
				}
				
				if ( sOldName !== "" )
				{
					document.cookie = sOldName+"=; expires=Thu, 01-Jan-1970 00:00:01 GMT; path="+
						aParts.join('/') + "/";
				}
			}
			
			document.cookie = sFullCookie;
		}
		
		
		/**
		 * Read an old cookie to get a cookie with an old table state
		 *  @param {string} sName name of the cookie to read
		 *  @returns {string} contents of the cookie - or null if no cookie with that name found
		 *  @memberof DataTable#oApi
		 */
		function _fnReadCookie ( sName )
		{
			var
				aParts = window.location.pathname.split('/'),
				sNameEQ = sName + '_' + aParts[aParts.length-1].replace(/[\/:]/g,"").toLowerCase() + '=',
			 	sCookieContents = document.cookie.split(';');
			
			for( var i=0 ; i<sCookieContents.length ; i++ )
			{
				var c = sCookieContents[i];
				
				while (c.charAt(0)==' ')
				{
					c = c.substring(1,c.length);
				}
				
				if (c.indexOf(sNameEQ) === 0)
				{
					return decodeURIComponent( c.substring(sNameEQ.length,c.length) );
				}
			}
			return null;
		}
		
		
		
		/**
		 * Return the settings object for a particular table
		 *  @param {node} nTable table we are using as a dataTable
		 *  @returns {object} Settings object - or null if not found
		 *  @memberof DataTable#oApi
		 */
		function _fnSettingsFromNode ( nTable )
		{
			for ( var i=0 ; i<DataTable.settings.length ; i++ )
			{
				if ( DataTable.settings[i].nTable === nTable )
				{
					return DataTable.settings[i];
				}
			}
			
			return null;
		}
		
		
		/**
		 * Return an array with the TR nodes for the table
		 *  @param {object} oSettings dataTables settings object
		 *  @returns {array} TR array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetTrNodes ( oSettings )
		{
			var aNodes = [];
			var aoData = oSettings.aoData;
			for ( var i=0, iLen=aoData.length ; i<iLen ; i++ )
			{
				if ( aoData[i].nTr !== null )
				{
					aNodes.push( aoData[i].nTr );
				}
			}
			return aNodes;
		}
		
		
		/**
		 * Return an flat array with all TD nodes for the table, or row
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} [iIndividualRow] aoData index to get the nodes for - optional 
		 *    if not given then the return array will contain all nodes for the table
		 *  @returns {array} TD array
		 *  @memberof DataTable#oApi
		 */
		function _fnGetTdNodes ( oSettings, iIndividualRow )
		{
			var anReturn = [];
			var iCorrector;
			var anTds;
			var iRow, iRows=oSettings.aoData.length,
				iColumn, iColumns, oData, sNodeName, iStart=0, iEnd=iRows;
			
			/* Allow the collection to be limited to just one row */
			if ( iIndividualRow !== undefined )
			{
				iStart = iIndividualRow;
				iEnd = iIndividualRow+1;
			}
		
			for ( iRow=iStart ; iRow<iEnd ; iRow++ )
			{
				oData = oSettings.aoData[iRow];
				if ( oData.nTr !== null )
				{
					/* get the TD child nodes - taking into account text etc nodes */
					anTds = [];
					for ( iColumn=0, iColumns=oData.nTr.childNodes.length ; iColumn<iColumns ; iColumn++ )
					{
						sNodeName = oData.nTr.childNodes[iColumn].nodeName.toLowerCase();
						if ( sNodeName == 'td' || sNodeName == 'th' )
						{
							anTds.push( oData.nTr.childNodes[iColumn] );
						}
					}
		
					iCorrector = 0;
					for ( iColumn=0, iColumns=oSettings.aoColumns.length ; iColumn<iColumns ; iColumn++ )
					{
						if ( oSettings.aoColumns[iColumn].bVisible )
						{
							anReturn.push( anTds[iColumn-iCorrector] );
						}
						else
						{
							anReturn.push( oData._anHidden[iColumn] );
							iCorrector++;
						}
					}
				}
			}
		
			return anReturn;
		}
		
		
		/**
		 * Log an error message
		 *  @param {object} oSettings dataTables settings object
		 *  @param {int} iLevel log error messages, or display them to the user
		 *  @param {string} sMesg error message
		 *  @memberof DataTable#oApi
		 */
		function _fnLog( oSettings, iLevel, sMesg )
		{
			var sAlert = (oSettings===null) ?
				"DataTables warning: "+sMesg :
				"DataTables warning (table id = '"+oSettings.sTableId+"'): "+sMesg;
			
			if ( iLevel === 0 )
			{
				if ( DataTable.ext.sErrMode == 'alert' )
				{
					alert( sAlert );
				}
				else
				{
					throw sAlert;
				}
				return;
			}
			else if ( console !== undefined && console.log )
			{
				console.log( sAlert );
			}
		}
		
		
		/**
		 * See if a property is defined on one object, if so assign it to the other object
		 *  @param {object} oRet target object
		 *  @param {object} oSrc source object
		 *  @param {string} sName property
		 *  @param {string} [sMappedName] name to map too - optional, sName used if not given
		 *  @memberof DataTable#oApi
		 */
		function _fnMap( oRet, oSrc, sName, sMappedName )
		{
			if ( sMappedName === undefined )
			{
				sMappedName = sName;
			}
			if ( oSrc[sName] !== undefined )
			{
				oRet[sMappedName] = oSrc[sName];
			}
		}
		
		
		/**
		 * Extend objects - very similar to jQuery.extend, but deep copy objects, and shallow
		 * copy arrays. The reason we need to do this, is that we don't want to deep copy array
		 * init values (such as aaSorting) since the dev wouldn't be able to override them, but
		 * we do want to deep copy arrays.
		 *  @param {object} oOut Object to extend
		 *  @param {object} oExtender Object from which the properties will be applied to oOut
		 *  @returns {object} oOut Reference, just for convenience - oOut === the return.
		 *  @memberof DataTable#oApi
		 *  @todo This doesn't take account of arrays inside the deep copied objects.
		 */
		function _fnExtend( oOut, oExtender )
		{
			for ( var prop in oOut )
			{
				if ( oOut.hasOwnProperty(prop) && oExtender[prop] !== undefined )
				{
					if ( typeof oInit[prop] === 'object' && $.isArray(oExtender[prop]) === false )
					{
						$.extend( true, oOut[prop], oExtender[prop] );
					}
					else
					{
						oOut[prop] = oExtender[prop];
					}
				}
			}
		
			return oOut;
		}
		
		
		/**
		 * Bind an event handers to allow a click or return key to activate the callback.
		 * This is good for accessability since a return on the keyboard will have the
		 * same effect as a click, if the element has focus.
		 *  @param {element} n Element to bind the action to
		 *  @param {object} oData Data object to pass to the triggered function
		 *  @param {function) fn Callback function for when the event is triggered
		 *  @memberof DataTable#oApi
		 */
		function _fnBindAction( n, oData, fn )
		{
			$(n)
				.bind( 'click.DT', oData, function (e) {
						fn(e);
						n.blur(); // Remove focus outline for mouse users
					} )
				.bind( 'keypress.DT', oData, function (e){
					if ( e.which === 13 ) {
						fn(e);
					} } )
				.bind( 'selectstart.DT', function () {
					/* Take the brutal approach to cancelling text selection */
					return false;
					} );
		}
		
		
		/**
		 * Register a callback function. Easily allows a callback function to be added to
		 * an array store of callback functions that can then all be called together.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sStore Name of the array storeage for the callbacks in oSettings
		 *  @param {function} fn Function to be called back
		 *  @param {string) sName Identifying name for the callback (i.e. a label)
		 *  @memberof DataTable#oApi
		 */
		function _fnCallbackReg( oSettings, sStore, fn, sName )
		{
			if ( fn )
			{
				oSettings[sStore].push( {
					"fn": fn,
					"sName": sName
				} );
			}
		}
		
		
		/**
		 * Fire callback functions and trigger events. Note that the loop over the callback
		 * array store is done backwards! Further note that you do not want to fire off triggers
		 * in time sensitive applications (for example cell creation) as its slow.
		 *  @param {object} oSettings dataTables settings object
		 *  @param {string} sStore Name of the array storeage for the callbacks in oSettings
		 *  @param {string} sTrigger Name of the jQuery custom event to trigger. If null no trigger
		 *    is fired
		 *  @param {array) aArgs Array of arguments to pass to the callback function / trigger
		 *  @memberof DataTable#oApi
		 */
		function _fnCallbackFire( oSettings, sStore, sTrigger, aArgs )
		{
			var aoStore = oSettings[sStore];
			var aRet =[];
		
			for ( var i=aoStore.length-1 ; i>=0 ; i-- )
			{
				aRet.push( aoStore[i].fn.apply( oSettings.oInstance, aArgs ) );
			}
		
			if ( sTrigger !== null )
			{
				$(oSettings.oInstance).trigger(sTrigger, aArgs);
			}
		
			return aRet;
		}
		
		
		/**
		 * JSON stringify. If JSON.stringify it provided by the browser, json2.js or any other
		 * library, then we use that as it is fast, safe and accurate. If the function isn't 
		 * available then we need to built it ourselves - the insperation for this function comes
		 * from Craig Buckler ( http://www.sitepoint.com/javascript-json-serialization/ ). It is
		 * not perfect and absolutely should not be used as a replacement to json2.js - but it does
		 * do what we need, without requiring a dependency for DataTables.
		 *  @param {object} o JSON object to be converted
		 *  @returns {string} JSON string
		 *  @memberof DataTable#oApi
		 */
		var _fnJsonString = (window.JSON) ? JSON.stringify : function( o )
		{
			/* Not an object or array */
			var sType = typeof o;
			if (sType !== "object" || o === null)
			{
				// simple data type
				if (sType === "string")
				{
					o = '"'+o+'"';
				}
				return o+"";
			}
		
			/* If object or array, need to recurse over it */
			var
				sProp, mValue,
				json = [],
				bArr = $.isArray(o);
			
			for (sProp in o)
			{
				mValue = o[sProp];
				sType = typeof mValue;
		
				if (sType === "string")
				{
					mValue = '"'+mValue+'"';
				}
				else if (sType === "object" && mValue !== null)
				{
					mValue = _fnJsonString(mValue);
				}
		
				json.push((bArr ? "" : '"'+sProp+'":') + mValue);
			}
		
			return (bArr ? "[" : "{") + json + (bArr ? "]" : "}");
		};
		

		
		
		/**
		 * Perform a jQuery selector action on the table's TR elements (from the tbody) and
		 * return the resulting jQuery object.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select TR elements that meet the current filter
		 *    criterion ("applied") or all TR elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the TR elements in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be 
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {object} jQuery object, filtered by the given selector.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Highlight every second row
		 *      oTable.$('tr:odd').css('backgroundColor', 'blue');
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to rows with 'Webkit' in them, add a background colour and then
		 *      // remove the filter, thus highlighting the 'Webkit' rows only.
		 *      oTable.fnFilter('Webkit');
		 *      oTable.$('tr', {"filter": "applied"}).css('backgroundColor', 'blue');
		 *      oTable.fnFilter('');
		 *    } );
		 */
		this.$ = function ( sSelector, oOpts )
		{
			var i, iLen, a = [];
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
		
			if ( !oOpts )
			{
				oOpts = {};
			}
		
			oOpts = $.extend( {}, {
				"filter": "none", // applied
				"order": "current", // "original"
				"page": "all" // current
			}, oOpts );
		
			// Current page implies that order=current and fitler=applied, since it is fairly
			// senseless otherwise
			if ( oOpts.page == 'current' )
			{
				for ( i=oSettings._iDisplayStart, iLen=oSettings.fnDisplayEnd() ; i<iLen ; i++ )
				{
					a.push( oSettings.aoData[ oSettings.aiDisplay[i] ].nTr );
				}
			}
			else if ( oOpts.order == "current" && oOpts.filter == "none" )
			{
				for ( i=0, iLen=oSettings.aiDisplayMaster.length ; i<iLen ; i++ )
				{
					a.push( oSettings.aoData[ oSettings.aiDisplayMaster[i] ].nTr );
				}
			}
			else if ( oOpts.order == "current" && oOpts.filter == "applied" )
			{
				for ( i=0, iLen=oSettings.aiDisplay.length ; i<iLen ; i++ )
				{
					a.push( oSettings.aoData[ oSettings.aiDisplay[i] ].nTr );
				}
			}
			else if ( oOpts.order == "original" && oOpts.filter == "none" )
			{
				for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
				{
					a.push( oSettings.aoData[ i ].nTr );
				}
			}
			else if ( oOpts.order == "original" && oOpts.filter == "applied" )
			{
				for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
				{
					if ( $.inArray( i, oSettings.aiDisplay ) !== -1 )
					{
						a.push( oSettings.aoData[ i ].nTr );
					}
				}
			}
			else
			{
				_fnLog( oSettings, 1, "Unknown selection options" );
			}
		
			/* We need to filter on the TR elements and also 'find' in their descendants
			 * to make the selector act like it would in a full table - so we need
			 * to build both results and then combine them together
			 */
			var jqA = $(a);
			var jqTRs = jqA.filter( sSelector );
			var jqDescendants = jqA.find( sSelector );
		
			return $( [].concat($.makeArray(jqTRs), $.makeArray(jqDescendants)) );
		};
		
		
		/**
		 * Almost identical to $ in operation, but in this case returns the data for the matched
		 * rows - as such, the jQuery selector used should match TR row nodes or TD/TH cell nodes
		 * rather than any decendents, so the data can be obtained for the row/cell. If matching
		 * rows are found, the data returned is the original data array/object that was used to  
		 * create the row (or a generated array if from a DOM source).
		 *
		 * This method is often useful incombination with $ where both functions are given the
		 * same parameters and the array indexes will match identically.
		 *  @param {string|node|jQuery} sSelector jQuery selector or node collection to act on
		 *  @param {object} [oOpts] Optional parameters for modifying the rows to be included
		 *  @param {string} [oOpts.filter=none] Select elements that meet the current filter
		 *    criterion ("applied") or all elements (i.e. no filter).
		 *  @param {string} [oOpts.order=current] Order of the data in the processed array.
		 *    Can be either 'current', whereby the current sorting of the table is used, or
		 *    'original' whereby the original order the data was read into the table is used.
		 *  @param {string} [oOpts.page=all] Limit the selection to the currently displayed page
		 *    ("current") or not ("all"). If 'current' is given, then order is assumed to be 
		 *    'current' and filter is 'applied', regardless of what they might be given as.
		 *  @returns {array} Data for the matched elements. If any elements, as a result of the
		 *    selector, were not TR, TD or TH elements in the DataTable, they will have a null 
		 *    entry in the array.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Get the data from the first row in the table
		 *      var data = oTable._('tr:first');
		 *
		 *      // Do something useful with the data
		 *      alert( "First cell is: "+data[0] );
		 *    } );
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *
		 *      // Filter to 'Webkit' and get all data for 
		 *      oTable.fnFilter('Webkit');
		 *      var data = oTable._('tr', {"filter": "applied"});
		 *      
		 *      // Do something with the data
		 *      alert( data.length+" rows matched the filter" );
		 *    } );
		 */
		this._ = function ( sSelector, oOpts )
		{
			var aOut = [];
			var i, iLen, iIndex;
			var aTrs = this.$( sSelector, oOpts );
		
			for ( i=0, iLen=aTrs.length ; i<iLen ; i++ )
			{
				aOut.push( this.fnGetData(aTrs[i]) );
			}
		
			return aOut;
		};
		
		
		/**
		 * Add a single new row or multiple rows of data to the table. Please note
		 * that this is suitable for client-side processing only - if you are using 
		 * server-side processing (i.e. "bServerSide": true), then to add data, you
		 * must add it to the data source, i.e. the server-side, through an Ajax call.
		 *  @param {array|object} mData The data to be added to the table. This can be:
		 *    <ul>
		 *      <li>1D array of data - add a single row with the data provided</li>
		 *      <li>2D array of arrays - add multiple rows in a single call</li>
		 *      <li>object - data object when using <i>mDataProp</i></li>
		 *      <li>array of objects - multiple data objects when using <i>mDataProp</i></li>
		 *    </ul>
		 *  @param {bool} [bRedraw=true] redraw the table or not
		 *  @returns {array} An array of integers, representing the list of indexes in 
		 *    <i>aoData</i> ({@link DataTable.models.oSettings}) that have been added to 
		 *    the table.
		 *  @dtopt API
		 *
		 *  @example
		 *    // Global var for counter
		 *    var giCount = 2;
		 *    
		 *    $(document).ready(function() {
		 *      $('#example').dataTable();
		 *    } );
		 *    
		 *    function fnClickAddRow() {
		 *      $('#example').dataTable().fnAddData( [
		 *        giCount+".1",
		 *        giCount+".2",
		 *        giCount+".3",
		 *        giCount+".4" ]
		 *      );
		 *        
		 *      giCount++;
		 *    }
		 */
		this.fnAddData = function( mData, bRedraw )
		{
			if ( mData.length === 0 )
			{
				return [];
			}
			
			var aiReturn = [];
			var iTest;
			
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			
			/* Check if we want to add multiple rows or not */
			if ( typeof mData[0] === "object" && mData[0] !== null )
			{
				for ( var i=0 ; i<mData.length ; i++ )
				{
					iTest = _fnAddData( oSettings, mData[i] );
					if ( iTest == -1 )
					{
						return aiReturn;
					}
					aiReturn.push( iTest );
				}
			}
			else
			{
				iTest = _fnAddData( oSettings, mData );
				if ( iTest == -1 )
				{
					return aiReturn;
				}
				aiReturn.push( iTest );
			}
			
			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
			if ( bRedraw === undefined || bRedraw )
			{
				_fnReDraw( oSettings );
			}
			return aiReturn;
		};
		
		
		/**
		 * This function will make DataTables recalculate the column sizes, based on the data 
		 * contained in the table and the sizes applied to the columns (in the DOM, CSS or 
		 * through the sWidth parameter). This can be useful when the width of the table's 
		 * parent element changes (for example a window resize).
		 *  @param {boolean} [bRedraw=true] Redraw the table or not, you will typically want to
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *      
		 *      $(window).bind('resize', function () {
		 *        oTable.fnAdjustColumnSizing();
		 *      } );
		 *    } );
		 */
		this.fnAdjustColumnSizing = function ( bRedraw )
		{
			var oSettings = _fnSettingsFromNode(this[DataTable.ext.iApiIndex]);
			_fnAdjustColumnSizing( oSettings );
			
			if ( bRedraw === undefined || bRedraw )
			{
				this.fnDraw( false );
			}
			else if ( oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "" )
			{
				/* If not redrawing, but scrolling, we want to apply the new column sizes anyway */
				this.oApi._fnScrollDraw(oSettings);
			}
		};
		
		
		/**
		 * Quickly and simply clear a table
		 *  @param {bool} [bRedraw=true] redraw the table or not
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Immediately 'nuke' the current rows (perhaps waiting for an Ajax callback...)
		 *      oTable.fnClearTable();
		 *    } );
		 */
		this.fnClearTable = function( bRedraw )
		{
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			_fnClearTable( oSettings );
			
			if ( bRedraw === undefined || bRedraw )
			{
				_fnDraw( oSettings );
			}
		};
		
		
		/**
		 * The exact opposite of 'opening' a row, this function will close any rows which 
		 * are currently 'open'.
		 *  @param {node} nTr the table row to 'close'
		 *  @returns {int} 0 on success, or 1 if failed (can't find the row)
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnClose = function( nTr )
		{
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			
			for ( var i=0 ; i<oSettings.aoOpenRows.length ; i++ )
			{
				if ( oSettings.aoOpenRows[i].nParent == nTr )
				{
					var nTrParent = oSettings.aoOpenRows[i].nTr.parentNode;
					if ( nTrParent )
					{
						/* Remove it if it is currently on display */
						nTrParent.removeChild( oSettings.aoOpenRows[i].nTr );
					}
					oSettings.aoOpenRows.splice( i, 1 );
					return 0;
				}
			}
			return 1;
		};
		
		
		/**
		 * Remove a row for the table
		 *  @param {mixed} mTarget The index of the row from aoData to be deleted, or
		 *    the TR element you want to delete
		 *  @param {function|null} [fnCallBack] Callback function
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @returns {array} The row that was deleted
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Immediately remove the first row
		 *      oTable.fnDeleteRow( 0 );
		 *    } );
		 */
		this.fnDeleteRow = function( mTarget, fnCallBack, bRedraw )
		{
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			var i, iLen, iAODataIndex;
			
			iAODataIndex = (typeof mTarget === 'object') ? 
				_fnNodeToDataIndex(oSettings, mTarget) : mTarget;
			
			/* Return the data array from this row */
			var oData = oSettings.aoData.splice( iAODataIndex, 1 );
		
			/* Update the _DT_RowIndex parameter */
			for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
			{
				if ( oSettings.aoData[i].nTr !== null )
				{
					oSettings.aoData[i].nTr._DT_RowIndex = i;
				}
			}
			
			/* Remove the target row from the search array */
			var iDisplayIndex = $.inArray( iAODataIndex, oSettings.aiDisplay );
			oSettings.asDataSearch.splice( iDisplayIndex, 1 );
			
			/* Delete from the display arrays */
			_fnDeleteIndex( oSettings.aiDisplayMaster, iAODataIndex );
			_fnDeleteIndex( oSettings.aiDisplay, iAODataIndex );
			
			/* If there is a user callback function - call it */
			if ( typeof fnCallBack === "function" )
			{
				fnCallBack.call( this, oSettings, oData );
			}
			
			/* Check for an 'overflow' they case for dislaying the table */
			if ( oSettings._iDisplayStart >= oSettings.aiDisplay.length )
			{
				oSettings._iDisplayStart -= oSettings._iDisplayLength;
				if ( oSettings._iDisplayStart < 0 )
				{
					oSettings._iDisplayStart = 0;
				}
			}
			
			if ( bRedraw === undefined || bRedraw )
			{
				_fnCalculateEnd( oSettings );
				_fnDraw( oSettings );
			}
			
			return oData;
		};
		
		
		/**
		 * Restore the table to it's original state in the DOM by removing all of DataTables 
		 * enhancements, alterations to the DOM structure of the table and event listeners.
		 *  @param {boolean} [bRemove=false] Completely remove the table from the DOM
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      // This example is fairly pointless in reality, but shows how fnDestroy can be used
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnDestroy();
		 *    } );
		 */
		this.fnDestroy = function ( bRemove )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			var nOrig = oSettings.nTableWrapper.parentNode;
			var nBody = oSettings.nTBody;
			var i, iLen;
		
			bRemove = (bRemove===undefined) ? false : true;
			
			/* Flag to note that the table is currently being destroyed - no action should be taken */
			oSettings.bDestroying = true;
			
			/* Restore hidden columns */
			for ( i=0, iLen=oSettings.aoDestroyCallback.length ; i<iLen ; i++ ) {
				oSettings.aoDestroyCallback[i].fn();
			}
			
			/* Restore hidden columns */
			for ( i=0, iLen=oSettings.aoColumns.length ; i<iLen ; i++ )
			{
				if ( oSettings.aoColumns[i].bVisible === false )
				{
					this.fnSetColumnVis( i, true );
				}
			}
			
			/* Blitz all DT events */
			$(oSettings.nTableWrapper).find('*').andSelf().unbind('.DT');
			
			/* If there is an 'empty' indicator row, remove it */
			$('tbody>tr>td.'+oSettings.oClasses.sRowEmpty, oSettings.nTable).parent().remove();
			
			/* When scrolling we had to break the table up - restore it */
			if ( oSettings.nTable != oSettings.nTHead.parentNode )
			{
				$(oSettings.nTable).children('thead').remove();
				oSettings.nTable.appendChild( oSettings.nTHead );
			}
			
			if ( oSettings.nTFoot && oSettings.nTable != oSettings.nTFoot.parentNode )
			{
				$(oSettings.nTable).children('tfoot').remove();
				oSettings.nTable.appendChild( oSettings.nTFoot );
			}
			
			/* Remove the DataTables generated nodes, events and classes */
			oSettings.nTable.parentNode.removeChild( oSettings.nTable );
			$(oSettings.nTableWrapper).remove();
			
			oSettings.aaSorting = [];
			oSettings.aaSortingFixed = [];
			_fnSortingClasses( oSettings );
			
			$(_fnGetTrNodes( oSettings )).removeClass( oSettings.asStripeClasses.join(' ') );
			
			$('th, td', oSettings.nTHead).removeClass( [
				oSettings.oClasses.sSortable,
				oSettings.oClasses.sSortableAsc,
				oSettings.oClasses.sSortableDesc,
				oSettings.oClasses.sSortableNone ].join(' ')
			);
			if ( oSettings.bJUI )
			{
				$('th span.'+oSettings.oClasses.sSortIcon
					+ ', td span.'+oSettings.oClasses.sSortIcon, oSettings.nTHead).remove();
		
				$('th, td', oSettings.nTHead).each( function () {
					var jqWrapper = $('div.'+oSettings.oClasses.sSortJUIWrapper, this);
					var kids = jqWrapper.contents();
					$(this).append( kids );
					jqWrapper.remove();
				} );
			}
			
			/* Add the TR elements back into the table in their original order */
			if ( !bRemove && oSettings.nTableReinsertBefore )
			{
				nOrig.insertBefore( oSettings.nTable, oSettings.nTableReinsertBefore );
			}
			else if ( !bRemove )
			{
				nOrig.appendChild( oSettings.nTable );
			}
		
			for ( i=0, iLen=oSettings.aoData.length ; i<iLen ; i++ )
			{
				if ( oSettings.aoData[i].nTr !== null )
				{
					nBody.appendChild( oSettings.aoData[i].nTr );
				}
			}
			
			/* Restore the width of the original table */
			if ( oSettings.oFeatures.bAutoWidth === true )
			{
			  oSettings.nTable.style.width = _fnStringToCss(oSettings.sDestroyWidth);
			}
			
			/* If the were originally odd/even type classes - then we add them back here. Note
			 * this is not fool proof (for example if not all rows as odd/even classes - but 
			 * it's a good effort without getting carried away
			 */
			$(nBody).children('tr:even').addClass( oSettings.asDestroyStripes[0] );
			$(nBody).children('tr:odd').addClass( oSettings.asDestroyStripes[1] );
			
			/* Remove the settings object from the settings array */
			for ( i=0, iLen=DataTable.settings.length ; i<iLen ; i++ )
			{
				if ( DataTable.settings[i] == oSettings )
				{
					DataTable.settings.splice( i, 1 );
				}
			}
			
			/* End it all */
			oSettings = null;
		};
		
		
		/**
		 * Redraw the table
		 *  @param {bool} [bComplete=true] Re-filter and resort (if enabled) the table before the draw.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Re-draw the table - you wouldn't want to do it here, but it's an example :-)
		 *      oTable.fnDraw();
		 *    } );
		 */
		this.fnDraw = function( bComplete )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			if ( bComplete )
			{
				_fnCalculateEnd( oSettings );
				_fnDraw( oSettings );
			}
			else
			{
				_fnReDraw( oSettings );
			}
		};
		
		
		/**
		 * Filter the input based on data
		 *  @param {string} sInput String to filter the table on
		 *  @param {int|null} [iColumn] Column to limit filtering to
		 *  @param {bool} [bRegex=false] Treat as regular expression or not
		 *  @param {bool} [bSmart=true] Perform smart filtering or not
		 *  @param {bool} [bShowGlobal=true] Show the input global filter in it's input box(es)
		 *  @param {bool} [bCaseInsensitive=true] Do case-insensitive matching (true) or not (false)
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sometime later - filter...
		 *      oTable.fnFilter( 'test string' );
		 *    } );
		 */
		this.fnFilter = function( sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			
			if ( !oSettings.oFeatures.bFilter )
			{
				return;
			}
			
			if ( bRegex === undefined || bRegex === null )
			{
				bRegex = false;
			}
			
			if ( bSmart === undefined || bSmart === null )
			{
				bSmart = true;
			}
			
			if ( bShowGlobal === undefined || bShowGlobal === null )
			{
				bShowGlobal = true;
			}
			
			if ( bCaseInsensitive === undefined || bCaseInsensitive === null )
			{
				bCaseInsensitive = true;
			}
			
			if ( iColumn === undefined || iColumn === null )
			{
				/* Global filter */
				_fnFilterComplete( oSettings, {
					"sSearch":sInput+"",
					"bRegex": bRegex,
					"bSmart": bSmart,
					"bCaseInsensitive": bCaseInsensitive
				}, 1 );
				
				if ( bShowGlobal && oSettings.aanFeatures.f )
				{
					var n = oSettings.aanFeatures.f;
					for ( var i=0, iLen=n.length ; i<iLen ; i++ )
					{
						$('input', n[i]).val( sInput );
					}
				}
			}
			else
			{
				/* Single column filter */
				$.extend( oSettings.aoPreSearchCols[ iColumn ], {
					"sSearch": sInput+"",
					"bRegex": bRegex,
					"bSmart": bSmart,
					"bCaseInsensitive": bCaseInsensitive
				} );
				_fnFilterComplete( oSettings, oSettings.oPreviousSearch, 1 );
			}
		};
		
		
		/**
		 * Get the data for the whole table, an individual row or an individual cell based on the 
		 * provided parameters.
		 *  @param {int|node} [mRow] A TR row node, TD/TH cell node or an integer. If given as
		 *    a TR node then the data source for the whole row will be returned. If given as a
		 *    TD/TH cell node then iCol will be automatically calculated and the data for the
		 *    cell returned. If given as an integer, then this is treated as the aoData internal
		 *    data index for the row (see fnGetPosition) and the data for that row used.
		 *  @param {int} [iCol] Optional column index that you want the data of.
		 *  @returns {array|object|string} If mRow is undefined, then the data for all rows is
		 *    returned. If mRow is defined, just data for that row, and is iCol is
		 *    defined, only data for the designated cell is returned.
		 *  @dtopt API
		 *
		 *  @example
		 *    // Row data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('tr').click( function () {
		 *        var data = oTable.fnGetData( this );
		 *        // ... do something with the array / object of data for the row
		 *      } );
		 *    } );
		 *
		 *  @example
		 *    // Individual cell data
		 *    $(document).ready(function() {
		 *      oTable = $('#example').dataTable();
		 *
		 *      oTable.$('td').click( function () {
		 *        var sData = oTable.fnGetData( this );
		 *        alert( 'The cell clicked on had the value of '+sData );
		 *      } );
		 *    } );
		 */
		this.fnGetData = function( mRow, iCol )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			
			if ( mRow !== undefined )
			{
				var iRow = mRow;
				if ( typeof mRow === 'object' )
				{
					var sNode = mRow.nodeName.toLowerCase();
					if (sNode === "tr" )
					{
						iRow = _fnNodeToDataIndex(oSettings, mRow);
					}
					else if ( sNode === "td" )
					{
						iRow = _fnNodeToDataIndex(oSettings, mRow.parentNode);
						iCol = _fnNodeToColumnIndex( oSettings, iRow, mRow );
					}
				}
		
				if ( iCol !== undefined )
				{
					return _fnGetCellData( oSettings, iRow, iCol, '' );
				}
				return (oSettings.aoData[iRow]!==undefined) ?
					oSettings.aoData[iRow]._aData : null;
			}
			return _fnGetDataMaster( oSettings );
		};
		
		
		/**
		 * Get an array of the TR nodes that are used in the table's body. Note that you will 
		 * typically want to use the '$' API method in preference to this as it is more 
		 * flexible.
		 *  @param {int} [iRow] Optional row index for the TR element you want
		 *  @returns {array|node} If iRow is undefined, returns an array of all TR elements
		 *    in the table's body, or iRow is defined, just the TR element requested.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Get the nodes from the table
		 *      var nNodes = oTable.fnGetNodes( );
		 *    } );
		 */
		this.fnGetNodes = function( iRow )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			
			if ( iRow !== undefined ) {
				return (oSettings.aoData[iRow]!==undefined) ?
					oSettings.aoData[iRow].nTr : null;
			}
			return _fnGetTrNodes( oSettings );
		};
		
		
		/**
		 * Get the array indexes of a particular cell from it's DOM element
		 * and column index including hidden columns
		 *  @param {node} nNode this can either be a TR, TD or TH in the table's body
		 *  @returns {int} If nNode is given as a TR, then a single index is returned, or
		 *    if given as a cell, an array of [row index, column index (visible)] is given.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example tbody td').click( function () {
		 *        // Get the position of the current data from the node
		 *        var aPos = oTable.fnGetPosition( this );
		 *        
		 *        // Get the data array for this row
		 *        var aData = oTable.fnGetData( aPos[0] );
		 *        
		 *        // Update the data array and return the value
		 *        aData[ aPos[1] ] = 'clicked';
		 *        this.innerHTML = 'clicked';
		 *      } );
		 *      
		 *      // Init DataTables
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnGetPosition = function( nNode )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			var sNodeName = nNode.nodeName.toUpperCase();
			
			if ( sNodeName == "TR" )
			{
				return _fnNodeToDataIndex(oSettings, nNode);
			}
			else if ( sNodeName == "TD" || sNodeName == "TH" )
			{
				var iDataIndex = _fnNodeToDataIndex( oSettings, nNode.parentNode );
				var iColumnIndex = _fnNodeToColumnIndex( oSettings, iDataIndex, nNode );
				return [ iDataIndex, _fnColumnIndexToVisible(oSettings, iColumnIndex ), iColumnIndex ];
			}
			return null;
		};
		
		
		/**
		 * Check to see if a row is 'open' or not.
		 *  @param {node} nTr the table row to check
		 *  @returns {boolean} true if the row is currently open, false otherwise
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnIsOpen = function( nTr )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			var aoOpenRows = oSettings.aoOpenRows;
			
			for ( var i=0 ; i<oSettings.aoOpenRows.length ; i++ )
			{
				if ( oSettings.aoOpenRows[i].nParent == nTr )
				{
					return true;
				}
			}
			return false;
		};
		
		
		/**
		 * This function will place a new row directly after a row which is currently 
		 * on display on the page, with the HTML contents that is passed into the 
		 * function. This can be used, for example, to ask for confirmation that a 
		 * particular record should be deleted.
		 *  @param {node} nTr The table row to 'open'
		 *  @param {string|node|jQuery} mHtml The HTML to put into the row
		 *  @param {string} sClass Class to give the new TD cell
		 *  @returns {node} The row opened. Note that if the table row passed in as the
		 *    first parameter, is not found in the table, this method will silently
		 *    return.
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable;
		 *      
		 *      // 'open' an information row when a row is clicked on
		 *      $('#example tbody tr').click( function () {
		 *        if ( oTable.fnIsOpen(this) ) {
		 *          oTable.fnClose( this );
		 *        } else {
		 *          oTable.fnOpen( this, "Temporary row opened", "info_row" );
		 *        }
		 *      } );
		 *      
		 *      oTable = $('#example').dataTable();
		 *    } );
		 */
		this.fnOpen = function( nTr, mHtml, sClass )
		{
			/* Find settings from table node */
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
		
			/* Check that the row given is in the table */
			var nTableRows = _fnGetTrNodes( oSettings );
			if ( $.inArray(nTr, nTableRows) === -1 )
			{
				return;
			}
			
			/* the old open one if there is one */
			this.fnClose( nTr );
			
			var nNewRow = document.createElement("tr");
			var nNewCell = document.createElement("td");
			nNewRow.appendChild( nNewCell );
			nNewCell.className = sClass;
			nNewCell.colSpan = _fnVisbleColumns( oSettings );
		
			if (typeof mHtml === "string")
			{
				nNewCell.innerHTML = mHtml;
			}
			else
			{
				$(nNewCell).html( mHtml );
			}
		
			/* If the nTr isn't on the page at the moment - then we don't insert at the moment */
			var nTrs = $('tr', oSettings.nTBody);
			if ( $.inArray(nTr, nTrs) != -1  )
			{
				$(nNewRow).insertAfter(nTr);
			}
			
			oSettings.aoOpenRows.push( {
				"nTr": nNewRow,
				"nParent": nTr
			} );
			
			return nNewRow;
		};
		
		
		/**
		 * Change the pagination - provides the internal logic for pagination in a simple API 
		 * function. With this function you can have a DataTables table go to the next, 
		 * previous, first or last pages.
		 *  @param {string|int} mAction Paging action to take: "first", "previous", "next" or "last"
		 *    or page number to jump to (integer), note that page 0 is the first page.
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnPageChange( 'next' );
		 *    } );
		 */
		this.fnPageChange = function ( mAction, bRedraw )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			_fnPageChange( oSettings, mAction );
			_fnCalculateEnd( oSettings );
			
			if ( bRedraw === undefined || bRedraw )
			{
				_fnDraw( oSettings );
			}
		};
		
		
		/**
		 * Show a particular column
		 *  @param {int} iCol The column whose display should be changed
		 *  @param {bool} bShow Show (true) or hide (false) the column
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Hide the second column after initialisation
		 *      oTable.fnSetColumnVis( 1, false );
		 *    } );
		 */
		this.fnSetColumnVis = function ( iCol, bShow, bRedraw )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			var i, iLen;
			var aoColumns = oSettings.aoColumns;
			var aoData = oSettings.aoData;
			var nTd, nCell, anTrs, jqChildren, bAppend, iBefore;
			
			/* No point in doing anything if we are requesting what is already true */
			if ( aoColumns[iCol].bVisible == bShow )
			{
				return;
			}
			
			/* Show the column */
			if ( bShow )
			{
				var iInsert = 0;
				for ( i=0 ; i<iCol ; i++ )
				{
					if ( aoColumns[i].bVisible )
					{
						iInsert++;
					}
				}
				
				/* Need to decide if we should use appendChild or insertBefore */
				bAppend = (iInsert >= _fnVisbleColumns( oSettings ));
		
				/* Which coloumn should we be inserting before? */
				if ( !bAppend )
				{
					for ( i=iCol ; i<aoColumns.length ; i++ )
					{
						if ( aoColumns[i].bVisible )
						{
							iBefore = i;
							break;
						}
					}
				}
		
				for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
				{
					if ( aoData[i].nTr !== null )
					{
						if ( bAppend )
						{
							aoData[i].nTr.appendChild( 
								aoData[i]._anHidden[iCol]
							);
						}
						else
						{
							aoData[i].nTr.insertBefore(
								aoData[i]._anHidden[iCol], 
								_fnGetTdNodes( oSettings, i )[iBefore] );
						}
					}
				}
			}
			else
			{
				/* Remove a column from display */
				for ( i=0, iLen=aoData.length ; i<iLen ; i++ )
				{
					if ( aoData[i].nTr !== null )
					{
						nTd = _fnGetTdNodes( oSettings, i )[iCol];
						aoData[i]._anHidden[iCol] = nTd;
						nTd.parentNode.removeChild( nTd );
					}
				}
			}
		
			/* Clear to set the visible flag */
			aoColumns[iCol].bVisible = bShow;
		
			/* Redraw the header and footer based on the new column visibility */
			_fnDrawHead( oSettings, oSettings.aoHeader );
			if ( oSettings.nTFoot )
			{
				_fnDrawHead( oSettings, oSettings.aoFooter );
			}
			
			/* If there are any 'open' rows, then we need to alter the colspan for this col change */
			for ( i=0, iLen=oSettings.aoOpenRows.length ; i<iLen ; i++ )
			{
				oSettings.aoOpenRows[i].nTr.colSpan = _fnVisbleColumns( oSettings );
			}
			
			/* Do a redraw incase anything depending on the table columns needs it 
			 * (built-in: scrolling) 
			 */
			if ( bRedraw === undefined || bRedraw )
			{
				_fnAdjustColumnSizing( oSettings );
				_fnDraw( oSettings );
			}
			
			_fnSaveState( oSettings );
		};
		
		
		/**
		 * Get the settings for a particular table for external manipulation
		 *  @returns {object} DataTables settings object. See 
		 *    {@link DataTable.models.oSettings}
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      var oSettings = oTable.fnSettings();
		 *      
		 *      // Show an example parameter from the settings
		 *      alert( oSettings._iDisplayStart );
		 *    } );
		 */
		this.fnSettings = function()
		{
			return _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
		};
		
		
		/**
		 * Sort the table by a particular row
		 *  @param {int} iCol the data index to sort on. Note that this will not match the 
		 *    'display index' if you have hidden data entries
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sort immediately with columns 0 and 1
		 *      oTable.fnSort( [ [0,'asc'], [1,'asc'] ] );
		 *    } );
		 */
		this.fnSort = function( aaSort )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			oSettings.aaSorting = aaSort;
			_fnSort( oSettings );
		};
		
		
		/**
		 * Attach a sort listener to an element for a given column
		 *  @param {node} nNode the element to attach the sort listener to
		 *  @param {int} iColumn the column that a click on this node will sort on
		 *  @param {function} [fnCallback] callback function when sort is run
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      
		 *      // Sort on column 1, when 'sorter' is clicked on
		 *      oTable.fnSortListener( document.getElementById('sorter'), 1 );
		 *    } );
		 */
		this.fnSortListener = function( nNode, iColumn, fnCallback )
		{
			_fnSortAttachListener( _fnSettingsFromNode( this[DataTable.ext.iApiIndex] ), nNode, iColumn,
			 	fnCallback );
		};
		
		
		/**
		 * Update a table cell or row - this method will accept either a single value to
		 * update the cell with, an array of values with one element for each column or
		 * an object in the same format as the original data source. The function is
		 * self-referencing in order to make the multi column updates easier.
		 *  @param {object|array|string} mData Data to update the cell/row with
		 *  @param {node|int} mRow TR element you want to update or the aoData index
		 *  @param {int} [iColumn] The column to update (not used of mData is an array or object)
		 *  @param {bool} [bRedraw=true] Redraw the table or not
		 *  @param {bool} [bAction=true] Perform predraw actions or not
		 *  @returns {int} 0 on success, 1 on error
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      oTable.fnUpdate( 'Example update', 0, 0 ); // Single cell
		 *      oTable.fnUpdate( ['a', 'b', 'c', 'd', 'e'], 1, 0 ); // Row
		 *    } );
		 */
		this.fnUpdate = function( mData, mRow, iColumn, bRedraw, bAction )
		{
			var oSettings = _fnSettingsFromNode( this[DataTable.ext.iApiIndex] );
			var iVisibleColumn, i, iLen, sDisplay;
			var iRow = (typeof mRow === 'object') ? 
				_fnNodeToDataIndex(oSettings, mRow) : mRow;
			
			if ( oSettings.__fnUpdateDeep === undefined && $.isArray(mData) && typeof mData === 'object' )
			{
				/* Array update - update the whole row */
				oSettings.aoData[iRow]._aData = mData.slice();
				
				/* Flag to the function that we are recursing */
				oSettings.__fnUpdateDeep = true;
				for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
				{
					this.fnUpdate( _fnGetCellData( oSettings, iRow, i ), iRow, i, false, false );
				}
				oSettings.__fnUpdateDeep = undefined;
			}
			else if ( oSettings.__fnUpdateDeep === undefined && mData !== null && typeof mData === 'object' )
			{
				/* Object update - update the whole row - assume the developer gets the object right */
				oSettings.aoData[iRow]._aData = $.extend( true, {}, mData );
		
				oSettings.__fnUpdateDeep = true;
				for ( i=0 ; i<oSettings.aoColumns.length ; i++ )
				{
					this.fnUpdate( _fnGetCellData( oSettings, iRow, i ), iRow, i, false, false );
				}
				oSettings.__fnUpdateDeep = undefined;
			}
			else
			{
				/* Individual cell update */
				_fnSetCellData( oSettings, iRow, iColumn, mData );
				sDisplay = _fnGetCellData( oSettings, iRow, iColumn, 'display' );
				
				var oCol = oSettings.aoColumns[iColumn];
				if ( oCol.fnRender !== null )
				{
					sDisplay = _fnRender( oSettings, iRow, iColumn );
					if ( oCol.bUseRendered )
					{
						_fnSetCellData( oSettings, iRow, iColumn, sDisplay );
					}
				}
				
				if ( oSettings.aoData[iRow].nTr !== null )
				{
					/* Do the actual HTML update */
					_fnGetTdNodes( oSettings, iRow )[iColumn].innerHTML = sDisplay;
				}
			}
			
			/* Modify the search index for this row (strictly this is likely not needed, since fnReDraw
			 * will rebuild the search array - however, the redraw might be disabled by the user)
			 */
			var iDisplayIndex = $.inArray( iRow, oSettings.aiDisplay );
			oSettings.asDataSearch[iDisplayIndex] = _fnBuildSearchRow( oSettings, 
				_fnGetRowData( oSettings, iRow, 'filter' ) );
			
			/* Perform pre-draw actions */
			if ( bAction === undefined || bAction )
			{
				_fnAdjustColumnSizing( oSettings );
			}
			
			/* Redraw the table */
			if ( bRedraw === undefined || bRedraw )
			{
				_fnReDraw( oSettings );
			}
			return 0;
		};
		
		
		/**
		 * Provide a common method for plug-ins to check the version of DataTables being used, in order
		 * to ensure compatibility.
		 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note that the
		 *    formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to the required
		 *    version, or false if this version of DataTales is not suitable
		 *  @method
		 *  @dtopt API
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
		 */
		this.fnVersionCheck = DataTable.ext.fnVersionCheck;
		
		
		/*
		 * This is really a good bit rubbish this method of exposing the internal methods
		 * publically... - To be fixed in 2.0 using methods on the prototype
		 */
		
		
		/**
		 * Create a wrapper function for exporting an internal functions to an external API.
		 *  @param {string} sFunc API function name
		 *  @returns {function} wrapped function
		 *  @memberof DataTable#oApi
		 */
		function _fnExternApiFunc (sFunc)
		{
			return function() {
				var aArgs = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat( 
					Array.prototype.slice.call(arguments) );
				return DataTable.ext.oApi[sFunc].apply( this, aArgs );
			};
		}
		
		
		/**
		 * Reference to internal functions for use by plug-in developers. Note that these
		 * methods are references to internal functions and are considered to be private.
		 * If you use these methods, be aware that they are liable to change between versions
		 * (check the upgrade notes).
		 *  @namespace
		 */
		this.oApi = {
			"_fnExternApiFunc": _fnExternApiFunc,
			"_fnInitialise": _fnInitialise,
			"_fnInitComplete": _fnInitComplete,
			"_fnLanguageCompat": _fnLanguageCompat,
			"_fnAddColumn": _fnAddColumn,
			"_fnColumnOptions": _fnColumnOptions,
			"_fnAddData": _fnAddData,
			"_fnCreateTr": _fnCreateTr,
			"_fnGatherData": _fnGatherData,
			"_fnBuildHead": _fnBuildHead,
			"_fnDrawHead": _fnDrawHead,
			"_fnDraw": _fnDraw,
			"_fnReDraw": _fnReDraw,
			"_fnAjaxUpdate": _fnAjaxUpdate,
			"_fnAjaxParameters": _fnAjaxParameters,
			"_fnAjaxUpdateDraw": _fnAjaxUpdateDraw,
			"_fnServerParams": _fnServerParams,
			"_fnAddOptionsHtml": _fnAddOptionsHtml,
			"_fnFeatureHtmlTable": _fnFeatureHtmlTable,
			"_fnScrollDraw": _fnScrollDraw,
			"_fnAdjustColumnSizing": _fnAdjustColumnSizing,
			"_fnFeatureHtmlFilter": _fnFeatureHtmlFilter,
			"_fnFilterComplete": _fnFilterComplete,
			"_fnFilterCustom": _fnFilterCustom,
			"_fnFilterColumn": _fnFilterColumn,
			"_fnFilter": _fnFilter,
			"_fnBuildSearchArray": _fnBuildSearchArray,
			"_fnBuildSearchRow": _fnBuildSearchRow,
			"_fnFilterCreateSearch": _fnFilterCreateSearch,
			"_fnDataToSearch": _fnDataToSearch,
			"_fnSort": _fnSort,
			"_fnSortAttachListener": _fnSortAttachListener,
			"_fnSortingClasses": _fnSortingClasses,
			"_fnFeatureHtmlPaginate": _fnFeatureHtmlPaginate,
			"_fnPageChange": _fnPageChange,
			"_fnFeatureHtmlInfo": _fnFeatureHtmlInfo,
			"_fnUpdateInfo": _fnUpdateInfo,
			"_fnFeatureHtmlLength": _fnFeatureHtmlLength,
			"_fnFeatureHtmlProcessing": _fnFeatureHtmlProcessing,
			"_fnProcessingDisplay": _fnProcessingDisplay,
			"_fnVisibleToColumnIndex": _fnVisibleToColumnIndex,
			"_fnColumnIndexToVisible": _fnColumnIndexToVisible,
			"_fnNodeToDataIndex": _fnNodeToDataIndex,
			"_fnVisbleColumns": _fnVisbleColumns,
			"_fnCalculateEnd": _fnCalculateEnd,
			"_fnConvertToWidth": _fnConvertToWidth,
			"_fnCalculateColumnWidths": _fnCalculateColumnWidths,
			"_fnScrollingWidthAdjust": _fnScrollingWidthAdjust,
			"_fnGetWidestNode": _fnGetWidestNode,
			"_fnGetMaxLenString": _fnGetMaxLenString,
			"_fnStringToCss": _fnStringToCss,
			"_fnDetectType": _fnDetectType,
			"_fnSettingsFromNode": _fnSettingsFromNode,
			"_fnGetDataMaster": _fnGetDataMaster,
			"_fnGetTrNodes": _fnGetTrNodes,
			"_fnGetTdNodes": _fnGetTdNodes,
			"_fnEscapeRegex": _fnEscapeRegex,
			"_fnDeleteIndex": _fnDeleteIndex,
			"_fnReOrderIndex": _fnReOrderIndex,
			"_fnColumnOrdering": _fnColumnOrdering,
			"_fnLog": _fnLog,
			"_fnClearTable": _fnClearTable,
			"_fnSaveState": _fnSaveState,
			"_fnLoadState": _fnLoadState,
			"_fnCreateCookie": _fnCreateCookie,
			"_fnReadCookie": _fnReadCookie,
			"_fnDetectHeader": _fnDetectHeader,
			"_fnGetUniqueThs": _fnGetUniqueThs,
			"_fnScrollBarWidth": _fnScrollBarWidth,
			"_fnApplyToChildren": _fnApplyToChildren,
			"_fnMap": _fnMap,
			"_fnGetRowData": _fnGetRowData,
			"_fnGetCellData": _fnGetCellData,
			"_fnSetCellData": _fnSetCellData,
			"_fnGetObjectDataFn": _fnGetObjectDataFn,
			"_fnSetObjectDataFn": _fnSetObjectDataFn,
			"_fnApplyColumnDefs": _fnApplyColumnDefs,
			"_fnBindAction": _fnBindAction,
			"_fnExtend": _fnExtend,
			"_fnCallbackReg": _fnCallbackReg,
			"_fnCallbackFire": _fnCallbackFire,
			"_fnJsonString": _fnJsonString,
			"_fnRender": _fnRender,
			"_fnNodeToColumnIndex": _fnNodeToColumnIndex
		};
		
		$.extend( DataTable.ext.oApi, this.oApi );
		
		for ( var sFunc in DataTable.ext.oApi )
		{
			if ( sFunc )
			{
				this[sFunc] = _fnExternApiFunc(sFunc);
			}
		}
		
		
		var _that = this;
		return this.each(function() {
			
			var i=0, iLen, j, jLen, k, kLen;
			var sId = this.getAttribute( 'id' );
			var bInitHandedOff = false;
			var bUsePassedData = false;
			
			
			/* Sanity check */
			if ( this.nodeName.toLowerCase() != 'table' )
			{
				_fnLog( null, 0, "Attempted to initialise DataTables on a node which is not a "+
					"table: "+this.nodeName );
				return;
			}
			
			/* Check to see if we are re-initialising a table */
			for ( i=0, iLen=DataTable.settings.length ; i<iLen ; i++ )
			{
				/* Base check on table node */
				if ( DataTable.settings[i].nTable == this )
				{
					if ( oInit === undefined || oInit.bRetrieve )
					{
						return DataTable.settings[i].oInstance;
					}
					else if ( oInit.bDestroy )
					{
						DataTable.settings[i].oInstance.fnDestroy();
						break;
					}
					else
					{
						_fnLog( DataTable.settings[i], 0, "Cannot reinitialise DataTable.\n\n"+
							"To retrieve the DataTables object for this table, pass no arguments or see "+
							"the docs for bRetrieve and bDestroy" );
						return;
					}
				}
				
				/* If the element we are initialising has the same ID as a table which was previously
				 * initialised, but the table nodes don't match (from before) then we destroy the old
				 * instance by simply deleting it. This is under the assumption that the table has been
				 * destroyed by other methods. Anyone using non-id selectors will need to do this manually
				 */
				if ( DataTable.settings[i].sTableId == this.id )
				{
					DataTable.settings.splice( i, 1 );
					break;
				}
			}
			
			/* Ensure the table has an ID - required for accessibility */
			if ( sId === null )
			{
				sId = "DataTables_Table_"+(DataTable.ext._oExternConfig.iNextUnique++);
				this.id = sId;
			}
			
			/* Create the settings object for this table and set some of the default parameters */
			var oSettings = $.extend( true, {}, DataTable.models.oSettings, {
				"nTable":        this,
				"oApi":          _that.oApi,
				"oInit":         oInit,
				"sDestroyWidth": $(this).width(),
				"sInstance":     sId,
				"sTableId":      sId
			} );
			DataTable.settings.push( oSettings );
			
			// Need to add the instance after the instance after the settings object has been added
			// to the settings array, so we can self reference the table instance if more than one
			oSettings.oInstance = (_that.length===1) ? _that : $(this).dataTable();
			
			/* Setting up the initialisation object */
			if ( !oInit )
			{
				oInit = {};
			}
			
			// Backwards compatibility, before we apply all the defaults
			if ( oInit.oLanguage )
			{
				_fnLanguageCompat( oInit.oLanguage );
			}
			
			oInit = _fnExtend( $.extend(true, {}, DataTable.defaults), oInit );
			
			// Map the initialisation options onto the settings object
			_fnMap( oSettings.oFeatures, oInit, "bPaginate" );
			_fnMap( oSettings.oFeatures, oInit, "bLengthChange" );
			_fnMap( oSettings.oFeatures, oInit, "bFilter" );
			_fnMap( oSettings.oFeatures, oInit, "bSort" );
			_fnMap( oSettings.oFeatures, oInit, "bInfo" );
			_fnMap( oSettings.oFeatures, oInit, "bProcessing" );
			_fnMap( oSettings.oFeatures, oInit, "bAutoWidth" );
			_fnMap( oSettings.oFeatures, oInit, "bSortClasses" );
			_fnMap( oSettings.oFeatures, oInit, "bServerSide" );
			_fnMap( oSettings.oFeatures, oInit, "bDeferRender" );
			_fnMap( oSettings.oScroll, oInit, "sScrollX", "sX" );
			_fnMap( oSettings.oScroll, oInit, "sScrollXInner", "sXInner" );
			_fnMap( oSettings.oScroll, oInit, "sScrollY", "sY" );
			_fnMap( oSettings.oScroll, oInit, "bScrollCollapse", "bCollapse" );
			_fnMap( oSettings.oScroll, oInit, "bScrollInfinite", "bInfinite" );
			_fnMap( oSettings.oScroll, oInit, "iScrollLoadGap", "iLoadGap" );
			_fnMap( oSettings.oScroll, oInit, "bScrollAutoCss", "bAutoCss" );
			_fnMap( oSettings, oInit, "asStripClasses", "asStripeClasses" ); // legacy
			_fnMap( oSettings, oInit, "asStripeClasses" );
			_fnMap( oSettings, oInit, "fnServerData" );
			_fnMap( oSettings, oInit, "fnFormatNumber" );
			_fnMap( oSettings, oInit, "sServerMethod" );
			_fnMap( oSettings, oInit, "aaSorting" );
			_fnMap( oSettings, oInit, "aaSortingFixed" );
			_fnMap( oSettings, oInit, "aLengthMenu" );
			_fnMap( oSettings, oInit, "sPaginationType" );
			_fnMap( oSettings, oInit, "sAjaxSource" );
			_fnMap( oSettings, oInit, "sAjaxDataProp" );
			_fnMap( oSettings, oInit, "iCookieDuration" );
			_fnMap( oSettings, oInit, "sCookiePrefix" );
			_fnMap( oSettings, oInit, "sDom" );
			_fnMap( oSettings, oInit, "bSortCellsTop" );
			_fnMap( oSettings, oInit, "iTabIndex" );
			_fnMap( oSettings, oInit, "oSearch", "oPreviousSearch" );
			_fnMap( oSettings, oInit, "aoSearchCols", "aoPreSearchCols" );
			_fnMap( oSettings, oInit, "iDisplayLength", "_iDisplayLength" );
			_fnMap( oSettings, oInit, "bJQueryUI", "bJUI" );
			_fnMap( oSettings, oInit, "fnCookieCallback" );
			_fnMap( oSettings, oInit, "fnStateLoad" );
			_fnMap( oSettings, oInit, "fnStateSave" );
			_fnMap( oSettings.oLanguage, oInit, "fnInfoCallback" );
			
			/* Callback functions which are array driven */
			_fnCallbackReg( oSettings, 'aoDrawCallback',       oInit.fnDrawCallback,      'user' );
			_fnCallbackReg( oSettings, 'aoServerParams',       oInit.fnServerParams,      'user' );
			_fnCallbackReg( oSettings, 'aoStateSaveParams',    oInit.fnStateSaveParams,   'user' );
			_fnCallbackReg( oSettings, 'aoStateLoadParams',    oInit.fnStateLoadParams,   'user' );
			_fnCallbackReg( oSettings, 'aoStateLoaded',        oInit.fnStateLoaded,       'user' );
			_fnCallbackReg( oSettings, 'aoRowCallback',        oInit.fnRowCallback,       'user' );
			_fnCallbackReg( oSettings, 'aoRowCreatedCallback', oInit.fnCreatedRow,        'user' );
			_fnCallbackReg( oSettings, 'aoHeaderCallback',     oInit.fnHeaderCallback,    'user' );
			_fnCallbackReg( oSettings, 'aoFooterCallback',     oInit.fnFooterCallback,    'user' );
			_fnCallbackReg( oSettings, 'aoInitComplete',       oInit.fnInitComplete,      'user' );
			_fnCallbackReg( oSettings, 'aoPreDrawCallback',    oInit.fnPreDrawCallback,   'user' );
			
			if ( oSettings.oFeatures.bServerSide && oSettings.oFeatures.bSort &&
				   oSettings.oFeatures.bSortClasses )
			{
				/* Enable sort classes for server-side processing. Safe to do it here, since server-side
				 * processing must be enabled by the developer
				 */
				_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSortingClasses, 'server_side_sort_classes' );
			}
			else if ( oSettings.oFeatures.bDeferRender )
			{
				_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSortingClasses, 'defer_sort_classes' );
			}
			
			if ( oInit.bJQueryUI )
			{
				/* Use the JUI classes object for display. You could clone the oStdClasses object if 
				 * you want to have multiple tables with multiple independent classes 
				 */
				$.extend( oSettings.oClasses, DataTable.ext.oJUIClasses );
				
				if ( oInit.sDom === DataTable.defaults.sDom && DataTable.defaults.sDom === "lfrtip" )
				{
					/* Set the DOM to use a layout suitable for jQuery UI's theming */
					oSettings.sDom = '<"H"lfr>t<"F"ip>';
				}
			}
			else
			{
				$.extend( oSettings.oClasses, DataTable.ext.oStdClasses );
			}
			$(this).addClass( oSettings.oClasses.sTable );
			
			/* Calculate the scroll bar width and cache it for use later on */
			if ( oSettings.oScroll.sX !== "" || oSettings.oScroll.sY !== "" )
			{
				oSettings.oScroll.iBarWidth = _fnScrollBarWidth();
			}
			
			if ( oSettings.iInitDisplayStart === undefined )
			{
				/* Display start point, taking into account the save saving */
				oSettings.iInitDisplayStart = oInit.iDisplayStart;
				oSettings._iDisplayStart = oInit.iDisplayStart;
			}
			
			/* Must be done after everything which can be overridden by a cookie! */
			if ( oInit.bStateSave )
			{
				oSettings.oFeatures.bStateSave = true;
				_fnLoadState( oSettings, oInit );
				_fnCallbackReg( oSettings, 'aoDrawCallback', _fnSaveState, 'state_save' );
			}
			
			if ( oInit.iDeferLoading !== null )
			{
				oSettings.bDeferLoading = true;
				oSettings._iRecordsTotal = oInit.iDeferLoading;
				oSettings._iRecordsDisplay = oInit.iDeferLoading;
			}
			
			if ( oInit.aaData !== null )
			{
				bUsePassedData = true;
			}
			
			/* Language definitions */
			if ( oInit.oLanguage.sUrl !== "" )
			{
				/* Get the language definitions from a file - because this Ajax call makes the language
				 * get async to the remainder of this function we use bInitHandedOff to indicate that 
				 * _fnInitialise will be fired by the returned Ajax handler, rather than the constructor
				 */
				oSettings.oLanguage.sUrl = oInit.oLanguage.sUrl;
				$.getJSON( oSettings.oLanguage.sUrl, null, function( json ) {
					_fnLanguageCompat( json );
					$.extend( true, oSettings.oLanguage, oInit.oLanguage, json );
					_fnInitialise( oSettings );
				} );
				bInitHandedOff = true;
			}
			else
			{
				$.extend( true, oSettings.oLanguage, oInit.oLanguage );
			}
			
			
			/*
			 * Stripes
			 */
			
			/* Remove row stripe classes if they are already on the table row */
			var bStripeRemove = false;
			var anRows = $(this).children('tbody').children('tr');
			for ( i=0, iLen=oSettings.asStripeClasses.length ; i<iLen ; i++ )
			{
				if ( anRows.filter(":lt(2)").hasClass( oSettings.asStripeClasses[i]) )
				{
					bStripeRemove = true;
					break;
				}
			}
					
			if ( bStripeRemove )
			{
				/* Store the classes which we are about to remove so they can be readded on destroy */
				oSettings.asDestroyStripes = [ '', '' ];
				if ( $(anRows[0]).hasClass(oSettings.oClasses.sStripeOdd) )
				{
					oSettings.asDestroyStripes[0] += oSettings.oClasses.sStripeOdd+" ";
				}
				if ( $(anRows[0]).hasClass(oSettings.oClasses.sStripeEven) )
				{
					oSettings.asDestroyStripes[0] += oSettings.oClasses.sStripeEven;
				}
				if ( $(anRows[1]).hasClass(oSettings.oClasses.sStripeOdd) )
				{
					oSettings.asDestroyStripes[1] += oSettings.oClasses.sStripeOdd+" ";
				}
				if ( $(anRows[1]).hasClass(oSettings.oClasses.sStripeEven) )
				{
					oSettings.asDestroyStripes[1] += oSettings.oClasses.sStripeEven;
				}
				
				anRows.removeClass( oSettings.asStripeClasses.join(' ') );
			}
			
			
			/*
			 * Columns
			 * See if we should load columns automatically or use defined ones
			 */
			var anThs = [];
			var aoColumnsInit;
			var nThead = this.getElementsByTagName('thead');
			if ( nThead.length !== 0 )
			{
				_fnDetectHeader( oSettings.aoHeader, nThead[0] );
				anThs = _fnGetUniqueThs( oSettings );
			}
			
			/* If not given a column array, generate one with nulls */
			if ( oInit.aoColumns === null )
			{
				aoColumnsInit = [];
				for ( i=0, iLen=anThs.length ; i<iLen ; i++ )
				{
					aoColumnsInit.push( null );
				}
			}
			else
			{
				aoColumnsInit = oInit.aoColumns;
			}
			
			/* Add the columns */
			for ( i=0, iLen=aoColumnsInit.length ; i<iLen ; i++ )
			{
				/* Short cut - use the loop to check if we have column visibility state to restore */
				if ( oInit.saved_aoColumns !== undefined && oInit.saved_aoColumns.length == iLen )
				{
					if ( aoColumnsInit[i] === null )
					{
						aoColumnsInit[i] = {};
					}
					aoColumnsInit[i].bVisible = oInit.saved_aoColumns[i].bVisible;
				}
				
				_fnAddColumn( oSettings, anThs ? anThs[i] : null );
			}
			
			/* Apply the column definitions */
			_fnApplyColumnDefs( oSettings, oInit.aoColumnDefs, aoColumnsInit, function (iCol, oDef) {
				_fnColumnOptions( oSettings, iCol, oDef );
			} );
			
			
			/*
			 * Sorting
			 * Check the aaSorting array
			 */
			for ( i=0, iLen=oSettings.aaSorting.length ; i<iLen ; i++ )
			{
				if ( oSettings.aaSorting[i][0] >= oSettings.aoColumns.length )
				{
					oSettings.aaSorting[i][0] = 0;
				}
				var oColumn = oSettings.aoColumns[ oSettings.aaSorting[i][0] ];
				
				/* Add a default sorting index */
				if ( oSettings.aaSorting[i][2] === undefined )
				{
					oSettings.aaSorting[i][2] = 0;
				}
				
				/* If aaSorting is not defined, then we use the first indicator in asSorting */
				if ( oInit.aaSorting === undefined && oSettings.saved_aaSorting === undefined )
				{
					oSettings.aaSorting[i][1] = oColumn.asSorting[0];
				}
				
				/* Set the current sorting index based on aoColumns.asSorting */
				for ( j=0, jLen=oColumn.asSorting.length ; j<jLen ; j++ )
				{
					if ( oSettings.aaSorting[i][1] == oColumn.asSorting[j] )
					{
						oSettings.aaSorting[i][2] = j;
						break;
					}
				}
			}
				
			/* Do a first pass on the sorting classes (allows any size changes to be taken into
			 * account, and also will apply sorting disabled classes if disabled
			 */
			_fnSortingClasses( oSettings );
			
			
			/*
			 * Final init
			 * Cache the header, body and footer as required, creating them if needed
			 */
			var thead = $(this).children('thead');
			if ( thead.length === 0 )
			{
				thead = [ document.createElement( 'thead' ) ];
				this.appendChild( thead[0] );
			}
			oSettings.nTHead = thead[0];
			
			var tbody = $(this).children('tbody');
			if ( tbody.length === 0 )
			{
				tbody = [ document.createElement( 'tbody' ) ];
				this.appendChild( tbody[0] );
			}
			oSettings.nTBody = tbody[0];
			oSettings.nTBody.setAttribute( "role", "alert" );
			oSettings.nTBody.setAttribute( "aria-live", "polite" );
			oSettings.nTBody.setAttribute( "aria-relevant", "all" );
			
			var tfoot = $(this).children('tfoot');
			if ( tfoot.length > 0 )
			{
				oSettings.nTFoot = tfoot[0];
				_fnDetectHeader( oSettings.aoFooter, oSettings.nTFoot );
			}
			
			/* Check if there is data passing into the constructor */
			if ( bUsePassedData )
			{
				for ( i=0 ; i<oInit.aaData.length ; i++ )
				{
					_fnAddData( oSettings, oInit.aaData[ i ] );
				}
			}
			else
			{
				/* Grab the data from the page */
				_fnGatherData( oSettings );
			}
			
			/* Copy the data index array */
			oSettings.aiDisplay = oSettings.aiDisplayMaster.slice();
			
			/* Initialisation complete - table can be drawn */
			oSettings.bInitialised = true;
			
			/* Check if we need to initialise the table (it might not have been handed off to the
			 * language processor)
			 */
			if ( bInitHandedOff === false )
			{
				_fnInitialise( oSettings );
			}
		} );
	};

	/**
	 * Version string for plug-ins to check compatibility. Allowed format is
	 * a.b.c.d.e where: a:int, b:int, c:int, d:string(dev|beta), e:int. d and
	 * e are optional
	 *  @member
	 *  @type string
	 *  @default Version number
	 */
	DataTable.version = "1.9.0";

	/**
	 * Private data store, containing all of the settings objects that are created for the
	 * tables on a given page.
	 * 
	 * Note that the <i>DataTable.settings</i> object is aliased to <i>jQuery.fn.dataTableExt</i> 
	 * through which it may be accessed and manipulated, or <i>jQuery.fn.dataTable.settings</i>.
	 *  @member
	 *  @type array
	 *  @default []
	 *  @private
	 */
	DataTable.settings = [];

	/**
	 * Object models container, for the various models that DataTables has available
	 * to it. These models define the objects that are used to hold the active state 
	 * and configuration of the table.
	 *  @namespace
	 */
	DataTable.models = {};
	
	
	/**
	 * DataTables extension options and plug-ins. This namespace acts as a collection "area"
	 * for plug-ins that can be used to extend the default DataTables behaviour - indeed many
	 * of the build in methods use this method to provide their own capabilities (sorting methods
	 * for example).
	 * 
	 * Note that this namespace is aliased to jQuery.fn.dataTableExt so it can be readily accessed
	 * and modified by plug-ins.
	 *  @namespace
	 */
	DataTable.models.ext = {
		/**
		 * Plug-in filtering functions - this method of filtering is complimentary to the default
		 * type based filtering, and a lot more comprehensive as it allows you complete control
		 * over the filtering logic. Each element in this array is a function (parameters
		 * described below) that is called for every row in the table, and your logic decides if
		 * it should be included in the filtered data set or not.
		 *   <ul>
		 *     <li>
		 *       Function input parameters:
		 *       <ul>
		 *         <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
		 *         <li>{array|object} Data for the row to be processed (same as the original format
		 *           that was passed in as the data source, or an array from a DOM data source</li>
		 *         <li>{int} Row index in aoData ({@link DataTable.models.oSettings.aoData}), which can
		 *           be useful to retrieve the TR element if you need DOM interaction.</li>
		 *       </ul>
		 *     </li>
		 *     <li>
		 *       Function return:
		 *       <ul>
		 *         <li>{boolean} Include the row in the filtered result set (true) or not (false)</li>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 *  @type array
		 *  @default []
		 *
		 *  @example
		 *    // The following example shows custom filtering being applied to the fourth column (i.e.
		 *    // the aData[3] index) based on two input values from the end-user, matching the data in 
		 *    // a certain range.
		 *    $.fn.dataTableExt.afnFiltering.push(
		 *      function( oSettings, aData, iDataIndex ) {
		 *        var iMin = document.getElementById('min').value * 1;
		 *        var iMax = document.getElementById('max').value * 1;
		 *        var iVersion = aData[3] == "-" ? 0 : aData[3]*1;
		 *        if ( iMin == "" && iMax == "" ) {
		 *          return true;
		 *        }
		 *        else if ( iMin == "" && iVersion < iMax ) {
		 *          return true;
		 *        }
		 *        else if ( iMin < iVersion && "" == iMax ) {
		 *          return true;
		 *        }
		 *        else if ( iMin < iVersion && iVersion < iMax ) {
		 *          return true;
		 *        }
		 *        return false;
		 *      }
		 *    );
		 */
		"afnFiltering": [],
	
	
		/**
		 * Plug-in sorting functions - this method of sorting is complimentary to the default type
		 * based sorting that DataTables does automatically, allowing much greater control over the
		 * the data that is being used to sort a column. This is useful if you want to do sorting
		 * based on live data (for example the contents of an 'input' element) rather than just the
		 * static string that DataTables knows of. The way these plug-ins work is that you create
		 * an array of the values you wish to be sorted for the column in question and then return
		 * that array. Which pre-sorting function is run here depends on the sSortDataType parameter
		 * that is used for the column (if any). This is the corollary of <i>ofnSearch</i> for sort 
		 * data.
		 *   <ul>
	     *     <li>
	     *       Function input parameters:
	     *       <ul>
		 *         <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
	     *         <li>{int} Target column index</li>
	     *       </ul>
	     *     </li>
		 *     <li>
		 *       Function return:
		 *       <ul>
		 *         <li>{array} Data for the column to be sorted upon</li>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 *  
		 * Note that as of v1.9, it is typically preferable to use <i>mDataProp</i> to prepare data for
		 * the different uses that DataTables can put the data to. Specifically <i>mDataProp</i> when
		 * used as a function will give you a 'type' (sorting, filtering etc) that you can use to 
		 * prepare the data as required for the different types. As such, this method is deprecated.
		 *  @type array
		 *  @default []
		 *  @deprecated
		 *
		 *  @example
		 *    // Updating the cached sorting information with user entered values in HTML input elements
		 *    jQuery.fn.dataTableExt.afnSortData['dom-text'] = function ( oSettings, iColumn )
		 *    {
		 *      var aData = [];
		 *      $( 'td:eq('+iColumn+') input', oSettings.oApi._fnGetTrNodes(oSettings) ).each( function () {
		 *        aData.push( this.value );
		 *      } );
		 *      return aData;
		 *    }
		 */
		"afnSortData": [],
	
	
		/**
		 * Feature plug-ins - This is an array of objects which describe the feature plug-ins that are
		 * available to DataTables. These feature plug-ins are accessible through the sDom initialisation
		 * option. As such, each feature plug-in must describe a function that is used to initialise
		 * itself (fnInit), a character so the feature can be enabled by sDom (cFeature) and the name
		 * of the feature (sFeature). Thus the objects attached to this method must provide:
		 *   <ul>
		 *     <li>{function} fnInit Initialisation of the plug-in
		 *       <ul>
	     *         <li>
	     *           Function input parameters:
	     *           <ul>
		 *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
	     *           </ul>
	     *         </li>
		 *         <li>
		 *           Function return:
		 *           <ul>
		 *             <li>{node|null} The element which contains your feature. Note that the return
		 *                may also be void if your plug-in does not require to inject any DOM elements 
		 *                into DataTables control (sDom) - for example this might be useful when 
		 *                developing a plug-in which allows table control via keyboard entry.</li>
		 *           </ul>
		 *         </il>
		 *       </ul>
		 *     </li>
		 *     <li>{character} cFeature Character that will be matched in sDom - case sensitive</li>
		 *     <li>{string} sFeature Feature name</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 * 
		 *  @example
		 *    // How TableTools initialises itself.
		 *    $.fn.dataTableExt.aoFeatures.push( {
		 *      "fnInit": function( oSettings ) {
		 *        return new TableTools( { "oDTSettings": oSettings } );
		 *      },
		 *      "cFeature": "T",
		 *      "sFeature": "TableTools"
		 *    } );
		 */
		"aoFeatures": [],
	
	
		/**
		 * Type detection plug-in functions - DataTables utilises types to define how sorting and
		 * filtering behave, and types can be either  be defined by the developer (sType for the
		 * column) or they can be automatically detected by the methods in this array. The functions
		 * defined in the array are quite simple, taking a single parameter (the data to analyse) 
		 * and returning the type if it is a known type, or null otherwise.
		 *   <ul>
	     *     <li>
	     *       Function input parameters:
	     *       <ul>
		 *         <li>{*} Data from the column cell to be analysed</li>
	     *       </ul>
	     *     </li>
		 *     <li>
		 *       Function return:
		 *       <ul>
		 *         <li>{string|null} Data type detected, or null if unknown (and thus pass it
		 *           on to the other type detection functions.</li>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 *  @type array
		 *  @default []
		 *  
		 *  @example
		 *    // Currency type detection plug-in:
		 *    jQuery.fn.dataTableExt.aTypes.push(
		 *      function ( sData ) {
		 *        var sValidChars = "0123456789.-";
		 *        var Char;
		 *        
		 *        // Check the numeric part
		 *        for ( i=1 ; i<sData.length ; i++ ) {
		 *          Char = sData.charAt(i); 
		 *          if (sValidChars.indexOf(Char) == -1) {
		 *            return null;
		 *          }
		 *        }
		 *        
		 *        // Check prefixed by currency
		 *        if ( sData.charAt(0) == '$' || sData.charAt(0) == '&pound;' ) {
		 *          return 'currency';
		 *        }
		 *        return null;
		 *      }
		 *    );
		 */
		"aTypes": [],
	
	
		/**
		 * Provide a common method for plug-ins to check the version of DataTables being used, 
		 * in order to ensure compatibility.
		 *  @type function
		 *  @param {string} sVersion Version string to check for, in the format "X.Y.Z". Note 
		 *    that the formats "X" and "X.Y" are also acceptable.
		 *  @returns {boolean} true if this version of DataTables is greater or equal to the 
		 *    required version, or false if this version of DataTales is not suitable
		 *
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable();
		 *      alert( oTable.fnVersionCheck( '1.9.0' ) );
		 *    } );
		 */
		"fnVersionCheck": function( sVersion )
		{
			/* This is cheap, but very effective */
			var fnZPad = function (Zpad, count)
			{
				while(Zpad.length < count) {
					Zpad += '0';
				}
				return Zpad;
			};
			var aThis = DataTable.ext.sVersion.split('.');
			var aThat = sVersion.split('.');
			var sThis = '', sThat = '';
			
			for ( var i=0, iLen=aThat.length ; i<iLen ; i++ )
			{
				sThis += fnZPad( aThis[i], 3 );
				sThat += fnZPad( aThat[i], 3 );
			}
			
			return parseInt(sThis, 10) >= parseInt(sThat, 10);
		},
	
	
		/**
		 * Index for what 'this' index API functions should use
		 *  @type int
		 *  @default 0
		 */
		"iApiIndex": 0,
	
	
		/**
		 * Pre-processing of filtering data plug-ins - When you assign the sType for a column
		 * (or have it automatically detected for you by DataTables or a type detection plug-in), 
		 * you will typically be using this for custom sorting, but it can also be used to provide 
		 * custom filtering by allowing you to pre-processing the data and returning the data in
		 * the format that should be filtered upon. This is done by adding functions this object 
		 * with a parameter name which matches the sType for that target column. This is the
		 * corollary of <i>afnSortData</i> for filtering data.
		 *   <ul>
	     *     <li>
	     *       Function input parameters:
	     *       <ul>
		 *         <li>{*} Data from the column cell to be prepared for filtering</li>
	     *       </ul>
	     *     </li>
		 *     <li>
		 *       Function return:
		 *       <ul>
		 *         <li>{string|null} Formatted string that will be used for the filtering.</li>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 * 
		 * Note that as of v1.9, it is typically preferable to use <i>mDataProp</i> to prepare data for
		 * the different uses that DataTables can put the data to. Specifically <i>mDataProp</i> when
		 * used as a function will give you a 'type' (sorting, filtering etc) that you can use to 
		 * prepare the data as required for the different types. As such, this method is deprecated.
		 *  @type object
		 *  @default {}
		 *  @deprecated
		 *
		 *  @example
		 *    $.fn.dataTableExt.ofnSearch['title-numeric'] = function ( sData ) {
		 *      return sData.replace(/\n/g," ").replace( /<.*?>/g, "" );
		 *    }
		 */
		"ofnSearch": {},
	
	
		/**
		 * Container for all private functions in DataTables so they can be exposed externally
		 *  @type object
		 *  @default {}
		 */
		"oApi": {},
	
	
		/**
		 * Storage for the various classes that DataTables uses
		 *  @type object
		 *  @default {}
		 */
		"oStdClasses": {},
		
	
		/**
		 * Storage for the various classes that DataTables uses - jQuery UI suitable
		 *  @type object
		 *  @default {}
		 */
		"oJUIClasses": {},
	
	
		/**
		 * Pagination plug-in methods - The style and controls of the pagination can significantly 
		 * impact on how the end user interacts with the data in your table, and DataTables allows 
		 * the addition of pagination controls by extending this object, which can then be enabled
		 * through the <i>sPaginationType</i> initialisation parameter. Each pagination type that
		 * is added is an object (the property name of which is what <i>sPaginationType</i> refers
		 * to) that has two properties, both methods that are used by DataTables to update the
		 * control's state.
		 *   <ul>
		 *     <li>
		 *       fnInit -  Initialisation of the paging controls. Called only during initialisation 
		 *         of the table. It is expected that this function will add the required DOM elements 
		 *         to the page for the paging controls to work. The element pointer 
		 *         'oSettings.aanFeatures.p' array is provided by DataTables to contain the paging 
		 *         controls (note that this is a 2D array to allow for multiple instances of each 
		 *         DataTables DOM element). It is suggested that you add the controls to this element 
		 *         as children
		 *       <ul>
	     *         <li>
	     *           Function input parameters:
	     *           <ul>
		 *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
		 *             <li>{node} Container into which the pagination controls must be inserted</li>
		 *             <li>{function} Draw callback function - whenever the controls cause a page
		 *               change, this method must be called to redraw the table.</li>
	     *           </ul>
	     *         </li>
		 *         <li>
		 *           Function return:
		 *           <ul>
		 *             <li>No return required</li>
		 *           </ul>
		 *         </il>
		 *       </ul>
		 *     </il>
		 *     <li>
		 *       fnInit -  This function is called whenever the paging status of the table changes and is
		 *         typically used to update classes and/or text of the paging controls to reflex the new 
		 *         status.
		 *       <ul>
	     *         <li>
	     *           Function input parameters:
	     *           <ul>
		 *             <li>{object} DataTables settings object: see {@link DataTable.models.oSettings}.</li>
		 *             <li>{function} Draw callback function - in case you need to redraw the table again
		 *               or attach new event listeners</li>
	     *           </ul>
	     *         </li>
		 *         <li>
		 *           Function return:
		 *           <ul>
		 *             <li>No return required</li>
		 *           </ul>
		 *         </il>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    $.fn.dataTableExt.oPagination.four_button = {
		 *      "fnInit": function ( oSettings, nPaging, fnCallbackDraw ) {
		 *        nFirst = document.createElement( 'span' );
		 *        nPrevious = document.createElement( 'span' );
		 *        nNext = document.createElement( 'span' );
		 *        nLast = document.createElement( 'span' );
		 *        
		 *        nFirst.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sFirst ) );
		 *        nPrevious.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sPrevious ) );
		 *        nNext.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sNext ) );
		 *        nLast.appendChild( document.createTextNode( oSettings.oLanguage.oPaginate.sLast ) );
		 *        
		 *        nFirst.className = "paginate_button first";
		 *        nPrevious.className = "paginate_button previous";
		 *        nNext.className="paginate_button next";
		 *        nLast.className = "paginate_button last";
		 *        
		 *        nPaging.appendChild( nFirst );
		 *        nPaging.appendChild( nPrevious );
		 *        nPaging.appendChild( nNext );
		 *        nPaging.appendChild( nLast );
		 *        
		 *        $(nFirst).click( function () {
		 *          oSettings.oApi._fnPageChange( oSettings, "first" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nPrevious).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "previous" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nNext).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "next" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nLast).click( function() {
		 *          oSettings.oApi._fnPageChange( oSettings, "last" );
		 *          fnCallbackDraw( oSettings );
		 *        } );
		 *        
		 *        $(nFirst).bind( 'selectstart', function () { return false; } );
		 *        $(nPrevious).bind( 'selectstart', function () { return false; } );
		 *        $(nNext).bind( 'selectstart', function () { return false; } );
		 *        $(nLast).bind( 'selectstart', function () { return false; } );
		 *      },
		 *      
		 *      "fnUpdate": function ( oSettings, fnCallbackDraw ) {
		 *        if ( !oSettings.aanFeatures.p ) {
		 *          return;
		 *        }
		 *        
		 *        // Loop over each instance of the pager
		 *        var an = oSettings.aanFeatures.p;
		 *        for ( var i=0, iLen=an.length ; i<iLen ; i++ ) {
		 *          var buttons = an[i].getElementsByTagName('span');
		 *          if ( oSettings._iDisplayStart === 0 ) {
		 *            buttons[0].className = "paginate_disabled_previous";
		 *            buttons[1].className = "paginate_disabled_previous";
		 *          }
		 *          else {
		 *            buttons[0].className = "paginate_enabled_previous";
		 *            buttons[1].className = "paginate_enabled_previous";
		 *          }
		 *          
		 *          if ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() ) {
		 *            buttons[2].className = "paginate_disabled_next";
		 *            buttons[3].className = "paginate_disabled_next";
		 *          }
		 *          else {
		 *            buttons[2].className = "paginate_enabled_next";
		 *            buttons[3].className = "paginate_enabled_next";
		 *          }
		 *        }
		 *      }
		 *    };
		 */
		"oPagination": {},
	
	
		/**
		 * Sorting plug-in methods - Sorting in DataTables is based on the detected type of the
		 * data column (you can add your own type detection functions, or override automatic 
		 * detection using sType). With this specific type given to the column, DataTables will 
		 * apply the required sort from the functions in the object. Each sort type must provide
		 * two mandatory methods, one each for ascending and descending sorting, and can optionally
		 * provide a pre-formatting method that will help speed up sorting by allowing DataTables
		 * to pre-format the sort data only once (rather than every time the actual sort functions
		 * are run). The two sorting functions are typical Javascript sort methods:
		 *   <ul>
	     *     <li>
	     *       Function input parameters:
	     *       <ul>
		 *         <li>{*} Data to compare to the second parameter</li>
		 *         <li>{*} Data to compare to the first parameter</li>
	     *       </ul>
	     *     </li>
		 *     <li>
		 *       Function return:
		 *       <ul>
		 *         <li>{int} Sorting match: <0 if first parameter should be sorted lower than
		 *           the second parameter, ===0 if the two parameters are equal and >0 if
		 *           the first parameter should be sorted height than the second parameter.</li>
		 *       </ul>
		 *     </il>
		 *   </ul>
		 *  @type object
		 *  @default {}
		 *
		 *  @example
		 *    // Case-sensitive string sorting, with no pre-formatting method
		 *    $.extend( $.fn.dataTableExt.oSort, {
		 *      "string-case-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-case-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
		 *
		 *  @example
		 *    // Case-insensitive string sorting, with pre-formatting
		 *    $.extend( $.fn.dataTableExt.oSort, {
		 *      "string-pre": function(x) {
		 *        return x.toLowerCase();
		 *      },
		 *      "string-asc": function(x,y) {
		 *        return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		 *      },
		 *      "string-desc": function(x,y) {
		 *        return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		 *      }
		 *    } );
		 */
		"oSort": {},
	
	
		/**
		 * Version string for plug-ins to check compatibility. Allowed format is
		 * a.b.c.d.e where: a:int, b:int, c:int, d:string(dev|beta), e:int. d and
		 * e are optional
		 *  @type string
		 *  @default Version number
		 */
		"sVersion": DataTable.version,
	
	
		/**
		 * How should DataTables report an error. Can take the value 'alert' or 'throw'
		 *  @type string
		 *  @default alert
		 */
		"sErrMode": "alert",
	
	
		/**
		 * Store information for DataTables to access globally about other instances
		 *  @namespace
		 *  @private
		 */
		"_oExternConfig": {
			/* int:iNextUnique - next unique number for an instance */
			"iNextUnique": 0
		}
	};
	
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * search information for the global filter and individual column filters.
	 *  @namespace
	 */
	DataTable.models.oSearch = {
		/**
		 * Flag to indicate if the filtering should be case insensitive or not
		 *  @type boolean
		 *  @default true
		 */
		"bCaseInsensitive": true,
	
		/**
		 * Applied search term
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sSearch": "",
	
		/**
		 * Flag to indicate if the search term should be interpreted as a
		 * regular expression (true) or not (false) and therefore and special
		 * regex characters escaped.
		 *  @type boolean
		 *  @default false
		 */
		"bRegex": false,
	
		/**
		 * Flag to indicate if DataTables is to use its smart filtering or not.
		 *  @type boolean
		 *  @default true
		 */
		"bSmart": true
	};
	
	
	
	
	/**
	 * Template object for the way in which DataTables holds information about
	 * each individual row. This is the object format used for the settings 
	 * aoData array.
	 *  @namespace
	 */
	DataTable.models.oRow = {
		/**
		 * TR element for the row
		 *  @type node
		 *  @default null
		 */
		"nTr": null,
	
		/**
		 * Data object from the original data source for the row. This is either
		 * an array if using the traditional form of DataTables, or an object if
		 * using mDataProp options. The exact type will depend on the passed in
		 * data from the data source, or will be an array if using DOM a data 
		 * source.
		 *  @type array|object
		 *  @default []
		 */
		"_aData": [],
	
		/**
		 * Sorting data cache - this array is ostensibly the same length as the
		 * number of columns (although each index is generated only as it is 
		 * needed), and holds the data that is used for sorting each column in the
		 * row. We do this cache generation at the start of the sort in order that
		 * the formatting of the sort data need be done only once for each cell
		 * per sort. This array should not be read from or written to by anything
		 * other than the master sorting methods.
		 *  @type array
		 *  @default []
		 *  @private
		 */
		"_aSortData": [],
	
		/**
		 * Array of TD elements that are cached for hidden rows, so they can be
		 * reinserted into the table if a column is made visible again (or to act
		 * as a store if a column is made hidden). Only hidden columns have a 
		 * reference in the array. For non-hidden columns the value is either
		 * undefined or null.
		 *  @type array nodes
		 *  @default []
		 *  @private
		 */
		"_anHidden": [],
	
		/**
		 * Cache of the class name that DataTables has applied to the row, so we
		 * can quickly look at this variable rather than needing to do a DOM check
		 * on className for the nTr property.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *  @private
		 */
		"_sRowStripe": ""
	};
	
	
	
	/**
	 * Template object for the column information object in DataTables. This object
	 * is held in the settings aoColumns array and contains all the information that
	 * DataTables needs about each individual column.
	 * 
	 * Note that this object is related to {@link DataTable.defaults.columns} 
	 * but this one is the internal data store for DataTables's cache of columns.
	 * It should NOT be manipulated outside of DataTables. Any configuration should
	 * be done through the initialisation options.
	 *  @namespace
	 */
	DataTable.models.oColumn = {
		/**
		 * A list of the columns that sorting should occur on when this column
		 * is sorted. That this property is an array allows multi-column sorting
		 * to be defined for a column (for example first name / last name columns
		 * would benefit from this). The values are integers pointing to the
		 * columns to be sorted on (typically it will be a single integer pointing
		 * at itself, but that doesn't need to be the case).
		 *  @type array
		 */
		"aDataSort": null,
	
		/**
		 * Define the sorting directions that are applied to the column, in sequence
		 * as the column is repeatedly sorted upon - i.e. the first value is used
		 * as the sorting direction when the column if first sorted (clicked on).
		 * Sort it again (click again) and it will move on to the next index.
		 * Repeat until loop.
		 *  @type array
		 */
		"asSorting": null,
		
		/**
		 * Flag to indicate if the column is searchable, and thus should be included
		 * in the filtering or not.
		 *  @type boolean
		 */
		"bSearchable": null,
		
		/**
		 * Flag to indicate if the column is sortable or not.
		 *  @type boolean
		 */
		"bSortable": null,
		
		/**
		 * When using fnRender, you have two options for what to do with the data,
		 * and this property serves as the switch. Firstly, you can have the sorting
		 * and filtering use the rendered value (true - default), or you can have
		 * the sorting and filtering us the original value (false).
		 * 
		 * *NOTE* It is it is advisable now to use mDataProp as a function and make 
		 * use of the 'type' that it gives, allowing (potentially) different data to
		 * be used for sorting, filtering, display and type detection.
		 *  @type boolean
		 *  @deprecated
		 */
		"bUseRendered": null,
		
		/**
		 * Flag to indicate if the column is currently visible in the table or not
		 *  @type boolean
		 */
		"bVisible": null,
		
		/**
		 * Flag to indicate to the type detection method if the automatic type
		 * detection should be used, or if a column type (sType) has been specified
		 *  @type boolean
		 *  @default true
		 *  @private
		 */
		"_bAutoType": true,
		
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to fnRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available (since it is not when fnRender is called).
		 *  @type function
		 *  @param {element} nTd The TD node that has been created
		 *  @param {*} sData The Data for the cell
		 *  @param {array|object} oData The data for the whole row
		 *  @param {int} iRow The row index for the aoData data store
		 *  @default null
		 */
		"fnCreatedCell": null,
		
		/**
		 * Function to get data from a cell in a column. You should <b>never</b>
		 * access data directly through _aData internally in DataTables - always use
		 * the method attached to this property. It allows mDataProp to function as
		 * required. This function is automatically assigned by the column 
		 * initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array 
		 *    (i.e. aoData[]._aData)
		 *  @param {string} sSpecific The specific data type you want to get - 
		 *    'display', 'type' 'filter' 'sort'
		 *  @returns {*} The data for the cell from the given row's data
		 *  @default null
		 */
		"fnGetData": null,
		
		/**
		 * Custom display function that will be called for the display of each cell 
		 * in this column.
		 *  @type function
		 *  @param {object} o Object with the following parameters:
		 *  @param {int}    o.iDataRow The row in aoData
		 *  @param {int}    o.iDataColumn The column in question
		 *  @param {array   o.aData The data for the row in question
		 *  @param {object} o.oSettings The settings object for this DataTables instance
		 *  @returns {string} The string you which to use in the display
		 *  @default null
		 */
		"fnRender": null,
		
		/**
		 * Function to set data for a cell in the column. You should <b>never</b> 
		 * set the data directly to _aData internally in DataTables - always use
		 * this method. It allows mDataProp to function as required. This function
		 * is automatically assigned by the column initialisation method
		 *  @type function
		 *  @param {array|object} oData The data array/object for the array 
		 *    (i.e. aoData[]._aData)
		 *  @param {*} sValue Value to set
		 *  @default null
		 */
		"fnSetData": null,
		
		/**
		 * Property to read the value for the cells in the column from the data 
		 * source array / object. If null, then the default content is used, if a
		 * function is given then the return from the function is used.
		 *  @type function|int|string|null
		 *  @default null
		 */
		"mDataProp": null,
		
		/**
		 * Unique header TH/TD element for this column - this is what the sorting
		 * listener is attached to (if sorting is enabled.)
		 *  @type node
		 *  @default null
		 */
		"nTh": null,
		
		/**
		 * Unique footer TH/TD element for this column (if there is one). Not used 
		 * in DataTables as such, but can be used for plug-ins to reference the 
		 * footer for each column.
		 *  @type node
		 *  @default null
		 */
		"nTf": null,
		
		/**
		 * The class to apply to all TD elements in the table's TBODY for the column
		 *  @type string
		 *  @default null
		 */
		"sClass": null,
		
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer 
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 *  @type string
		 */
		"sContentPadding": null,
		
		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because mDataProp
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 */
		"sDefaultContent": null,
		
		/**
		 * Name for the column, allowing reference to the column by name as well as
		 * by index (needs a lookup to work by name).
		 *  @type string
		 */
		"sName": null,
		
		/**
		 * Custom sorting data type - defines which of the available plug-ins in
		 * afnSortData the custom sorting will use - if any is defined.
		 *  @type string
		 *  @default std
		 */
		"sSortDataType": 'std',
		
		/**
		 * Class to be applied to the header element when sorting on this column
		 *  @type string
		 *  @default null
		 */
		"sSortingClass": null,
		
		/**
		 * Class to be applied to the header element when sorting on this column -
		 * when jQuery UI theming is used.
		 *  @type string
		 *  @default null
		 */
		"sSortingClassJUI": null,
		
		/**
		 * Title of the column - what is seen in the TH element (nTh).
		 *  @type string
		 */
		"sTitle": null,
		
		/**
		 * Column sorting and filtering type
		 *  @type string
		 *  @default null
		 */
		"sType": null,
		
		/**
		 * Width of the column
		 *  @type string
		 *  @default null
		 */
		"sWidth": null,
		
		/**
		 * Width of the column when it was first "encountered"
		 *  @type string
		 *  @default null
		 */
		"sWidthOrig": null
	};
	
	
	
	/**
	 * Initialisation options that can be given to DataTables at initialisation 
	 * time.
	 *  @namespace
	 */
	DataTable.defaults = {
		/**
		 * An array of data to use for the table, passed in at initialisation which 
		 * will be used in preference to any data which is already in the DOM. This is
		 * particularly useful for constructing tables purely in Javascript, for
		 * example with a custom Ajax call.
		 *  @type array
		 *  @default null
		 *  @dtopt Option
		 * 
		 *  @example
		 *    // Using a 2D array data source
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "aaData": [
		 *          ['Trident', 'Internet Explorer 4.0', 'Win 95+', 4, 'X'],
		 *          ['Trident', 'Internet Explorer 5.0', 'Win 95+', 5, 'C'],
		 *        ],
		 *        "aoColumns": [
		 *          { "sTitle": "Engine" },
		 *          { "sTitle": "Browser" },
		 *          { "sTitle": "Platform" },
		 *          { "sTitle": "Version" },
		 *          { "sTitle": "Grade" }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using an array of objects as a data source (mDataProp)
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "aaData": [
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 4.0",
		 *            "platform": "Win 95+",
		 *            "version":  4,
		 *            "grade":    "X"
		 *          },
		 *          {
		 *            "engine":   "Trident",
		 *            "browser":  "Internet Explorer 5.0",
		 *            "platform": "Win 95+",
		 *            "version":  5,
		 *            "grade":    "C"
		 *          }
		 *        ],
		 *        "aoColumns": [
		 *          { "sTitle": "Engine",   "mDataProp": "engine" },
		 *          { "sTitle": "Browser",  "mDataProp": "browser" },
		 *          { "sTitle": "Platform", "mDataProp": "platform" },
		 *          { "sTitle": "Version",  "mDataProp": "version" },
		 *          { "sTitle": "Grade",    "mDataProp": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"aaData": null,
	
	
		/**
		 * If sorting is enabled, then DataTables will perform a first pass sort on 
		 * initialisation. You can define which column(s) the sort is performed upon, 
		 * and the sorting direction, with this variable. The aaSorting array should 
		 * contain an array for each column to be sorted initially containing the 
		 * column's index and a direction string ('asc' or 'desc').
		 *  @type array
		 *  @default [[0,'asc']]
		 *  @dtopt Option
		 * 
		 *  @example
		 *    // Sort by 3rd column first, and then 4th column
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSorting": [[2,'asc'], [3,'desc']]
		 *      } );
		 *    } );
		 *    
		 *    // No initial sorting
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSorting": []
		 *      } );
		 *    } );
		 */
		"aaSorting": [[0,'asc']],
	
	
		/**
		 * This parameter is basically identical to the aaSorting parameter, but 
		 * cannot be overridden by user interaction with the table. What this means 
		 * is that you could have a column (visible or hidden) which the sorting will 
		 * always be forced on first - any sorting after that (from the user) will 
		 * then be performed as required. This can be useful for grouping rows 
		 * together.
		 *  @type array
		 *  @default null
		 *  @dtopt Option
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aaSortingFixed": [[0,'asc']]
		 *      } );
		 *    } )
		 */
		"aaSortingFixed": null,
	
	
		/**
		 * This parameter allows you to readily specify the entries in the length drop
		 * down menu that DataTables shows when pagination is enabled. It can be 
		 * either a 1D array of options which will be used for both the displayed 
		 * option and the value, or a 2D array which will use the array in the first 
		 * position as the value, and the array in the second position as the 
		 * displayed options (useful for language strings such as 'All').
		 *  @type array
		 *  @default [ 10, 25, 50, 100 ]
		 *  @dtopt Option
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aLengthMenu": [[10, 25, 50, -1], [10, 25, 50, "All"]]
		 *      } );
		 *    } );
		 *  
		 *  @example
		 *    // Setting the default display length as well as length menu
		 *    // This is likely to be wanted if you remove the '10' option which
		 *    // is the iDisplayLength default.
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayLength": 25,
		 *        "aLengthMenu": [[25, 50, 100, -1], [25, 50, 100, "All"]]
		 *      } );
		 *    } );
		 */
		"aLengthMenu": [ 10, 25, 50, 100 ],
	
	
		/**
		 * The aoColumns option in the initialisation parameter allows you to define
		 * details about the way individual columns behave. For a full list of
		 * column options that can be set, please see 
		 * {@link DataTable.defaults.columns}. Note that if you use aoColumns to
		 * define your columns, you must have an entry in the array for every single
		 * column that you have in your table (these can be null if you don't which
		 * to specify any options).
		 *  @member
		 */
		"aoColumns": null,
	
		/**
		 * Very similar to aoColumns, aoColumnDefs allows you to target a specific 
		 * column, multiple columns, or all columns, using the aTargets property of 
		 * each object in the array. This allows great flexibility when creating 
		 * tables, as the aoColumnDefs arrays can be of any length, targeting the 
		 * columns you specifically want. aoColumnDefs may use any of the column 
		 * options available: {@link DataTable.defaults.columns}, but it _must_
		 * have aTargets defined in each object in the array. Values in the aTargets
		 * array may be:
		 *   <ul>
		 *     <li>a string - class name will be matched on the TH for the column</li>
		 *     <li>0 or a positive integer - column index counting from the left</li>
		 *     <li>a negative integer - column index counting from the right</li>
		 *     <li>the string "_all" - all columns (i.e. assign a default)</li>
		 *   </ul>
		 *  @member
		 */
		"aoColumnDefs": null,
	
	
		/**
		 * Basically the same as oSearch, this parameter defines the individual column
		 * filtering state at initialisation time. The array must be of the same size 
		 * as the number of columns, and each element be an object with the parameters
		 * "sSearch" and "bEscapeRegex" (the latter is optional). 'null' is also
		 * accepted and the default will be used.
		 *  @type array
		 *  @default []
		 *  @dtopt Option
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "aoSearchCols": [
		 *          null,
		 *          { "sSearch": "My filter" },
		 *          null,
		 *          { "sSearch": "^[0-9]", "bEscapeRegex": false }
		 *        ]
		 *      } );
		 *    } )
		 */
		"aoSearchCols": [],
	
	
		/**
		 * An array of CSS classes that should be applied to displayed rows. This 
		 * array may be of any length, and DataTables will apply each class 
		 * sequentially, looping when required.
		 *  @type array
		 *  @default [ 'odd', 'even' ]
		 *  @dtopt Option
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "asStripeClasses": [ 'strip1', 'strip2', 'strip3' ]
		 *      } );
		 *    } )
		 */
		"asStripeClasses": [ 'odd', 'even' ],
	
	
		/**
		 * Enable or disable automatic column width calculation. This can be disabled
		 * as an optimisation (it takes some time to calculate the widths) if the
		 * tables widths are passed in using aoColumns.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bAutoWidth": false
		 *      } );
		 *    } );
		 */
		"bAutoWidth": true,
	
	
		/**
		 * Deferred rendering can provide DataTables with a huge speed boost when you
		 * are using an Ajax or JS data source for the table. This option, when set to
		 * true, will cause DataTables to defer the creation of the table elements for
		 * each row until they are needed for a draw - saving a significant amount of
		 * time.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/arrays.txt",
		 *        "bDeferRender": true
		 *      } );
		 *    } );
		 */
		"bDeferRender": false,
	
	
		/**
		 * Replace a DataTable which matches the given selector and replace it with 
		 * one which has the properties of the new initialisation object passed. If no
		 * table matches the selector, then the new DataTable will be constructed as
		 * per normal.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *      
		 *      // Some time later....
		 *      $('#example').dataTable( {
		 *        "bFilter": false,
		 *        "bDestroy": true
		 *      } );
		 *    } );
		 */
		"bDestroy": false,
	
	
		/**
		 * Enable or disable filtering of data. Filtering in DataTables is "smart" in
		 * that it allows the end user to input multiple words (space separated) and
		 * will match a row containing those words, even if not in the order that was
		 * specified (this allow matching across multiple columns). Note that if you
		 * wish to use filtering in DataTables this must remain 'true' - to remove the
		 * default filtering input box and retain filtering abilities, please use
		 * @ref{sDom}.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bFilter": false
		 *      } );
		 *    } );
		 */
		"bFilter": true,
	
	
		/**
		 * Enable or disable the table information display. This shows information 
		 * about the data that is currently visible on the page, including information
		 * about filtered data if that action is being performed.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bInfo": false
		 *      } );
		 *    } );
		 */
		"bInfo": true,
	
	
		/**
		 * Enable jQuery UI ThemeRoller support (required as ThemeRoller requires some
		 * slightly different and additional mark-up from what DataTables has
		 * traditionally used).
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "bJQueryUI": true
		 *      } );
		 *    } );
		 */
		"bJQueryUI": false,
	
	
		/**
		 * Allows the end user to select the size of a formatted page from a select
		 * menu (sizes are 10, 25, 50 and 100). Requires pagination (bPaginate).
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bLengthChange": false
		 *      } );
		 *    } );
		 */
		"bLengthChange": true,
	
	
		/**
		 * Enable or disable pagination.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bPaginate": false
		 *      } );
		 *    } );
		 */
		"bPaginate": true,
	
	
		/**
		 * Enable or disable the display of a 'processing' indicator when the table is
		 * being processed (e.g. a sort). This is particularly useful for tables with
		 * large amounts of data where it can take a noticeable amount of time to sort
		 * the entries.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true
		 *      } );
		 *    } );
		 */
		"bProcessing": false,
	
	
		/**
		 * Retrieve the DataTables object for the given selector. Note that if the
		 * table has already been initialised, this parameter will cause DataTables
		 * to simply return the object that has already been set up - it will not take
		 * account of any changes you might have made to the initialisation object
		 * passed to DataTables (setting this parameter to true is an acknowledgement
		 * that you understand this). bDestroy can be used to reinitialise a table if
		 * you need.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      initTable();
		 *      tableActions();
		 *    } );
		 *    
		 *    function initTable ()
		 *    {
		 *      return $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false,
		 *        "bRetrieve": true
		 *      } );
		 *    }
		 *    
		 *    function tableActions ()
		 *    {
		 *      var oTable = initTable();
		 *      // perform API operations with oTable 
		 *    }
		 */
		"bRetrieve": false,
	
	
		/**
		 * Indicate if DataTables should be allowed to set the padding / margin
		 * etc for the scrolling header elements or not. Typically you will want
		 * this.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bScrollAutoCss": false,
		 *        "sScrollY": "200px"
		 *      } );
		 *    } );
		 */
		"bScrollAutoCss": true,
	
	
		/**
		 * When vertical (y) scrolling is enabled, DataTables will force the height of
		 * the table's viewport to the given height at all times (useful for layout).
		 * However, this can look odd when filtering data down to a small data set,
		 * and the footer is left "floating" further down. This parameter (when
		 * enabled) will cause DataTables to collapse the table's viewport down when
		 * the result set will fit within the given Y height.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200",
		 *        "bScrollCollapse": true
		 *      } );
		 *    } );
		 */
		"bScrollCollapse": false,
	
	
		/**
		 * Enable infinite scrolling for DataTables (to be used in combination with
		 * sScrollY). Infinite scrolling means that DataTables will continually load
		 * data as a user scrolls through a table, which is very useful for large
		 * dataset. This cannot be used with pagination, which is automatically
		 * disabled. Note - the Scroller extra for DataTables is recommended in
		 * in preference to this option.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bScrollInfinite": true,
		 *        "bScrollCollapse": true,
		 *        "sScrollY": "200px"
		 *      } );
		 *    } );
		 */
		"bScrollInfinite": false,
	
	
		/**
		 * Configure DataTables to use server-side processing. Note that the
		 * sAjaxSource parameter must also be given in order to give DataTables a
		 * source to obtain the required data for each draw.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "xhr.php"
		 *      } );
		 *    } );
		 */
		"bServerSide": false,
	
	
		/**
		 * Enable or disable sorting of columns. Sorting of individual columns can be
		 * disabled by the "bSortable" option for each column.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bSort": false
		 *      } );
		 *    } );
		 */
		"bSort": true,
	
	
		/**
		 * Allows control over whether DataTables should use the top (true) unique
		 * cell that is found for a single column, or the bottom (false - default).
		 * This is useful when using complex headers.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bSortCellsTop": true
		 *      } );
		 *    } );
		 */
		"bSortCellsTop": false,
	
	
		/**
		 * Enable or disable the addition of the classes 'sorting_1', 'sorting_2' and
		 * 'sorting_3' to the columns which are currently being sorted on. This is
		 * presented as a feature switch as it can increase processing time (while
		 * classes are removed and added) so for large data sets you might want to
		 * turn this off.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bSortClasses": false
		 *      } );
		 *    } );
		 */
		"bSortClasses": true,
	
	
		/**
		 * Enable or disable state saving. When enabled a cookie will be used to save
		 * table display information such as pagination information, display length,
		 * filtering and sorting. As such when the end user reloads the page the
		 * display display will match what thy had previously set up.
		 *  @type boolean
		 *  @default false
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true
		 *      } );
		 *    } );
		 */
		"bStateSave": false,
	
	
		/**
		 * Customise the cookie and / or the parameters being stored when using
		 * DataTables with state saving enabled. This function is called whenever
		 * the cookie is modified, and it expects a fully formed cookie string to be
		 * returned. Note that the data object passed in is a Javascript object which
		 * must be converted to a string (JSON.stringify for example).
		 *  @type function
		 *  @param {string} sName Name of the cookie defined by DataTables
		 *  @param {object} oData Data to be stored in the cookie
		 *  @param {string} sExpires Cookie expires string
		 *  @param {string} sPath Path of the cookie to set
		 *  @returns {string} Cookie formatted string (which should be encoded by
		 *    using encodeURIComponent())
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function () {
		 *      $('#example').dataTable( {
		 *        "fnCookieCallback": function (sName, oData, sExpires, sPath) {
		 *          // Customise oData or sName or whatever else here
		 *          return sName + "="+JSON.stringify(oData)+"; expires=" + sExpires +"; path=" + sPath;
		 *        }
		 *      } );
		 *    } );
		 */
		"fnCookieCallback": null,
	
	
		/**
		 * This function is called when a TR element is created (and all TD child
		 * elements have been inserted), or registered if using a DOM source, allowing
		 * manipulation of the TR element (adding classes etc).
		 *  @type function
		 *  @param {node} nRow "TR" element for the current row
		 *  @param {array} aData Raw data array for this row
		 *  @param {int} iDataIndex The index of this row in aoData
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "fnCreatedRow": function( nRow, aData, iDataIndex ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( aData[4] == "A" )
		 *          {
		 *            $('td:eq(4)', nRow).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnCreatedRow": null,
	
	
		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify any aspect you want about the created DOM.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnDrawCallback": function() {
		 *          alert( 'DataTables has redrawn the table' );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnDrawCallback": null,
	
	
		/**
		 * Identical to fnHeaderCallback() but for the table footer this function
		 * allows you to modify the table footer on every 'draw' even.
		 *  @type function
		 *  @param {node} nFoot "TR" element for the footer
		 *  @param {array} aData Full table data (as derived from the original HTML)
		 *  @param {int} iStart Index for the current display starting point in the 
		 *    display array
		 *  @param {int} iEnd Index for the current display ending point in the 
		 *    display array
		 *  @param {array int} aiDisplay Index array to translate the visual position
		 *    to the full data array
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnFooterCallback": function( nFoot, aData, iStart, iEnd, aiDisplay ) {
		 *          nFoot.getElementsByTagName('th')[0].innerHTML = "Starting index is "+iStart;
		 *        }
		 *      } );
		 *    } )
		 */
		"fnFooterCallback": null,
	
	
		/**
		 * When rendering large numbers in the information element for the table
		 * (i.e. "Showing 1 to 10 of 57 entries") DataTables will render large numbers
		 * to have a comma separator for the 'thousands' units (e.g. 1 million is
		 * rendered as "1,000,000") to help readability for the end user. This
		 * function will override the default method DataTables uses.
		 *  @type function
		 *  @member
		 *  @param {int} iIn number to be formatted
		 *  @returns {string} formatted string for DataTables to show the number
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "fnFormatNumber": function ( iIn ) {
		 *          if ( iIn &lt; 1000 ) {
		 *            return iIn;
		 *          } else {
		 *            var 
		 *              s=(iIn+""), 
		 *              a=s.split(""), out="", 
		 *              iLen=s.length;
		 *            
		 *            for ( var i=0 ; i&lt;iLen ; i++ ) {
		 *              if ( i%3 === 0 &amp;&amp; i !== 0 ) {
		 *                out = "'"+out;
		 *              }
		 *              out = a[iLen-i-1]+out;
		 *            }
		 *          }
		 *          return out;
		 *        };
		 *      } );
		 *    } );
		 */
		"fnFormatNumber": function ( iIn ) {
			if ( iIn < 1000 )
			{
				// A small optimisation for what is likely to be the majority of use cases
				return iIn;
			}
	
			var s=(iIn+""), a=s.split(""), out="", iLen=s.length;
			
			for ( var i=0 ; i<iLen ; i++ )
			{
				if ( i%3 === 0 && i !== 0 )
				{
					out = this.oLanguage.sInfoThousands+out;
				}
				out = a[iLen-i-1]+out;
			}
			return out;
		},
	
	
		/**
		 * This function is called on every 'draw' event, and allows you to
		 * dynamically modify the header row. This can be used to calculate and
		 * display useful information about the table.
		 *  @type function
		 *  @param {node} nHead "TR" element for the header
		 *  @param {array} aData Full table data (as derived from the original HTML)
		 *  @param {int} iStart Index for the current display starting point in the
		 *    display array
		 *  @param {int} iEnd Index for the current display ending point in the
		 *    display array
		 *  @param {array int} aiDisplay Index array to translate the visual position
		 *    to the full data array
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnHeaderCallback": function( nHead, aData, iStart, iEnd, aiDisplay ) {
		 *          nHead.getElementsByTagName('th')[0].innerHTML = "Displaying "+(iEnd-iStart)+" records";
		 *        }
		 *      } );
		 *    } )
		 */
		"fnHeaderCallback": null,
	
	
		/**
		 * The information element can be used to convey information about the current
		 * state of the table. Although the internationalisation options presented by
		 * DataTables are quite capable of dealing with most customisations, there may
		 * be times where you wish to customise the string further. This callback
		 * allows you to do exactly that.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {int} iStart Starting position in data for the draw
		 *  @param {int} iEnd End position in data for the draw
		 *  @param {int} iMax Total number of rows in the table (regardless of
		 *    filtering)
		 *  @param {int} iTotal Total number of rows in the data set, after filtering
		 *  @param {string} sPre The string that DataTables has formatted using it's
		 *    own rules
		 *  @returns {string} The string to be displayed in the information element.
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $('#example').dataTable( {
		 *      "fnInfoCallback": function( oSettings, iStart, iEnd, iMax, iTotal, sPre ) {
		 *        return iStart +" to "+ iEnd;
		 *      }
		 *    } );
		 */
		"fnInfoCallback": null,
	
	
		/**
		 * Called when the table has been initialised. Normally DataTables will
		 * initialise sequentially and there will be no need for this function,
		 * however, this does not hold true when using external language information
		 * since that is obtained using an async XHR call.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} json The JSON object request from the server - only
		 *    present if client-side Ajax sourced data is used
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnInitComplete": function(oSettings, json) {
		 *          alert( 'DataTables has finished its initialisation.' );
		 *        }
		 *      } );
		 *    } )
		 */
		"fnInitComplete": null,
	
	
		/**
		 * Called at the very start of each table draw and can be used to cancel the
		 * draw by returning false, any other return (including undefined) results in
		 * the full draw occurring).
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @returns {boolean} False will cancel the draw, anything else (including no
		 *    return) will allow it to complete.
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "fnPreDrawCallback": function( oSettings ) {
		 *          if ( $('#test').val() == 1 ) {
		 *            return false;
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnPreDrawCallback": null,
	
	
		/**
		 * This function allows you to 'post process' each row after it have been
		 * generated for each table draw, but before it is rendered on screen. This
		 * function might be used for setting the row class name etc.
		 *  @type function
		 *  @param {node} nRow "TR" element for the current row
		 *  @param {array} aData Raw data array for this row
		 *  @param {int} iDisplayIndex The display index for the current table draw
		 *  @param {int} iDisplayIndexFull The index of the data in the full list of
		 *    rows (after filtering)
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "fnRowCallback": function( nRow, aData, iDisplayIndex, iDisplayIndexFull ) {
		 *          // Bold the grade for all 'A' grade browsers
		 *          if ( aData[4] == "A" )
		 *          {
		 *            $('td:eq(4)', nRow).html( '<b>A</b>' );
		 *          }
		 *        }
		 *      } );
		 *    } );
		 */
		"fnRowCallback": null,
	
	
		/**
		 * This parameter allows you to override the default function which obtains
		 * the data from the server ($.getJSON) so something more suitable for your
		 * application. For example you could use POST data, or pull information from
		 * a Gears or AIR database.
		 *  @type function
		 *  @member
		 *  @param {string} sSource HTTP source to obtain the data from (sAjaxSource)
		 *  @param {array} aoData A key/value pair object containing the data to send
		 *    to the server
		 *  @param {function} fnCallback to be called on completion of the data get
		 *    process that will draw the data on the page.
		 *  @param {object} oSettings DataTables settings object
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    // POST data to server
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true,
		 *        "bServerSide": true,
		 *        "sAjaxSource": "xhr.php",
		 *        "fnServerData": function ( sSource, aoData, fnCallback ) {
		 *          $.ajax( {
		 *            "dataType": 'json', 
		 *            "type": "POST", 
		 *            "url": sSource, 
		 *            "data": aoData, 
		 *            "success": fnCallback
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnServerData": function ( sUrl, aoData, fnCallback, oSettings ) {
			oSettings.jqXHR = $.ajax( {
				"url":  sUrl,
				"data": aoData,
				"success": function (json) {
					$(oSettings.oInstance).trigger('xhr', oSettings);
					fnCallback( json );
				},
				"dataType": "json",
				"cache": false,
				"type": oSettings.sServerMethod,
				"error": function (xhr, error, thrown) {
					if ( error == "parsererror" ) {
						alert( "DataTables warning: JSON data from server could not be parsed. "+
							"This is caused by a JSON formatting error." );
					}
				}
			} );
		},
	
	
		/**
		 * It is often useful to send extra data to the server when making an Ajax
		 * request - for example custom filtering information, and this callback
		 * function makes it trivial to send extra information to the server. The
		 * passed in parameter is the data set that has been constructed by
		 * DataTables, and you can add to this or modify it as you require.
		 *  @type function
		 *  @param {array} aoData Data array (array of objects which are name/value
		 *    pairs) that has been constructed by DataTables and will be sent to the
		 *    server. In the case of Ajax sourced data with server-side processing
		 *    this will be an empty array, for server-side processing there will be a
		 *    significant number of parameters!
		 *  @returns {undefined} Ensure that you modify the aoData array passed in,
		 *    as this is passed by reference.
		 *  @dtopt Callbacks
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bProcessing": true,
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "fnServerParams": function ( aoData ) {
		 *          aoData.push( { "name": "more_data", "value": "my_value" } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnServerParams": null,
	
	
		/**
		 * Load the table state. With this function you can define from where, and how, the
		 * state of a table is loaded. By default DataTables will load from its state saving
		 * cookie, but you might wish to use local storage (HTML5) or a server-side database.
		 *  @type function
		 *  @member
		 *  @param {object} oSettings DataTables settings object
		 *  @return {object} The DataTables state object to be loaded
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateSave": function (oSettings, oData) {
		 *          var o;
		 *          
		 *          // Send an Ajax request to the server to get the data. Note that
		 *          // this is a synchronous request.
		 *          $.ajax( {
		 *            "url": "/state_load",
		 *            "async": false,
		 *            "dataType": "json",
		 *            "success": function (json) {
		 *              o = json;
		 *            }
		 *          } );
		 *          
		 *          return o;
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateLoad": function ( oSettings ) {
			var sData = this.oApi._fnReadCookie( oSettings.sCookiePrefix+oSettings.sInstance );
			var oData;
	
			try {
				oData = (typeof $.parseJSON === 'function') ? 
					$.parseJSON(sData) : eval( '('+sData+')' );
			} catch (e) {
				oData = null;
			}
	
			return oData;
		},
	
	
		/**
		 * Callback which allows modification of the saved state prior to loading that state.
		 * This callback is called when the table is loading state from the stored data, but
		 * prior to the settings object being modified by the saved state. Note that for 
		 * plug-in authors, you should use the 'stateLoadParams' event to load parameters for 
		 * a plug-in.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} oData The state object that is to be loaded
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    // Remove a saved filter, so filtering is never loaded
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoadParams": function (oSettings, oData) {
		 *          oData.oFilter.sSearch = "";
		 *      } );
		 *    } );
		 * 
		 *  @example
		 *    // Disallow state loading by returning false
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoadParams": function (oSettings, oData) {
		 *          return false;
		 *      } );
		 *    } );
		 */
		"fnStateLoadParams": null,
	
	
		/**
		 * Callback that is called when the state has been loaded from the state saving method
		 * and the DataTables settings object has been modified as a result of the loaded state.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} oData The state object that was loaded
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    // Show an alert with the filtering value that was saved
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoaded": function (oSettings, oData) {
		 *          alert( 'Saved filter was: '+oData.oFilter.sSearch );
		 *      } );
		 *    } );
		 */
		"fnStateLoaded": null,
	
	
		/**
		 * Save the table state. This function allows you to define where and how the state
		 * information for the table is stored - by default it will use a cookie, but you
		 * might want to use local storage (HTML5) or a server-side database.
		 *  @type function
		 *  @member
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} oData The state object to be saved
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateSave": function (oSettings, oData) {
		 *          // Send an Ajax request to the server with the state object
		 *          $.ajax( {
		 *            "url": "/state_save",
		 *            "data": oData,
		 *            "dataType": "json",
		 *            "method": "POST"
		 *            "success": function () {}
		 *          } );
		 *        }
		 *      } );
		 *    } );
		 */
		"fnStateSave": function ( oSettings, oData ) {
			this.oApi._fnCreateCookie( 
				oSettings.sCookiePrefix+oSettings.sInstance, 
				this.oApi._fnJsonString(oData), 
				oSettings.iCookieDuration, 
				oSettings.sCookiePrefix, 
				oSettings.fnCookieCallback
			);
		},
	
	
		/**
		 * Callback which allows modification of the state to be saved. Called when the table 
		 * has changed state a new state save is required. This method allows modification of
		 * the state saving object prior to actually doing the save, including addition or 
		 * other state properties or modification. Note that for plug-in authors, you should 
		 * use the 'stateSaveParams' event to save parameters for a plug-in.
		 *  @type function
		 *  @param {object} oSettings DataTables settings object
		 *  @param {object} oData The state object to be saved
		 *  @dtopt Callbacks
		 * 
		 *  @example
		 *    // Remove a saved filter, so filtering is never saved
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bStateSave": true,
		 *        "fnStateLoadParams": function (oSettings, oData) {
		 *          oData.oFilter.sSearch = "";
		 *      } );
		 *    } );
		 */
		"fnStateSaveParams": null,
	
	
		/**
		 * Duration of the cookie which is used for storing session information. This
		 * value is given in seconds.
		 *  @type int
		 *  @default 7200 <i>(2 hours)</i>
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iCookieDuration": 60*60*24 // 1 day
		 *      } );
		 *    } )
		 */
		"iCookieDuration": 7200,
	
	
		/**
		 * When enabled DataTables will not make a request to the server for the first
		 * page draw - rather it will use the data already on the page (no sorting etc
		 * will be applied to it), thus saving on an XHR at load time. iDeferLoading
		 * is used to indicate that deferred loading is required, but it is also used
		 * to tell DataTables how many records there are in the full table (allowing
		 * the information element and pagination to be displayed correctly).
		 *  @type int
		 *  @default null
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/server_processing.php",
		 *        "iDeferLoading": 57
		 *      } );
		 *    } );
		 */
		"iDeferLoading": null,
	
	
		/**
		 * Number of rows to display on a single page when using pagination. If
		 * feature enabled (bLengthChange) then the end user will be able to override
		 * this to a custom setting using a pop-up menu.
		 *  @type int
		 *  @default 10
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayLength": 50
		 *      } );
		 *    } )
		 */
		"iDisplayLength": 10,
	
	
		/**
		 * Define the starting point for data display when using DataTables with
		 * pagination. Note that this parameter is the number of records, rather than
		 * the page number, so if you have 10 records per page and want to start on
		 * the third page, it should be "20".
		 *  @type int
		 *  @default 0
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "iDisplayStart": 20
		 *      } );
		 *    } )
		 */
		"iDisplayStart": 0,
	
	
		/**
		 * The scroll gap is the amount of scrolling that is left to go before
		 * DataTables will load the next 'page' of data automatically. You typically
		 * want a gap which is big enough that the scrolling will be smooth for the
		 * user, while not so large that it will load more data than need.
		 *  @type int
		 *  @default 100
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bScrollInfinite": true,
		 *        "bScrollCollapse": true,
		 *        "sScrollY": "200px",
		 *        "iScrollLoadGap": 50
		 *      } );
		 *    } );
		 */
		"iScrollLoadGap": 100,
	
	
		/**
		 * By default DataTables allows keyboard navigation of the table (sorting, paging,
		 * and filtering) by adding a tabindex attribute to the required elements. This
		 * allows you to tab through the controls and press the enter key to activate them.
		 * The tabindex is default 0, meaning that the tab follows the flow of the document.
		 * You can overrule this using this parameter if you wish. Use a value of -1 to
		 * disable built-in keyboard navigation.
		 *  @type int
		 *  @default 0
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "iTabIndex": 1
		 *      } );
		 *    } );
		 */
		"iTabIndex": 0,
	
	
		/**
		 * All strings that DataTables uses in the user interface that it creates
		 * are defined in this object, allowing you to modified them individually or
		 * completely replace them all as required.
		 *  @namespace
		 */
		"oLanguage": {
			/**
			 * Strings that are used for WAI-ARIA labels and controls only (these are not
			 * actually visible on the page, but will be read by screenreaders, and thus
			 * must be internationalised as well).
			 *  @namespace
			 */
			"oAria": {
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted ascending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready(function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oAria": {
				 *            "sSortAscending": " - click/return to sort ascending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortAscending": ": activate to sort column ascending",
	
				/**
				 * ARIA label that is added to the table headers when the column may be
				 * sorted descending by activing the column (click or return when focused).
				 * Note that the column header is prefixed to this string.
				 *  @type string
				 *  @default : activate to sort column ascending
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready(function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oAria": {
				 *            "sSortDescending": " - click/return to sort descending"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sSortDescending": ": activate to sort column descending"
			},
	
			/**
			 * Pagination string used by DataTables for the two built-in pagination
			 * control types ("two_button" and "full_numbers")
			 *  @namespace
			 */
			"oPaginate": {
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the first page.
				 *  @type string
				 *  @default First
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready(function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sFirst": "First page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sFirst": "First",
			
			
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the last page.
				 *  @type string
				 *  @default Last
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready(function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sLast": "Last page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sLast": "Last",
			
			
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the next page.
				 *  @type string
				 *  @default Next
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready(function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sNext": "Next page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sNext": "Next",
			
			
				/**
				 * Text to use when using the 'full_numbers' type of pagination for the
				 * button to take the user to the previous page.
				 *  @type string
				 *  @default Previous
				 *  @dtopt Language
				 * 
				 *  @example
				 *    $(document).ready(function() {
				 *      $('#example').dataTable( {
				 *        "oLanguage": {
				 *          "oPaginate": {
				 *            "sPrevious": "Previous page"
				 *          }
				 *        }
				 *      } );
				 *    } );
				 */
				"sPrevious": "Previous"
			},
		
			/**
			 * This string is shown in preference to sZeroRecords when the table is
			 * empty of data (regardless of filtering). Note that this is an optional
			 * parameter - if it is not given, the value of sZeroRecords will be used
			 * instead (either the default or given value).
			 *  @type string
			 *  @default No data available in table
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sEmptyTable": "No data available in table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sEmptyTable": "No data available in table",
		
		
			/**
			 * This string gives information to the end user about the information that 
			 * is current on display on the page. The _START_, _END_ and _TOTAL_ 
			 * variables are all dynamically replaced as the table display updates, and 
			 * can be freely moved or removed as the language requirements change.
			 *  @type string
			 *  @default Showing _START_ to _END_ of _TOTAL_ entries
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfo": "Got a total of _TOTAL_ entries to show (_START_ to _END_)"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfo": "Showing _START_ to _END_ of _TOTAL_ entries",
		
		
			/**
			 * Display information string for when the table is empty. Typically the 
			 * format of this string should match sInfo.
			 *  @type string
			 *  @default Showing 0 to 0 of 0 entries
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoEmpty": "No entries to show"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoEmpty": "Showing 0 to 0 of 0 entries",
		
		
			/**
			 * When a user filters the information in a table, this string is appended 
			 * to the information (sInfo) to give an idea of how strong the filtering 
			 * is. The variable _MAX_ is dynamically updated.
			 *  @type string
			 *  @default (filtered from _MAX_ total entries)
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoFiltered": " - filtering from _MAX_ records"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoFiltered": "(filtered from _MAX_ total entries)",
		
		
			/**
			 * If can be useful to append extra information to the info string at times,
			 * and this variable does exactly that. This information will be appended to
			 * the sInfo (sInfoEmpty and sInfoFiltered in whatever combination they are
			 * being used) at all times.
			 *  @type string
			 *  @default <i>Empty string</i>
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoPostFix": "All records shown are derived from real information."
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoPostFix": "",
		
		
			/**
			 * DataTables has a build in number formatter (fnFormatNumber) which is used
			 * to format large numbers that are used in the table information. By
			 * default a comma is used, but this can be trivially changed to any
			 * character you wish with this parameter.
			 *  @type string
			 *  @default ,
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sInfoThousands": "'"
			 *        }
			 *      } );
			 *    } );
			 */
			"sInfoThousands": ",",
		
		
			/**
			 * Detail the action that will be taken when the drop down menu for the
			 * pagination length option is changed. The '_MENU_' variable is replaced
			 * with a default select list of 10, 25, 50 and 100, and can be replaced
			 * with a custom select box if required.
			 *  @type string
			 *  @default Show _MENU_ entries
			 *  @dtopt Language
			 * 
			 *  @example
			 *    // Language change only
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLengthMenu": "Display _MENU_ records"
			 *        }
			 *      } );
			 *    } );
			 *    
			 *  @example
			 *    // Language and options change
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLengthMenu": 'Display <select>'+
			 *            '<option value="10">10</option>'+
			 *            '<option value="20">20</option>'+
			 *            '<option value="30">30</option>'+
			 *            '<option value="40">40</option>'+
			 *            '<option value="50">50</option>'+
			 *            '<option value="-1">All</option>'+
			 *            '</select> records'
			 *        }
			 *      } );
			 *    } );
			 */
			"sLengthMenu": "Show _MENU_ entries",
		
		
			/**
			 * When using Ajax sourced data and during the first draw when DataTables is
			 * gathering the data, this message is shown in an empty row in the table to
			 * indicate to the end user the the data is being loaded. Note that this
			 * parameter is not used when loading data by server-side processing, just
			 * Ajax sourced data with client-side processing.
			 *  @type string
			 *  @default Loading...
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready( function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sLoadingRecords": "Please wait - loading..."
			 *        }
			 *      } );
			 *    } );
			 */
			"sLoadingRecords": "Loading...",
		
		
			/**
			 * Text which is displayed when the table is processing a user action
			 * (usually a sort command or similar).
			 *  @type string
			 *  @default Processing...
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sProcessing": "DataTables is currently busy"
			 *        }
			 *      } );
			 *    } );
			 */
			"sProcessing": "Processing...",
		
		
			/**
			 * Details the actions that will be taken when the user types into the
			 * filtering input text box. The variable "_INPUT_", if used in the string,
			 * is replaced with the HTML text box for the filtering input allowing
			 * control over where it appears in the string. If "_INPUT_" is not given
			 * then the input box is appended to the string automatically.
			 *  @type string
			 *  @default Search:
			 *  @dtopt Language
			 * 
			 *  @example
			 *    // Input text box will be appended at the end automatically
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sSearch": "Filter records:"
			 *        }
			 *      } );
			 *    } );
			 *    
			 *  @example
			 *    // Specify where the filter should appear
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sSearch": "Apply filter _INPUT_ to table"
			 *        }
			 *      } );
			 *    } );
			 */
			"sSearch": "Search:",
		
		
			/**
			 * All of the language information can be stored in a file on the
			 * server-side, which DataTables will look up if this parameter is passed.
			 * It must store the URL of the language file, which is in a JSON format,
			 * and the object has the same properties as the oLanguage object in the
			 * initialiser object (i.e. the above parameters). Please refer to one of
			 * the example language files to see how this works in action.
			 *  @type string
			 *  @default <i>Empty string - i.e. disabled</i>
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sUrl": "http://www.sprymedia.co.uk/dataTables/lang.txt"
			 *        }
			 *      } );
			 *    } );
			 */
			"sUrl": "",
		
		
			/**
			 * Text shown inside the table records when the is no information to be
			 * displayed after filtering. sEmptyTable is shown when there is simply no
			 * information in the table at all (regardless of filtering).
			 *  @type string
			 *  @default No matching records found
			 *  @dtopt Language
			 * 
			 *  @example
			 *    $(document).ready(function() {
			 *      $('#example').dataTable( {
			 *        "oLanguage": {
			 *          "sZeroRecords": "No records to display"
			 *        }
			 *      } );
			 *    } );
			 */
			"sZeroRecords": "No matching records found"
		},
	
	
		/**
		 * This parameter allows you to have define the global filtering state at
		 * initialisation time. As an object the "sSearch" parameter must be
		 * defined, but all other parameters are optional. When "bRegex" is true,
		 * the search string will be treated as a regular expression, when false
		 * (default) it will be treated as a straight string. When "bSmart"
		 * DataTables will use it's smart filtering methods (to word match at
		 * any point in the data), when false this will not be done.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "oSearch": {"sSearch": "Initial search"}
		 *      } );
		 *    } )
		 */
		"oSearch": $.extend( {}, DataTable.models.oSearch ),
	
	
		/**
		 * By default DataTables will look for the property 'aaData' when obtaining
		 * data from an Ajax source or for server-side processing - this parameter
		 * allows that property to be changed. You can use Javascript dotted object
		 * notation to get a data source for multiple levels of nesting.
		 *  @type string
		 *  @default aaData
		 *  @dtopt Options
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    // Get data from { "data": [...] }
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/data.txt",
		 *        "sAjaxDataProp": "data"
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Get data from { "data": { "inner": [...] } }
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/data.txt",
		 *        "sAjaxDataProp": "data.inner"
		 *      } );
		 *    } );
		 */
		"sAjaxDataProp": "aaData",
	
	
		/**
		 * You can instruct DataTables to load data from an external source using this
		 * parameter (use aData if you want to pass data in you already have). Simply
		 * provide a url a JSON object can be obtained from. This object must include
		 * the parameter 'aaData' which is the data source for the table.
		 *  @type string
		 *  @default null
		 *  @dtopt Options
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sAjaxSource": "http://www.sprymedia.co.uk/dataTables/json.php"
		 *      } );
		 *    } )
		 */
		"sAjaxSource": null,
	
	
		/**
		 * This parameter can be used to override the default prefix that DataTables
		 * assigns to a cookie when state saving is enabled.
		 *  @type string
		 *  @default SpryMedia_DataTables_
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "sCookiePrefix": "my_datatable_",
		 *      } );
		 *    } );
		 */
		"sCookiePrefix": "SpryMedia_DataTables_",
	
	
		/**
		 * This initialisation variable allows you to specify exactly where in the
		 * DOM you want DataTables to inject the various controls it adds to the page
		 * (for example you might want the pagination controls at the top of the
		 * table). DIV elements (with or without a custom class) can also be added to
		 * aid styling. The follow syntax is used:
		 *   <ul>
		 *     <li>The following options are allowed:	
		 *       <ul>
		 *         <li>'l' - Length changing</li
		 *         <li>'f' - Filtering input</li>
		 *         <li>'t' - The table!</li>
		 *         <li>'i' - Information</li>
		 *         <li>'p' - Pagination</li>
		 *         <li>'r' - pRocessing</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following constants are allowed:
		 *       <ul>
		 *         <li>'H' - jQueryUI theme "header" classes ('fg-toolbar ui-widget-header ui-corner-tl ui-corner-tr ui-helper-clearfix')</li>
		 *         <li>'F' - jQueryUI theme "footer" classes ('fg-toolbar ui-widget-header ui-corner-bl ui-corner-br ui-helper-clearfix')</li>
		 *       </ul>
		 *     </li>
		 *     <li>The following syntax is expected:
		 *       <ul>
		 *         <li>'&lt;' and '&gt;' - div elements</li>
		 *         <li>'&lt;"class" and '&gt;' - div with a class</li>
		 *         <li>'&lt;"#id" and '&gt;' - div with an ID</li>
		 *       </ul>
		 *     </li>
		 *     <li>Examples:
		 *       <ul>
		 *         <li>'&lt;"wrapper"flipt&gt;'</li>
		 *         <li>'&lt;lf&lt;t&gt;ip&gt;'</li>
		 *       </ul>
		 *     </li>
		 *   </ul>
		 *  @type string
		 *  @default lfrtip <i>(when bJQueryUI is false)</i> <b>or</b> 
		 *    <"H"lfr>t<"F"ip> <i>(when bJQueryUI is true)</i>
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "sDom": '&lt;"top"i&gt;rt&lt;"bottom"flp&gt;&lt;"clear"&lgt;'
		 *      } );
		 *    } );
		 */
		"sDom": "lfrtip",
	
	
		/**
		 * DataTables features two different built-in pagination interaction methods
		 * ('two_button' or 'full_numbers') which present different page controls to
		 * the end user. Further methods can be added using the API (see below).
		 *  @type string
		 *  @default two_button
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready( function() {
		 *      $('#example').dataTable( {
		 *        "sPaginationType": "full_numbers"
		 *      } );
		 *    } )
		 */
		"sPaginationType": "two_button",
	
	
		/**
		 * Enable horizontal scrolling. When a table is too wide to fit into a certain
		 * layout, or you have a large number of columns in the table, you can enable
		 * x-scrolling to show the table in a viewport, which can be scrolled. This
		 * property can by any CSS unit, or a number (in which case it will be treated
		 * as a pixel measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "sScrollX": "100%",
		 *        "bScrollCollapse": true
		 *      } );
		 *    } );
		 */
		"sScrollX": "",
	
	
		/**
		 * This property can be used to force a DataTable to use more width than it
		 * might otherwise do when x-scrolling is enabled. For example if you have a
		 * table which requires to be well spaced, this parameter is useful for
		 * "over-sizing" the table, and thus forcing scrolling. This property can by
		 * any CSS unit, or a number (in which case it will be treated as a pixel
		 * measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *  @dtopt Options
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "sScrollX": "100%",
		 *        "sScrollXInner": "110%"
		 *      } );
		 *    } );
		 */
		"sScrollXInner": "",
	
	
		/**
		 * Enable vertical scrolling. Vertical scrolling will constrain the DataTable
		 * to the given height, an enable scrolling for any data which overflows the
		 * current viewport. This can be used as an alternative to paging to display
		 * a lot of data in a small area (although paging and scrolling can both be
		 * enabled at the same time). This property can by any CSS unit, or a number
		 * (in which case it will be treated as a pixel measurement).
		 *  @type string
		 *  @default <i>blank string - i.e. disabled</i>
		 *  @dtopt Features
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "sScrollY": "200px",
		 *        "bPaginate": false
		 *      } );
		 *    } );
		 */
		"sScrollY": "",
	
	
		/**
		 * Set the HTTP method that is used to make the Ajax call for server-side
		 * processing or Ajax sourced data.
		 *  @type string
		 *  @default GET
		 *  @dtopt Options
		 *  @dtopt Server-side
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "bServerSide": true,
		 *        "sAjaxSource": "scripts/post.php",
		 *        "sServerMethod": "POST"
		 *      } );
		 *    } );
		 */
		"sServerMethod": "GET"
	};
	
	
	
	/**
	 * Column options that can be given to DataTables at initialisation time.
	 *  @namespace
	 */
	DataTable.defaults.columns = {
		/**
		 * Allows a column's sorting to take multiple columns into account when 
		 * doing a sort. For example first name / last name columns make sense to 
		 * do a multi-column sort over the two columns.
		 *  @type array
		 *  @default null <i>Takes the value of the column index automatically</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "aDataSort": [ 0, 1 ], "aTargets": [ 0 ] },
		 *          { "aDataSort": [ 1, 0 ], "aTargets": [ 1 ] },
		 *          { "aDataSort": [ 2, 3, 4 ], "aTargets": [ 2 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          { "aDataSort": [ 0, 1 ] },
		 *          { "aDataSort": [ 1, 0 ] },
		 *          { "aDataSort": [ 2, 3, 4 ] },
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"aDataSort": null,
	
	
		/**
		 * You can control the default sorting direction, and even alter the behaviour
		 * of the sort handler (i.e. only allow ascending sorting etc) using this
		 * parameter.
		 *  @type array
		 *  @default [ 'asc', 'desc' ]
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "asSorting": [ "asc" ], "aTargets": [ 1 ] },
		 *          { "asSorting": [ "desc", "asc", "asc" ], "aTargets": [ 2 ] },
		 *          { "asSorting": [ "desc" ], "aTargets": [ 3 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          null,
		 *          { "asSorting": [ "asc" ] },
		 *          { "asSorting": [ "desc", "asc", "asc" ] },
		 *          { "asSorting": [ "desc" ] },
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"asSorting": [ 'asc', 'desc' ],
	
	
		/**
		 * Enable or disable filtering on the data in this column.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bSearchable": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bSearchable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSearchable": true,
	
	
		/**
		 * Enable or disable sorting on this column.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bSortable": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bSortable": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bSortable": true,
	
	
		/**
		 * When using fnRender() for a column, you may wish to use the original data
		 * (before rendering) for sorting and filtering (the default is to used the
		 * rendered data that the user can see). This may be useful for dates etc.
		 * 
		 * *NOTE* It is it is advisable now to use mDataProp as a function and make 
		 * use of the 'type' that it gives, allowing (potentially) different data to
		 * be used for sorting, filtering, display and type detection.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          {
		 *            "fnRender": function ( oObj ) {
		 *              return oObj.aData[0] +' '+ oObj.aData[3];
		 *            },
		 *            "bUseRendered": false,
		 *            "aTargets": [ 0 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          {
		 *            "fnRender": function ( oObj ) {
		 *              return oObj.aData[0] +' '+ oObj.aData[3];
		 *            },
		 *            "bUseRendered": false
		 *          },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"bUseRendered": true,
	
	
		/**
		 * Enable or disable the display of this column.
		 *  @type boolean
		 *  @default true
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "bVisible": false, "aTargets": [ 0 ] }
		 *        ] } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "bVisible": false },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ] } );
		 *    } );
		 */
		"bVisible": true,
		
		
		/**
		 * Developer definable function that is called whenever a cell is created (Ajax source,
		 * etc) or processed for input (DOM source). This can be used as a compliment to fnRender
		 * allowing you to modify the DOM element (add background colour for example) when the
		 * element is available (since it is not when fnRender is called).
		 *  @type function
		 *  @param {element} nTd The TD node that has been created
		 *  @param {*} sData The Data for the cell
		 *  @param {array|object} oData The data for the whole row
		 *  @param {int} iRow The row index for the aoData data store
		 *  @param {int} iCol The column index for aoColumns
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ {
		 *          "aTargets": [3],
		 *          "fnCreatedCell": function (nTd, sData, oData, iRow, iCol) {
		 *            if ( sData == "1.7" ) {
		 *              $(nTd).css('color', 'blue')
		 *            }
		 *          }
		 *        } ]
		 *      });
		 *    } );
		 */
		"fnCreatedCell": null,
	
	
		/**
		 * Custom display function that will be called for the display of each cell in
		 * this column.
		 *  @type function
		 *  @param {object} o Object with the following parameters:
		 *  @param {int}    o.iDataRow The row in aoData
		 *  @param {int}    o.iDataColumn The column in question
		 *  @param {array}  o.aData The data for the row in question
		 *  @param {object} o.oSettings The settings object for this DataTables instance
		 *  @param {object} o.mDataProp The data property used for this column
		 *  @param {*}      val The current cell value
		 *  @returns {string} The string you which to use in the display
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          {
		 *            "fnRender": function ( o, val ) {
		 *              return o.aData[0] +' '+ o.aData[3];
		 *            },
		 *            "aTargets": [ 0 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "fnRender": function ( o, val ) {
		 *            return o.aData[0] +' '+ o.aData[3];
		 *          } },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"fnRender": null,
	
	
		/**
		 * The column index (starting from 0!) that you wish a sort to be performed
		 * upon when this column is selected for sorting. This can be used for sorting
		 * on hidden columns for example.
		 *  @type int
		 *  @default -1 <i>Use automatically calculated column index</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "iDataSort": 1, "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "iDataSort": 1 },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"iDataSort": -1,
	
	
		/**
		 * This property can be used to read data from any JSON data source property,
		 * including deeply nested objects / properties. mDataProp can be given in a
		 * number of different ways which effect its behaviour:
		 *   <ul>
		 *     <li>integer - treated as an array index for the data source. This is the
		 *       default that DataTables uses (incrementally increased for each column).</li>
		 *     <li>string - read an object property from the data source. Note that you can
		 *       use Javascript dotted notation to read deep properties/arrays from the
		 *       data source.</li>
		 *     <li>null -  the sDafaultContent option will use used for the cell (empty
		 *       string by default. This can be useful on generated columns such as
		 *       edit / delete action columns.</li>
		 *     <li>function - the function given will be executed whenever DataTables 
		 *       needs to set or get the data for a cell in the column. The function 
		 *       takes three parameters:
		 *       <ul>
		 *         <li>{array|object} The data source for the row</li>
		 *         <li>{string} The type call data requested - this will be 'set' when
		 *           setting data or 'filter', 'display', 'type' or 'sort' when gathering
		 *           data.</li>
		 *         <li>{*} Data to set when the second parameter is 'set'.</li>
		 *       </ul>
		 *       The return value from the function is not required when 'set' is the type
		 *       of call, but otherwise the return is what will be used for the data
		 *       requested.</li>
		 *    </ul>
		 *  @type string|int|function|null
		 *  @default null <i>Use automatically calculated column index</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Read table data from objects
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "sAjaxSource": "sources/deep.txt",
		 *        "aoColumns": [
		 *          { "mDataProp": "engine" },
		 *          { "mDataProp": "browser" },
		 *          { "mDataProp": "platform.inner" },
		 *          { "mDataProp": "platform.details.0" },
		 *          { "mDataProp": "platform.details.1" }
		 *        ]
		 *      } );
		 *    } );
		 * 
		 *  @example
		 *    // Using mDataProp as a function to provide different information for
		 *    // sorting, filtering and display. In this case, currency (price)
		 *    $(document).ready(function() {
		 *      var oTable = $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *        {
		 *          "aTargets": [ 0 ],
		 *          "mDataProp": function ( source, type, val ) {
		 *            if (type === 'set') {
		 *              source.price = val;
		 *              // Store the computed dislay and filter values for efficiency
		 *              source.price_display = val=="" ? "" : "$"+numberFormat(val);
		 *              source.price_filter  = val=="" ? "" : "$"+numberFormat(val)+" "+val;
		 *              return;
		 *            }
		 *            else if (type === 'display') {
		 *              return source.price_display;
		 *            }
		 *            else if (type === 'filter') {
		 *              return source.price_filter;
		 *            }
		 *            // 'sort' and 'type' both just use the integer
		 *            return source.price;
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"mDataProp": null,
	
	
		/**
		 * Class to give to each cell in this column.
		 *  @type string
		 *  @default <i>Empty string</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sClass": "my_class", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sClass": "my_class" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sClass": "",
		
		/**
		 * When DataTables calculates the column widths to assign to each column,
		 * it finds the longest string in each column and then constructs a
		 * temporary table and reads the widths from that. The problem with this
		 * is that "mmm" is much wider then "iiii", but the latter is a longer 
		 * string - thus the calculation can go wrong (doing it properly and putting
		 * it into an DOM object and measuring that is horribly(!) slow). Thus as
		 * a "work around" we provide this option. It will append its value to the
		 * text that is found to be the longest string for the column - i.e. padding.
		 * Generally you shouldn't need this, and it is not documented on the 
		 * general DataTables.net documentation
		 *  @type string
		 *  @default <i>Empty string<i>
		 *  @dtopt Columns
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "sContentPadding": "mmm"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sContentPadding": "",
	
	
		/**
		 * Allows a default value to be given for a column's data, and will be used
		 * whenever a null data source is encountered (this can be because mDataProp
		 * is set to null, or because the data source itself is null).
		 *  @type string
		 *  @default null
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          {
		 *            "mDataProp": null,
		 *            "sDefaultContent": "Edit",
		 *            "aTargets": [ -1 ]
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          null,
		 *          null,
		 *          null,
		 *          {
		 *            "mDataProp": null,
		 *            "sDefaultContent": "Edit"
		 *          }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sDefaultContent": null,
	
	
		/**
		 * This parameter is only used in DataTables' server-side processing. It can
		 * be exceptionally useful to know what columns are being displayed on the
		 * client side, and to map these to database fields. When defined, the names
		 * also allow DataTables to reorder information from the server if it comes
		 * back in an unexpected order (i.e. if you switch your columns around on the
		 * client-side, your server-side code does not also need updating).
		 *  @type string
		 *  @default <i>Empty string</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sName": "engine", "aTargets": [ 0 ] },
		 *          { "sName": "browser", "aTargets": [ 1 ] },
		 *          { "sName": "platform", "aTargets": [ 2 ] },
		 *          { "sName": "version", "aTargets": [ 3 ] },
		 *          { "sName": "grade", "aTargets": [ 4 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sName": "engine" },
		 *          { "sName": "browser" },
		 *          { "sName": "platform" },
		 *          { "sName": "version" },
		 *          { "sName": "grade" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sName": "",
	
	
		/**
		 * Defines a data source type for the sorting which can be used to read
		 * realtime information from the table (updating the internally cached
		 * version) prior to sorting. This allows sorting to occur on user editable
		 * elements such as form inputs.
		 *  @type string
		 *  @default std
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [
		 *          { "sSortDataType": "dom-text", "aTargets": [ 2, 3 ] },
		 *          { "sType": "numeric", "aTargets": [ 3 ] },
		 *          { "sSortDataType": "dom-select", "aTargets": [ 4 ] },
		 *          { "sSortDataType": "dom-checkbox", "aTargets": [ 5 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [
		 *          null,
		 *          null,
		 *          { "sSortDataType": "dom-text" },
		 *          { "sSortDataType": "dom-text", "sType": "numeric" },
		 *          { "sSortDataType": "dom-select" },
		 *          { "sSortDataType": "dom-checkbox" }
		 *        ]
		 *      } );
		 *    } );
		 */
		"sSortDataType": "std",
	
	
		/**
		 * The title of this column.
		 *  @type string
		 *  @default null <i>Derived from the 'TH' value for this column in the 
		 *    original HTML table.</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sTitle": "My column title", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sTitle": "My column title" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sTitle": null,
	
	
		/**
		 * The type allows you to specify how the data for this column will be sorted.
		 * Four types (string, numeric, date and html (which will strip HTML tags
		 * before sorting)) are currently available. Note that only date formats
		 * understood by Javascript's Date() object will be accepted as type date. For
		 * example: "Mar 26, 2008 5:03 PM". May take the values: 'string', 'numeric',
		 * 'date' or 'html' (by default). Further types can be adding through
		 * plug-ins.
		 *  @type string
		 *  @default null <i>Auto-detected from raw data</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sType": "html", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sType": "html" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sType": null,
	
	
		/**
		 * Defining the width of the column, this parameter may take any CSS value
		 * (3em, 20px etc). DataTables applys 'smart' widths to columns which have not
		 * been given a specific width through this interface ensuring that the table
		 * remains readable.
		 *  @type string
		 *  @default null <i>Automatic</i>
		 *  @dtopt Columns
		 * 
		 *  @example
		 *    // Using aoColumnDefs
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumnDefs": [ 
		 *          { "sWidth": "20%", "aTargets": [ 0 ] }
		 *        ]
		 *      } );
		 *    } );
		 *    
		 *  @example
		 *    // Using aoColumns
		 *    $(document).ready(function() {
		 *      $('#example').dataTable( {
		 *        "aoColumns": [ 
		 *          { "sWidth": "20%" },
		 *          null,
		 *          null,
		 *          null,
		 *          null
		 *        ]
		 *      } );
		 *    } );
		 */
		"sWidth": null
	};
	
	
	
	/**
	 * DataTables settings object - this holds all the information needed for a
	 * given table, including configuration, data and current application of the
	 * table options. DataTables does not have a single instance for each DataTable
	 * with the settings attached to that instance, but rather instances of the
	 * DataTable "class" are created on-the-fly as needed (typically by a 
	 * $().dataTable() call) and the settings object is then applied to that
	 * instance.
	 * 
	 * Note that this object is related to {@link DataTable.defaults} but this 
	 * one is the internal data store for DataTables's cache of columns. It should
	 * NOT be manipulated outside of DataTables. Any configuration should be done
	 * through the initialisation options.
	 *  @namespace
	 *  @todo Really should attach the settings object to individual instances so we
	 *    don't need to create new instances on each $().dataTable() call (if the
	 *    table already exists). It would also save passing oSettings around and
	 *    into every single function. However, this is a very significant 
	 *    architecture change for DataTables and will almost certainly break
	 *    backwards compatibility with older installations. This is something that
	 *    will be done in 2.0.
	 */
	DataTable.models.oSettings = {
		/**
		 * Primary features of DataTables and their enablement state.
		 *  @namespace
		 */
		"oFeatures": {
			
			/**
			 * Flag to say if DataTables should automatically try to calculate the
			 * optimum table and columns widths (true) or not (false).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bAutoWidth": null,
	
			/**
			 * Delay the creation of TR and TD elements until they are actually
			 * needed by a driven page draw. This can give a significant speed
			 * increase for Ajax source and Javascript source data, but makes no
			 * difference at all fro DOM and server-side processing tables.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bDeferRender": null,
			
			/**
			 * Enable filtering on the table or not. Note that if this is disabled
			 * then there is no filtering at all on the table, including fnFilter.
			 * To just remove the filtering input use sDom and remove the 'f' option.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bFilter": null,
			
			/**
			 * Table information element (the 'Showing x of y records' div) enable
			 * flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bInfo": null,
			
			/**
			 * Present a user control allowing the end user to change the page size
			 * when pagination is enabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bLengthChange": null,
	
			/**
			 * Pagination enabled or not. Note that if this is disabled then length
			 * changing must also be disabled.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bPaginate": null,
			
			/**
			 * Processing indicator enable flag whenever DataTables is enacting a
			 * user request - typically an Ajax request for server-side processing.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bProcessing": null,
			
			/**
			 * Server-side processing enabled flag - when enabled DataTables will
			 * get all data from the server for every draw - there is no filtering,
			 * sorting or paging done on the client-side.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bServerSide": null,
			
			/**
			 * Sorting enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSort": null,
			
			/**
			 * Apply a class to the columns which are being sorted to provide a
			 * visual highlight or not. This can slow things down when enabled since
			 * there is a lot of DOM interaction.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bSortClasses": null,
			
			/**
			 * State saving enablement flag.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bStateSave": null
		},
		
	
		/**
		 * Scrolling settings for a table.
		 *  @namespace
		 */
		"oScroll": {
			/**
			 * Indicate if DataTables should be allowed to set the padding / margin
			 * etc for the scrolling header elements or not. Typically you will want
			 * this.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bAutoCss": null,
			
			/**
			 * When the table is shorter in height than sScrollY, collapse the
			 * table container down to the height of the table (when true).
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bCollapse": null,
			
			/**
			 * Infinite scrolling enablement flag. Now deprecated in favour of
			 * using the Scroller plug-in.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type boolean
			 */
			"bInfinite": null,
			
			/**
			 * Width of the scrollbar for the web-browser's platform. Calculated
			 * during table initialisation.
			 *  @type int
			 *  @default 0
			 */
			"iBarWidth": 0,
			
			/**
			 * Space (in pixels) between the bottom of the scrolling container and 
			 * the bottom of the scrolling viewport before the next page is loaded
			 * when using infinite scrolling.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type int
			 */
			"iLoadGap": null,
			
			/**
			 * Viewport width for horizontal scrolling. Horizontal scrolling is 
			 * disabled if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sX": null,
			
			/**
			 * Width to expand the table to when using x-scrolling. Typically you
			 * should not need to use this.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 *  @deprecated
			 */
			"sXInner": null,
			
			/**
			 * Viewport height for vertical scrolling. Vertical scrolling is disabled
			 * if an empty string.
			 * Note that this parameter will be set by the initialisation routine. To
			 * set a default use {@link DataTable.defaults}.
			 *  @type string
			 */
			"sY": null
		},
		
		/**
		 * Language information for the table.
		 *  @namespace
		 *  @extends DataTable.defaults.oLanguage
		 */
		"oLanguage": {
			/**
			 * Information callback function. See 
			 * {@link DataTable.defaults.fnInfoCallback}
			 *  @type function
			 *  @default 
			 */
			"fnInfoCallback": null
		},
		
		/**
		 * Array referencing the nodes which are used for the features. The 
		 * parameters of this object match what is allowed by sDom - i.e.
		 *   <ul>
		 *     <li>'l' - Length changing</li>
		 *     <li>'f' - Filtering input</li>
		 *     <li>'t' - The table!</li>
		 *     <li>'i' - Information</li>
		 *     <li>'p' - Pagination</li>
		 *     <li>'r' - pRocessing</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aanFeatures": [],
		
		/**
		 * Store data information - see {@link DataTable.models.oRow} for detailed
		 * information.
		 *  @type array
		 *  @default []
		 */
		"aoData": [],
		
		/**
		 * Array of indexes which are in the current display (after filtering etc)
		 *  @type array
		 *  @default []
		 */
		"aiDisplay": [],
		
		/**
		 * Array of indexes for display - no filtering
		 *  @type array
		 *  @default []
		 */
		"aiDisplayMaster": [],
		
		/**
		 * Store information about each column that is in use
		 *  @type array
		 *  @default []
		 */
		"aoColumns": [],
		
		/**
		 * Store information about the table's header
		 *  @type array
		 *  @default []
		 */
		"aoHeader": [],
		
		/**
		 * Store information about the table's footer
		 *  @type array
		 *  @default []
		 */
		"aoFooter": [],
		
		/**
		 * Search data array for regular expression searching
		 *  @type array
		 *  @default []
		 */
		"asDataSearch": [],
		
		/**
		 * Store the applied global search information in case we want to force a 
		 * research or compare the old search to a new one.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @namespace
		 *  @extends DataTable.models.oSearch
		 */
		"oPreviousSearch": {},
		
		/**
		 * Store the applied search for each column - see 
		 * {@link DataTable.models.oSearch} for the format that is used for the
		 * filtering information for each column.
		 *  @type array
		 *  @default []
		 */
		"aoPreSearchCols": [],
		
		/**
		 * Sorting that is applied to the table. Note that the inner arrays are
		 * used in the following manner:
		 * <ul>
		 *   <li>Index 0 - column number</li>
		 *   <li>Index 1 - current sorting direction</li>
		 *   <li>Index 2 - index of asSorting for this column</li>
		 * </ul>
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @todo These inner arrays should really be objects
		 */
		"aaSorting": null,
		
		/**
		 * Sorting that is always applied to the table (i.e. prefixed in front of
		 * aaSorting).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array|null
		 *  @default null
		 */
		"aaSortingFixed": null,
		
		/**
		 * Classes to use for the striping of a table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"asStripeClasses": null,
		
		/**
		 * If restoring a table - we should restore its striping classes as well
		 *  @type array
		 *  @default []
		 */
		"asDestroyStripes": [],
		
		/**
		 * If restoring a table - we should restore its width 
		 *  @type int
		 *  @default 0
		 */
		"sDestroyWidth": 0,
		
		/**
		 * Callback functions array for every time a row is inserted (i.e. on a draw).
		 *  @type array
		 *  @default []
		 */
		"aoRowCallback": [],
		
		/**
		 * Callback functions for the header on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoHeaderCallback": [],
		
		/**
		 * Callback function for the footer on each draw.
		 *  @type array
		 *  @default []
		 */
		"aoFooterCallback": [],
		
		/**
		 * Array of callback functions for draw callback functions
		 *  @type array
		 *  @default []
		 */
		"aoDrawCallback": [],
		
		/**
		 * Array of callback functions for row created function
		 *  @type array
		 *  @default []
		 */
		"aoRowCreatedCallback": [],
		
		/**
		 * Callback functions for just before the table is redrawn. A return of 
		 * false will be used to cancel the draw.
		 *  @type array
		 *  @default []
		 */
		"aoPreDrawCallback": [],
		
		/**
		 * Callback functions for when the table has been initialised.
		 *  @type array
		 *  @default []
		 */
		"aoInitComplete": [],
	
		
		/**
		 * Callbacks for modifying the settings to be stored for state saving, prior to
		 * saving state.
		 *  @type array
		 *  @default []
		 */
		"aoStateSaveParams": [],
		
		/**
		 * Callbacks for modifying the settings that have been stored for state saving
		 * prior to using the stored values to restore the state.
		 *  @type array
		 *  @default []
		 */
		"aoStateLoadParams": [],
		
		/**
		 * Callbacks for operating on the settings object once the saved state has been
		 * loaded
		 *  @type array
		 *  @default []
		 */
		"aoStateLoaded": [],
		
		/**
		 * Cache the table ID for quick access
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sTableId": "",
		
		/**
		 * The TABLE node for the main table
		 *  @type node
		 *  @default null
		 */
		"nTable": null,
		
		/**
		 * Permanent ref to the thead element
		 *  @type node
		 *  @default null
		 */
		"nTHead": null,
		
		/**
		 * Permanent ref to the tfoot element - if it exists
		 *  @type node
		 *  @default null
		 */
		"nTFoot": null,
		
		/**
		 * Permanent ref to the tbody element
		 *  @type node
		 *  @default null
		 */
		"nTBody": null,
		
		/**
		 * Cache the wrapper node (contains all DataTables controlled elements)
		 *  @type node
		 *  @default null
		 */
		"nTableWrapper": null,
		
		/**
		 * Indicate if when using server-side processing the loading of data 
		 * should be deferred until the second draw.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 *  @default false
		 */
		"bDeferLoading": false,
		
		/**
		 * Indicate if all required information has been read in
		 *  @type boolean
		 *  @default false
		 */
		"bInitialised": false,
		
		/**
		 * Information about open rows. Each object in the array has the parameters
		 * 'nTr' and 'nParent'
		 *  @type array
		 *  @default []
		 */
		"aoOpenRows": [],
		
		/**
		 * Dictate the positioning of DataTables' control elements - see
		 * {@link DataTable.model.oInit.sDom}.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sDom": null,
		
		/**
		 * Which type of pagination should be used.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string 
		 *  @default two_button
		 */
		"sPaginationType": "two_button",
		
		/**
		 * The cookie duration (for bStateSave) in seconds.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type int
		 *  @default 0
		 */
		"iCookieDuration": 0,
		
		/**
		 * The cookie name prefix.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default <i>Empty string</i>
		 */
		"sCookiePrefix": "",
		
		/**
		 * Callback function for cookie creation.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 *  @default null
		 */
		"fnCookieCallback": null,
		
		/**
		 * Array of callback functions for state saving. Each array element is an 
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings
		 *       and the JSON string to save that has been thus far created. Returns
		 *       a JSON string to be inserted into a json object 
		 *       (i.e. '"param": [ 0, 1, 2]')</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateSave": [],
		
		/**
		 * Array of callback functions for state loading. Each array element is an 
		 * object with the following parameters:
		 *   <ul>
		 *     <li>function:fn - function to call. Takes two parameters, oSettings 
		 *       and the object stored. May return false to cancel state loading</li>
		 *     <li>string:sName - name of callback</li>
		 *   </ul>
		 *  @type array
		 *  @default []
		 */
		"aoStateLoad": [],
		
		/**
		 * State that was loaded from the cookie. Useful for back reference
		 *  @type object
		 *  @default null
		 */
		"oLoadedState": null,
		
		/**
		 * Source url for AJAX data for the table.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 *  @default null
		 */
		"sAjaxSource": null,
		
		/**
		 * Property from a given object from which to read the table data from. This
		 * can be an empty string (when not server-side processing), in which case 
		 * it is  assumed an an array is given directly.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sAjaxDataProp": null,
		
		/**
		 * Note if draw should be blocked while getting data
		 *  @type boolean
		 *  @default true
		 */
		"bAjaxDataGet": true,
		
		/**
		 * The last jQuery XHR object that was used for server-side data gathering. 
		 * This can be used for working with the XHR information in one of the 
		 * callbacks
		 *  @type object
		 *  @default null
		 */
		"jqXHR": null,
		
		/**
		 * Function to get the server-side data.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnServerData": null,
		
		/**
		 * Functions which are called prior to sending an Ajax request so extra 
		 * parameters can easily be sent to the server
		 *  @type array
		 *  @default []
		 */
		"aoServerParams": [],
		
		/**
		 * Send the XHR HTTP method - GET or POST (could be PUT or DELETE if 
		 * required).
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type string
		 */
		"sServerMethod": null,
		
		/**
		 * Format numbers for display.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type function
		 */
		"fnFormatNumber": null,
		
		/**
		 * List of options that can be used for the user selectable length menu.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type array
		 *  @default []
		 */
		"aLengthMenu": null,
		
		/**
		 * Counter for the draws that the table does. Also used as a tracker for
		 * server-side processing
		 *  @type int
		 *  @default 0
		 */
		"iDraw": 0,
		
		/**
		 * Indicate if a redraw is being done - useful for Ajax
		 *  @type boolean
		 *  @default false
		 */
		"bDrawing": false,
		
		/**
		 * Draw index (iDraw) of the last error when parsing the returned data
		 *  @type int
		 *  @default -1
		 */
		"iDrawError": -1,
		
		/**
		 * Paging display length
		 *  @type int
		 *  @default 10
		 */
		"_iDisplayLength": 10,
	
		/**
		 * Paging start point - aiDisplay index
		 *  @type int
		 *  @default 0
		 */
		"_iDisplayStart": 0,
	
		/**
		 * Paging end point - aiDisplay index. Use fnDisplayEnd rather than
		 * this property to get the end point
		 *  @type int
		 *  @default 10
		 *  @private
		 */
		"_iDisplayEnd": 10,
		
		/**
		 * Server-side processing - number of records in the result set
		 * (i.e. before filtering), Use fnRecordsTotal rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type int
		 *  @default 0
		 *  @private
		 */
		"_iRecordsTotal": 0,
	
		/**
		 * Server-side processing - number of records in the current display set
		 * (i.e. after filtering). Use fnRecordsDisplay rather than
		 * this property to get the value of the number of records, regardless of
		 * the server-side processing setting.
		 *  @type boolean
		 *  @default 0
		 *  @private
		 */
		"_iRecordsDisplay": 0,
		
		/**
		 * Flag to indicate if jQuery UI marking and classes should be used.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 */
		"bJUI": null,
		
		/**
		 * The classes to use for the table
		 *  @type object
		 *  @default {}
		 */
		"oClasses": {},
		
		/**
		 * Flag attached to the settings object so you can check in the draw 
		 * callback if filtering has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bFiltered": false,
		
		/**
		 * Flag attached to the settings object so you can check in the draw 
		 * callback if sorting has been done in the draw. Deprecated in favour of
		 * events.
		 *  @type boolean
		 *  @default false
		 *  @deprecated
		 */
		"bSorted": false,
		
		/**
		 * Indicate that if multiple rows are in the header and there is more than 
		 * one unique cell per column, if the top one (true) or bottom one (false) 
		 * should be used for sorting / title by DataTables.
		 * Note that this parameter will be set by the initialisation routine. To
		 * set a default use {@link DataTable.defaults}.
		 *  @type boolean
		 */
		"bSortCellsTop": null,
		
		/**
		 * Initialisation object that is used for the table
		 *  @type object
		 *  @default null
		 */
		"oInit": null,
		
		/**
		 * Destroy callback functions - for plug-ins to attach themselves to the
		 * destroy so they can clean up markup and events.
		 *  @type array
		 *  @default []
		 */
		"aoDestroyCallback": [],
	
		
		/**
		 * Get the number of records in the current record set, before filtering
		 *  @type function
		 */
		"fnRecordsTotal": function ()
		{
			if ( this.oFeatures.bServerSide ) {
				return parseInt(this._iRecordsTotal, 10);
			} else {
				return this.aiDisplayMaster.length;
			}
		},
		
		/**
		 * Get the number of records in the current record set, after filtering
		 *  @type function
		 */
		"fnRecordsDisplay": function ()
		{
			if ( this.oFeatures.bServerSide ) {
				return parseInt(this._iRecordsDisplay, 10);
			} else {
				return this.aiDisplay.length;
			}
		},
		
		/**
		 * Set the display end point - aiDisplay index
		 *  @type function
		 *  @todo Should do away with _iDisplayEnd and calculate it on-the-fly here
		 */
		"fnDisplayEnd": function ()
		{
			if ( this.oFeatures.bServerSide ) {
				if ( this.oFeatures.bPaginate === false || this._iDisplayLength == -1 ) {
					return this._iDisplayStart+this.aiDisplay.length;
				} else {
					return Math.min( this._iDisplayStart+this._iDisplayLength, 
						this._iRecordsDisplay );
				}
			} else {
				return this._iDisplayEnd;
			}
		},
		
		/**
		 * The DataTables object for this table
		 *  @type object
		 *  @default null
		 */
		"oInstance": null,
		
		/**
		 * Unique identifier for each instance of the DataTables object. If there
		 * is an ID on the table node, then it takes that value, otherwise an
		 * incrementing internal counter is used.
		 *  @type string
		 *  @default null
		 */
		"sInstance": null,
	
		/**
		 * tabindex attribute value that is added to DataTables control elements, allowing
		 * keyboard navigation of the table and its controls.
		 */
		"iTabIndex": 0
	};

	/**
	 * Extension object for DataTables that is used to provide all extension options.
	 * 
	 * Note that the <i>DataTable.ext</i> object is available through
	 * <i>jQuery.fn.dataTable.ext</i> where it may be accessed and manipulated. It is
	 * also aliased to <i>jQuery.fn.dataTableExt</i> for historic reasons.
	 *  @namespace
	 *  @extends DataTable.models.ext
	 */
	DataTable.ext = $.extend( true, {}, DataTable.models.ext );
	
	$.extend( DataTable.ext.oStdClasses, {
		"sTable": "dataTable",
	
		/* Two buttons buttons */
		"sPagePrevEnabled": "paginate_enabled_previous",
		"sPagePrevDisabled": "paginate_disabled_previous",
		"sPageNextEnabled": "paginate_enabled_next",
		"sPageNextDisabled": "paginate_disabled_next",
		"sPageJUINext": "",
		"sPageJUIPrev": "",
		
		/* Full numbers paging buttons */
		"sPageButton": "paginate_button",
		"sPageButtonActive": "paginate_active",
		"sPageButtonStaticDisabled": "paginate_button paginate_button_disabled",
		"sPageFirst": "first",
		"sPagePrevious": "previous",
		"sPageNext": "next",
		"sPageLast": "last",
		
		/* Striping classes */
		"sStripeOdd": "odd",
		"sStripeEven": "even",
		
		/* Empty row */
		"sRowEmpty": "dataTables_empty",
		
		/* Features */
		"sWrapper": "dataTables_wrapper",
		"sFilter": "dataTables_filter",
		"sInfo": "dataTables_info",
		"sPaging": "dataTables_paginate paging_", /* Note that the type is postfixed */
		"sLength": "dataTables_length",
		"sProcessing": "dataTables_processing",
		
		/* Sorting */
		"sSortAsc": "sorting_asc",
		"sSortDesc": "sorting_desc",
		"sSortable": "sorting", /* Sortable in both directions */
		"sSortableAsc": "sorting_asc_disabled",
		"sSortableDesc": "sorting_desc_disabled",
		"sSortableNone": "sorting_disabled",
		"sSortColumn": "sorting_", /* Note that an int is postfixed for the sorting order */
		"sSortJUIAsc": "",
		"sSortJUIDesc": "",
		"sSortJUI": "",
		"sSortJUIAscAllowed": "",
		"sSortJUIDescAllowed": "",
		"sSortJUIWrapper": "",
		"sSortIcon": "",
		
		/* Scrolling */
		"sScrollWrapper": "dataTables_scroll",
		"sScrollHead": "dataTables_scrollHead",
		"sScrollHeadInner": "dataTables_scrollHeadInner",
		"sScrollBody": "dataTables_scrollBody",
		"sScrollFoot": "dataTables_scrollFoot",
		"sScrollFootInner": "dataTables_scrollFootInner",
		
		/* Misc */
		"sFooterTH": ""
	} );
	
	
	$.extend( DataTable.ext.oJUIClasses, DataTable.ext.oStdClasses, {
		/* Two buttons buttons */
		"sPagePrevEnabled": "fg-button ui-button ui-state-default ui-corner-left",
		"sPagePrevDisabled": "fg-button ui-button ui-state-default ui-corner-left ui-state-disabled",
		"sPageNextEnabled": "fg-button ui-button ui-state-default ui-corner-right",
		"sPageNextDisabled": "fg-button ui-button ui-state-default ui-corner-right ui-state-disabled",
		"sPageJUINext": "ui-icon ui-icon-circle-arrow-e",
		"sPageJUIPrev": "ui-icon ui-icon-circle-arrow-w",
		
		/* Full numbers paging buttons */
		"sPageButton": "fg-button ui-button ui-state-default",
		"sPageButtonActive": "fg-button ui-button ui-state-default ui-state-disabled",
		"sPageButtonStaticDisabled": "fg-button ui-button ui-state-default ui-state-disabled",
		"sPageFirst": "first ui-corner-tl ui-corner-bl",
		"sPageLast": "last ui-corner-tr ui-corner-br",
		
		/* Features */
		"sPaging": "dataTables_paginate fg-buttonset ui-buttonset fg-buttonset-multi "+
			"ui-buttonset-multi paging_", /* Note that the type is postfixed */
		
		/* Sorting */
		"sSortAsc": "ui-state-default",
		"sSortDesc": "ui-state-default",
		"sSortable": "ui-state-default",
		"sSortableAsc": "ui-state-default",
		"sSortableDesc": "ui-state-default",
		"sSortableNone": "ui-state-default",
		"sSortJUIAsc": "css_right ui-icon ui-icon-triangle-1-n",
		"sSortJUIDesc": "css_right ui-icon ui-icon-triangle-1-s",
		"sSortJUI": "css_right ui-icon ui-icon-carat-2-n-s",
		"sSortJUIAscAllowed": "css_right ui-icon ui-icon-carat-1-n",
		"sSortJUIDescAllowed": "css_right ui-icon ui-icon-carat-1-s",
		"sSortJUIWrapper": "DataTables_sort_wrapper",
		"sSortIcon": "DataTables_sort_icon",
		
		/* Scrolling */
		"sScrollHead": "dataTables_scrollHead ui-state-default",
		"sScrollFoot": "dataTables_scrollFoot ui-state-default",
		
		/* Misc */
		"sFooterTH": "ui-state-default"
	} );
	
	
	/*
	 * Variable: oPagination
	 * Purpose:  
	 * Scope:    jQuery.fn.dataTableExt
	 */
	$.extend( DataTable.ext.oPagination, {
		/*
		 * Variable: two_button
		 * Purpose:  Standard two button (forward/back) pagination
		 * Scope:    jQuery.fn.dataTableExt.oPagination
		 */
		"two_button": {
			/*
			 * Function: oPagination.two_button.fnInit
			 * Purpose:  Initialise dom elements required for pagination with forward/back buttons only
			 * Returns:  -
			 * Inputs:   object:oSettings - dataTables settings object
			 *           node:nPaging - the DIV which contains this pagination control
			 *           function:fnCallbackDraw - draw function which must be called on update
			 */
			"fnInit": function ( oSettings, nPaging, fnCallbackDraw )
			{
				var oLang = oSettings.oLanguage.oPaginate;
				var oClasses = oSettings.oClasses;
				var fnClickHandler = function ( e ) {
					if ( oSettings.oApi._fnPageChange( oSettings, e.data.action ) )
					{
						fnCallbackDraw( oSettings );
					}
				};
	
				var sAppend = (!oSettings.bJUI) ?
					'<a class="'+oSettings.oClasses.sPagePrevDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button">'+oLang.sPrevious+'</a>'+
					'<a class="'+oSettings.oClasses.sPageNextDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button">'+oLang.sNext+'</a>'
					:
					'<a class="'+oSettings.oClasses.sPagePrevDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+oSettings.oClasses.sPageJUIPrev+'"></span></a>'+
					'<a class="'+oSettings.oClasses.sPageNextDisabled+'" tabindex="'+oSettings.iTabIndex+'" role="button"><span class="'+oSettings.oClasses.sPageJUINext+'"></span></a>';
				$(nPaging).append( sAppend );
				
				var els = $('a', nPaging);
				var nPrevious = els[0],
					nNext = els[1];
				
				oSettings.oApi._fnBindAction( nPrevious, {action: "previous"}, fnClickHandler );
				oSettings.oApi._fnBindAction( nNext,     {action: "next"},     fnClickHandler );
				
				/* ID the first elements only */
				if ( !oSettings.aanFeatures.p )
				{
					nPaging.id = oSettings.sTableId+'_paginate';
					nPrevious.id = oSettings.sTableId+'_previous';
					nNext.id = oSettings.sTableId+'_next';
	
					nPrevious.setAttribute('aria-controls', oSettings.sTableId);
					nNext.setAttribute('aria-controls', oSettings.sTableId);
				}
			},
			
			/*
			 * Function: oPagination.two_button.fnUpdate
			 * Purpose:  Update the two button pagination at the end of the draw
			 * Returns:  -
			 * Inputs:   object:oSettings - dataTables settings object
			 *           function:fnCallbackDraw - draw function to call on page change
			 */
			"fnUpdate": function ( oSettings, fnCallbackDraw )
			{
				if ( !oSettings.aanFeatures.p )
				{
					return;
				}
				
				var oClasses = oSettings.oClasses;
				var an = oSettings.aanFeatures.p;
	
				/* Loop over each instance of the pager */
				for ( var i=0, iLen=an.length ; i<iLen ; i++ )
				{
					if ( an[i].childNodes.length !== 0 )
					{
						an[i].childNodes[0].className = ( oSettings._iDisplayStart === 0 ) ? 
							oClasses.sPagePrevDisabled : oClasses.sPagePrevEnabled;
						
						an[i].childNodes[1].className = ( oSettings.fnDisplayEnd() == oSettings.fnRecordsDisplay() ) ? 
							oClasses.sPageNextDisabled : oClasses.sPageNextEnabled;
					}
				}
			}
		},
		
		
		/*
		 * Variable: iFullNumbersShowPages
		 * Purpose:  Change the number of pages which can be seen
		 * Scope:    jQuery.fn.dataTableExt.oPagination
		 */
		"iFullNumbersShowPages": 5,
		
		/*
		 * Variable: full_numbers
		 * Purpose:  Full numbers pagination
		 * Scope:    jQuery.fn.dataTableExt.oPagination
		 */
		"full_numbers": {
			/*
			 * Function: oPagination.full_numbers.fnInit
			 * Purpose:  Initialise dom elements required for pagination with a list of the pages
			 * Returns:  -
			 * Inputs:   object:oSettings - dataTables settings object
			 *           node:nPaging - the DIV which contains this pagination control
			 *           function:fnCallbackDraw - draw function which must be called on update
			 */
			"fnInit": function ( oSettings, nPaging, fnCallbackDraw )
			{
				var oLang = oSettings.oLanguage.oPaginate;
				var oClasses = oSettings.oClasses;
				var fnClickHandler = function ( e ) {
					if ( oSettings.oApi._fnPageChange( oSettings, e.data.action ) )
					{
						fnCallbackDraw( oSettings );
					}
				};
	
				$(nPaging).append(
					'<a  tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPageFirst+'">'+oLang.sFirst+'</a>'+
					'<a  tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPagePrevious+'">'+oLang.sPrevious+'</a>'+
					'<span></span>'+
					'<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPageNext+'">'+oLang.sNext+'</a>'+
					'<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+" "+oClasses.sPageLast+'">'+oLang.sLast+'</a>'
				);
				var els = $('a', nPaging);
				var nFirst = els[0],
					nPrev = els[1],
					nNext = els[2],
					nLast = els[3];
				
				oSettings.oApi._fnBindAction( nFirst, {action: "first"},    fnClickHandler );
				oSettings.oApi._fnBindAction( nPrev,  {action: "previous"}, fnClickHandler );
				oSettings.oApi._fnBindAction( nNext,  {action: "next"},     fnClickHandler );
				oSettings.oApi._fnBindAction( nLast,  {action: "last"},     fnClickHandler );
				
				/* ID the first elements only */
				if ( !oSettings.aanFeatures.p )
				{
					nPaging.id = oSettings.sTableId+'_paginate';
					nFirst.id =oSettings.sTableId+'_first';
					nPrev.id =oSettings.sTableId+'_previous';
					nNext.id =oSettings.sTableId+'_next';
					nLast.id =oSettings.sTableId+'_last';
				}
			},
			
			/*
			 * Function: oPagination.full_numbers.fnUpdate
			 * Purpose:  Update the list of page buttons shows
			 * Returns:  -
			 * Inputs:   object:oSettings - dataTables settings object
			 *           function:fnCallbackDraw - draw function to call on page change
			 */
			"fnUpdate": function ( oSettings, fnCallbackDraw )
			{
				if ( !oSettings.aanFeatures.p )
				{
					return;
				}
				
				var iPageCount = DataTable.ext.oPagination.iFullNumbersShowPages;
				var iPageCountHalf = Math.floor(iPageCount / 2);
				var iPages = Math.ceil((oSettings.fnRecordsDisplay()) / oSettings._iDisplayLength);
				var iCurrentPage = Math.ceil(oSettings._iDisplayStart / oSettings._iDisplayLength) + 1;
				var sList = "";
				var iStartButton, iEndButton, i, iLen;
				var oClasses = oSettings.oClasses;
				var anButtons, anStatic, nPaginateList;
				var an = oSettings.aanFeatures.p;
				var fnBind = function (j) {
					oSettings.oApi._fnBindAction( this, {"page": j+iStartButton-1}, function(e) {
						/* Use the information in the element to jump to the required page */
						oSettings.oApi._fnPageChange( oSettings, e.data.page );
						fnCallbackDraw( oSettings );
						e.preventDefault();
					} );
				};
				
				/* Pages calculation */
				if (iPages < iPageCount)
				{
					iStartButton = 1;
					iEndButton = iPages;
				}
				else if (iCurrentPage <= iPageCountHalf)
				{
					iStartButton = 1;
					iEndButton = iPageCount;
				}
				else if (iCurrentPage >= (iPages - iPageCountHalf))
				{
					iStartButton = iPages - iPageCount + 1;
					iEndButton = iPages;
				}
				else
				{
					iStartButton = iCurrentPage - Math.ceil(iPageCount / 2) + 1;
					iEndButton = iStartButton + iPageCount - 1;
				}
				
				/* Build the dynamic list */
				for ( i=iStartButton ; i<=iEndButton ; i++ )
				{
					sList += (iCurrentPage !== i) ?
						'<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButton+'">'+oSettings.fnFormatNumber(i)+'</a>' :
						'<a tabindex="'+oSettings.iTabIndex+'" class="'+oClasses.sPageButtonActive+'">'+oSettings.fnFormatNumber(i)+'</a>';
				}
				
				/* Loop over each instance of the pager */
				for ( i=0, iLen=an.length ; i<iLen ; i++ )
				{
					if ( an[i].childNodes.length === 0 )
					{
						continue;
					}
					
					/* Build up the dynamic list forst - html and listeners */
					$('span:eq(0)', an[i])
						.html( sList )
						.children('a').each( fnBind );
					
					/* Update the premanent botton's classes */
					anButtons = an[i].getElementsByTagName('a');
					anStatic = [
						anButtons[0], anButtons[1], 
						anButtons[anButtons.length-2], anButtons[anButtons.length-1]
					];
	
					$(anStatic).removeClass( oClasses.sPageButton+" "+oClasses.sPageButtonActive+" "+oClasses.sPageButtonStaticDisabled );
					$([anStatic[0], anStatic[1]]).addClass( 
						(iCurrentPage==1) ?
							oClasses.sPageButtonStaticDisabled :
							oClasses.sPageButton
					);
					$([anStatic[2], anStatic[3]]).addClass(
						(iPages===0 || iCurrentPage===iPages || oSettings._iDisplayLength===-1) ?
							oClasses.sPageButtonStaticDisabled :
							oClasses.sPageButton
					);
				}
			}
		}
	} );
	
	$.extend( DataTable.ext.oSort, {
		/*
		 * text sorting
		 */
		"string-pre": function ( a )
		{
			if ( typeof a != 'string' ) { a = ''; }
			return a.toLowerCase();
		},
	
		"string-asc": function ( x, y )
		{
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		},
		
		"string-desc": function ( x, y )
		{
			return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		},
		
		
		/*
		 * html sorting (ignore html tags)
		 */
		"html-pre": function ( a )
		{
			return a.replace( /<.*?>/g, "" ).toLowerCase();
		},
		
		"html-asc": function ( x, y )
		{
			return ((x < y) ? -1 : ((x > y) ? 1 : 0));
		},
		
		"html-desc": function ( x, y )
		{
			return ((x < y) ? 1 : ((x > y) ? -1 : 0));
		},
		
		
		/*
		 * date sorting
		 */
		"date-pre": function ( a )
		{
			var x = Date.parse( a );
			
			if ( isNaN(x) || x==="" )
			{
				x = Date.parse( "01/01/1970 00:00:00" );
			}
			return x;
		},
	
		"date-asc": function ( x, y )
		{
			return x - y;
		},
		
		"date-desc": function ( x, y )
		{
			return y - x;
		},
		
		
		/*
		 * numerical sorting
		 */
		"numeric-pre": function ( a )
		{
			return (a=="-" || a==="") ? 0 : a*1;
		},
	
		"numeric-asc": function ( x, y )
		{
			return x - y;
		},
		
		"numeric-desc": function ( x, y )
		{
			return y - x;
		}
	} );
	
	
	$.extend( DataTable.ext.aTypes, [
		/*
		 * Function: -
		 * Purpose:  Check to see if a string is numeric
		 * Returns:  string:'numeric' or null
		 * Inputs:   mixed:sText - string to check
		 */
		function ( sData )
		{
			/* Allow zero length strings as a number */
			if ( typeof sData === 'number' )
			{
				return 'numeric';
			}
			else if ( typeof sData !== 'string' )
			{
				return null;
			}
			
			var sValidFirstChars = "0123456789-";
			var sValidChars = "0123456789.";
			var Char;
			var bDecimal = false;
			
			/* Check for a valid first char (no period and allow negatives) */
			Char = sData.charAt(0); 
			if (sValidFirstChars.indexOf(Char) == -1) 
			{
				return null;
			}
			
			/* Check all the other characters are valid */
			for ( var i=1 ; i<sData.length ; i++ ) 
			{
				Char = sData.charAt(i); 
				if (sValidChars.indexOf(Char) == -1) 
				{
					return null;
				}
				
				/* Only allowed one decimal place... */
				if ( Char == "." )
				{
					if ( bDecimal )
					{
						return null;
					}
					bDecimal = true;
				}
			}
			
			return 'numeric';
		},
		
		/*
		 * Function: -
		 * Purpose:  Check to see if a string is actually a formatted date
		 * Returns:  string:'date' or null
		 * Inputs:   string:sText - string to check
		 */
		function ( sData )
		{
			var iParse = Date.parse(sData);
			if ( (iParse !== null && !isNaN(iParse)) || (typeof sData === 'string' && sData.length === 0) )
			{
				return 'date';
			}
			return null;
		},
		
		/*
		 * Function: -
		 * Purpose:  Check to see if a string should be treated as an HTML string
		 * Returns:  string:'html' or null
		 * Inputs:   string:sText - string to check
		 */
		function ( sData )
		{
			if ( typeof sData === 'string' && sData.indexOf('<') != -1 && sData.indexOf('>') != -1 )
			{
				return 'html';
			}
			return null;
		}
	] );
	

	// jQuery aliases
	$.fn.DataTable = DataTable;
	$.fn.dataTable = DataTable;
	$.fn.dataTableSettings = DataTable.settings;
	$.fn.dataTableExt = DataTable.ext;


	// Information about events fired by DataTables - for documentation.
	/**
	 * Draw event, fired whenever the table is redrawn on the page, at the same point as
	 * fnDrawCallback. This may be useful for binding events or performing calculations when
	 * the table is altered at all.
	 *  @name DataTable#draw
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Filter event, fired when the filtering applied to the table (using the build in global
	 * global filter, or column filters) is altered.
	 *  @name DataTable#filter
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Page change event, fired when the paging of the table is altered.
	 *  @name DataTable#page
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * Sort event, fired when the sorting applied to the table is altered.
	 *  @name DataTable#sort
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */

	/**
	 * DataTables initialisation complete event, fired when the table is fully drawn,
	 * including Ajax data loaded, if Ajax data is required.
	 *  @name DataTable#init
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The JSON object request from the server - only
	 *    present if client-side Ajax sourced data is used</li></ol>
	 */

	/**
	 * State save event, fired when the table has changed state a new state save is required.
	 * This method allows modification of the state saving object prior to actually doing the
	 * save, including addition or other state properties (for plug-ins) or modification
	 * of a DataTables core property.
	 *  @name DataTable#stateSaveParams
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The state information to be saved
	 */

	/**
	 * State load event, fired when the table is loading state from the stored data, but
	 * prior to the settings object being modified by the saved state - allowing modification
	 * of the saved state is required or loading of state for a plug-in.
	 *  @name DataTable#stateLoadParams
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */

	/**
	 * State loaded event, fired when state has been loaded from stored data and the settings
	 * object has been modified by the loaded data.
	 *  @name DataTable#stateLoaded
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {object} json The saved state information
	 */

	/**
	 * Processing event, fired when DataTables is doing some kind of processing (be it,
	 * sort, filter or anything else). Can be used to indicate to the end user that
	 * there is something happening, or that something has finished.
	 *  @name DataTable#processing
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} oSettings DataTables settings object
	 *  @param {boolean} bShow Flag for if DataTables is doing processing or not
	 */

	/**
	 * Ajax (XHR) event, fired whenever an Ajax request is completed from a request to 
	 * made to the server for new data (note that this trigger is called in fnServerData,
	 * if you override fnServerData and which to use this event, you need to trigger it in
	 * you success function).
	 *  @name DataTable#xhr
	 *  @event
	 *  @param {event} e jQuery event object
	 *  @param {object} o DataTables settings object {@link DataTable.models.oSettings}
	 */
}(jQuery, window, document, undefined));
/**
 * @preserve jQuery DateTimePicker plugin v2.3.4
 * @homepage http://xdsoft.net/jqplugins/datetimepicker/
 * (c) 2014, Chupurnov Valeriy.
 */
(function( $ ) {
	'use strict';
	var default_options  = {
		i18n:{
			bg:{ // Bulgarian
				months:[
					"Януари", "Февруари", "Март", "Април", "Май", "Юни", "Юли", "Август", "Септември", "Октомври", "Ноември", "Декември"
				],
				dayOfWeek:[
					"Нд", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"
				]
			},
			fa:{ // Persian/Farsi
				months:[
					'فروردین', 'اردیبهشت', 'خرداد', 'تیر', 'مرداد', 'شهریور', 'مهر', 'آبان', 'آذر', 'دی', 'بهمن', 'اسفند'
				],
				dayOfWeek:[
					'یکشنبه', 'دوشنبه', 'سه شنبه', 'چهارشنبه', 'پنجشنبه', 'جمعه', 'شنبه'
				]
			},
			ru:{ // Russian
				months:[
					'Январь','Февраль','Март','Апрель','Май','Июнь','Июль','Август','Сентябрь','Октябрь','Ноябрь','Декабрь'
				],
				dayOfWeek:[
					"Вск", "Пн", "Вт", "Ср", "Чт", "Пт", "Сб"
				]
			},
			uk:{ // Ukrainian
				months:[
					'Січень','Лютий','Березень','Квітень','Травень','Червень','Липень','Серпень','Вересень','Жовтень','Листопад','Грудень'
				],
				dayOfWeek:[
					"Ндл", "Пнд", "Втр", "Срд", "Чтв", "Птн", "Сбт"
				]
			},
			en:{ // English
				months: [
					"January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"
				],
				dayOfWeek: [
					"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"
				]
			},
			el:{ // Ελληνικά
				months: [
					"Ιανουάριος", "Φεβρουάριος", "Μάρτιος", "Απρίλιος", "Μάιος", "Ιούνιος", "Ιούλιος", "Αύγουστος", "Σεπτέμβριος", "Οκτώβριος", "Νοέμβριος", "Δεκέμβριος"
				],
				dayOfWeek: [
					"Κυρ", "Δευ", "Τρι", "Τετ", "Πεμ", "Παρ", "Σαβ"
				]
			},
			de:{ // German
				months:[
					'Januar','Februar','März','April','Mai','Juni','Juli','August','September','Oktober','November','Dezember'
				],
				dayOfWeek:[
					"So", "Mo", "Di", "Mi", "Do", "Fr", "Sa"
				]
			},
			nl:{ // Dutch
				months:[
					"januari", "februari", "maart", "april", "mei", "juni", "juli", "augustus", "september", "oktober", "november", "december"
				],
				dayOfWeek:[
					"zo", "ma", "di", "wo", "do", "vr", "za"
				]
			},
			tr:{ // Turkish
				months:[
					"Ocak", "Şubat", "Mart", "Nisan", "Mayıs", "Haziran", "Temmuz", "Ağustos", "Eylül", "Ekim", "Kasım", "Aralık"
				],
				dayOfWeek:[
					"Paz", "Pts", "Sal", "Çar", "Per", "Cum", "Cts"
				]
			},
			fr:{ //French
				months:[
			    "Janvier", "Février", "Mars", "Avril", "Mai", "Juin", "Juillet", "Août", "Septembre", "Octobre", "Novembre", "Décembre"
				],
				dayOfWeek:[
					"Dim", "Lun", "Mar", "Mer", "Jeu", "Ven", "Sam"
				]
			},
			es:{ // Spanish
				months: [
					"Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre"
				],
				dayOfWeek: [
					"Dom", "Lun", "Mar", "Mié", "Jue", "Vie", "Sáb"
				]
			},
			th:{ // Thai
				months:[
					'มกราคม','กุมภาพันธ์','มีนาคม','เมษายน','พฤษภาคม','มิถุนายน','กรกฎาคม','สิงหาคม','กันยายน','ตุลาคม','พฤศจิกายน','ธันวาคม'
				],
				dayOfWeek:[
					'อา.','จ.','อ.','พ.','พฤ.','ศ.','ส.'
				]
			},
			pl:{ // Polish
				months: [
					"styczeń", "luty", "marzec", "kwiecień", "maj", "czerwiec", "lipiec", "sierpień", "wrzesień", "październik", "listopad", "grudzień"
				],
				dayOfWeek: [
					"nd", "pn", "wt", "śr", "cz", "pt", "sb"
				]
			},
			pt:{ // Portuguese
				months: [
					"Janeiro", "Fevereiro", "Março", "Abril", "Maio", "Junho", "Julho", "Agosto", "Setembro", "Outubro", "Novembro", "Dezembro"
				],
				dayOfWeek: [
					"Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sab"
				]
			},
			ch:{ // Simplified Chinese
				months: [
					"一月","二月","三月","四月","五月","六月","七月","八月","九月","十月","十一月","十二月"
				],
				dayOfWeek: [
					"日", "一","二","三","四","五","六"
				]
			},
			se:{ // Swedish
				months: [
					"Januari", "Februari", "Mars", "April", "Maj", "Juni", "Juli", "Augusti", "September","Oktober", "November", "December"
				],
				dayOfWeek: [
					"Sön", "Mån", "Tis", "Ons", "Tor", "Fre", "Lör"
				]
			},
			kr:{ // Korean
				months: [
					"1월", "2월", "3월", "4월", "5월", "6월", "7월", "8월", "9월", "10월", "11월", "12월"
				],
				dayOfWeek: [
					"일", "월", "화", "수", "목", "금", "토"
				]
			},
			it:{ // Italian
				months: [
					"Gennaio", "Febbraio", "Marzo", "Aprile", "Maggio", "Giugno", "Luglio", "Agosto", "Settembre", "Ottobre", "Novembre", "Dicembre"
				],
				dayOfWeek: [
					"Dom", "Lun", "Mar", "Mer", "Gio", "Ven", "Sab"
				]
			},
			da:{ // Dansk
				months: [
					"January", "Februar", "Marts", "April", "Maj", "Juni", "July", "August", "September", "Oktober", "November", "December"
				],
				dayOfWeek: [
					"Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"
				]
			},
			no:{ // Norwegian
				months: [
					"Januar", "Februar", "Mars", "April", "Mai", "Juni", "Juli", "August", "September", "Oktober", "November", "Desember"
				],
				dayOfWeek: [
					"Søn", "Man", "Tir", "Ons", "Tor", "Fre", "Lør"
				]
			},
			ja:{ // Japanese
				months: [
					"1月", "2月", "3月", "4月", "5月", "6月", "7月", "8月", "9月", "10月", "11月", "12月"
				],
				dayOfWeek: [
					"日", "月", "火", "水", "木", "金", "土"
				]
			},
			vi:{ // Vietnamese
				months: [
					"Tháng 1", "Tháng 2", "Tháng 3", "Tháng 4", "Tháng 5", "Tháng 6", "Tháng 7", "Tháng 8", "Tháng 9", "Tháng 10", "Tháng 11", "Tháng 12"
				],
				dayOfWeek: [
					"CN", "T2", "T3", "T4", "T5", "T6", "T7"
				]
			},
			sl:{ // Slovenščina
				months: [
					"Januar", "Februar", "Marec", "April", "Maj", "Junij", "Julij", "Avgust", "September", "Oktober", "November", "December"
				],
				dayOfWeek: [
					"Ned", "Pon", "Tor", "Sre", "Čet", "Pet", "Sob"
				]
			},
			cs:{ // Čeština
				months: [
					"Leden", "Únor", "Březen", "Duben", "Květen", "Červen", "Červenec", "Srpen", "Září", "Říjen", "Listopad", "Prosinec"
				],
				dayOfWeek: [
					"Ne", "Po", "Út", "St", "Čt", "Pá", "So"
				]
			},
			hu:{ // Hungarian
			    months: [
					"Január", "Február", "Március", "Április", "Május", "Június", "Július", "Augusztus", "Szeptember", "Október", "November", "December"
			    ],
			    dayOfWeek: [
					"Va", "Hé", "Ke", "Sze", "Cs", "Pé", "Szo"
			    ]
			}
		},
		value:'',
		lang:'en',
		
		format:	'Y/m/d H:i',
		formatTime:	'H:i',
		formatDate:	'Y/m/d',
		
		startDate:	false, // new Date(), '1986/12/08', '-1970/01/05','-1970/01/05', 
		
		step:60,
		monthChangeSpinner:true,
		closeOnDateSelect:false,
		closeOnWithoutClick:true,
		closeOnInputClick: true,
		
		timepicker:true,
		datepicker:true,
		weeks:false,
		
		defaultTime:false,		// use formatTime format (ex. '10:00' for formatTime:	'H:i')
		defaultDate:false, 		// use formatDate format (ex new Date() or '1986/12/08' or '-1970/01/05' or '-1970/01/05')
		
		minDate:false,
		maxDate:false,
		minTime:false,
		maxTime:false,
		
		allowTimes:[],
		opened:false,
		initTime:true,
		inline:false,
		
		onSelectDate:function() {},
		onSelectTime:function() {},
		onChangeMonth:function() {},
		onChangeDateTime:function() {},
		onShow:function() {},
		onClose:function() {},
		onGenerate:function() {},
		
		withoutCopyright:true,
		
		inverseButton:false,
		hours12:false,
		next:	'xdsoft_next',
		prev : 'xdsoft_prev',
		dayOfWeekStart:0,
		
		timeHeightInTimePicker:25,
		timepickerScrollbar:true,
		
		todayButton:true, // 2.1.0
		defaultSelect:true, // 2.1.0
		
		scrollMonth:true,
		scrollTime:true,
		scrollInput:true,
		
		lazyInit:false,
		
		mask:false,
		validateOnBlur:true,
		allowBlank:true,
		
		yearStart:1950,
		yearEnd:2050,
		
		style:'',
		id:'',
		
		fixed: false,
		
		roundTime:'round', // ceil, floor
		className:'',
		
		weekends	: 	[],
		yearOffset:0,
		beforeShowDay: null
	};
	
	// fix for ie8
	if ( !Array.prototype.indexOf ) {
		Array.prototype.indexOf = function(obj, start) {
			 for (var i = (start || 0), j = this.length; i < j; i++) {
				 if (this[i] === obj) { return i; }
			 }
			 return -1;
		}
	}
	
	Date.prototype.countDaysInMonth = function(){
		return new Date(this.getFullYear(), this.getMonth()+1, 0).getDate();
	};
	
	$.fn.xdsoftScroller = function( _percent ) {
		return this.each(function() {
			var timeboxparent = $(this);
			if( !$(this).hasClass('xdsoft_scroller_box') ) {
				var pointerEventToXY = function( e ) {
						var out = {x:0, y:0};
						if( e.type == 'touchstart' || e.type == 'touchmove' || e.type == 'touchend' || e.type == 'touchcancel' ) {
							var touch = e.originalEvent.touches[0] || e.originalEvent.changedTouches[0];
							out.x = touch.pageX;
							out.y = touch.pageY;
						}else if (e.type == 'mousedown' || e.type == 'mouseup' || e.type == 'mousemove' || e.type == 'mouseover'|| e.type=='mouseout' || e.type=='mouseenter' || e.type=='mouseleave') {
							out.x = e.pageX;
							out.y = e.pageY;
						}
						return out;
					},
					move = 0,
					timebox = timeboxparent.children().eq(0),
					parentHeight = timeboxparent[0].clientHeight,
					height = timebox[0].offsetHeight,
					scrollbar = $('<div class="xdsoft_scrollbar"></div>'),
					scroller = $('<div class="xdsoft_scroller"></div>'),
					maximumOffset = 100,
					start = false;

				scrollbar.append(scroller);

				timeboxparent.addClass('xdsoft_scroller_box').append(scrollbar);
				scroller.on('mousedown.xdsoft_scroller',function ( event ) {
					if( !parentHeight )
						timeboxparent.trigger('resize_scroll.xdsoft_scroller',[_percent]);
					var pageY = event.pageY,
						top = parseInt(scroller.css('margin-top')),
						h1 = scrollbar[0].offsetHeight;
					$(document.body).addClass('xdsoft_noselect');
					$([document.body,window]).on('mouseup.xdsoft_scroller',function arguments_callee() {
						$([document.body,window]).off('mouseup.xdsoft_scroller',arguments_callee)
							.off('mousemove.xdsoft_scroller',move)
							.removeClass('xdsoft_noselect');
					});
					$(document.body).on('mousemove.xdsoft_scroller',move = function(event) {
						var offset = event.pageY-pageY+top;
						if( offset<0 )
							offset = 0;
						if( offset+scroller[0].offsetHeight>h1 )
							offset = h1-scroller[0].offsetHeight;
						timeboxparent.trigger('scroll_element.xdsoft_scroller',[maximumOffset?offset/maximumOffset:0]);
					});
				});

				timeboxparent
					.on('scroll_element.xdsoft_scroller',function( event,percent ) {
						if( !parentHeight )
							timeboxparent.trigger('resize_scroll.xdsoft_scroller',[percent,true]);
						percent = percent>1?1:(percent<0||isNaN(percent))?0:percent;
						scroller.css('margin-top',maximumOffset*percent);
						timebox.css('marginTop',-parseInt((height-parentHeight)*percent))
					})
					.on('resize_scroll.xdsoft_scroller',function( event,_percent,noTriggerScroll ) {
						parentHeight = timeboxparent[0].clientHeight;
						height = timebox[0].offsetHeight;
						var percent = parentHeight/height,
							sh = percent*scrollbar[0].offsetHeight;
						if( percent>1 )
							scroller.hide();
						else{
							scroller.show();
							scroller.css('height',parseInt(sh>10?sh:10));
							maximumOffset = scrollbar[0].offsetHeight-scroller[0].offsetHeight;
							if( noTriggerScroll!==true )
								timeboxparent.trigger('scroll_element.xdsoft_scroller',[_percent?_percent:Math.abs(parseInt(timebox.css('marginTop')))/(height-parentHeight)]);
						}
					});
				timeboxparent.mousewheel&&timeboxparent.mousewheel(function(event, delta, deltaX, deltaY) {
					var top = Math.abs(parseInt(timebox.css('marginTop')));
					timeboxparent.trigger('scroll_element.xdsoft_scroller',[(top-delta*20)/(height-parentHeight)]);
					event.stopPropagation();
					return false;
				});
				timeboxparent.on('touchstart',function( event ) {
					start = pointerEventToXY(event);
				});
				timeboxparent.on('touchmove',function( event ) {
					if( start ) {
						var coord = pointerEventToXY(event), top = Math.abs(parseInt(timebox.css('marginTop')));
						timeboxparent.trigger('scroll_element.xdsoft_scroller',[(top-(coord.y-start.y))/(height-parentHeight)]);
						event.stopPropagation();
						event.preventDefault();
						start = pointerEventToXY(event);
					}
				});
				timeboxparent.on('touchend touchcancel',function( event ) {
					start = false;
				});
			}
			timeboxparent.trigger('resize_scroll.xdsoft_scroller',[_percent]);
		});
	};
	$.fn.datetimepicker = function( opt ) {
		var KEY0 = 48,
			KEY9 = 57,
			_KEY0 = 96,
			_KEY9 = 105,
			CTRLKEY = 17,
			DEL = 46,
			ENTER = 13,
			ESC = 27,
			BACKSPACE = 8,
			ARROWLEFT = 37,
			ARROWUP = 38,
			ARROWRIGHT = 39,
			ARROWDOWN = 40,
			TAB = 9,
			F5 = 116,
			AKEY = 65,
			CKEY = 67,
			VKEY = 86,
			ZKEY = 90,
			YKEY = 89,
			ctrlDown	=	false,
			options = ($.isPlainObject(opt)||!opt)?$.extend(true,{},default_options,opt):$.extend({},default_options),

			lazyInitTimer = 0,

			lazyInit = function( input ){
				input
					.on('open.xdsoft focusin.xdsoft mousedown.xdsoft',function initOnActionCallback(event) {
						if( input.is(':disabled')||input.is(':hidden')||!input.is(':visible')||input.data( 'xdsoft_datetimepicker') )
							return;
				
						clearTimeout(lazyInitTimer);
						
						lazyInitTimer = setTimeout(function() {

							if( !input.data( 'xdsoft_datetimepicker') )
								createDateTimePicker(input);
								
							input
								.off('open.xdsoft focusin.xdsoft mousedown.xdsoft',initOnActionCallback)
								.trigger('open.xdsoft');
						},100);
						
					});
			},
			
			createDateTimePicker = function( input ) {
				
				var datetimepicker = $('<div '+(options.id?'id="'+options.id+'"':'')+' '+(options.style?'style="'+options.style+'"':'')+' class="xdsoft_datetimepicker xdsoft_noselect '+(options.weeks?' xdsoft_showweeks':'')+options.className+'"></div>'),
					xdsoft_copyright = $('<div class="xdsoft_copyright"><a target="_blank" href="http://xdsoft.net/jqplugins/datetimepicker/">xdsoft.net</a></div>'),
					datepicker = $('<div class="xdsoft_datepicker active"></div>'),
					mounth_picker = $('<div class="xdsoft_mounthpicker"><button type="button" class="xdsoft_prev"></button><button type="button" class="xdsoft_today_button"></button><div class="xdsoft_label xdsoft_month"><span></span></div><div class="xdsoft_label xdsoft_year"><span></span></div><button type="button" class="xdsoft_next"></button></div>'),
					calendar = $('<div class="xdsoft_calendar"></div>'),
					timepicker = $('<div class="xdsoft_timepicker active"><button type="button" class="xdsoft_prev"></button><div class="xdsoft_time_box"></div><button type="button" class="xdsoft_next"></button></div>'),
					timeboxparent = timepicker.find('.xdsoft_time_box').eq(0),
					timebox = $('<div class="xdsoft_time_variant"></div>'),
					scrollbar = $('<div class="xdsoft_scrollbar"></div>'),
					scroller = $('<div class="xdsoft_scroller"></div>'),
					monthselect =$('<div class="xdsoft_select xdsoft_monthselect"><div></div></div>'),
					yearselect =$('<div class="xdsoft_select xdsoft_yearselect"><div></div></div>');

				//constructor lego
				mounth_picker
					.find('.xdsoft_month span')
						.after(monthselect);
				mounth_picker
					.find('.xdsoft_year span')
						.after(yearselect);

				mounth_picker
					.find('.xdsoft_month,.xdsoft_year')
						.on('mousedown.xdsoft',function(event) {
							mounth_picker
								.find('.xdsoft_select')
									.hide();
									
							var select = $(this).find('.xdsoft_select').eq(0),
								val = 0,
								top = 0;

							if( _xdsoft_datetime.currentTime )
								val = _xdsoft_datetime.currentTime[$(this).hasClass('xdsoft_month')?'getMonth':'getFullYear']();

							select.show();
							
							for(var items = select.find('div.xdsoft_option'),i = 0;i<items.length;i++) {
								if( items.eq(i).data('value')==val ) {
									break;
								}else top+=items[0].offsetHeight;
							}

							select.xdsoftScroller(top/(select.children()[0].offsetHeight-(select[0].clientHeight)));
							event.stopPropagation();
							
							return false;
						});

				mounth_picker
					.find('.xdsoft_select')
						.xdsoftScroller()
						.on('mousedown.xdsoft',function( event ) {
							event.stopPropagation();
							event.preventDefault();
						})
						.on('mousedown.xdsoft','.xdsoft_option',function( event ) {
							if( _xdsoft_datetime&&_xdsoft_datetime.currentTime )
								_xdsoft_datetime.currentTime[$(this).parent().parent().hasClass('xdsoft_monthselect')?'setMonth':'setFullYear']($(this).data('value'));
							
							$(this).parent().parent().hide();
							
							datetimepicker.trigger('xchange.xdsoft');
							options.onChangeMonth&&options.onChangeMonth.call&&options.onChangeMonth.call(datetimepicker,_xdsoft_datetime.currentTime,datetimepicker.data('input'));
						});


				// set options
				datetimepicker.setOptions = function( _options ) {
					options = $.extend(true,{},options,_options);
					
					if( _options.allowTimes && $.isArray(_options.allowTimes) && _options.allowTimes.length ){
						options['allowTimes'] = $.extend(true,[],_options.allowTimes);
					}
					
					if( _options.weekends && $.isArray(_options.weekends) && _options.weekends.length ){
						options['weekends'] = $.extend(true,[],_options.weekends);
					}
					
					if( (options.open||options.opened)&&(!options.inline) ) {
						input.trigger('open.xdsoft');
					}

					if( options.inline ) {
						triggerAfterOpen = true;
						datetimepicker.addClass('xdsoft_inline');
						input.after(datetimepicker).hide();
					}

					if( options.inverseButton ) {
						options.next = 'xdsoft_prev';
						options.prev = 'xdsoft_next';
					}

					if( options.datepicker )
						datepicker.addClass('active');
					else
						datepicker.removeClass('active');

					if( options.timepicker )
						timepicker.addClass('active');
					else
						timepicker.removeClass('active');

					if( options.value ){
						input&&input.val&&input.val(options.value);
						_xdsoft_datetime.setCurrentTime(options.value);
					}

					if( isNaN(options.dayOfWeekStart) )
						options.dayOfWeekStart = 0;
					else
						options.dayOfWeekStart = parseInt(options.dayOfWeekStart)%7;

					if( !options.timepickerScrollbar )
						scrollbar.hide();
					
					if( options.minDate && /^-(.*)$/.test(options.minDate) ){
						options.minDate = _xdsoft_datetime.strToDateTime(options.minDate).dateFormat( options.formatDate );
					}
					
					if( options.maxDate &&  /^\+(.*)$/.test(options.maxDate) ) {
						options.maxDate = _xdsoft_datetime.strToDateTime(options.maxDate).dateFormat( options.formatDate );
					}
					
					mounth_picker
						.find('.xdsoft_today_button')
							.css('visibility',!options.todayButton?'hidden':'visible');

					if( options.mask ) {
						var e,
							getCaretPos = function ( input ) {
								try{
									if ( document.selection && document.selection.createRange ) {
										var range = document.selection.createRange();
										return range.getBookmark().charCodeAt(2) - 2;
									}else
										if ( input.setSelectionRange )
											return input.selectionStart;
								}catch(e) {
									return 0;
								}
							},
							setCaretPos = function ( node,pos ) {
								node = (typeof node == "string" || node instanceof String) ? document.getElementById(node) : node;
								if(!node) {
									return false;
								}else if(node.createTextRange) {
									var textRange = node.createTextRange();
									textRange.collapse(true);
									textRange.moveEnd(pos);
									textRange.moveStart(pos);
									textRange.select();
									return true;
								}else if(node.setSelectionRange) {
									node.setSelectionRange(pos,pos);
									return true;
								}
								return false;
							},
							isValidValue = function ( mask,value ) {
								var reg = mask
									.replace(/([\[\]\/\{\}\(\)\-\.\+]{1})/g,'\\$1')
									.replace(/_/g,'{digit+}')
									.replace(/([0-9]{1})/g,'{digit$1}')
									.replace(/\{digit([0-9]{1})\}/g,'[0-$1_]{1}')
									.replace(/\{digit[\+]\}/g,'[0-9_]{1}');
								return RegExp(reg).test(value);
							};
						input.off('keydown.xdsoft');
						switch(true) {
							case ( options.mask===true ):
							
								options.mask = options.format
									.replace(/Y/g,'9999')
									.replace(/F/g,'9999')
									.replace(/m/g,'19')
									.replace(/d/g,'39')
									.replace(/H/g,'29')
									.replace(/i/g,'59')
									.replace(/s/g,'59');
									
							case ( $.type(options.mask) == 'string' ):
							
								if( !isValidValue( options.mask,input.val() ) )
									input.val(options.mask.replace(/[0-9]/g,'_'));

								input.on('keydown.xdsoft',function( event ) {
									var val = this.value,
										key = event.which;
										
									switch(true) {
										case (( key>=KEY0&&key<=KEY9 )||( key>=_KEY0&&key<=_KEY9 ))||(key==BACKSPACE||key==DEL):
											var pos = getCaretPos(this),
												digit = ( key!=BACKSPACE&&key!=DEL )?String.fromCharCode((_KEY0 <= key && key <= _KEY9)? key-KEY0 : key):'_';
											
											if( (key==BACKSPACE||key==DEL)&&pos ) {
												pos--;
												digit='_';
											}
											
											while( /[^0-9_]/.test(options.mask.substr(pos,1))&&pos<options.mask.length&&pos>0 )
												pos+=( key==BACKSPACE||key==DEL )?-1:1;

											val = val.substr(0,pos)+digit+val.substr(pos+1);
											if( $.trim(val)=='' ){
												val = options.mask.replace(/[0-9]/g,'_');
											}else{
												if( pos==options.mask.length )
													break;
											}
											
											pos+=(key==BACKSPACE||key==DEL)?0:1;
											while( /[^0-9_]/.test(options.mask.substr(pos,1))&&pos<options.mask.length&&pos>0 )
												pos+=(key==BACKSPACE||key==DEL)?-1:1;
												
											if( isValidValue( options.mask,val ) ) {
												this.value = val;
												setCaretPos(this,pos);
											}else if( $.trim(val)=='' )
												this.value = options.mask.replace(/[0-9]/g,'_');
											else{
												input.trigger('error_input.xdsoft');
											}
										break;
										case ( !!~([AKEY,CKEY,VKEY,ZKEY,YKEY].indexOf(key))&&ctrlDown ):
										 case !!~([ESC,ARROWUP,ARROWDOWN,ARROWLEFT,ARROWRIGHT,F5,CTRLKEY,TAB,ENTER].indexOf(key)):
										return true;
									}
									event.preventDefault();
									return false;
								});
							break;
						}
					}
					if( options.validateOnBlur ) {
						input
							.off('blur.xdsoft')
							.on('blur.xdsoft', function() {
								if( options.allowBlank && !$.trim($(this).val()).length ) {
									$(this).val(null);
									datetimepicker.data('xdsoft_datetime').empty();
								}else if( !Date.parseDate( $(this).val(), options.format ) ) {
									$(this).val((_xdsoft_datetime.now()).dateFormat( options.format ));
									datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
								}
								else{
									datetimepicker.data('xdsoft_datetime').setCurrentTime($(this).val());
 								}
								datetimepicker.trigger('changedatetime.xdsoft');
							});
					}
					options.dayOfWeekStartPrev = (options.dayOfWeekStart==0)?6:options.dayOfWeekStart-1;
					
					datetimepicker
						.trigger('xchange.xdsoft')
						.trigger('afterOpen.xdsoft')
				};

				datetimepicker
					.data('options',options)
					.on('mousedown.xdsoft',function( event ) {
						event.stopPropagation();
						event.preventDefault();
						yearselect.hide();
						monthselect.hide();
						return false;
					});

				var scroll_element = timepicker.find('.xdsoft_time_box');
				scroll_element.append(timebox);
				scroll_element.xdsoftScroller();
				
				datetimepicker.on('afterOpen.xdsoft',function() {
					scroll_element.xdsoftScroller();
				});

				datetimepicker
					.append(datepicker)
					.append(timepicker);

				if( options.withoutCopyright!==true )
					datetimepicker
						.append(xdsoft_copyright);

				datepicker
					.append(mounth_picker)
					.append(calendar);

				$('body').append(datetimepicker);

				var _xdsoft_datetime = new function() {
					var _this = this;
					_this.now = function( norecursion ) {
						var d = new Date();
						
						if( !norecursion && options.defaultDate  ){
							var date = _this.strToDate(options.defaultDate);
							d.setFullYear( date.getFullYear() );
							d.setMonth( date.getMonth() );
							d.setDate( date.getDate() );
						}
						
						if( options.yearOffset  ){
							d.setFullYear(d.getFullYear()+options.yearOffset);
						}
						
						if( !norecursion && options.defaultTime ){
							var time = _this.strtotime(options.defaultTime);
							d.setHours( time.getHours() );
							d.setMinutes( time.getMinutes() );
						}
							
						return d;
					};

					
					_this.isValidDate = function (d) {
						if ( Object.prototype.toString.call(d) !== "[object Date]" )
							return false;
						return !isNaN(d.getTime());
					};

					_this.setCurrentTime = function( dTime ) {
						_this.currentTime = (typeof dTime == 'string')? _this.strToDateTime(dTime) : _this.isValidDate(dTime) ? dTime: _this.now();
						datetimepicker.trigger('xchange.xdsoft');
					};

					_this.empty = function() {
						_this.currentTime = null;
					};

					_this.getCurrentTime = function( dTime) {
						return _this.currentTime;
					};

					_this.nextMonth = function() {
						var month = _this.currentTime.getMonth()+1;
						if( month==12 ) {
							_this.currentTime.setFullYear(_this.currentTime.getFullYear()+1);
							month = 0;
						}
						_this.currentTime.setDate(
							Math.min(
								Date.daysInMonth[month],
								_this.currentTime.getDate()
							)
						);
						_this.currentTime.setMonth(month);
						options.onChangeMonth&&options.onChangeMonth.call&&options.onChangeMonth.call(datetimepicker,_xdsoft_datetime.currentTime,datetimepicker.data('input'));
						datetimepicker.trigger('xchange.xdsoft');
						return month;
					};

					_this.prevMonth = function() {
						var month = _this.currentTime.getMonth()-1;
						if( month==-1 ) {
							_this.currentTime.setFullYear(_this.currentTime.getFullYear()-1);
							month = 11;
						}
						_this.currentTime.setDate(
							Math.min(
								Date.daysInMonth[month],
								_this.currentTime.getDate()
							)
						);
						_this.currentTime.setMonth(month);
						options.onChangeMonth&&options.onChangeMonth.call&&options.onChangeMonth.call(datetimepicker,_xdsoft_datetime.currentTime,datetimepicker.data('input'));
						datetimepicker.trigger('xchange.xdsoft');
						return month;
					};

					_this.strToDateTime = function( sDateTime ) {
						if( sDateTime && sDateTime instanceof Date && _this.isValidDate(sDateTime) )
							return sDateTime;
						
						var tmpDate = [],timeOffset,currentTime;
					
						if( ( tmpDate = /^(\+|\-)(.*)$/.exec(sDateTime) )  && ( tmpDate[2]=Date.parseDate(tmpDate[2], options.formatDate) ) ) {
							timeOffset = tmpDate[2].getTime()-(tmpDate[2].getTimezoneOffset())*60000;
							currentTime = new Date((_xdsoft_datetime.now()).getTime()+parseInt(tmpDate[1]+'1')*timeOffset);
						}else
							currentTime = sDateTime?Date.parseDate(sDateTime, options.format):_this.now();
							
						if( !_this.isValidDate(currentTime) )
							currentTime = _this.now();
							
						return currentTime;
					};

					_this.strToDate = function( sDate ) {
						if( sDate && sDate instanceof Date && _this.isValidDate(sDate) )
							return sDate;
						
						var currentTime = sDate?Date.parseDate(sDate, options.formatDate):_this.now(true);
						if( !_this.isValidDate(currentTime) )
							currentTime = _this.now(true);
							
						return currentTime;
					};

					_this.strtotime = function( sTime ) {
						if( sTime && sTime instanceof Date && _this.isValidDate(sTime) )
							return sTime;
							
						var currentTime = sTime?Date.parseDate(sTime, options.formatTime):_this.now();
						if( !_this.isValidDate(currentTime) )
							currentTime = _this.now(true);
							
						return currentTime;
					};

					_this.str = function() {
						return _this.currentTime.dateFormat(options.format);
					};
					
					_this.currentTime = this.now();
				};
				mounth_picker
					.find('.xdsoft_today_button')
						.on('mousedown.xdsoft',function() {
							datetimepicker.data('changed',true);
							_xdsoft_datetime.setCurrentTime(0);
							datetimepicker.trigger('afterOpen.xdsoft');
						}).on('dblclick.xdsoft',function(){
							input.val( _xdsoft_datetime.str() );
							datetimepicker.trigger('close.xdsoft');
						});
				mounth_picker
					.find('.xdsoft_prev,.xdsoft_next')
						.on('mousedown.xdsoft',function() {
							var $this = $(this),
								timer = 0,
								stop = false;

							(function arguments_callee1(v) {
								var month =  _xdsoft_datetime.currentTime.getMonth();
								if( $this.hasClass( options.next ) ) {
									_xdsoft_datetime.nextMonth();
								}else if( $this.hasClass( options.prev ) ) {
									_xdsoft_datetime.prevMonth();
								}
								if (options.monthChangeSpinner) {
									!stop&&(timer = setTimeout(arguments_callee1,v?v:100));
								}
							})(500);

							$([document.body,window]).on('mouseup.xdsoft',function arguments_callee2() {
								clearTimeout(timer);
								stop = true;
								$([document.body,window]).off('mouseup.xdsoft',arguments_callee2);
							});
						});

				timepicker
					.find('.xdsoft_prev,.xdsoft_next')
						.on('mousedown.xdsoft',function() {
							var $this = $(this),
								timer = 0,
								stop = false,
								period = 110;
							(function arguments_callee4(v) {
								var pheight = timeboxparent[0].clientHeight,
									height = timebox[0].offsetHeight,
									top = Math.abs(parseInt(timebox.css('marginTop')));
								if( $this.hasClass(options.next) && (height-pheight)- options.timeHeightInTimePicker>=top ) {
									timebox.css('marginTop','-'+(top+options.timeHeightInTimePicker)+'px')
								}else if( $this.hasClass(options.prev) && top-options.timeHeightInTimePicker>=0  ) {
									timebox.css('marginTop','-'+(top-options.timeHeightInTimePicker)+'px')
								}
								timeboxparent.trigger('scroll_element.xdsoft_scroller',[Math.abs(parseInt(timebox.css('marginTop'))/(height-pheight))]);
								period= ( period>10 )?10:period-10;
								!stop&&(timer = setTimeout(arguments_callee4,v?v:period));
							})(500);
							$([document.body,window]).on('mouseup.xdsoft',function arguments_callee5() {
								clearTimeout(timer);
								stop = true;
								$([document.body,window])
									.off('mouseup.xdsoft',arguments_callee5);
							});
						});

				var xchangeTimer = 0;
				// base handler - generating a calendar and timepicker
				datetimepicker
					.on('xchange.xdsoft',function( event ) {
						clearTimeout(xchangeTimer);
						xchangeTimer = setTimeout(function(){
							var table 	=	'',
									start	= new Date(_xdsoft_datetime.currentTime.getFullYear(),_xdsoft_datetime.currentTime.getMonth(),1, 12, 0, 0),
									i = 0,
									today = _xdsoft_datetime.now();
								
								while( start.getDay()!=options.dayOfWeekStart )
									start.setDate(start.getDate()-1);

								//generate calendar
								table+='<table><thead><tr>';

								if(options.weeks) {
									table+='<th></th>';
								}

								// days
								for(var j = 0; j<7; j++) {
									table+='<th>'+options.i18n[options.lang].dayOfWeek[(j+options.dayOfWeekStart)%7]+'</th>';
								}

								table+='</tr></thead>';
								table+='<tbody>';
								var maxDate = false, minDate = false;
								
								if( options.maxDate!==false ) {
									maxDate = _xdsoft_datetime.strToDate(options.maxDate);
									maxDate = new Date(maxDate.getFullYear(),maxDate.getMonth(),maxDate.getDate(),23,59,59,999);
								}
								
								if( options.minDate!==false ) {
									minDate = _xdsoft_datetime.strToDate(options.minDate);
									minDate = new Date(minDate.getFullYear(),minDate.getMonth(),minDate.getDate());
								}
								
								var d,y,m,w,classes = [],customDateSettings,newRow=true;
								
								while( i<_xdsoft_datetime.currentTime.countDaysInMonth()||start.getDay()!=options.dayOfWeekStart||_xdsoft_datetime.currentTime.getMonth()==start.getMonth() ) {
									classes = [];
									i++;

									d = start.getDate(); y = start.getFullYear(); m = start.getMonth(); w = start.getWeekOfYear();

									classes.push('xdsoft_date');

									if ( options.beforeShowDay && options.beforeShowDay.call ) {
										customDateSettings = options.beforeShowDay.call(datetimepicker, start);
									} else {
										customDateSettings = null;
									}

									if( ( maxDate!==false && start > maxDate )||(  minDate!==false && start < minDate )||(customDateSettings && customDateSettings[0] === false) ){
										classes.push('xdsoft_disabled');
									}

									if ( customDateSettings && customDateSettings[1] != "" ) {
										classes.push(customDateSettings[1]);
									}

									if( _xdsoft_datetime.currentTime.getMonth()!=m ) classes.push('xdsoft_other_month');

									if( (options.defaultSelect||datetimepicker.data('changed')) && _xdsoft_datetime.currentTime.dateFormat( options.formatDate )==start.dateFormat( options.formatDate ) ) {
										classes.push('xdsoft_current');
									}

									if( today.dateFormat( options.formatDate )==start.dateFormat( options.formatDate ) ) {
										classes.push('xdsoft_today');
									}

									if( start.getDay()==0||start.getDay()==6||~options.weekends.indexOf(start.dateFormat( options.formatDate )) ) {
										classes.push('xdsoft_weekend');
									}

									if(options.beforeShowDay && typeof options.beforeShowDay == 'function') {
										classes.push(options.beforeShowDay(start))
									}

									if(newRow) {
										table+='<tr>';
										newRow = false;
										
										if(options.weeks) {
											table+='<th>'+w+'</th>';
										}
									}

									table+='<td data-date="'+d+'" data-month="'+m+'" data-year="'+y+'"'+' class="xdsoft_date xdsoft_day_of_week'+start.getDay()+' '+ classes.join(' ')+'">'+
												'<div>'+d+'</div>'+
											'</td>';

									if( start.getDay()==options.dayOfWeekStartPrev ) {
										table+='</tr>';
										newRow = true;
									}

									start.setDate(d+1);
								}
								table+='</tbody></table>';

								calendar.html(table);

								mounth_picker.find('.xdsoft_label span').eq(0).text(options.i18n[options.lang].months[_xdsoft_datetime.currentTime.getMonth()]);
								mounth_picker.find('.xdsoft_label span').eq(1).text(_xdsoft_datetime.currentTime.getFullYear());

								// generate timebox
								var time = '',
									h = '',
									m ='',
									line_time = function line_time( h,m ) {
										var now = _xdsoft_datetime.now();
										now.setHours(h);
										h = parseInt(now.getHours());
										now.setMinutes(m);
										m = parseInt(now.getMinutes());

										classes = [];
										if( (options.maxTime!==false&&_xdsoft_datetime.strtotime(options.maxTime).getTime()<now.getTime())||(options.minTime!==false&&_xdsoft_datetime.strtotime(options.minTime).getTime()>now.getTime()))
											classes.push('xdsoft_disabled');
										if( (options.initTime||options.defaultSelect||datetimepicker.data('changed')) && parseInt(_xdsoft_datetime.currentTime.getHours())==parseInt(h)&&(options.step>59||Math[options.roundTime](_xdsoft_datetime.currentTime.getMinutes()/options.step)*options.step==parseInt(m))) {
											if( options.defaultSelect||datetimepicker.data('changed')) {
												classes.push('xdsoft_current');
											} else if( options.initTime ) {
												classes.push('xdsoft_init_time');
											}
										}
										if( parseInt(today.getHours())==parseInt(h)&&parseInt(today.getMinutes())==parseInt(m))
											classes.push('xdsoft_today');
										time+= '<div class="xdsoft_time '+classes.join(' ')+'" data-hour="'+h+'" data-minute="'+m+'">'+now.dateFormat(options.formatTime)+'</div>';
									};

								if( !options.allowTimes || !$.isArray(options.allowTimes) || !options.allowTimes.length ) {
									for( var i=0,j=0;i<(options.hours12?12:24);i++ ) {
										for( j=0;j<60;j+=options.step ) {
											h = (i<10?'0':'')+i;
											m = (j<10?'0':'')+j;
											line_time( h,m );
										}
									}
								}else{
									for( var i=0;i<options.allowTimes.length;i++ ) {
										h = _xdsoft_datetime.strtotime(options.allowTimes[i]).getHours();
										m = _xdsoft_datetime.strtotime(options.allowTimes[i]).getMinutes();
										line_time( h,m );
									}
								}

								timebox.html(time);

								var opt = '',
									i = 0;

								for( i = parseInt(options.yearStart,10)+options.yearOffset;i<= parseInt(options.yearEnd,10)+options.yearOffset;i++ ) {
									opt+='<div class="xdsoft_option '+(_xdsoft_datetime.currentTime.getFullYear()==i?'xdsoft_current':'')+'" data-value="'+i+'">'+i+'</div>';
								}
								yearselect.children().eq(0)
														.html(opt);

								for( i = 0,opt = '';i<= 11;i++ ) {
									opt+='<div class="xdsoft_option '+(_xdsoft_datetime.currentTime.getMonth()==i?'xdsoft_current':'')+'" data-value="'+i+'">'+options.i18n[options.lang].months[i]+'</div>';
								}
								monthselect.children().eq(0).html(opt);
								$(datetimepicker)
									.trigger('generate.xdsoft');
						},10);
						event.stopPropagation();
					})
					.on('afterOpen.xdsoft',function() {
						if( options.timepicker ) {
							var classType;
							if( timebox.find('.xdsoft_current').length ) {
								classType = '.xdsoft_current';
							} else if( timebox.find('.xdsoft_init_time').length ) {
								classType = '.xdsoft_init_time';
							}
							
							if( classType ) {
								var pheight = timeboxparent[0].clientHeight,
									height = timebox[0].offsetHeight,
									top = timebox.find(classType).index()*options.timeHeightInTimePicker+1;
								if( (height-pheight)<top )
									top = height-pheight;
								timeboxparent.trigger('scroll_element.xdsoft_scroller',[parseInt(top)/(height-pheight)]);
							}else{
								timeboxparent.trigger('scroll_element.xdsoft_scroller',[0]);
							}
						}
					});
				
				var timerclick = 0;
				
				calendar
					.on('click.xdsoft', 'td', function (xdevent) {
					  xdevent.stopPropagation();  // Prevents closing of Pop-ups, Modals and Flyouts in Bootstrap
						timerclick++;
						var $this = $(this),
							currentTime = _xdsoft_datetime.currentTime;
						
						if( currentTime===undefined||currentTime===null ){
                            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
                            currentTime = _xdsoft_datetime.currentTime;
                        }
						
						if( $this.hasClass('xdsoft_disabled') )
							return false;

						currentTime.setDate( 1 );
						currentTime.setFullYear( $this.data('year') );
						currentTime.setMonth( $this.data('month') );
						currentTime.setDate( $this.data('date') );
						
						datetimepicker.trigger('select.xdsoft',[currentTime]);

						input.val( _xdsoft_datetime.str() );
						if( (timerclick>1||(options.closeOnDateSelect===true||( options.closeOnDateSelect===0&&!options.timepicker )))&&!options.inline ) {
							datetimepicker.trigger('close.xdsoft');
						}

						if( options.onSelectDate &&	options.onSelectDate.call ) {
							options.onSelectDate.call(datetimepicker,_xdsoft_datetime.currentTime,datetimepicker.data('input'));
						}

						datetimepicker.data('changed',true);
						datetimepicker.trigger('xchange.xdsoft');
						datetimepicker.trigger('changedatetime.xdsoft');
						setTimeout(function(){
							timerclick = 0;
						},200);
					});

				timebox
					.on('click.xdsoft', 'div', function (xdevent) {
					    xdevent.stopPropagation(); // NAJ: Prevents closing of Pop-ups, Modals and Flyouts
						var $this = $(this),
							currentTime = _xdsoft_datetime.currentTime;
						
						if( currentTime===undefined||currentTime===null ){
                            _xdsoft_datetime.currentTime = _xdsoft_datetime.now();
                            currentTime = _xdsoft_datetime.currentTime;
                        }
						
						if( $this.hasClass('xdsoft_disabled') )
							return false;
						currentTime.setHours($this.data('hour'));
						currentTime.setMinutes($this.data('minute'));
						datetimepicker.trigger('select.xdsoft',[currentTime]);

						datetimepicker.data('input').val( _xdsoft_datetime.str() );

						!options.inline&&datetimepicker.trigger('close.xdsoft');

						if( options.onSelectTime&&options.onSelectTime.call ) {
							options.onSelectTime.call(datetimepicker,_xdsoft_datetime.currentTime,datetimepicker.data('input'));
						}
						datetimepicker.data('changed',true);
						datetimepicker.trigger('xchange.xdsoft');
						datetimepicker.trigger('changedatetime.xdsoft');
					});

				datetimepicker.mousewheel&&datepicker.mousewheel(function(event, delta, deltaX, deltaY) {
					if( !options.scrollMonth )
						return true;
					if( delta<0 )
						_xdsoft_datetime.nextMonth();
					else
						_xdsoft_datetime.prevMonth();
					return false;
				});

				datetimepicker.mousewheel&&timeboxparent.unmousewheel().mousewheel(function(event, delta, deltaX, deltaY) {
					if( !options.scrollTime )
						return true;
					var pheight = timeboxparent[0].clientHeight,
						height = timebox[0].offsetHeight,
						top = Math.abs(parseInt(timebox.css('marginTop'))),
						fl = true;
					if( delta<0 && (height-pheight)-options.timeHeightInTimePicker>=top ) {
						timebox.css('marginTop','-'+(top+options.timeHeightInTimePicker)+'px');
						fl = false;
					}else if( delta>0&&top-options.timeHeightInTimePicker>=0 ) {
						timebox.css('marginTop','-'+(top-options.timeHeightInTimePicker)+'px');
						fl = false;
					}
					timeboxparent.trigger('scroll_element.xdsoft_scroller',[Math.abs(parseInt(timebox.css('marginTop'))/(height-pheight))]);
					event.stopPropagation();
					return fl;
				});
				
				var triggerAfterOpen = false;
				datetimepicker
					.on('changedatetime.xdsoft',function() {
						if( options.onChangeDateTime&&options.onChangeDateTime.call ) {
							var $input = datetimepicker.data('input');
							options.onChangeDateTime.call(datetimepicker, _xdsoft_datetime.currentTime, $input);
							delete options.value;
							$input.trigger('change');
						}
					})
					.on('generate.xdsoft',function() {
						if( options.onGenerate&&options.onGenerate.call )
							options.onGenerate.call(datetimepicker,_xdsoft_datetime.currentTime,datetimepicker.data('input'));
						if( triggerAfterOpen ){
							datetimepicker.trigger('afterOpen.xdsoft');
							triggerAfterOpen = false;
						}
					})
					.on( 'click.xdsoft', function( xdevent )
					{
						xdevent.stopPropagation();  // Prevents closing of Pop-ups, Modals and Flyouts in Bootstrap
					});

				var current_time_index = 0;
				input.mousewheel&&input.mousewheel(function( event, delta, deltaX, deltaY ) {
					if( !options.scrollInput )
						return true;
					if( !options.datepicker && options.timepicker ) {
						current_time_index = timebox.find('.xdsoft_current').length?timebox.find('.xdsoft_current').eq(0).index():0;
						if( current_time_index+delta>=0&&current_time_index+delta<timebox.children().length )
							current_time_index+=delta;
						timebox.children().eq(current_time_index).length&&timebox.children().eq(current_time_index).trigger('mousedown');
						return false;
					}else if( options.datepicker && !options.timepicker ) {
						datepicker.trigger( event, [delta, deltaX, deltaY]);
						input.val&&input.val( _xdsoft_datetime.str() );
						datetimepicker.trigger('changedatetime.xdsoft');
						return false;
					}
				});
				var setPos = function() {
					var offset = datetimepicker.data('input').offset(), top = offset.top+datetimepicker.data('input')[0].offsetHeight-1, left = offset.left, position = "absolute";
					if (options.fixed) {
						top -= $(window).scrollTop();
						left -= $(window).scrollLeft();
						position = "fixed";
					}else {
						if( top+datetimepicker[0].offsetHeight>$(window).height()+$(window).scrollTop() )
							top = offset.top-datetimepicker[0].offsetHeight+1;
							if (top < 0)
								top = 0;
						if( left+datetimepicker[0].offsetWidth>$(window).width() )
							left = offset.left-datetimepicker[0].offsetWidth+datetimepicker.data('input')[0].offsetWidth;
					}
					datetimepicker.css({
						left:left,
						top:top,
						position: position
					});
				};
				datetimepicker
					.on('open.xdsoft', function() {
						var onShow = true;
						if( options.onShow&&options.onShow.call) {
							onShow = options.onShow.call(datetimepicker,_xdsoft_datetime.currentTime,datetimepicker.data('input'));
						}
						if( onShow!==false ) {
							datetimepicker.show();
							setPos();
							$(window)
								.off('resize.xdsoft',setPos)
								.on('resize.xdsoft',setPos);

							if( options.closeOnWithoutClick ) {
								$([document.body,window]).on('mousedown.xdsoft',function arguments_callee6() {
									datetimepicker.trigger('close.xdsoft');
									$([document.body,window]).off('mousedown.xdsoft',arguments_callee6);
								});
							}
						}
					})
					.on('close.xdsoft', function( event ) {
						var onClose = true;
						if( options.onClose&&options.onClose.call ) {
							onClose=options.onClose.call(datetimepicker,_xdsoft_datetime.currentTime,datetimepicker.data('input'));
						}
						if( onClose!==false&&!options.opened&&!options.inline ) {
							datetimepicker.hide();
						}
						event.stopPropagation();
					})
					.data('input',input);

				var timer = 0,
					timer1 = 0;

				datetimepicker.data('xdsoft_datetime',_xdsoft_datetime);
				datetimepicker.setOptions(options);
				
				function getCurrentValue(){

					var ct = false;

                    if ( options.startDate ) {
                        ct = _xdsoft_datetime.strToDate(options.startDate);
                    } else {
                        ct = options.value?options.value:(input&&input.val&&input.val())?input.val():'';
						if( ct ) {
							ct = _xdsoft_datetime.strToDateTime(ct);
						} else if ( options.defaultDate ) {
							ct = _xdsoft_datetime.strToDate(options.defaultDate);
						}
                    }

					if ( ct && _xdsoft_datetime.isValidDate(ct) ) {
						datetimepicker.data('changed',true);
					} else {
                        ct = '';
                    }
					
					return ct?ct:0;
				}
				//debugger
				_xdsoft_datetime.setCurrentTime( getCurrentValue() );

				input
					.data( 'xdsoft_datetimepicker',datetimepicker )
					.on('open.xdsoft focusin.xdsoft mousedown.xdsoft',function(event) {
						if( input.is(':disabled')||input.is(':hidden')||!input.is(':visible')||(input.data('xdsoft_datetimepicker').is(':visible') && options.closeOnInputClick) )
							return;
						clearTimeout(timer);
						timer = setTimeout(function() {
							if( input.is(':disabled')||input.is(':hidden')||!input.is(':visible') )
								return;
								
							triggerAfterOpen = true;
							_xdsoft_datetime.setCurrentTime(getCurrentValue());
							
							datetimepicker.trigger('open.xdsoft');
						},100);
					})
					.on('keydown.xdsoft',function( event ) {
						var val = this.value,
							key = event.which;
						switch(true) {
							case !!~([ENTER].indexOf(key)):
								var elementSelector = $("input:visible,textarea:visible");
								datetimepicker.trigger('close.xdsoft');
								elementSelector.eq(elementSelector.index(this) + 1).focus();
							return false;
							case !!~[TAB].indexOf(key):
								datetimepicker.trigger('close.xdsoft');
							return true;
						}
					});
			},
			destroyDateTimePicker = function( input ) {
				var datetimepicker = input.data('xdsoft_datetimepicker');
				if( datetimepicker ) {
					datetimepicker.data('xdsoft_datetime',null);
					datetimepicker.remove();
					input
						.data( 'xdsoft_datetimepicker',null )
						.off( 'open.xdsoft focusin.xdsoft focusout.xdsoft mousedown.xdsoft blur.xdsoft keydown.xdsoft' );
					$(window).off('resize.xdsoft');
					$([window,document.body]).off('mousedown.xdsoft');
					input.unmousewheel&&input.unmousewheel();
				}
			};
		$(document)
			.off('keydown.xdsoftctrl keyup.xdsoftctrl')
			.on('keydown.xdsoftctrl',function(e) {
				if ( e.keyCode == CTRLKEY )
					ctrlDown = true;
			})
			.on('keyup.xdsoftctrl',function(e) {
				if ( e.keyCode == CTRLKEY )
					ctrlDown = false;
			});
		return this.each(function() {
			var datetimepicker;
			if( datetimepicker = $(this).data('xdsoft_datetimepicker') ) {
				if( $.type(opt) === 'string' ) {
					switch(opt) {
						case 'show':
							$(this).select().focus();
							datetimepicker.trigger( 'open.xdsoft' );
						break;
						case 'hide':
							datetimepicker.trigger('close.xdsoft');
						break;
						case 'destroy':
							destroyDateTimePicker($(this));
						break;
						case 'reset':
							this.value = this.defaultValue;
							if(!this.value || !datetimepicker.data('xdsoft_datetime').isValidDate(Date.parseDate(this.value, options.format)))
								datetimepicker.data('changed',false);
							datetimepicker.data('xdsoft_datetime').setCurrentTime(this.value);
						break;
					}
				}else{
					datetimepicker
						.setOptions(opt);
				}
				return 0;
			}else
				if( ($.type(opt) !== 'string') ){
					if( !options.lazyInit||options.open||options.inline ){
						createDateTimePicker($(this));
					}else
						lazyInit($(this));
				}
		});
	};
	$.fn.datetimepicker.defaults = default_options;
})( jQuery );

/*
 * Copyright (c) 2013 Brandon Aaron (http://brandonaaron.net)
 *
 * Licensed under the MIT License (LICENSE.txt).
 *
 * Thanks to: http://adomas.org/javascript-mouse-wheel/ for some pointers.
 * Thanks to: Mathias Bank(http://www.mathias-bank.de) for a scope bug fix.
 * Thanks to: Seamus Leahy for adding deltaX and deltaY
 *
 * Version: 3.1.3
 *
 * Requires: 1.2.2+
 */
(function(factory) {if(typeof define==='function'&&define.amd) {define(['jquery'],factory)}else if(typeof exports==='object') {module.exports=factory}else{factory(jQuery)}}(function($) {var toFix=['wheel','mousewheel','DOMMouseScroll','MozMousePixelScroll'];var toBind='onwheel'in document||document.documentMode>=9?['wheel']:['mousewheel','DomMouseScroll','MozMousePixelScroll'];var lowestDelta,lowestDeltaXY;if($.event.fixHooks) {for(var i=toFix.length;i;) {$.event.fixHooks[toFix[--i]]=$.event.mouseHooks}}$.event.special.mousewheel={setup:function() {if(this.addEventListener) {for(var i=toBind.length;i;) {this.addEventListener(toBind[--i],handler,false)}}else{this.onmousewheel=handler}},teardown:function() {if(this.removeEventListener) {for(var i=toBind.length;i;) {this.removeEventListener(toBind[--i],handler,false)}}else{this.onmousewheel=null}}};$.fn.extend({mousewheel:function(fn) {return fn?this.bind("mousewheel",fn):this.trigger("mousewheel")},unmousewheel:function(fn) {return this.unbind("mousewheel",fn)}});function handler(event) {var orgEvent=event||window.event,args=[].slice.call(arguments,1),delta=0,deltaX=0,deltaY=0,absDelta=0,absDeltaXY=0,fn;event=$.event.fix(orgEvent);event.type="mousewheel";if(orgEvent.wheelDelta) {delta=orgEvent.wheelDelta}if(orgEvent.detail) {delta=orgEvent.detail*-1}if(orgEvent.deltaY) {deltaY=orgEvent.deltaY*-1;delta=deltaY}if(orgEvent.deltaX) {deltaX=orgEvent.deltaX;delta=deltaX*-1}if(orgEvent.wheelDeltaY!==undefined) {deltaY=orgEvent.wheelDeltaY}if(orgEvent.wheelDeltaX!==undefined) {deltaX=orgEvent.wheelDeltaX*-1}absDelta=Math.abs(delta);if(!lowestDelta||absDelta<lowestDelta) {lowestDelta=absDelta}absDeltaXY=Math.max(Math.abs(deltaY),Math.abs(deltaX));if(!lowestDeltaXY||absDeltaXY<lowestDeltaXY) {lowestDeltaXY=absDeltaXY}fn=delta>0?'floor':'ceil';delta=Math[fn](delta/lowestDelta);deltaX=Math[fn](deltaX/lowestDeltaXY);deltaY=Math[fn](deltaY/lowestDeltaXY);args.unshift(event,delta,deltaX,deltaY);return($.event.dispatch||$.event.handle).apply(this,args)}}));


// Parse and Format Library
//http://www.xaprb.com/blog/2005/12/12/javascript-closures-for-runtime-efficiency/
/*
 * Copyright (C) 2004 Baron Schwartz <baron at sequent dot org>
 *
 * This program is free software; you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, version 2.1.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
 * FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License for more
 * details.
 */
Date.parseFunctions={count:0};Date.parseRegexes=[];Date.formatFunctions={count:0};Date.prototype.dateFormat=function(b){if(b=="unixtime"){return parseInt(this.getTime()/1000);}if(Date.formatFunctions[b]==null){Date.createNewFormat(b);}var a=Date.formatFunctions[b];return this[a]();};Date.createNewFormat=function(format){var funcName="format"+Date.formatFunctions.count++;Date.formatFunctions[format]=funcName;var code="Date.prototype."+funcName+" = function() {return ";var special=false;var ch="";for(var i=0;i<format.length;++i){ch=format.charAt(i);if(!special&&ch=="\\"){special=true;}else{if(special){special=false;code+="'"+String.escape(ch)+"' + ";}else{code+=Date.getFormatCode(ch);}}}eval(code.substring(0,code.length-3)+";}");};Date.getFormatCode=function(a){switch(a){case"d":return"String.leftPad(this.getDate(), 2, '0') + ";case"D":return"Date.dayNames[this.getDay()].substring(0, 3) + ";case"j":return"this.getDate() + ";case"l":return"Date.dayNames[this.getDay()] + ";case"S":return"this.getSuffix() + ";case"w":return"this.getDay() + ";case"z":return"this.getDayOfYear() + ";case"W":return"this.getWeekOfYear() + ";case"F":return"Date.monthNames[this.getMonth()] + ";case"m":return"String.leftPad(this.getMonth() + 1, 2, '0') + ";case"M":return"Date.monthNames[this.getMonth()].substring(0, 3) + ";case"n":return"(this.getMonth() + 1) + ";case"t":return"this.getDaysInMonth() + ";case"L":return"(this.isLeapYear() ? 1 : 0) + ";case"Y":return"this.getFullYear() + ";case"y":return"('' + this.getFullYear()).substring(2, 4) + ";case"a":return"(this.getHours() < 12 ? 'am' : 'pm') + ";case"A":return"(this.getHours() < 12 ? 'AM' : 'PM') + ";case"g":return"((this.getHours() %12) ? this.getHours() % 12 : 12) + ";case"G":return"this.getHours() + ";case"h":return"String.leftPad((this.getHours() %12) ? this.getHours() % 12 : 12, 2, '0') + ";case"H":return"String.leftPad(this.getHours(), 2, '0') + ";case"i":return"String.leftPad(this.getMinutes(), 2, '0') + ";case"s":return"String.leftPad(this.getSeconds(), 2, '0') + ";case"O":return"this.getGMTOffset() + ";case"T":return"this.getTimezone() + ";case"Z":return"(this.getTimezoneOffset() * -60) + ";default:return"'"+String.escape(a)+"' + ";}};Date.parseDate=function(a,c){if(c=="unixtime"){return new Date(!isNaN(parseInt(a))?parseInt(a)*1000:0);}if(Date.parseFunctions[c]==null){Date.createParser(c);}var b=Date.parseFunctions[c];return Date[b](a);};Date.createParser=function(format){var funcName="parse"+Date.parseFunctions.count++;var regexNum=Date.parseRegexes.length;var currentGroup=1;Date.parseFunctions[format]=funcName;var code="Date."+funcName+" = function(input) {\nvar y = -1, m = -1, d = -1, h = -1, i = -1, s = -1, z = -1;\nvar d = new Date();\ny = d.getFullYear();\nm = d.getMonth();\nd = d.getDate();\nvar results = input.match(Date.parseRegexes["+regexNum+"]);\nif (results && results.length > 0) {";var regex="";var special=false;var ch="";for(var i=0;i<format.length;++i){ch=format.charAt(i);if(!special&&ch=="\\"){special=true;}else{if(special){special=false;regex+=String.escape(ch);}else{obj=Date.formatCodeToRegex(ch,currentGroup);currentGroup+=obj.g;regex+=obj.s;if(obj.g&&obj.c){code+=obj.c;}}}}code+="if (y > 0 && z > 0){\nvar doyDate = new Date(y,0);\ndoyDate.setDate(z);\nm = doyDate.getMonth();\nd = doyDate.getDate();\n}";code+="if (y > 0 && m >= 0 && d > 0 && h >= 0 && i >= 0 && s >= 0)\n{return new Date(y, m, d, h, i, s);}\nelse if (y > 0 && m >= 0 && d > 0 && h >= 0 && i >= 0)\n{return new Date(y, m, d, h, i);}\nelse if (y > 0 && m >= 0 && d > 0 && h >= 0)\n{return new Date(y, m, d, h);}\nelse if (y > 0 && m >= 0 && d > 0)\n{return new Date(y, m, d);}\nelse if (y > 0 && m >= 0)\n{return new Date(y, m);}\nelse if (y > 0)\n{return new Date(y);}\n}return null;}";Date.parseRegexes[regexNum]=new RegExp("^"+regex+"$");eval(code);};Date.formatCodeToRegex=function(b,a){switch(b){case"D":return{g:0,c:null,s:"(?:Sun|Mon|Tue|Wed|Thu|Fri|Sat)"};case"j":case"d":return{g:1,c:"d = parseInt(results["+a+"], 10);\n",s:"(\\d{1,2})"};case"l":return{g:0,c:null,s:"(?:"+Date.dayNames.join("|")+")"};case"S":return{g:0,c:null,s:"(?:st|nd|rd|th)"};case"w":return{g:0,c:null,s:"\\d"};case"z":return{g:1,c:"z = parseInt(results["+a+"], 10);\n",s:"(\\d{1,3})"};case"W":return{g:0,c:null,s:"(?:\\d{2})"};case"F":return{g:1,c:"m = parseInt(Date.monthNumbers[results["+a+"].substring(0, 3)], 10);\n",s:"("+Date.monthNames.join("|")+")"};case"M":return{g:1,c:"m = parseInt(Date.monthNumbers[results["+a+"]], 10);\n",s:"(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)"};case"n":case"m":return{g:1,c:"m = parseInt(results["+a+"], 10) - 1;\n",s:"(\\d{1,2})"};case"t":return{g:0,c:null,s:"\\d{1,2}"};case"L":return{g:0,c:null,s:"(?:1|0)"};case"Y":return{g:1,c:"y = parseInt(results["+a+"], 10);\n",s:"(\\d{4})"};case"y":return{g:1,c:"var ty = parseInt(results["+a+"], 10);\ny = ty > Date.y2kYear ? 1900 + ty : 2000 + ty;\n",s:"(\\d{1,2})"};case"a":return{g:1,c:"if (results["+a+"] == 'am') {\nif (h == 12) { h = 0; }\n} else { if (h < 12) { h += 12; }}",s:"(am|pm)"};case"A":return{g:1,c:"if (results["+a+"] == 'AM') {\nif (h == 12) { h = 0; }\n} else { if (h < 12) { h += 12; }}",s:"(AM|PM)"};case"g":case"G":case"h":case"H":return{g:1,c:"h = parseInt(results["+a+"], 10);\n",s:"(\\d{1,2})"};case"i":return{g:1,c:"i = parseInt(results["+a+"], 10);\n",s:"(\\d{2})"};case"s":return{g:1,c:"s = parseInt(results["+a+"], 10);\n",s:"(\\d{2})"};case"O":return{g:0,c:null,s:"[+-]\\d{4}"};case"T":return{g:0,c:null,s:"[A-Z]{3}"};case"Z":return{g:0,c:null,s:"[+-]\\d{1,5}"};default:return{g:0,c:null,s:String.escape(b)};}};Date.prototype.getTimezone=function(){return this.toString().replace(/^.*? ([A-Z]{3}) [0-9]{4}.*$/,"$1").replace(/^.*?\(([A-Z])[a-z]+ ([A-Z])[a-z]+ ([A-Z])[a-z]+\)$/,"$1$2$3");};Date.prototype.getGMTOffset=function(){return(this.getTimezoneOffset()>0?"-":"+")+String.leftPad(Math.floor(Math.abs(this.getTimezoneOffset())/60),2,"0")+String.leftPad(Math.abs(this.getTimezoneOffset())%60,2,"0");};Date.prototype.getDayOfYear=function(){var a=0;Date.daysInMonth[1]=this.isLeapYear()?29:28;for(var b=0;b<this.getMonth();++b){a+=Date.daysInMonth[b];}return a+this.getDate();};Date.prototype.getWeekOfYear=function(){var b=this.getDayOfYear()+(4-this.getDay());var a=new Date(this.getFullYear(),0,1);var c=(7-a.getDay()+4);return String.leftPad(Math.ceil((b-c)/7)+1,2,"0");};Date.prototype.isLeapYear=function(){var a=this.getFullYear();return((a&3)==0&&(a%100||(a%400==0&&a)));};Date.prototype.getFirstDayOfMonth=function(){var a=(this.getDay()-(this.getDate()-1))%7;return(a<0)?(a+7):a;};Date.prototype.getLastDayOfMonth=function(){var a=(this.getDay()+(Date.daysInMonth[this.getMonth()]-this.getDate()))%7;return(a<0)?(a+7):a;};Date.prototype.getDaysInMonth=function(){Date.daysInMonth[1]=this.isLeapYear()?29:28;return Date.daysInMonth[this.getMonth()];};Date.prototype.getSuffix=function(){switch(this.getDate()){case 1:case 21:case 31:return"st";case 2:case 22:return"nd";case 3:case 23:return"rd";default:return"th";}};String.escape=function(a){return a.replace(/('|\\)/g,"\\$1");};String.leftPad=function(d,b,c){var a=new String(d);if(c==null){c=" ";}while(a.length<b){a=c+a;}return a;};Date.daysInMonth=[31,28,31,30,31,30,31,31,30,31,30,31];Date.monthNames=["January","February","March","April","May","June","July","August","September","October","November","December"];Date.dayNames=["Sunday","Monday","Tuesday","Wednesday","Thursday","Friday","Saturday"];Date.y2kYear=50;Date.monthNumbers={Jan:0,Feb:1,Mar:2,Apr:3,May:4,Jun:5,Jul:6,Aug:7,Sep:8,Oct:9,Nov:10,Dec:11};Date.patterns={ISO8601LongPattern:"Y-m-d H:i:s",ISO8601ShortPattern:"Y-m-d",ShortDatePattern:"n/j/Y",LongDatePattern:"l, F d, Y",FullDateTimePattern:"l, F d, Y g:i:s A",MonthDayPattern:"F d",ShortTimePattern:"g:i A",LongTimePattern:"g:i:s A",SortableDateTimePattern:"Y-m-d\\TH:i:s",UniversalSortableDateTimePattern:"Y-m-d H:i:sO",YearMonthPattern:"F, Y"};
(function($) {
    jQuery.fn.html5_upload = function(options) {
        function get_file_name(file) {
            //return file.name || file.fileName;
            return 'temp';
        }
        function get_file_size(file) {
            return file.size || file.fileSize;
        }
        var available_events = ['onStart', 'onStartOne', 'onProgress', 'onFinishOne', 'onFinish', 'onError'];
        var options = jQuery.extend({
            onStart: function(event, total) {
                return true;
            },
            onStartOne: function(event, name, number, total) {
                return true;
            },
            onProgress: function(event, progress, name, number, total) {
            },
            onFinishOne: function(event, response, name, number, total) {
            },
            onFinish: function(event, total) {
            },
            onError: function(event, name, error) {
            },
            onBrowserIncompatible: function() {
                alert("Sorry, but your browser is incompatible with uploading files using HTML5 (at least, with current preferences.\n Please install the latest version of Firefox, Safari or Chrome");
            },
            autostart: true,
            autoclear: true,
            stopOnFirstError: false,
            sendBoundary: false,
            fieldName: 'user_file[]',//ignore if sendBoundary is false
            extraFields: {}, // extra fields to send with file upload request (HTML5 only)
            method: 'post',

            STATUSES: {
                'STARTED'   : 'Started',
                'PROGRESS'  : 'Progress',
                'LOADED'    : 'Loaded',
                'FINISHED'  : 'Finished'
            },
            headers: {
                "Cache-Control":"no-cache",
                "X-Requested-With":"XMLHttpRequest",
                "X-File-Name": function(file){return get_file_name(file)},
                "X-File-Size": function(file){return get_file_size(file)},
                "X-CSRF-Token": $('meta[name="csrf-token"]').attr("content"),
                "Content-Type": function(file){
                    if (!options.sendBoundary) return 'multipart/form-data';
                    return false;
                }
            },


            setName: function(text) {},
            setStatus: function(text) {},
            setProgress: function(value) {},

            genName: function(file, number, total) {
                return file + "(" + (number+1) + " из " + total + ")";
            },
            genStatus: function(progress, finished) {
                if (finished) {
                    return options.STATUSES['FINISHED'];
                }
                if (progress == 0) {
                    return options.STATUSES['STARTED'];
                }
                else if (progress == 1) {
                    return options.STATUSES['LOADED'];
                }
                else {
                    return options.STATUSES['PROGRESS'];
                }
            },
            genProgress: function(loaded, total) {
                return loaded / total;
            }
        }, options);

        function upload() {
            var files = this.files;
            var total = files.length;
            var $this = $(this);
            if (!$this.triggerHandler('html5_upload.onStart', [total])) {
                return false;
            }
            this.disabled = true;
            var uploaded = 0;
            var xhr = this.html5_upload['xhr'];
            this.html5_upload['continue_after_abort'] = true;
            function upload_file(number) {
                if (number == total) {
                    $this.triggerHandler('html5_upload.onFinish', [total]);
                    options.setStatus(options.genStatus(1, true));
                    $this.attr("disabled", false);
                    if (options.autoclear) {
                        $this.val("");
                    }
                    return;
                }
                var file = files[number];
                if (!$this.triggerHandler('html5_upload.onStartOne', [get_file_name(file), number, total])) {
                    return upload_file(number+1);
                }
                options.setStatus(options.genStatus(0));
                options.setName(options.genName(get_file_name(file), number, total));
                options.setProgress(options.genProgress(0, get_file_size(file)));
                xhr.upload['onprogress'] = function(rpe) {
                    $this.triggerHandler('html5_upload.onProgress', [rpe.loaded / rpe.total, get_file_name(file), number, total]);
                    options.setStatus(options.genStatus(rpe.loaded / rpe.total));
                    options.setProgress(options.genProgress(rpe.loaded, rpe.total));
                };
                xhr.onload = function(load) {
                    if (xhr.status != 200) {
                        $this.triggerHandler('html5_upload.onError', [get_file_name(file), load]);
                        if (!options.stopOnFirstError) {
                            upload_file(number+1);
                        }
                    }
                    else {
                        $this.triggerHandler('html5_upload.onFinishOne', [xhr.responseText, get_file_name(file), number, total]);
                        options.setStatus(options.genStatus(1, true));
                        options.setProgress(options.genProgress(get_file_size(file), get_file_size(file)));
                        upload_file(number+1);
                    }
                };
                xhr.onabort = function() {
                    if ($this[0].html5_upload['continue_after_abort']) {
                        upload_file(number+1);
                    }
                    else {
                        $this.attr("disabled", false);
                        if (options.autoclear) {
                            $this.val("");
                        }
                    }
                };
                xhr.onerror = function(e) {
                    $this.triggerHandler('html5_upload.onError', [get_file_name(file), e]);
                    if (!options.stopOnFirstError) {
                        upload_file(number+1);
                    }
                };
                xhr.open(options.method, typeof(options.url) == "function" ? options.url(number) : options.url, true);
                $.each(options.headers,function(key,val){
                    val = typeof(val) == "function" ? val(file) : val; // resolve value
                    if (val === false) return true; // if resolved value is boolean false, do not send this header
                    xhr.setRequestHeader(key, val);
                });

                if (!options.sendBoundary) {
                    xhr.send(file);
                }
                else {
                    if (window.FormData) {//Many thanks to scottt.tw
                        var f = new FormData();
                        f.append(typeof(options.fieldName) == "function" ? options.fieldName() : options.fieldName, file);
                        $.each(options.extraFields, function(key, val){
                            f.append(key, val);
                        });
                        xhr.send(f);
                    }
                    else if (file.getAsBinary) {//Thanks to jm.schelcher
                        var boundary = '------multipartformboundary' + (new Date).getTime();
                        var dashdash = '--';
                        var crlf     = '\r\n';

                        /* Build RFC2388 string. */
                        var builder = '';

                        builder += dashdash;
                        builder += boundary;
                        builder += crlf;

                        builder += 'Content-Disposition: form-data; name="'+(typeof(options.fieldName) == "function" ? options.fieldName() : options.fieldName)+'"';

                        //thanks to oyejo...@gmail.com for this fix
                        fileName = unescape(encodeURIComponent(get_file_name(file))); //encode_utf8

                        builder += '; filename="' + fileName + '"';
                        builder += crlf;

                        builder += 'Content-Type: ' + file.type;
                        builder += crlf;
                        builder += crlf;

                        /* Append binary data. */
                        builder += file.getAsBinary();
                        builder += crlf;

                        /* Write boundary. */
                        builder += dashdash;
                        builder += boundary;
                        builder += dashdash;
                        builder += crlf;

                        xhr.setRequestHeader('content-type', 'multipart/form-data; boundary=' + boundary);
                        xhr.sendAsBinary(builder);
                    }
                    else {
                        options.onBrowserIncompatible();
                    }
                }
            }
            upload_file(0);
            return true;
        }

        try {
            return this.each(function() {
                this.html5_upload = {
                    xhr:                    new XMLHttpRequest(),
                    continue_after_abort:    true
                };
                if (options.autostart) {
                    $(this).bind('change', upload);
                }
                for (event in available_events) {
                    if (options[available_events[event]]) {
                        $(this).bind("html5_upload."+available_events[event], options[available_events[event]]);
                    }
                }
                $(this)
                    .bind('html5_upload.start', upload)
                    .bind('html5_upload.cancelOne', function() {
                        this.html5_upload['xhr'].abort();
                    })
                    .bind('html5_upload.cancelAll', function() {
                        this.html5_upload['continue_after_abort'] = false;
                        this.html5_upload['xhr'].abort();
                    })
                    .bind('html5_upload.destroy', function() {
                        this.html5_upload['continue_after_abort'] = false;
                        this.xhr.abort();
                        delete this.html5_upload;
                        $(this).unbind('html5_upload.*').unbind('change', upload);
                    });
            });
        }
        catch (ex) {
            options.onBrowserIncompatible();
            return false;
        }
    };
})(jQuery);
/*
 * Jeditable - jQuery in place edit plugin
 *
 * Copyright (c) 2006-2009 Mika Tuupola, Dylan Verheul
 *
 * Licensed under the MIT license:
 *   http://www.opensource.org/licenses/mit-license.php
 *
 * Project home:
 *   http://www.appelsiini.net/projects/jeditable
 *
 * Based on editable by Dylan Verheul <dylan_at_dyve.net>:
 *    http://www.dyve.net/jquery/?editable
 *
 */

/**
  * Version 1.7.1
  *
  * ** means there is basic unit tests for this parameter. 
  *
  * @name  Jeditable
  * @type  jQuery
  * @param String  target             (POST) URL or function to send edited content to **
  * @param Hash    options            additional options 
  * @param String  options[method]    method to use to send edited content (POST or PUT) **
  * @param Function options[callback] Function to run after submitting edited content **
  * @param String  options[name]      POST parameter name of edited content
  * @param String  options[id]        POST parameter name of edited div id
  * @param Hash    options[submitdata] Extra parameters to send when submitting edited content.
  * @param String  options[type]      text, textarea or select (or any 3rd party input type) **
  * @param Integer options[rows]      number of rows if using textarea ** 
  * @param Integer options[cols]      number of columns if using textarea **
  * @param Mixed   options[height]    'auto', 'none' or height in pixels **
  * @param Mixed   options[width]     'auto', 'none' or width in pixels **
  * @param String  options[loadurl]   URL to fetch input content before editing **
  * @param String  options[loadtype]  Request type for load url. Should be GET or POST.
  * @param String  options[loadtext]  Text to display while loading external content.
  * @param Mixed   options[loaddata]  Extra parameters to pass when fetching content before editing.
  * @param Mixed   options[data]      Or content given as paramameter. String or function.**
  * @param String  options[indicator] indicator html to show when saving
  * @param String  options[tooltip]   optional tooltip text via title attribute **
  * @param String  options[event]     jQuery event such as 'click' of 'dblclick' **
  * @param String  options[submit]    submit button value, empty means no button **
  * @param String  options[cancel]    cancel button value, empty means no button **
  * @param String  options[cssclass]  CSS class to apply to input form. 'inherit' to copy from parent. **
  * @param String  options[style]     Style to apply to input form 'inherit' to copy from parent. **
  * @param String  options[select]    true or false, when true text is highlighted ??
  * @param String  options[placeholder] Placeholder text or html to insert when element is empty. **
  * @param String  options[onblur]    'cancel', 'submit', 'ignore' or function ??
  *             
  * @param Function options[onsubmit] function(settings, original) { ... } called before submit
  * @param Function options[onreset]  function(settings, original) { ... } called before reset
  * @param Function options[onerror]  function(settings, original, xhr) { ... } called on error
  *             
  * @param Hash    options[ajaxoptions]  jQuery Ajax options. See docs.jquery.com.
  *             
  */

(function($) {

    $.fn.editable = function(target, options) {
            
        if ('disable' == target) {
            $(this).data('disabled.editable', true);
            return;
        }
        if ('enable' == target) {
            $(this).data('disabled.editable', false);
            return;
        }
        if ('destroy' == target) {
            $(this)
                .unbind($(this).data('event.editable'))
                .removeData('disabled.editable')
                .removeData('event.editable');
            return;
        }
        
        var settings = $.extend({}, $.fn.editable.defaults, {target:target}, options);
        
        /* setup some functions */
        var plugin   = $.editable.types[settings.type].plugin || function() { };
        var submit   = $.editable.types[settings.type].submit || function() { };
        var buttons  = $.editable.types[settings.type].buttons 
                    || $.editable.types['defaults'].buttons;
        var content  = $.editable.types[settings.type].content 
                    || $.editable.types['defaults'].content;
        var element  = $.editable.types[settings.type].element 
                    || $.editable.types['defaults'].element;
        var reset    = $.editable.types[settings.type].reset 
                    || $.editable.types['defaults'].reset;
        var callback = settings.callback || function() { };
        var onedit   = settings.onedit   || function() { }; 
        var onsubmit = settings.onsubmit || function() { };
        var onreset  = settings.onreset  || function() { };
        var onerror  = settings.onerror  || reset;
          
        /* show tooltip */
        if (settings.tooltip) {
            $(this).attr('title', settings.tooltip);
        }
        
        settings.autowidth  = 'auto' == settings.width;
        settings.autoheight = 'auto' == settings.height;
        
        return this.each(function() {
                        
            /* save this to self because this changes when scope changes */
            var self = this;  
                   
            /* inlined block elements lose their width and height after first edit */
            /* save them for later use as workaround */
            var savedwidth  = $(self).width();
            var savedheight = $(self).height();
            
            /* save so it can be later used by $.editable('destroy') */
            $(this).data('event.editable', settings.event);
            
            /* if element is empty add something clickable (if requested) */
            if (!$.trim($(this).html())) {
                $(this).html(settings.placeholder);
            }
            
            $(this).bind(settings.event, function(e) {
                
                /* abort if disabled for this element */
                if (true === $(this).data('disabled.editable')) {
                    return;
                }
                
                /* prevent throwing an exeption if edit field is clicked again */
                if (self.editing) {
                    return;
                }
                
                /* abort if onedit hook returns false */
                if (false === onedit.apply(this, [settings, self])) {
                   return;
                }
                
                /* prevent default action and bubbling */
                e.preventDefault();
                e.stopPropagation();
                
                /* remove tooltip */
                if (settings.tooltip) {
                    $(self).removeAttr('title');
                }
                
                /* figure out how wide and tall we are, saved width and height */
                /* are workaround for http://dev.jquery.com/ticket/2190 */
                if (0 == $(self).width()) {
                    //$(self).css('visibility', 'hidden');
                    settings.width  = savedwidth;
                    settings.height = savedheight;
                } else {
                    if (settings.width != 'none') {
                        settings.width = 
                            settings.autowidth ? $(self).width()  : settings.width;
                    }
                    if (settings.height != 'none') {
                        settings.height = 
                            settings.autoheight ? $(self).height() : settings.height;
                    }
                }
                //$(this).css('visibility', '');
                
                /* remove placeholder text, replace is here because of IE */
                if ($(this).html().toLowerCase().replace(/(;|")/g, '') == 
                    settings.placeholder.toLowerCase().replace(/(;|")/g, '')) {
                        $(this).html('');
                }
                                
                self.editing    = true;
                self.revert     = $(self).html();
                $(self).html('');

                /* create the form object */
                var form = $('<form />');
                
                /* apply css or style or both */
                if (settings.cssclass) {
                    if ('inherit' == settings.cssclass) {
                        form.attr('class', $(self).attr('class'));
                    } else {
                        form.attr('class', settings.cssclass);
                    }
                }

                if (settings.style) {
                    if ('inherit' == settings.style) {
                        form.attr('style', $(self).attr('style'));
                        /* IE needs the second line or display wont be inherited */
                        form.css('display', $(self).css('display'));                
                    } else {
                        form.attr('style', settings.style);
                    }
                }

                /* add main input element to form and store it in input */
                var input = element.apply(form, [settings, self]);

                /* set input content via POST, GET, given data or existing value */
                var input_content;
                
                if (settings.loadurl) {
                    var t = setTimeout(function() {
                        input.disabled = true;
                        content.apply(form, [settings.loadtext, settings, self]);
                    }, 100);

                    var loaddata = {};
                    loaddata[settings.id] = self.id;
                    if ($.isFunction(settings.loaddata)) {
                        $.extend(loaddata, settings.loaddata.apply(self, [self.revert, settings]));
                    } else {
                        $.extend(loaddata, settings.loaddata);
                    }
                    $.ajax({
                       type : settings.loadtype,
                       url  : settings.loadurl,
                       data : loaddata,
                       async : false,
                       success: function(result) {
                          window.clearTimeout(t);
                          input_content = result;
                          input.disabled = false;
                       }
                    });
                } else if (settings.data) {
                    input_content = settings.data;
                    if ($.isFunction(settings.data)) {
                        input_content = settings.data.apply(self, [self.revert, settings]);
                    }
                } else {
                    input_content = self.revert; 
                }
                content.apply(form, [input_content, settings, self]);

                input.attr('name', settings.name);
        
                /* add buttons to the form */
                buttons.apply(form, [settings, self]);
         
                /* add created form to self */
                $(self).append(form);
         
                /* attach 3rd party plugin if requested */
                plugin.apply(form, [settings, self]);

                /* focus to first visible form element */
                $(':input:visible:enabled:first', form).focus();

                /* highlight input contents when requested */
                if (settings.select) {
                    input.select();
                }
        
                /* discard changes if pressing esc */
                input.keydown(function(e) {
                    if (e.keyCode == 27) {
                        e.preventDefault();
                        //self.reset();
                        reset.apply(form, [settings, self]);
                    }
                });

                /* discard, submit or nothing with changes when clicking outside */
                /* do nothing is usable when navigating with tab */
                var t;
                if ('cancel' == settings.onblur) {
                    input.blur(function(e) {
                        /* prevent canceling if submit was clicked */
                        t = setTimeout(function() {
                            reset.apply(form, [settings, self]);
                        }, 500);
                    });
                } else if ('submit' == settings.onblur) {
                    input.blur(function(e) {
                        /* prevent double submit if submit was clicked */
                        t = setTimeout(function() {
                            form.submit();
                        }, 200);
                    });
                } else if ($.isFunction(settings.onblur)) {
                    input.blur(function(e) {
                        settings.onblur.apply(self, [input.val(), settings]);
                    });
                } else {
                    input.blur(function(e) {
                      /* TODO: maybe something here */
                    });
                }

                form.submit(function(e) {

                    if (t) { 
                        clearTimeout(t);
                    }

                    /* do no submit */
                    e.preventDefault(); 
            
                    /* call before submit hook. */
                    /* if it returns false abort submitting */                    
                    if (false !== onsubmit.apply(form, [settings, self])) { 
                        /* custom inputs call before submit hook. */
                        /* if it returns false abort submitting */
                        if (false !== submit.apply(form, [settings, self])) { 

                          /* check if given target is function */
                          if ($.isFunction(settings.target)) {
                              var str = settings.target.apply(self, [input.val(), settings]);
                              $(self).html(str);
                              self.editing = false;
                              callback.apply(self, [self.innerHTML, settings]);
                              /* TODO: this is not dry */                              
                              if (!$.trim($(self).html())) {
                                  $(self).html(settings.placeholder);
                              }
                          } else {
                              /* add edited content and id of edited element to POST */
                              var submitdata = {};
                              submitdata[settings.name] = input.val();
                              submitdata[settings.id] = self.id;
                              /* add extra data to be POST:ed */
                              if ($.isFunction(settings.submitdata)) {
                                  $.extend(submitdata, settings.submitdata.apply(self, [self.revert, settings]));
                              } else {
                                  $.extend(submitdata, settings.submitdata);
                              }

                              /* quick and dirty PUT support */
                              if ('PUT' == settings.method) {
                                  submitdata['_method'] = 'put';
                              }

                              /* show the saving indicator */
                              $(self).html(settings.indicator);
                              
                              /* defaults for ajaxoptions */
                              var ajaxoptions = {
                                  type    : 'POST',
                                  data    : submitdata,
                                  dataType: 'html',
                                  url     : settings.target,
                                  success : function(result, status) {
                                      if (ajaxoptions.dataType == 'html') {
                                        $(self).html(result);
                                      }
                                      self.editing = false;
                                      callback.apply(self, [result, settings]);
                                      if (!$.trim($(self).html())) {
                                          $(self).html(settings.placeholder);
                                      }
                                  },
                                  error   : function(xhr, status, error) {
                                      onerror.apply(form, [settings, self, xhr]);
                                  }
                              };
                              
                              /* override with what is given in settings.ajaxoptions */
                              $.extend(ajaxoptions, settings.ajaxoptions);   
                              $.ajax(ajaxoptions);          
                              
                            }
                        }
                    }
                    
                    /* show tooltip again */
                    $(self).attr('title', settings.tooltip);
                    
                    return false;
                });
            });
            
            /* privileged methods */
            this.reset = function(form) {
                /* prevent calling reset twice when blurring */
                if (this.editing) {
                    /* before reset hook, if it returns false abort reseting */
                    if (false !== onreset.apply(form, [settings, self])) { 
                        $(self).html(self.revert);
                        self.editing   = false;
                        if (!$.trim($(self).html())) {
                            $(self).html(settings.placeholder);
                        }
                        /* show tooltip again */
                        if (settings.tooltip) {
                            $(self).attr('title', settings.tooltip);                
                        }
                    }                    
                }
            };            
        });

    };


    $.editable = {
        types: {
            defaults: {
                element : function(settings, original) {
                    var input = $('<input type="hidden"></input>');                
                    $(this).append(input);
                    return(input);
                },
                content : function(string, settings, original) {
                    $(':input:first', this).val(string);
                },
                reset : function(settings, original) {
                  original.reset(this);
                },
                buttons : function(settings, original) {
                    var form = this;
                    if (settings.submit) {
                        /* if given html string use that */
                        if (settings.submit.match(/>$/)) {
                            var submit = $(settings.submit).click(function() {
                                if (submit.attr("type") != "submit") {
                                    form.submit();
                                }
                            });
                        /* otherwise use button with given string as text */
                        } else {
                            var submit = $('<button type="submit" />');
                            submit.html(settings.submit);                            
                        }
                        $(this).append(submit);
                    }
                    if (settings.cancel) {
                        /* if given html string use that */
                        if (settings.cancel.match(/>$/)) {
                            var cancel = $(settings.cancel);
                        /* otherwise use button with given string as text */
                        } else {
                            var cancel = $('<button type="cancel" />');
                            cancel.html(settings.cancel);
                        }
                        $(this).append(cancel);

                        $(cancel).click(function(event) {
                            //original.reset();
                            if ($.isFunction($.editable.types[settings.type].reset)) {
                                var reset = $.editable.types[settings.type].reset;                                                                
                            } else {
                                var reset = $.editable.types['defaults'].reset;                                
                            }
                            reset.apply(form, [settings, original]);
                            return false;
                        });
                    }
                }
            },
            text: {
                element : function(settings, original) {
                    var input = $('<input />');
                    if (settings.width  != 'none') { input.width(settings.width);  }
                    if (settings.height != 'none') { input.height(settings.height); }
                    /* https://bugzilla.mozilla.org/show_bug.cgi?id=236791 */
                    //input[0].setAttribute('autocomplete','off');
                    input.attr('autocomplete','off');
                    $(this).append(input);
                    return(input);
                }
            },
            textarea: {
                element : function(settings, original) {
                    var textarea = $('<textarea />');
                    if (settings.rows) {
                        textarea.attr('rows', settings.rows);
                    } else if (settings.height != "none") {
                        textarea.height(settings.height);
                    }
                    if (settings.cols) {
                        textarea.attr('cols', settings.cols);
                    } else if (settings.width != "none") {
                        textarea.width(settings.width);
                    }
                    $(this).append(textarea);
                    return(textarea);
                }
            },
            select: {
               element : function(settings, original) {
                    var select = $('<select />');
                    $(this).append(select);
                    return(select);
                },
                content : function(data, settings, original) {
                    /* If it is string assume it is json. */
                    if (String == data.constructor) {      
                        eval ('var json = ' + data);
                    } else {
                    /* Otherwise assume it is a hash already. */
                        var json = data;
                    }
                    for (var key in json) {
                        if (!json.hasOwnProperty(key)) {
                            continue;
                        }
                        if ('selected' == key) {
                            continue;
                        } 
                        var option = $('<option />').val(key).append(json[key]);
                        $('select', this).append(option);    
                    }                    
                    /* Loop option again to set selected. IE needed this... */ 
                    $('select', this).children().each(function() {
                        if ($(this).val() == json['selected'] || 
                            $(this).text() == $.trim(original.revert)) {
                                $(this).attr('selected', 'selected');
                        }
                    });
                }
            }
        },

        /* Add new input type */
        addInputType: function(name, input) {
            $.editable.types[name] = input;
        }
    };

    // publicly accessible defaults
    $.fn.editable.defaults = {
        name       : 'value',
        id         : 'id',
        type       : 'text',
        width      : 'auto',
        height     : 'auto',
        event      : 'click.editable',
        onblur     : 'cancel',
        loadtype   : 'GET',
        loadtext   : 'Loading...',
        placeholder: 'Click to edit',
        loaddata   : {},
        submitdata : {},
        ajaxoptions: {}
    };

})(jQuery);
/* 
* jqGrid  4.4.0 - jQuery Grid 
* Copyright (c) 2008, Tony Tomov, tony@trirand.com 
* Dual licensed under the MIT and GPL licenses 
* http://www.opensource.org/licenses/mit-license.php 
* http://www.gnu.org/licenses/gpl-2.0.html 
* Date:2012-06-14 
* Modules: grid.base.js; jquery.fmatter.js; grid.custom.js; grid.common.js; grid.formedit.js; grid.filter.js; grid.inlinedit.js; grid.celledit.js; jqModal.js; jqDnR.js; grid.subgrid.js; grid.grouping.js; grid.treegrid.js; grid.import.js; JsonXml.js; grid.tbltogrid.js; grid.jqueryui.js; 
*/
(function(b){b.jgrid=b.jgrid||{};b.extend(b.jgrid,{version:"4.4.0",htmlDecode:function(b){return b&&("&nbsp;"==b||"&#160;"==b||1===b.length&&160===b.charCodeAt(0))?"":!b?b:(""+b).replace(/&gt;/g,">").replace(/&lt;/g,"<").replace(/&quot;/g,'"').replace(/&amp;/g,"&")},htmlEncode:function(b){return!b?b:(""+b).replace(/&/g,"&amp;").replace(/\"/g,"&quot;").replace(/</g,"&lt;").replace(/>/g,"&gt;")},format:function(f){var e=b.makeArray(arguments).slice(1);void 0===f&&(f="");return f.replace(/\{(\d+)\}/g,
function(b,d){return e[d]})},getCellIndex:function(f){f=b(f);if(f.is("tr"))return-1;f=(!f.is("td")&&!f.is("th")?f.closest("td,th"):f)[0];return b.browser.msie?b.inArray(f,f.parentNode.cells):f.cellIndex},stripHtml:function(b){var b=b+"",e=/<("[^"]*"|'[^']*'|[^'">])*>/gi;return b?(b=b.replace(e,""))&&"&nbsp;"!==b&&"&#160;"!==b?b.replace(/\"/g,"'"):"":b},stripPref:function(f,e){var c=b.type(f);if("string"==c||"number"==c)f=""+f,e=""!==f?(""+e).replace(""+f,""):e;return e},stringToDoc:function(b){var e;
if("string"!==typeof b)return b;try{e=(new DOMParser).parseFromString(b,"text/xml")}catch(c){e=new ActiveXObject("Microsoft.XMLDOM"),e.async=!1,e.loadXML(b)}return e&&e.documentElement&&"parsererror"!=e.documentElement.tagName?e:null},parse:function(f){"while(1);"==f.substr(0,9)&&(f=f.substr(9));"/*"==f.substr(0,2)&&(f=f.substr(2,f.length-4));f||(f="{}");return!0===b.jgrid.useJSON&&"object"===typeof JSON&&"function"===typeof JSON.parse?JSON.parse(f):eval("("+f+")")},parseDate:function(f,e){var c=
{m:1,d:1,y:1970,h:0,i:0,s:0,u:0},d,a,h;d=/[\\\/:_;.,\t\T\s-]/;if(e&&null!==e&&void 0!==e){e=b.trim(e);e=e.split(d);void 0!==b.jgrid.formatter.date.masks[f]&&(f=b.jgrid.formatter.date.masks[f]);var f=f.split(d),g=b.jgrid.formatter.date.monthNames,i=b.jgrid.formatter.date.AmPm,j=function(a,b){0===a?12===b&&(b=0):12!==b&&(b+=12);return b};d=0;for(a=f.length;d<a;d++)"M"==f[d]&&(h=b.inArray(e[d],g),-1!==h&&12>h&&(e[d]=h+1,c.m=e[d])),"F"==f[d]&&(h=b.inArray(e[d],g),-1!==h&&11<h&&(e[d]=h+1-12,c.m=e[d])),
"a"==f[d]&&(h=b.inArray(e[d],i),-1!==h&&2>h&&e[d]==i[h]&&(e[d]=h,c.h=j(e[d],c.h))),"A"==f[d]&&(h=b.inArray(e[d],i),-1!==h&&1<h&&e[d]==i[h]&&(e[d]=h-2,c.h=j(e[d],c.h))),void 0!==e[d]&&(c[f[d].toLowerCase()]=parseInt(e[d],10));c.m=parseInt(c.m,10)-1;d=c.y;70<=d&&99>=d?c.y=1900+c.y:0<=d&&69>=d&&(c.y=2E3+c.y);void 0!==c.j&&(c.d=c.j);void 0!==c.n&&(c.m=parseInt(c.n,10)-1)}return new Date(c.y,c.m,c.d,c.h,c.i,c.s,c.u)},jqID:function(b){return(""+b).replace(/[!"#$%&'()*+,.\/:;<=>?@\[\\\]\^`{|}~]/g,"\\$&")},
guid:1,uidPref:"jqg",randId:function(f){return(f?f:b.jgrid.uidPref)+b.jgrid.guid++},getAccessor:function(b,e){var c,d,a=[],h;if("function"===typeof e)return e(b);c=b[e];if(void 0===c)try{if("string"===typeof e&&(a=e.split(".")),h=a.length)for(c=b;c&&h--;)d=a.shift(),c=c[d]}catch(g){}return c},getXmlData:function(f,e,c){var d="string"===typeof e?e.match(/^(.*)\[(\w+)\]$/):null;if("function"===typeof e)return e(f);if(d&&d[2])return d[1]?b(d[1],f).attr(d[2]):b(f).attr(d[2]);f=b(e,f);return c?f:0<f.length?
b(f).text():void 0},cellWidth:function(){var f=b("<div class='ui-jqgrid' style='left:10000px'><table class='ui-jqgrid-btable' style='width:5px;'><tr class='jqgrow'><td style='width:5px;'></td></tr></table></div>"),e=f.appendTo("body").find("td").width();f.remove();return 5!==e},ajaxOptions:{},from:function(f){return new function(e,c){"string"==typeof e&&(e=b.data(e));var d=this,a=e,h=!0,f=!1,i=c,j=/[\$,%]/g,l=null,k=null,m=0,o=!1,p="",v=[],u=!0;if("object"==typeof e&&e.push)0<e.length&&(u="object"!=
typeof e[0]?!1:!0);else throw"data provides is not an array";this._hasData=function(){return null===a?!1:0===a.length?!1:!0};this._getStr=function(a){var b=[];f&&b.push("jQuery.trim(");b.push("String("+a+")");f&&b.push(")");h||b.push(".toLowerCase()");return b.join("")};this._strComp=function(a){return"string"==typeof a?".toString()":""};this._group=function(a,b){return{field:a.toString(),unique:b,items:[]}};this._toStr=function(a){f&&(a=b.trim(a));a=a.toString().replace(/\\/g,"\\\\").replace(/\"/g,
'\\"');return h?a:a.toLowerCase()};this._funcLoop=function(d){var c=[];b.each(a,function(a,b){c.push(d(b))});return c};this._append=function(a){var b;i=null===i?"":i+(""===p?" && ":p);for(b=0;b<m;b++)i+="(";o&&(i+="!");i+="("+a+")";o=!1;p="";m=0};this._setCommand=function(a,b){l=a;k=b};this._resetNegate=function(){o=!1};this._repeatCommand=function(a,b){return null===l?d:null!==a&&null!==b?l(a,b):null===k||!u?l(a):l(k,a)};this._equals=function(a,b){return 0===d._compare(a,b,1)};this._compare=function(a,
b,d){var c=Object.prototype.toString;void 0===d&&(d=1);void 0===a&&(a=null);void 0===b&&(b=null);if(null===a&&null===b)return 0;if(null===a&&null!==b)return 1;if(null!==a&&null===b)return-1;if("[object Date]"===c.call(a)&&"[object Date]"===c.call(b))return a<b?-d:a>b?d:0;!h&&"number"!==typeof a&&"number"!==typeof b&&(a=(""+a).toLowerCase(),b=(""+b).toLowerCase());return a<b?-d:a>b?d:0};this._performSort=function(){0!==v.length&&(a=d._doSort(a,0))};this._doSort=function(a,b){var c=v[b].by,f=v[b].dir,
h=v[b].type,e=v[b].datefmt;if(b==v.length-1)return d._getOrder(a,c,f,h,e);b++;c=d._getGroup(a,c,f,h,e);f=[];for(h=0;h<c.length;h++)for(var e=d._doSort(c[h].items,b),g=0;g<e.length;g++)f.push(e[g]);return f};this._getOrder=function(a,c,h,f,e){var g=[],i=[],l="a"==h?1:-1,k,m;void 0===f&&(f="text");m="float"==f||"number"==f||"currency"==f||"numeric"==f?function(a){a=parseFloat((""+a).replace(j,""));return isNaN(a)?0:a}:"int"==f||"integer"==f?function(a){return a?parseFloat((""+a).replace(j,"")):0}:"date"==
f||"datetime"==f?function(a){return b.jgrid.parseDate(e,a).getTime()}:b.isFunction(f)?f:function(a){a||(a="");return b.trim((""+a).toUpperCase())};b.each(a,function(a,d){k=""!==c?b.jgrid.getAccessor(d,c):d;void 0===k&&(k="");k=m(k,d);i.push({vSort:k,index:a})});i.sort(function(a,b){a=a.vSort;b=b.vSort;return d._compare(a,b,l)});for(var f=0,o=a.length;f<o;)h=i[f].index,g.push(a[h]),f++;return g};this._getGroup=function(a,c,f,h,e){var g=[],i=null,j=null,k;b.each(d._getOrder(a,c,f,h,e),function(a,f){k=
b.jgrid.getAccessor(f,c);void 0===k&&(k="");d._equals(j,k)||(j=k,null!==i&&g.push(i),i=d._group(c,k));i.items.push(f)});null!==i&&g.push(i);return g};this.ignoreCase=function(){h=!1;return d};this.useCase=function(){h=!0;return d};this.trim=function(){f=!0;return d};this.noTrim=function(){f=!1;return d};this.execute=function(){var c=i,f=[];if(null===c)return d;b.each(a,function(){eval(c)&&f.push(this)});a=f;return d};this.data=function(){return a};this.select=function(c){d._performSort();if(!d._hasData())return[];
d.execute();if(b.isFunction(c)){var f=[];b.each(a,function(a,b){f.push(c(b))});return f}return a};this.hasMatch=function(){if(!d._hasData())return!1;d.execute();return 0<a.length};this.andNot=function(a,b,c){o=!o;return d.and(a,b,c)};this.orNot=function(a,b,c){o=!o;return d.or(a,b,c)};this.not=function(a,b,c){return d.andNot(a,b,c)};this.and=function(a,b,c){p=" && ";return void 0===a?d:d._repeatCommand(a,b,c)};this.or=function(a,b,c){p=" || ";return void 0===a?d:d._repeatCommand(a,b,c)};this.orBegin=
function(){m++;return d};this.orEnd=function(){null!==i&&(i+=")");return d};this.isNot=function(a){o=!o;return d.is(a)};this.is=function(a){d._append("this."+a);d._resetNegate();return d};this._compareValues=function(a,c,f,h,e){var g;g=u?"jQuery.jgrid.getAccessor(this,'"+c+"')":"this";void 0===f&&(f=null);var i=f,k=void 0===e.stype?"text":e.stype;if(null!==f)switch(k){case "int":case "integer":i=isNaN(Number(i))||""===i?"0":i;g="parseInt("+g+",10)";i="parseInt("+i+",10)";break;case "float":case "number":case "numeric":i=
(""+i).replace(j,"");i=isNaN(Number(i))||""===i?"0":i;g="parseFloat("+g+")";i="parseFloat("+i+")";break;case "date":case "datetime":i=""+b.jgrid.parseDate(e.newfmt||"Y-m-d",i).getTime();g='jQuery.jgrid.parseDate("'+e.srcfmt+'",'+g+").getTime()";break;default:g=d._getStr(g),i=d._getStr('"'+d._toStr(i)+'"')}d._append(g+" "+h+" "+i);d._setCommand(a,c);d._resetNegate();return d};this.equals=function(a,b,c){return d._compareValues(d.equals,a,b,"==",c)};this.notEquals=function(a,b,c){return d._compareValues(d.equals,
a,b,"!==",c)};this.isNull=function(a,b,c){return d._compareValues(d.equals,a,null,"===",c)};this.greater=function(a,b,c){return d._compareValues(d.greater,a,b,">",c)};this.less=function(a,b,c){return d._compareValues(d.less,a,b,"<",c)};this.greaterOrEquals=function(a,b,c){return d._compareValues(d.greaterOrEquals,a,b,">=",c)};this.lessOrEquals=function(a,b,c){return d._compareValues(d.lessOrEquals,a,b,"<=",c)};this.startsWith=function(a,c){var h=void 0===c||null===c?a:c,h=f?b.trim(h.toString()).length:
h.toString().length;u?d._append(d._getStr("jQuery.jgrid.getAccessor(this,'"+a+"')")+".substr(0,"+h+") == "+d._getStr('"'+d._toStr(c)+'"')):(h=f?b.trim(c.toString()).length:c.toString().length,d._append(d._getStr("this")+".substr(0,"+h+") == "+d._getStr('"'+d._toStr(a)+'"')));d._setCommand(d.startsWith,a);d._resetNegate();return d};this.endsWith=function(a,c){var h=void 0===c||null===c?a:c,h=f?b.trim(h.toString()).length:h.toString().length;u?d._append(d._getStr("jQuery.jgrid.getAccessor(this,'"+a+
"')")+".substr("+d._getStr("jQuery.jgrid.getAccessor(this,'"+a+"')")+".length-"+h+","+h+') == "'+d._toStr(c)+'"'):d._append(d._getStr("this")+".substr("+d._getStr("this")+'.length-"'+d._toStr(a)+'".length,"'+d._toStr(a)+'".length) == "'+d._toStr(a)+'"');d._setCommand(d.endsWith,a);d._resetNegate();return d};this.contains=function(a,b){u?d._append(d._getStr("jQuery.jgrid.getAccessor(this,'"+a+"')")+'.indexOf("'+d._toStr(b)+'",0) > -1'):d._append(d._getStr("this")+'.indexOf("'+d._toStr(a)+'",0) > -1');
d._setCommand(d.contains,a);d._resetNegate();return d};this.groupBy=function(b,c,f,h){return!d._hasData()?null:d._getGroup(a,b,c,f,h)};this.orderBy=function(a,c,f,h){c=void 0===c||null===c?"a":b.trim(c.toString().toLowerCase());if(null===f||void 0===f)f="text";if(null===h||void 0===h)h="Y-m-d";if("desc"==c||"descending"==c)c="d";if("asc"==c||"ascending"==c)c="a";v.push({by:a,dir:c,type:f,datefmt:h});return d};return d}(f,null)},extend:function(f){b.extend(b.fn.jqGrid,f);this.no_legacy_api||b.fn.extend(f)}});
b.fn.jqGrid=function(f){if("string"==typeof f){var e=b.jgrid.getAccessor(b.fn.jqGrid,f);if(!e)throw"jqGrid - No such method: "+f;var c=b.makeArray(arguments).slice(1);return e.apply(this,c)}return this.each(function(){if(!this.grid){var d=b.extend(!0,{url:"",height:150,page:1,rowNum:20,rowTotal:null,records:0,pager:"",pgbuttons:!0,pginput:!0,colModel:[],rowList:[],colNames:[],sortorder:"asc",sortname:"",datatype:"xml",mtype:"GET",altRows:!1,selarrrow:[],savedRow:[],shrinkToFit:!0,xmlReader:{},jsonReader:{},
subGrid:!1,subGridModel:[],reccount:0,lastpage:0,lastsort:0,selrow:null,beforeSelectRow:null,onSelectRow:null,onSortCol:null,ondblClickRow:null,onRightClickRow:null,onPaging:null,onSelectAll:null,loadComplete:null,gridComplete:null,loadError:null,loadBeforeSend:null,afterInsertRow:null,beforeRequest:null,beforeProcessing:null,onHeaderClick:null,viewrecords:!1,loadonce:!1,multiselect:!1,multikey:!1,editurl:null,search:!1,caption:"",hidegrid:!0,hiddengrid:!1,postData:{},userData:{},treeGrid:!1,treeGridModel:"nested",
treeReader:{},treeANode:-1,ExpandColumn:null,tree_root_level:0,prmNames:{page:"page",rows:"rows",sort:"sidx",order:"sord",search:"_search",nd:"nd",id:"id",oper:"oper",editoper:"edit",addoper:"add",deloper:"del",subgridid:"id",npage:null,totalrows:"totalrows"},forceFit:!1,gridstate:"visible",cellEdit:!1,cellsubmit:"remote",nv:0,loadui:"enable",toolbar:[!1,""],scroll:!1,multiboxonly:!1,deselectAfterSort:!0,scrollrows:!1,autowidth:!1,scrollOffset:18,cellLayout:5,subGridWidth:20,multiselectWidth:20,gridview:!1,
rownumWidth:25,rownumbers:!1,pagerpos:"center",recordpos:"right",footerrow:!1,userDataOnFooter:!1,hoverrows:!0,altclass:"ui-priority-secondary",viewsortcols:[!1,"vertical",!0],resizeclass:"",autoencode:!1,remapColumns:[],ajaxGridOptions:{},direction:"ltr",toppager:!1,headertitles:!1,scrollTimeout:40,data:[],_index:{},grouping:!1,groupingView:{groupField:[],groupOrder:[],groupText:[],groupColumnShow:[],groupSummary:[],showSummaryOnHide:!1,sortitems:[],sortnames:[],summary:[],summaryval:[],plusicon:"ui-icon-circlesmall-plus",
minusicon:"ui-icon-circlesmall-minus"},ignoreCase:!1,cmTemplate:{},idPrefix:""},b.jgrid.defaults,f||{}),a=this,c={headers:[],cols:[],footers:[],dragStart:function(c,e,f){this.resizing={idx:c,startX:e.clientX,sOL:f[0]};this.hDiv.style.cursor="col-resize";this.curGbox=b("#rs_m"+b.jgrid.jqID(d.id),"#gbox_"+b.jgrid.jqID(d.id));this.curGbox.css({display:"block",left:f[0],top:f[1],height:f[2]});b(a).triggerHandler("jqGridResizeStart",[e,c]);b.isFunction(d.resizeStart)&&d.resizeStart.call(this,e,c);document.onselectstart=
function(){return!1}},dragMove:function(a){if(this.resizing){var b=a.clientX-this.resizing.startX,a=this.headers[this.resizing.idx],c="ltr"===d.direction?a.width+b:a.width-b,e;33<c&&(this.curGbox.css({left:this.resizing.sOL+b}),!0===d.forceFit?(e=this.headers[this.resizing.idx+d.nv],b="ltr"===d.direction?e.width-b:e.width+b,33<b&&(a.newWidth=c,e.newWidth=b)):(this.newWidth="ltr"===d.direction?d.tblwidth+b:d.tblwidth-b,a.newWidth=c))}},dragEnd:function(){this.hDiv.style.cursor="default";if(this.resizing){var c=
this.resizing.idx,e=this.headers[c].newWidth||this.headers[c].width,e=parseInt(e,10);this.resizing=!1;b("#rs_m"+b.jgrid.jqID(d.id)).css("display","none");d.colModel[c].width=e;this.headers[c].width=e;this.headers[c].el.style.width=e+"px";this.cols[c].style.width=e+"px";0<this.footers.length&&(this.footers[c].style.width=e+"px");!0===d.forceFit?(e=this.headers[c+d.nv].newWidth||this.headers[c+d.nv].width,this.headers[c+d.nv].width=e,this.headers[c+d.nv].el.style.width=e+"px",this.cols[c+d.nv].style.width=
e+"px",0<this.footers.length&&(this.footers[c+d.nv].style.width=e+"px"),d.colModel[c+d.nv].width=e):(d.tblwidth=this.newWidth||d.tblwidth,b("table:first",this.bDiv).css("width",d.tblwidth+"px"),b("table:first",this.hDiv).css("width",d.tblwidth+"px"),this.hDiv.scrollLeft=this.bDiv.scrollLeft,d.footerrow&&(b("table:first",this.sDiv).css("width",d.tblwidth+"px"),this.sDiv.scrollLeft=this.bDiv.scrollLeft));b(a).triggerHandler("jqGridResizeStop",[e,c]);b.isFunction(d.resizeStop)&&d.resizeStop.call(this,
e,c)}this.curGbox=null;document.onselectstart=function(){return!0}},populateVisible:function(){c.timer&&clearTimeout(c.timer);c.timer=null;var a=b(c.bDiv).height();if(a){var e=b("table:first",c.bDiv),f,G;if(e[0].rows.length)try{G=(f=e[0].rows[1])?b(f).outerHeight()||c.prevRowHeight:c.prevRowHeight}catch(g){G=c.prevRowHeight}if(G){c.prevRowHeight=G;var i=d.rowNum;f=c.scrollTop=c.bDiv.scrollTop;var j=Math.round(e.position().top)-f,k=j+e.height();G*=i;var y,z,B;if(k<a&&0>=j&&(void 0===d.lastpage||parseInt((k+
f+G-1)/G,10)<=d.lastpage))z=parseInt((a-k+G-1)/G,10),0<=k||2>z||!0===d.scroll?(y=Math.round((k+f)/G)+1,j=-1):j=1;0<j&&(y=parseInt(f/G,10)+1,z=parseInt((f+a)/G,10)+2-y,B=!0);if(z&&!(d.lastpage&&y>d.lastpage||1==d.lastpage||y===d.page&&y===d.lastpage))c.hDiv.loading?c.timer=setTimeout(c.populateVisible,d.scrollTimeout):(d.page=y,B&&(c.selectionPreserver(e[0]),c.emptyRows.call(e[0],!1,!1)),c.populate(z))}}},scrollGrid:function(a){if(d.scroll){var b=c.bDiv.scrollTop;void 0===c.scrollTop&&(c.scrollTop=
0);b!=c.scrollTop&&(c.scrollTop=b,c.timer&&clearTimeout(c.timer),c.timer=setTimeout(c.populateVisible,d.scrollTimeout))}c.hDiv.scrollLeft=c.bDiv.scrollLeft;d.footerrow&&(c.sDiv.scrollLeft=c.bDiv.scrollLeft);a&&a.stopPropagation()},selectionPreserver:function(a){var c=a.p,d=c.selrow,e=c.selarrrow?b.makeArray(c.selarrrow):null,f=a.grid.bDiv.scrollLeft,g=function(){var h;c.selrow=null;c.selarrrow=[];if(c.multiselect&&e&&0<e.length)for(h=0;h<e.length;h++)e[h]!=d&&b(a).jqGrid("setSelection",e[h],!1,null);
d&&b(a).jqGrid("setSelection",d,!1,null);a.grid.bDiv.scrollLeft=f;b(a).unbind(".selectionPreserver",g)};b(a).bind("jqGridGridComplete.selectionPreserver",g)}};if("TABLE"!=this.tagName.toUpperCase())alert("Element is not a table");else if(void 0!==document.documentMode&&5>=document.documentMode)alert("Grid can not be used in this ('quirks') mode!");else{b(this).empty().attr("tabindex","1");this.p=d;this.p.useProp=!!b.fn.prop;var e,i;if(0===this.p.colNames.length)for(e=0;e<this.p.colModel.length;e++)this.p.colNames[e]=
this.p.colModel[e].label||this.p.colModel[e].name;if(this.p.colNames.length!==this.p.colModel.length)alert(b.jgrid.errors.model);else{var j=b("<div class='ui-jqgrid-view'></div>"),l,k=b.browser.msie?!0:!1;a.p.direction=b.trim(a.p.direction.toLowerCase());-1==b.inArray(a.p.direction,["ltr","rtl"])&&(a.p.direction="ltr");i=a.p.direction;b(j).insertBefore(this);b(this).appendTo(j).removeClass("scroll");var m=b("<div class='ui-jqgrid ui-widget ui-widget-content ui-corner-all'></div>");b(m).insertBefore(j).attr({id:"gbox_"+
this.id,dir:i});b(j).appendTo(m).attr("id","gview_"+this.id);l=k&&6>=b.browser.version?'<iframe style="display:block;position:absolute;z-index:-1;filter:Alpha(Opacity=\'0\');" src="javascript:false;"></iframe>':"";b("<div class='ui-widget-overlay jqgrid-overlay' id='lui_"+this.id+"'></div>").append(l).insertBefore(j);b("<div class='loading ui-state-default ui-state-active' id='load_"+this.id+"'>"+this.p.loadtext+"</div>").insertBefore(j);b(this).attr({cellspacing:"0",cellpadding:"0",border:"0",role:"grid",
"aria-multiselectable":!!this.p.multiselect,"aria-labelledby":"gbox_"+this.id});var o=function(a,b){a=parseInt(a,10);return isNaN(a)?b?b:0:a},p=function(d,e,f,g,i,j){var K=a.p.colModel[d],k=K.align,y='style="',z=K.classes,B=K.name,q=[];k&&(y=y+("text-align:"+k+";"));K.hidden===true&&(y=y+"display:none;");if(e===0)y=y+("width: "+c.headers[d].width+"px;");else if(K.cellattr&&b.isFunction(K.cellattr))if((d=K.cellattr.call(a,i,f,g,K,j))&&typeof d==="string"){d=d.replace(/style/i,"style").replace(/title/i,
"title");if(d.indexOf("title")>-1)K.title=false;d.indexOf("class")>-1&&(z=void 0);q=d.split("style");if(q.length===2){q[1]=b.trim(q[1].replace("=",""));if(q[1].indexOf("'")===0||q[1].indexOf('"')===0)q[1]=q[1].substring(1);y=y+q[1].replace(/'/gi,'"')}else y=y+'"'}if(!q.length){q[0]="";y=y+'"'}y=y+((z!==void 0?' class="'+z+'"':"")+(K.title&&f?' title="'+b.jgrid.stripHtml(f)+'"':""));y=y+(' aria-describedby="'+a.p.id+"_"+B+'"');return y+q[0]},v=function(c){return c===void 0||c===null||c===""?"&#160;":
a.p.autoencode?b.jgrid.htmlEncode(c):c+""},u=function(c,d,e,f,g){var h=a.p.colModel[e];if(typeof h.formatter!=="undefined"){c={rowId:c,colModel:h,gid:a.p.id,pos:e};d=b.isFunction(h.formatter)?h.formatter.call(a,d,c,f,g):b.fmatter?b.fn.fmatter.call(a,h.formatter,d,c,f,g):v(d)}else d=v(d);return d},M=function(a,b,c,d,e){b=u(a,b,c,e,"add");return'<td role="gridcell" '+p(c,d,b,e,a,true)+">"+b+"</td>"},F=function(b,c,d){var e='<input role="checkbox" type="checkbox" id="jqg_'+a.p.id+"_"+b+'" class="cbox" name="jqg_'+
a.p.id+"_"+b+'"/>';return'<td role="gridcell" '+p(c,d,"",null,b,true)+">"+e+"</td>"},Z=function(a,b,c,d){c=(parseInt(c,10)-1)*parseInt(d,10)+1+b;return'<td role="gridcell" class="ui-state-default jqgrid-rownum" '+p(a,b,c,null,b,true)+">"+c+"</td>"},U=function(b){var c,d=[],e=0,f;for(f=0;f<a.p.colModel.length;f++){c=a.p.colModel[f];if(c.name!=="cb"&&c.name!=="subgrid"&&c.name!=="rn"){d[e]=b=="local"?c.name:b=="xml"||b==="xmlstring"?c.xmlmap||c.name:c.jsonmap||c.name;e++}}return d},V=function(c){var d=
a.p.remapColumns;if(!d||!d.length)d=b.map(a.p.colModel,function(a,b){return b});c&&(d=b.map(d,function(a){return a<c?null:a-c}));return d},N=function(a,c){var d;if(this.p.deepempty)b(this.rows).slice(1).remove();else{d=this.rows.length>0?this.rows[0]:null;b(this.firstChild).empty().append(d)}if(a&&this.p.scroll){b(this.grid.bDiv.firstChild).css({height:"auto"});b(this.grid.bDiv.firstChild.firstChild).css({height:0,display:"none"});if(this.grid.bDiv.scrollTop!==0)this.grid.bDiv.scrollTop=0}if(c===
true&&this.p.treeGrid){this.p.data=[];this.p._index={}}},S=function(){var c=a.p.data.length,d,e,f;d=a.p.rownumbers===true?1:0;e=a.p.multiselect===true?1:0;f=a.p.subGrid===true?1:0;d=a.p.keyIndex===false||a.p.loadonce===true?a.p.localReader.id:a.p.colModel[a.p.keyIndex+e+f+d].name;for(e=0;e<c;e++){f=b.jgrid.getAccessor(a.p.data[e],d);a.p._index[f]=e}},J=function(c,d,e,f,g){var h="-1",i="",j,d=d?"display:none;":"",e="ui-widget-content jqgrow ui-row-"+a.p.direction+e,f=b.isFunction(a.p.rowattr)?a.p.rowattr.call(a,
f,g):{};if(!b.isEmptyObject(f)){if(f.hasOwnProperty("id")){c=f.id;delete f.id}if(f.hasOwnProperty("tabindex")){h=f.tabindex;delete f.tabindex}if(f.hasOwnProperty("style")){d=d+f.style;delete f.style}if(f.hasOwnProperty("class")){e=e+(" "+f["class"]);delete f["class"]}try{delete f.role}catch(k){}for(j in f)f.hasOwnProperty(j)&&(i=i+(" "+j+"="+f[j]))}return'<tr role="row" id="'+c+'" tabindex="'+h+'" class="'+e+'"'+(d===""?"":' style="'+d+'"')+i+">"},$=function(c,d,e,f,g){var h=new Date,i=a.p.datatype!=
"local"&&a.p.loadonce||a.p.datatype=="xmlstring",j=a.p.xmlReader,k=a.p.datatype=="local"?"local":"xml";if(i){a.p.data=[];a.p._index={};a.p.localReader.id="_id_"}a.p.reccount=0;if(b.isXMLDoc(c)){if(a.p.treeANode===-1&&!a.p.scroll){N.call(a,false,true);e=1}else e=e>1?e:1;var z,B,q=0,l,s=a.p.multiselect===true?1:0,P=a.p.subGrid===true?1:0,m=a.p.rownumbers===true?1:0,o,p=[],u,n={},r,w,C=[],v=a.p.altRows===true?" "+a.p.altclass:"",A;j.repeatitems||(p=U(k));o=a.p.keyIndex===false?b.isFunction(j.id)?j.id.call(a,
c):j.id:a.p.keyIndex;if(p.length>0&&!isNaN(o)){a.p.remapColumns&&a.p.remapColumns.length&&(o=b.inArray(o,a.p.remapColumns));o=p[o]}k=(o+"").indexOf("[")===-1?p.length?function(a,c){return b(o,a).text()||c}:function(a,c){return b(j.cell,a).eq(o).text()||c}:function(a,b){return a.getAttribute(o.replace(/[\[\]]/g,""))||b};a.p.userData={};a.p.page=b.jgrid.getXmlData(c,j.page)||0;a.p.lastpage=b.jgrid.getXmlData(c,j.total);if(a.p.lastpage===void 0)a.p.lastpage=1;a.p.records=b.jgrid.getXmlData(c,j.records)||
0;b.isFunction(j.userdata)?a.p.userData=j.userdata.call(a,c)||{}:b.jgrid.getXmlData(c,j.userdata,true).each(function(){a.p.userData[this.getAttribute("name")]=b(this).text()});c=b.jgrid.getXmlData(c,j.root,true);(c=b.jgrid.getXmlData(c,j.row,true))||(c=[]);var t=c.length,H=0,Q=[],x=parseInt(a.p.rowNum,10);if(t>0&&a.p.page<=0)a.p.page=1;if(c&&t){var D=a.p.scroll?b.jgrid.randId():1;g&&(x=x*(g+1));for(var g=b.isFunction(a.p.afterInsertRow),E=a.p.grouping&&a.p.groupingView.groupCollapse===true;H<t;){r=
c[H];w=k(r,D+H);w=a.p.idPrefix+w;z=e===0?0:e+1;A=(z+H)%2==1?v:"";var I=C.length;C.push("");m&&C.push(Z(0,H,a.p.page,a.p.rowNum));s&&C.push(F(w,m,H));P&&C.push(b(a).jqGrid("addSubGridCell",s+m,H+e));if(j.repeatitems){u||(u=V(s+P+m));var L=b.jgrid.getXmlData(r,j.cell,true);b.each(u,function(b){var c=L[this];if(!c)return false;l=c.textContent||c.text;n[a.p.colModel[b+s+P+m].name]=l;C.push(M(w,l,b+s+P+m,H+e,r))})}else for(z=0;z<p.length;z++){l=b.jgrid.getXmlData(r,p[z]);n[a.p.colModel[z+s+P+m].name]=
l;C.push(M(w,l,z+s+P+m,H+e,r))}C[I]=J(w,E,A,n,r);C.push("</tr>");if(a.p.grouping){Q=b(a).jqGrid("groupingPrepare",C,Q,n,H);C=[]}if(i||a.p.treeGrid===true){n._id_=w;a.p.data.push(n);a.p._index[w]=a.p.data.length-1}if(a.p.gridview===false){b("tbody:first",d).append(C.join(""));b(a).triggerHandler("jqGridAfterInsertRow",[w,n,r]);g&&a.p.afterInsertRow.call(a,w,n,r);C=[]}n={};q++;H++;if(q==x)break}}if(a.p.gridview===true){B=a.p.treeANode>-1?a.p.treeANode:0;if(a.p.grouping){b(a).jqGrid("groupingRender",
Q,a.p.colModel.length);Q=null}else a.p.treeGrid===true&&B>0?b(a.rows[B]).after(C.join("")):b("tbody:first",d).append(C.join(""))}if(a.p.subGrid===true)try{b(a).jqGrid("addSubGrid",s+m)}catch(R){}a.p.totaltime=new Date-h;if(q>0&&a.p.records===0)a.p.records=t;C=null;if(a.p.treeGrid===true)try{b(a).jqGrid("setTreeNode",B+1,q+B+1)}catch(S){}if(!a.p.treeGrid&&!a.p.scroll)a.grid.bDiv.scrollTop=0;a.p.reccount=q;a.p.treeANode=-1;a.p.userDataOnFooter&&b(a).jqGrid("footerData","set",a.p.userData,true);if(i){a.p.records=
t;a.p.lastpage=Math.ceil(t/x)}f||a.updatepager(false,true);if(i)for(;q<t;){r=c[q];w=k(r,q+D);w=a.p.idPrefix+w;if(j.repeatitems){u||(u=V(s+P+m));var O=b.jgrid.getXmlData(r,j.cell,true);b.each(u,function(b){var c=O[this];if(!c)return false;l=c.textContent||c.text;n[a.p.colModel[b+s+P+m].name]=l})}else for(z=0;z<p.length;z++){l=b.jgrid.getXmlData(r,p[z]);n[a.p.colModel[z+s+P+m].name]=l}n._id_=w;a.p.data.push(n);a.p._index[w]=a.p.data.length-1;n={};q++}}},aa=function(c,d,e,f,g){d=new Date;if(c){if(a.p.treeANode===
-1&&!a.p.scroll){N.call(a,false,true);e=1}else e=e>1?e:1;var h,i,j=a.p.datatype!="local"&&a.p.loadonce||a.p.datatype=="jsonstring";if(j){a.p.data=[];a.p._index={};a.p.localReader.id="_id_"}a.p.reccount=0;if(a.p.datatype=="local"){h=a.p.localReader;i="local"}else{h=a.p.jsonReader;i="json"}var k=0,l,B,q=[],m,s=a.p.multiselect?1:0,o=a.p.subGrid?1:0,p=a.p.rownumbers===true?1:0,n,u,t={},v,r,w=[],C=a.p.altRows===true?" "+a.p.altclass:"",A;a.p.page=b.jgrid.getAccessor(c,h.page)||0;n=b.jgrid.getAccessor(c,
h.total);a.p.lastpage=n===void 0?1:n;a.p.records=b.jgrid.getAccessor(c,h.records)||0;a.p.userData=b.jgrid.getAccessor(c,h.userdata)||{};h.repeatitems||(m=q=U(i));i=a.p.keyIndex===false?b.isFunction(h.id)?h.id.call(a,c):h.id:a.p.keyIndex;if(q.length>0&&!isNaN(i)){a.p.remapColumns&&a.p.remapColumns.length&&(i=b.inArray(i,a.p.remapColumns));i=q[i]}(u=b.jgrid.getAccessor(c,h.root))||(u=[]);n=u.length;c=0;if(n>0&&a.p.page<=0)a.p.page=1;var x=parseInt(a.p.rowNum,10),D=a.p.scroll?b.jgrid.randId():1;g&&(x=
x*(g+1));for(var H=b.isFunction(a.p.afterInsertRow),Q=[],E=a.p.grouping&&a.p.groupingView.groupCollapse===true;c<n;){g=u[c];r=b.jgrid.getAccessor(g,i);if(r===void 0){r=D+c;if(q.length===0&&h.cell){l=b.jgrid.getAccessor(g,h.cell);r=l!==void 0?l[i]||r:r}}r=a.p.idPrefix+r;l=e===1?0:e;A=(l+c)%2==1?C:"";var I=w.length;w.push("");p&&w.push(Z(0,c,a.p.page,a.p.rowNum));s&&w.push(F(r,p,c));o&&w.push(b(a).jqGrid("addSubGridCell",s+p,c+e));if(h.repeatitems){h.cell&&(g=b.jgrid.getAccessor(g,h.cell));m||(m=V(s+
o+p))}for(B=0;B<m.length;B++){l=b.jgrid.getAccessor(g,m[B]);w.push(M(r,l,B+s+o+p,c+e,g));t[a.p.colModel[B+s+o+p].name]=l}w[I]=J(r,E,A,t,g);w.push("</tr>");if(a.p.grouping){Q=b(a).jqGrid("groupingPrepare",w,Q,t,c);w=[]}if(j||a.p.treeGrid===true){t._id_=r;a.p.data.push(t);a.p._index[r]=a.p.data.length-1}if(a.p.gridview===false){b("#"+b.jgrid.jqID(a.p.id)+" tbody:first").append(w.join(""));b(a).triggerHandler("jqGridAfterInsertRow",[r,t,g]);H&&a.p.afterInsertRow.call(a,r,t,g);w=[]}t={};k++;c++;if(k==
x)break}if(a.p.gridview===true){v=a.p.treeANode>-1?a.p.treeANode:0;a.p.grouping?b(a).jqGrid("groupingRender",Q,a.p.colModel.length):a.p.treeGrid===true&&v>0?b(a.rows[v]).after(w.join("")):b("#"+b.jgrid.jqID(a.p.id)+" tbody:first").append(w.join(""))}if(a.p.subGrid===true)try{b(a).jqGrid("addSubGrid",s+p)}catch(L){}a.p.totaltime=new Date-d;if(k>0&&a.p.records===0)a.p.records=n;if(a.p.treeGrid===true)try{b(a).jqGrid("setTreeNode",v+1,k+v+1)}catch(O){}if(!a.p.treeGrid&&!a.p.scroll)a.grid.bDiv.scrollTop=
0;a.p.reccount=k;a.p.treeANode=-1;a.p.userDataOnFooter&&b(a).jqGrid("footerData","set",a.p.userData,true);if(j){a.p.records=n;a.p.lastpage=Math.ceil(n/x)}f||a.updatepager(false,true);if(j)for(;k<n&&u[k];){g=u[k];r=b.jgrid.getAccessor(g,i);if(r===void 0){r=D+k;q.length===0&&h.cell&&(r=b.jgrid.getAccessor(g,h.cell)[i]||r)}if(g){r=a.p.idPrefix+r;if(h.repeatitems){h.cell&&(g=b.jgrid.getAccessor(g,h.cell));m||(m=V(s+o+p))}for(B=0;B<m.length;B++){l=b.jgrid.getAccessor(g,m[B]);t[a.p.colModel[B+s+o+p].name]=
l}t._id_=r;a.p.data.push(t);a.p._index[r]=a.p.data.length-1;t={}}k++}}},ma=function(){function c(d){var e=0,g,h,i,j,T;if(d.groups!==void 0){(h=d.groups.length&&d.groupOp.toString().toUpperCase()==="OR")&&s.orBegin();for(g=0;g<d.groups.length;g++){e>0&&h&&s.or();try{c(d.groups[g])}catch(k){alert(k)}e++}h&&s.orEnd()}if(d.rules!==void 0){if(e>0){h=s.select();s=b.jgrid.from(h);a.p.ignoreCase&&(s=s.ignoreCase())}try{(i=d.rules.length&&d.groupOp.toString().toUpperCase()==="OR")&&s.orBegin();for(g=0;g<d.rules.length;g++){T=
d.rules[g];j=d.groupOp.toString().toUpperCase();if(o[T.op]&&T.field){e>0&&j&&j==="OR"&&(s=s.or());s=o[T.op](s,j)(T.field,T.data,f[T.field])}e++}i&&s.orEnd()}catch(na){alert(na)}}}var d,e=false,f={},g=[],h=[],i,j,k;if(b.isArray(a.p.data)){var l=a.p.grouping?a.p.groupingView:false,m,q;b.each(a.p.colModel,function(){j=this.sorttype||"text";if(j=="date"||j=="datetime"){if(this.formatter&&typeof this.formatter==="string"&&this.formatter=="date"){i=this.formatoptions&&this.formatoptions.srcformat?this.formatoptions.srcformat:
b.jgrid.formatter.date.srcformat;k=this.formatoptions&&this.formatoptions.newformat?this.formatoptions.newformat:b.jgrid.formatter.date.newformat}else i=k=this.datefmt||"Y-m-d";f[this.name]={stype:j,srcfmt:i,newfmt:k}}else f[this.name]={stype:j,srcfmt:"",newfmt:""};if(a.p.grouping){q=0;for(m=l.groupField.length;q<m;q++)if(this.name==l.groupField[q]){var c=this.name;if(typeof this.index!="undefined")c=this.index;g[q]=f[c];h[q]=c}}if(!e&&(this.index==a.p.sortname||this.name==a.p.sortname)){d=this.name;
e=true}});if(a.p.treeGrid)b(a).jqGrid("SortTree",d,a.p.sortorder,f[d].stype,f[d].srcfmt);else{var o={eq:function(a){return a.equals},ne:function(a){return a.notEquals},lt:function(a){return a.less},le:function(a){return a.lessOrEquals},gt:function(a){return a.greater},ge:function(a){return a.greaterOrEquals},cn:function(a){return a.contains},nc:function(a,b){return b==="OR"?a.orNot().contains:a.andNot().contains},bw:function(a){return a.startsWith},bn:function(a,b){return b==="OR"?a.orNot().startsWith:
a.andNot().startsWith},en:function(a,b){return b==="OR"?a.orNot().endsWith:a.andNot().endsWith},ew:function(a){return a.endsWith},ni:function(a,b){return b==="OR"?a.orNot().equals:a.andNot().equals},"in":function(a){return a.equals},nu:function(a){return a.isNull},nn:function(a,b){return b==="OR"?a.orNot().isNull:a.andNot().isNull}},s=b.jgrid.from(a.p.data);a.p.ignoreCase&&(s=s.ignoreCase());if(a.p.search===true){var n=a.p.postData.filters;if(n){typeof n=="string"&&(n=b.jgrid.parse(n));c(n)}else try{s=
o[a.p.postData.searchOper](s)(a.p.postData.searchField,a.p.postData.searchString,f[a.p.postData.searchField])}catch(p){}}if(a.p.grouping)for(q=0;q<m;q++)s.orderBy(h[q],l.groupOrder[q],g[q].stype,g[q].srcfmt);d&&a.p.sortorder&&e&&(a.p.sortorder.toUpperCase()=="DESC"?s.orderBy(a.p.sortname,"d",f[d].stype,f[d].srcfmt):s.orderBy(a.p.sortname,"a",f[d].stype,f[d].srcfmt));var n=s.select(),u=parseInt(a.p.rowNum,10),t=n.length,v=parseInt(a.p.page,10),x=Math.ceil(t/u),r={},n=n.slice((v-1)*u,v*u),f=s=null;
r[a.p.localReader.total]=x;r[a.p.localReader.page]=v;r[a.p.localReader.records]=t;r[a.p.localReader.root]=n;r[a.p.localReader.userdata]=a.p.userData;n=null;return r}}},ca=function(){a.grid.hDiv.loading=true;if(!a.p.hiddengrid)switch(a.p.loadui){case "enable":b("#load_"+b.jgrid.jqID(a.p.id)).show();break;case "block":b("#lui_"+b.jgrid.jqID(a.p.id)).show();b("#load_"+b.jgrid.jqID(a.p.id)).show()}},O=function(){a.grid.hDiv.loading=false;switch(a.p.loadui){case "enable":b("#load_"+b.jgrid.jqID(a.p.id)).hide();
break;case "block":b("#lui_"+b.jgrid.jqID(a.p.id)).hide();b("#load_"+b.jgrid.jqID(a.p.id)).hide()}},I=function(c){if(!a.grid.hDiv.loading){var d=a.p.scroll&&c===false,e={},f,g=a.p.prmNames;if(a.p.page<=0)a.p.page=1;if(g.search!==null)e[g.search]=a.p.search;g.nd!==null&&(e[g.nd]=(new Date).getTime());if(g.rows!==null)e[g.rows]=a.p.rowNum;if(g.page!==null)e[g.page]=a.p.page;if(g.sort!==null)e[g.sort]=a.p.sortname;if(g.order!==null)e[g.order]=a.p.sortorder;if(a.p.rowTotal!==null&&g.totalrows!==null)e[g.totalrows]=
a.p.rowTotal;var h=b.isFunction(a.p.loadComplete),i=h?a.p.loadComplete:null,j=0,c=c||1;if(c>1)if(g.npage!==null){e[g.npage]=c;j=c-1;c=1}else i=function(b){a.p.page++;a.grid.hDiv.loading=false;h&&a.p.loadComplete.call(a,b);I(c-1)};else g.npage!==null&&delete a.p.postData[g.npage];if(a.p.grouping){b(a).jqGrid("groupingSetup");var k=a.p.groupingView,l,m="";for(l=0;l<k.groupField.length;l++)m=m+(k.groupField[l]+" "+k.groupOrder[l]+", ");e[g.sort]=m+e[g.sort]}b.extend(a.p.postData,e);var q=!a.p.scroll?
1:a.rows.length-1,e=b(a).triggerHandler("jqGridBeforeRequest");if(!(e===false||e==="stop"))if(b.isFunction(a.p.datatype))a.p.datatype.call(a,a.p.postData,"load_"+a.p.id);else{if(b.isFunction(a.p.beforeRequest)){e=a.p.beforeRequest.call(a);e===void 0&&(e=true);if(e===false)return}f=a.p.datatype.toLowerCase();switch(f){case "json":case "jsonp":case "xml":case "script":b.ajax(b.extend({url:a.p.url,type:a.p.mtype,dataType:f,data:b.isFunction(a.p.serializeGridData)?a.p.serializeGridData.call(a,a.p.postData):
a.p.postData,success:function(e,g,h){if(b.isFunction(a.p.beforeProcessing)&&a.p.beforeProcessing.call(a,e,g,h)===false)O();else{f==="xml"?$(e,a.grid.bDiv,q,c>1,j):aa(e,a.grid.bDiv,q,c>1,j);b(a).triggerHandler("jqGridLoadComplete",[e]);i&&i.call(a,e);b(a).triggerHandler("jqGridAfterLoadComplete",[e]);d&&a.grid.populateVisible();if(a.p.loadonce||a.p.treeGrid)a.p.datatype="local";c===1&&O()}},error:function(d,e,f){b.isFunction(a.p.loadError)&&a.p.loadError.call(a,d,e,f);c===1&&O()},beforeSend:function(c,
d){var e=true;b.isFunction(a.p.loadBeforeSend)&&(e=a.p.loadBeforeSend.call(a,c,d));e===void 0&&(e=true);if(e===false)return false;ca()}},b.jgrid.ajaxOptions,a.p.ajaxGridOptions));break;case "xmlstring":ca();e=b.jgrid.stringToDoc(a.p.datastr);$(e,a.grid.bDiv);b(a).triggerHandler("jqGridLoadComplete",[e]);h&&a.p.loadComplete.call(a,e);b(a).triggerHandler("jqGridAfterLoadComplete",[e]);a.p.datatype="local";a.p.datastr=null;O();break;case "jsonstring":ca();e=typeof a.p.datastr=="string"?b.jgrid.parse(a.p.datastr):
a.p.datastr;aa(e,a.grid.bDiv);b(a).triggerHandler("jqGridLoadComplete",[e]);h&&a.p.loadComplete.call(a,e);b(a).triggerHandler("jqGridAfterLoadComplete",[e]);a.p.datatype="local";a.p.datastr=null;O();break;case "local":case "clientside":ca();a.p.datatype="local";e=ma();aa(e,a.grid.bDiv,q,c>1,j);b(a).triggerHandler("jqGridLoadComplete",[e]);i&&i.call(a,e);b(a).triggerHandler("jqGridAfterLoadComplete",[e]);d&&a.grid.populateVisible();O()}}}},da=function(c){b("#cb_"+b.jgrid.jqID(a.p.id),a.grid.hDiv)[a.p.useProp?
"prop":"attr"]("checked",c);if(a.p.frozenColumns&&a.p.id+"_frozen")b("#cb_"+b.jgrid.jqID(a.p.id),a.grid.fhDiv)[a.p.useProp?"prop":"attr"]("checked",c)};l=function(c,e){var d="",f="<table cellspacing='0' cellpadding='0' border='0' style='table-layout:auto;' class='ui-pg-table'><tbody><tr>",g="",h,j,k,l,m=function(c){var e;b.isFunction(a.p.onPaging)&&(e=a.p.onPaging.call(a,c));a.p.selrow=null;if(a.p.multiselect){a.p.selarrrow=[];da(false)}a.p.savedRow=[];return e=="stop"?false:true},c=c.substr(1),e=
e+("_"+c);h="pg_"+c;j=c+"_left";k=c+"_center";l=c+"_right";b("#"+b.jgrid.jqID(c)).append("<div id='"+h+"' class='ui-pager-control' role='group'><table cellspacing='0' cellpadding='0' border='0' class='ui-pg-table' style='width:100%;table-layout:fixed;height:100%;' role='row'><tbody><tr><td id='"+j+"' align='left'></td><td id='"+k+"' align='center' style='white-space:pre;'></td><td id='"+l+"' align='right'></td></tr></tbody></table></div>").attr("dir","ltr");if(a.p.rowList.length>0){g="<td dir='"+
i+"'>";g=g+"<select class='ui-pg-selbox' role='listbox'>";for(j=0;j<a.p.rowList.length;j++)g=g+('<option role="option" value="'+a.p.rowList[j]+'"'+(a.p.rowNum==a.p.rowList[j]?' selected="selected"':"")+">"+a.p.rowList[j]+"</option>");g=g+"</select></td>"}i=="rtl"&&(f=f+g);a.p.pginput===true&&(d="<td dir='"+i+"'>"+b.jgrid.format(a.p.pgtext||"","<input class='ui-pg-input' type='text' size='2' maxlength='7' value='0' role='textbox'/>","<span id='sp_1_"+b.jgrid.jqID(c)+"'></span>")+"</td>");if(a.p.pgbuttons===
true){j=["first"+e,"prev"+e,"next"+e,"last"+e];i=="rtl"&&j.reverse();f=f+("<td id='"+j[0]+"' class='ui-pg-button ui-corner-all'><span class='ui-icon ui-icon-seek-first'></span></td>");f=f+("<td id='"+j[1]+"' class='ui-pg-button ui-corner-all'><span class='ui-icon ui-icon-seek-prev'></span></td>");f=f+(d!==""?"<td class='ui-pg-button ui-state-disabled' style='width:4px;'><span class='ui-separator'></span></td>"+d+"<td class='ui-pg-button ui-state-disabled' style='width:4px;'><span class='ui-separator'></span></td>":
"")+("<td id='"+j[2]+"' class='ui-pg-button ui-corner-all'><span class='ui-icon ui-icon-seek-next'></span></td>");f=f+("<td id='"+j[3]+"' class='ui-pg-button ui-corner-all'><span class='ui-icon ui-icon-seek-end'></span></td>")}else d!==""&&(f=f+d);i=="ltr"&&(f=f+g);f=f+"</tr></tbody></table>";a.p.viewrecords===true&&b("td#"+c+"_"+a.p.recordpos,"#"+h).append("<div dir='"+i+"' style='text-align:"+a.p.recordpos+"' class='ui-paging-info'></div>");b("td#"+c+"_"+a.p.pagerpos,"#"+h).append(f);g=b(".ui-jqgrid").css("font-size")||
"11px";b(document.body).append("<div id='testpg' class='ui-jqgrid ui-widget ui-widget-content' style='font-size:"+g+";visibility:hidden;' ></div>");f=b(f).clone().appendTo("#testpg").width();b("#testpg").remove();if(f>0){d!==""&&(f=f+50);b("td#"+c+"_"+a.p.pagerpos,"#"+h).width(f)}a.p._nvtd=[];a.p._nvtd[0]=f?Math.floor((a.p.width-f)/2):Math.floor(a.p.width/3);a.p._nvtd[1]=0;f=null;b(".ui-pg-selbox","#"+h).bind("change",function(){a.p.page=Math.round(a.p.rowNum*(a.p.page-1)/this.value-0.5)+1;a.p.rowNum=
this.value;a.p.pager&&b(".ui-pg-selbox",a.p.pager).val(this.value);a.p.toppager&&b(".ui-pg-selbox",a.p.toppager).val(this.value);if(!m("records"))return false;I();return false});if(a.p.pgbuttons===true){b(".ui-pg-button","#"+h).hover(function(){if(b(this).hasClass("ui-state-disabled"))this.style.cursor="default";else{b(this).addClass("ui-state-hover");this.style.cursor="pointer"}},function(){if(!b(this).hasClass("ui-state-disabled")){b(this).removeClass("ui-state-hover");this.style.cursor="default"}});
b("#first"+b.jgrid.jqID(e)+", #prev"+b.jgrid.jqID(e)+", #next"+b.jgrid.jqID(e)+", #last"+b.jgrid.jqID(e)).click(function(){var b=o(a.p.page,1),c=o(a.p.lastpage,1),d=false,f=true,g=true,h=true,i=true;if(c===0||c===1)i=h=g=f=false;else if(c>1&&b>=1)if(b===1)g=f=false;else{if(b===c)i=h=false}else if(c>1&&b===0){i=h=false;b=c-1}if(this.id==="first"+e&&f){a.p.page=1;d=true}if(this.id==="prev"+e&&g){a.p.page=b-1;d=true}if(this.id==="next"+e&&h){a.p.page=b+1;d=true}if(this.id==="last"+e&&i){a.p.page=c;d=
true}if(d){if(!m(this.id))return false;I()}return false})}a.p.pginput===true&&b("input.ui-pg-input","#"+h).keypress(function(c){if((c.charCode?c.charCode:c.keyCode?c.keyCode:0)==13){a.p.page=b(this).val()>0?b(this).val():a.p.page;if(!m("user"))return false;I();return false}return this})};var ja=function(c,e,d,f){if(a.p.colModel[e].sortable&&!(a.p.savedRow.length>0)){if(!d){if(a.p.lastsort==e)if(a.p.sortorder=="asc")a.p.sortorder="desc";else{if(a.p.sortorder=="desc")a.p.sortorder="asc"}else a.p.sortorder=
a.p.colModel[e].firstsortorder||"asc";a.p.page=1}if(f){if(a.p.lastsort==e&&a.p.sortorder==f&&!d)return;a.p.sortorder=f}d=a.grid.headers[a.p.lastsort].el;f=a.grid.headers[e].el;b("span.ui-grid-ico-sort",d).addClass("ui-state-disabled");b(d).attr("aria-selected","false");b("span.ui-icon-"+a.p.sortorder,f).removeClass("ui-state-disabled");b(f).attr("aria-selected","true");if(!a.p.viewsortcols[0]&&a.p.lastsort!=e){b("span.s-ico",d).hide();b("span.s-ico",f).show()}c=c.substring(5+a.p.id.length+1);a.p.sortname=
a.p.colModel[e].index||c;d=a.p.sortorder;if(b(a).triggerHandler("jqGridSortCol",[c,e,d])==="stop")a.p.lastsort=e;else if(b.isFunction(a.p.onSortCol)&&a.p.onSortCol.call(a,c,e,d)=="stop")a.p.lastsort=e;else{if(a.p.datatype=="local")a.p.deselectAfterSort&&b(a).jqGrid("resetSelection");else{a.p.selrow=null;a.p.multiselect&&da(false);a.p.selarrrow=[];a.p.savedRow=[]}if(a.p.scroll){d=a.grid.bDiv.scrollLeft;N.call(a,true,false);a.grid.hDiv.scrollLeft=d}a.p.subGrid&&a.p.datatype=="local"&&b("td.sgexpanded",
"#"+b.jgrid.jqID(a.p.id)).each(function(){b(this).trigger("click")});I();a.p.lastsort=e;if(a.p.sortname!=c&&e)a.p.lastsort=e}}},oa=function(c){var e,d={},f=b.jgrid.cellWidth()?0:a.p.cellLayout;for(e=d[0]=d[1]=d[2]=0;e<=c;e++)a.p.colModel[e].hidden===false&&(d[0]=d[0]+(a.p.colModel[e].width+f));a.p.direction=="rtl"&&(d[0]=a.p.width-d[0]);d[0]=d[0]-a.grid.bDiv.scrollLeft;b(a.grid.cDiv).is(":visible")&&(d[1]=d[1]+(b(a.grid.cDiv).height()+parseInt(b(a.grid.cDiv).css("padding-top"),10)+parseInt(b(a.grid.cDiv).css("padding-bottom"),
10)));if(a.p.toolbar[0]===true&&(a.p.toolbar[1]=="top"||a.p.toolbar[1]=="both"))d[1]=d[1]+(b(a.grid.uDiv).height()+parseInt(b(a.grid.uDiv).css("border-top-width"),10)+parseInt(b(a.grid.uDiv).css("border-bottom-width"),10));a.p.toppager&&(d[1]=d[1]+(b(a.grid.topDiv).height()+parseInt(b(a.grid.topDiv).css("border-bottom-width"),10)));d[2]=d[2]+(b(a.grid.bDiv).height()+b(a.grid.hDiv).height());return d},ka=function(c){var d,e=a.grid.headers,f=b.jgrid.getCellIndex(c);for(d=0;d<e.length;d++)if(c===e[d].el){f=
d;break}return f};this.p.id=this.id;-1==b.inArray(a.p.multikey,["shiftKey","altKey","ctrlKey"])&&(a.p.multikey=!1);a.p.keyIndex=!1;for(e=0;e<a.p.colModel.length;e++)a.p.colModel[e]=b.extend(!0,{},a.p.cmTemplate,a.p.colModel[e].template||{},a.p.colModel[e]),!1===a.p.keyIndex&&!0===a.p.colModel[e].key&&(a.p.keyIndex=e);a.p.sortorder=a.p.sortorder.toLowerCase();!0===a.p.grouping&&(a.p.scroll=!1,a.p.rownumbers=!1,a.p.treeGrid=!1,a.p.gridview=!0);if(!0===this.p.treeGrid){try{b(this).jqGrid("setTreeGrid")}catch(qa){}"local"!=
a.p.datatype&&(a.p.localReader={id:"_id_"})}if(this.p.subGrid)try{b(a).jqGrid("setSubGrid")}catch(ra){}this.p.multiselect&&(this.p.colNames.unshift("<input role='checkbox' id='cb_"+this.p.id+"' class='cbox' type='checkbox'/>"),this.p.colModel.unshift({name:"cb",width:b.jgrid.cellWidth()?a.p.multiselectWidth+a.p.cellLayout:a.p.multiselectWidth,sortable:!1,resizable:!1,hidedlg:!0,search:!1,align:"center",fixed:!0}));this.p.rownumbers&&(this.p.colNames.unshift(""),this.p.colModel.unshift({name:"rn",
width:a.p.rownumWidth,sortable:!1,resizable:!1,hidedlg:!0,search:!1,align:"center",fixed:!0}));a.p.xmlReader=b.extend(!0,{root:"rows",row:"row",page:"rows>page",total:"rows>total",records:"rows>records",repeatitems:!0,cell:"cell",id:"[id]",userdata:"userdata",subgrid:{root:"rows",row:"row",repeatitems:!0,cell:"cell"}},a.p.xmlReader);a.p.jsonReader=b.extend(!0,{root:"rows",page:"page",total:"total",records:"records",repeatitems:!0,cell:"cell",id:"id",userdata:"userdata",subgrid:{root:"rows",repeatitems:!0,
cell:"cell"}},a.p.jsonReader);a.p.localReader=b.extend(!0,{root:"rows",page:"page",total:"total",records:"records",repeatitems:!1,cell:"cell",id:"id",userdata:"userdata",subgrid:{root:"rows",repeatitems:!0,cell:"cell"}},a.p.localReader);a.p.scroll&&(a.p.pgbuttons=!1,a.p.pginput=!1,a.p.rowList=[]);a.p.data.length&&S();var x="<thead><tr class='ui-jqgrid-labels' role='rowheader'>",la,L,ea,ba,fa,A,n,W;L=W="";if(!0===a.p.shrinkToFit&&!0===a.p.forceFit)for(e=a.p.colModel.length-1;0<=e;e--)if(!a.p.colModel[e].hidden){a.p.colModel[e].resizable=
!1;break}"horizontal"==a.p.viewsortcols[1]&&(W=" ui-i-asc",L=" ui-i-desc");la=k?"class='ui-th-div-ie'":"";W="<span class='s-ico' style='display:none'><span sort='asc' class='ui-grid-ico-sort ui-icon-asc"+W+" ui-state-disabled ui-icon ui-icon-triangle-1-n ui-sort-"+i+"'></span>"+("<span sort='desc' class='ui-grid-ico-sort ui-icon-desc"+L+" ui-state-disabled ui-icon ui-icon-triangle-1-s ui-sort-"+i+"'></span></span>");for(e=0;e<this.p.colNames.length;e++)L=a.p.headertitles?' title="'+b.jgrid.stripHtml(a.p.colNames[e])+
'"':"",x+="<th id='"+a.p.id+"_"+a.p.colModel[e].name+"' role='columnheader' class='ui-state-default ui-th-column ui-th-"+i+"'"+L+">",L=a.p.colModel[e].index||a.p.colModel[e].name,x+="<div id='jqgh_"+a.p.id+"_"+a.p.colModel[e].name+"' "+la+">"+a.p.colNames[e],a.p.colModel[e].width=a.p.colModel[e].width?parseInt(a.p.colModel[e].width,10):150,"boolean"!==typeof a.p.colModel[e].title&&(a.p.colModel[e].title=!0),L==a.p.sortname&&(a.p.lastsort=e),x+=W+"</div></th>";W=null;b(this).append(x+"</tr></thead>");
b("thead tr:first th",this).hover(function(){b(this).addClass("ui-state-hover")},function(){b(this).removeClass("ui-state-hover")});if(this.p.multiselect){var ga=[],X;b("#cb_"+b.jgrid.jqID(a.p.id),this).bind("click",function(){a.p.selarrrow=[];var c=a.p.frozenColumns===true?a.p.id+"_frozen":"";if(this.checked){b(a.rows).each(function(d){if(d>0&&!b(this).hasClass("ui-subgrid")&&!b(this).hasClass("jqgroup")&&!b(this).hasClass("ui-state-disabled")){b("#jqg_"+b.jgrid.jqID(a.p.id)+"_"+b.jgrid.jqID(this.id))[a.p.useProp?
"prop":"attr"]("checked",true);b(this).addClass("ui-state-highlight").attr("aria-selected","true");a.p.selarrrow.push(this.id);a.p.selrow=this.id;if(c){b("#jqg_"+b.jgrid.jqID(a.p.id)+"_"+b.jgrid.jqID(this.id),a.grid.fbDiv)[a.p.useProp?"prop":"attr"]("checked",true);b("#"+b.jgrid.jqID(this.id),a.grid.fbDiv).addClass("ui-state-highlight")}}});X=true;ga=[]}else{b(a.rows).each(function(d){if(d>0&&!b(this).hasClass("ui-subgrid")&&!b(this).hasClass("ui-state-disabled")){b("#jqg_"+b.jgrid.jqID(a.p.id)+"_"+
b.jgrid.jqID(this.id))[a.p.useProp?"prop":"attr"]("checked",false);b(this).removeClass("ui-state-highlight").attr("aria-selected","false");ga.push(this.id);if(c){b("#jqg_"+b.jgrid.jqID(a.p.id)+"_"+b.jgrid.jqID(this.id),a.grid.fbDiv)[a.p.useProp?"prop":"attr"]("checked",false);b("#"+b.jgrid.jqID(this.id),a.grid.fbDiv).removeClass("ui-state-highlight")}}});a.p.selrow=null;X=false}b(a).triggerHandler("jqGridSelectAll",[X?a.p.selarrrow:ga,X]);b.isFunction(a.p.onSelectAll)&&a.p.onSelectAll.call(a,X?a.p.selarrrow:
ga,X)})}!0===a.p.autowidth&&(x=b(m).innerWidth(),a.p.width=0<x?x:"nw");(function(){var d=0,e=b.jgrid.cellWidth()?0:o(a.p.cellLayout,0),f=0,g,i=o(a.p.scrollOffset,0),j,k=false,l,m=0,n=0,p;b.each(a.p.colModel,function(){if(typeof this.hidden==="undefined")this.hidden=false;this.widthOrg=j=o(this.width,0);if(this.hidden===false){d=d+(j+e);this.fixed?m=m+(j+e):f++;n++}});if(isNaN(a.p.width))a.p.width=d+(a.p.shrinkToFit===false&&!isNaN(a.p.height)?i:0);c.width=a.p.width;a.p.tblwidth=d;if(a.p.shrinkToFit===
false&&a.p.forceFit===true)a.p.forceFit=false;if(a.p.shrinkToFit===true&&f>0){l=c.width-e*f-m;if(!isNaN(a.p.height)){l=l-i;k=true}d=0;b.each(a.p.colModel,function(b){if(this.hidden===false&&!this.fixed){this.width=j=Math.round(l*this.width/(a.p.tblwidth-e*f-m));d=d+j;g=b}});p=0;k?c.width-m-(d+e*f)!==i&&(p=c.width-m-(d+e*f)-i):!k&&Math.abs(c.width-m-(d+e*f))!==1&&(p=c.width-m-(d+e*f));a.p.colModel[g].width=a.p.colModel[g].width+p;a.p.tblwidth=d+p+e*f+m;if(a.p.tblwidth>a.p.width){a.p.colModel[g].width=
a.p.colModel[g].width-(a.p.tblwidth-parseInt(a.p.width,10));a.p.tblwidth=a.p.width}}})();b(m).css("width",c.width+"px").append("<div class='ui-jqgrid-resize-mark' id='rs_m"+a.p.id+"'>&#160;</div>");b(j).css("width",c.width+"px");var x=b("thead:first",a).get(0),R="";a.p.footerrow&&(R+="<table role='grid' style='width:"+a.p.tblwidth+"px' class='ui-jqgrid-ftable' cellspacing='0' cellpadding='0' border='0'><tbody><tr role='row' class='ui-widget-content footrow footrow-"+i+"'>");var j=b("tr:first",x),
Y="<tr class='jqgfirstrow' role='row' style='height:auto'>";a.p.disableClick=!1;b("th",j).each(function(d){ea=a.p.colModel[d].width;if(typeof a.p.colModel[d].resizable==="undefined")a.p.colModel[d].resizable=true;if(a.p.colModel[d].resizable){ba=document.createElement("span");b(ba).html("&#160;").addClass("ui-jqgrid-resize ui-jqgrid-resize-"+i);b.browser.opera||b(ba).css("cursor","col-resize");b(this).addClass(a.p.resizeclass)}else ba="";b(this).css("width",ea+"px").prepend(ba);var e="";if(a.p.colModel[d].hidden){b(this).css("display",
"none");e="display:none;"}Y=Y+("<td role='gridcell' style='height:0px;width:"+ea+"px;"+e+"'></td>");c.headers[d]={width:ea,el:this};fa=a.p.colModel[d].sortable;if(typeof fa!=="boolean")fa=a.p.colModel[d].sortable=true;e=a.p.colModel[d].name;e=="cb"||e=="subgrid"||e=="rn"||a.p.viewsortcols[2]&&b(">div",this).addClass("ui-jqgrid-sortable");if(fa)if(a.p.viewsortcols[0]){b("div span.s-ico",this).show();d==a.p.lastsort&&b("div span.ui-icon-"+a.p.sortorder,this).removeClass("ui-state-disabled")}else if(d==
a.p.lastsort){b("div span.s-ico",this).show();b("div span.ui-icon-"+a.p.sortorder,this).removeClass("ui-state-disabled")}a.p.footerrow&&(R=R+("<td role='gridcell' "+p(d,0,"",null,"",false)+">&#160;</td>"))}).mousedown(function(d){if(b(d.target).closest("th>span.ui-jqgrid-resize").length==1){var e=ka(this);if(a.p.forceFit===true){var f=a.p,g=e,i;for(i=e+1;i<a.p.colModel.length;i++)if(a.p.colModel[i].hidden!==true){g=i;break}f.nv=g-e}c.dragStart(e,d,oa(e));return false}}).click(function(c){if(a.p.disableClick)return a.p.disableClick=
false;var d="th>div.ui-jqgrid-sortable",e,f;a.p.viewsortcols[2]||(d="th>div>span>span.ui-grid-ico-sort");c=b(c.target).closest(d);if(c.length==1){d=ka(this);if(!a.p.viewsortcols[2]){e=true;f=c.attr("sort")}ja(b("div",this)[0].id,d,e,f);return false}});if(a.p.sortable&&b.fn.sortable)try{b(a).jqGrid("sortableColumns",j)}catch(sa){}a.p.footerrow&&(R+="</tr></tbody></table>");Y+="</tr>";this.appendChild(document.createElement("tbody"));b(this).addClass("ui-jqgrid-btable").append(Y);var Y=null,j=b("<table class='ui-jqgrid-htable' style='width:"+
a.p.tblwidth+"px' role='grid' aria-labelledby='gbox_"+this.id+"' cellspacing='0' cellpadding='0' border='0'></table>").append(x),D=a.p.caption&&!0===a.p.hiddengrid?!0:!1;e=b("<div class='ui-jqgrid-hbox"+("rtl"==i?"-rtl":"")+"'></div>");x=null;c.hDiv=document.createElement("div");b(c.hDiv).css({width:c.width+"px"}).addClass("ui-state-default ui-jqgrid-hdiv").append(e);b(e).append(j);j=null;D&&b(c.hDiv).hide();a.p.pager&&("string"==typeof a.p.pager?"#"!=a.p.pager.substr(0,1)&&(a.p.pager="#"+a.p.pager):
a.p.pager="#"+b(a.p.pager).attr("id"),b(a.p.pager).css({width:c.width+"px"}).appendTo(m).addClass("ui-state-default ui-jqgrid-pager ui-corner-bottom"),D&&b(a.p.pager).hide(),l(a.p.pager,""));!1===a.p.cellEdit&&!0===a.p.hoverrows&&b(a).bind("mouseover",function(a){n=b(a.target).closest("tr.jqgrow");b(n).attr("class")!=="ui-subgrid"&&b(n).addClass("ui-state-hover")}).bind("mouseout",function(a){n=b(a.target).closest("tr.jqgrow");b(n).removeClass("ui-state-hover")});var t,E,ha;b(a).before(c.hDiv).click(function(c){A=
c.target;n=b(A,a.rows).closest("tr.jqgrow");if(b(n).length===0||n[0].className.indexOf("ui-state-disabled")>-1||(b(A,a).closest("table.ui-jqgrid-btable").attr("id")||"").replace("_frozen","")!==a.id)return this;var d=b(A).hasClass("cbox"),e=b(a).triggerHandler("jqGridBeforeSelectRow",[n[0].id,c]);(e=e===false||e==="stop"?false:true)&&b.isFunction(a.p.beforeSelectRow)&&(e=a.p.beforeSelectRow.call(a,n[0].id,c));if(!(A.tagName=="A"||(A.tagName=="INPUT"||A.tagName=="TEXTAREA"||A.tagName=="OPTION"||A.tagName==
"SELECT")&&!d)&&e===true){t=n[0].id;E=b.jgrid.getCellIndex(A);ha=b(A).closest("td,th").html();b(a).triggerHandler("jqGridCellSelect",[t,E,ha,c]);b.isFunction(a.p.onCellSelect)&&a.p.onCellSelect.call(a,t,E,ha,c);if(a.p.cellEdit===true)if(a.p.multiselect&&d)b(a).jqGrid("setSelection",t,true,c);else{t=n[0].rowIndex;try{b(a).jqGrid("editCell",t,E,true)}catch(f){}}else if(a.p.multikey)if(c[a.p.multikey])b(a).jqGrid("setSelection",t,true,c);else{if(a.p.multiselect&&d){d=b("#jqg_"+b.jgrid.jqID(a.p.id)+"_"+
t).is(":checked");b("#jqg_"+b.jgrid.jqID(a.p.id)+"_"+t)[a.p.useProp?"prop":"attr"]("checked",d)}}else{if(a.p.multiselect&&a.p.multiboxonly&&!d){var g=a.p.frozenColumns?a.p.id+"_frozen":"";b(a.p.selarrrow).each(function(c,d){var e=a.rows.namedItem(d);b(e).removeClass("ui-state-highlight");b("#jqg_"+b.jgrid.jqID(a.p.id)+"_"+b.jgrid.jqID(d))[a.p.useProp?"prop":"attr"]("checked",false);if(g){b("#"+b.jgrid.jqID(d),"#"+b.jgrid.jqID(g)).removeClass("ui-state-highlight");b("#jqg_"+b.jgrid.jqID(a.p.id)+"_"+
b.jgrid.jqID(d),"#"+b.jgrid.jqID(g))[a.p.useProp?"prop":"attr"]("checked",false)}});a.p.selarrrow=[]}b(a).jqGrid("setSelection",t,true,c)}}}).bind("reloadGrid",function(c,d){if(a.p.treeGrid===true)a.p.datatype=a.p.treedatatype;d&&d.current&&a.grid.selectionPreserver(a);if(a.p.datatype=="local"){b(a).jqGrid("resetSelection");a.p.data.length&&S()}else if(!a.p.treeGrid){a.p.selrow=null;if(a.p.multiselect){a.p.selarrrow=[];da(false)}a.p.savedRow=[]}a.p.scroll&&N.call(a,true,false);if(d&&d.page){var e=
d.page;if(e>a.p.lastpage)e=a.p.lastpage;e<1&&(e=1);a.p.page=e;a.grid.bDiv.scrollTop=a.grid.prevRowHeight?(e-1)*a.grid.prevRowHeight*a.p.rowNum:0}if(a.grid.prevRowHeight&&a.p.scroll){delete a.p.lastpage;a.grid.populateVisible()}else a.grid.populate();a.p._inlinenav===true&&b(a).jqGrid("showAddEditButtons");return false}).dblclick(function(c){A=c.target;n=b(A,a.rows).closest("tr.jqgrow");if(b(n).length!==0){t=n[0].rowIndex;E=b.jgrid.getCellIndex(A);b(a).triggerHandler("jqGridDblClickRow",[b(n).attr("id"),
t,E,c]);b.isFunction(this.p.ondblClickRow)&&a.p.ondblClickRow.call(a,b(n).attr("id"),t,E,c)}}).bind("contextmenu",function(c){A=c.target;n=b(A,a.rows).closest("tr.jqgrow");if(b(n).length!==0){a.p.multiselect||b(a).jqGrid("setSelection",n[0].id,true,c);t=n[0].rowIndex;E=b.jgrid.getCellIndex(A);b(a).triggerHandler("jqGridRightClickRow",[b(n).attr("id"),t,E,c]);b.isFunction(this.p.onRightClickRow)&&a.p.onRightClickRow.call(a,b(n).attr("id"),t,E,c)}});c.bDiv=document.createElement("div");k&&"auto"===
(""+a.p.height).toLowerCase()&&(a.p.height="100%");b(c.bDiv).append(b('<div style="position:relative;'+(k&&8>b.browser.version?"height:0.01%;":"")+'"></div>').append("<div></div>").append(this)).addClass("ui-jqgrid-bdiv").css({height:a.p.height+(isNaN(a.p.height)?"":"px"),width:c.width+"px"}).scroll(c.scrollGrid);b("table:first",c.bDiv).css({width:a.p.tblwidth+"px"});k?(2==b("tbody",this).size()&&b("tbody:gt(0)",this).remove(),a.p.multikey&&b(c.bDiv).bind("selectstart",function(){return false})):
a.p.multikey&&b(c.bDiv).bind("mousedown",function(){return false});D&&b(c.bDiv).hide();c.cDiv=document.createElement("div");var ia=!0===a.p.hidegrid?b("<a role='link' href='javascript:void(0)'/>").addClass("ui-jqgrid-titlebar-close HeaderButton").hover(function(){ia.addClass("ui-state-hover")},function(){ia.removeClass("ui-state-hover")}).append("<span class='ui-icon ui-icon-circle-triangle-n'></span>").css("rtl"==i?"left":"right","0px"):"";b(c.cDiv).append(ia).append("<span class='ui-jqgrid-title"+
("rtl"==i?"-rtl":"")+"'>"+a.p.caption+"</span>").addClass("ui-jqgrid-titlebar ui-widget-header ui-corner-top ui-helper-clearfix");b(c.cDiv).insertBefore(c.hDiv);a.p.toolbar[0]&&(c.uDiv=document.createElement("div"),"top"==a.p.toolbar[1]?b(c.uDiv).insertBefore(c.hDiv):"bottom"==a.p.toolbar[1]&&b(c.uDiv).insertAfter(c.hDiv),"both"==a.p.toolbar[1]?(c.ubDiv=document.createElement("div"),b(c.uDiv).insertBefore(c.hDiv).addClass("ui-userdata ui-state-default").attr("id","t_"+this.id),b(c.ubDiv).insertAfter(c.hDiv).addClass("ui-userdata ui-state-default").attr("id",
"tb_"+this.id),D&&b(c.ubDiv).hide()):b(c.uDiv).width(c.width).addClass("ui-userdata ui-state-default").attr("id","t_"+this.id),D&&b(c.uDiv).hide());a.p.toppager&&(a.p.toppager=b.jgrid.jqID(a.p.id)+"_toppager",c.topDiv=b("<div id='"+a.p.toppager+"'></div>")[0],a.p.toppager="#"+a.p.toppager,b(c.topDiv).insertBefore(c.hDiv).addClass("ui-state-default ui-jqgrid-toppager").width(c.width),l(a.p.toppager,"_t"));a.p.footerrow&&(c.sDiv=b("<div class='ui-jqgrid-sdiv'></div>")[0],e=b("<div class='ui-jqgrid-hbox"+
("rtl"==i?"-rtl":"")+"'></div>"),b(c.sDiv).append(e).insertAfter(c.hDiv).width(c.width),b(e).append(R),c.footers=b(".ui-jqgrid-ftable",c.sDiv)[0].rows[0].cells,a.p.rownumbers&&(c.footers[0].className="ui-state-default jqgrid-rownum"),D&&b(c.sDiv).hide());e=null;if(a.p.caption){var pa=a.p.datatype;!0===a.p.hidegrid&&(b(".ui-jqgrid-titlebar-close",c.cDiv).click(function(d){var e=b.isFunction(a.p.onHeaderClick),f=".ui-jqgrid-bdiv, .ui-jqgrid-hdiv, .ui-jqgrid-pager, .ui-jqgrid-sdiv",g,i=this;if(a.p.toolbar[0]===
true){a.p.toolbar[1]=="both"&&(f=f+(", #"+b(c.ubDiv).attr("id")));f=f+(", #"+b(c.uDiv).attr("id"))}g=b(f,"#gview_"+b.jgrid.jqID(a.p.id)).length;a.p.gridstate=="visible"?b(f,"#gbox_"+b.jgrid.jqID(a.p.id)).slideUp("fast",function(){g--;if(g===0){b("span",i).removeClass("ui-icon-circle-triangle-n").addClass("ui-icon-circle-triangle-s");a.p.gridstate="hidden";b("#gbox_"+b.jgrid.jqID(a.p.id)).hasClass("ui-resizable")&&b(".ui-resizable-handle","#gbox_"+b.jgrid.jqID(a.p.id)).hide();b(a).triggerHandler("jqGridHeaderClick",
[a.p.gridstate,d]);e&&(D||a.p.onHeaderClick.call(a,a.p.gridstate,d))}}):a.p.gridstate=="hidden"&&b(f,"#gbox_"+b.jgrid.jqID(a.p.id)).slideDown("fast",function(){g--;if(g===0){b("span",i).removeClass("ui-icon-circle-triangle-s").addClass("ui-icon-circle-triangle-n");if(D){a.p.datatype=pa;I();D=false}a.p.gridstate="visible";b("#gbox_"+b.jgrid.jqID(a.p.id)).hasClass("ui-resizable")&&b(".ui-resizable-handle","#gbox_"+b.jgrid.jqID(a.p.id)).show();b(a).triggerHandler("jqGridHeaderClick",[a.p.gridstate,d]);
e&&(D||a.p.onHeaderClick.call(a,a.p.gridstate,d))}});return false}),D&&(a.p.datatype="local",b(".ui-jqgrid-titlebar-close",c.cDiv).trigger("click")))}else b(c.cDiv).hide();b(c.hDiv).after(c.bDiv).mousemove(function(a){if(c.resizing){c.dragMove(a);return false}});b(".ui-jqgrid-labels",c.hDiv).bind("selectstart",function(){return false});b(document).mouseup(function(){if(c.resizing){c.dragEnd();return false}return true});a.formatCol=p;a.sortData=ja;a.updatepager=function(c,d){var e,f,g,h,i,j,k,l="",
m=a.p.pager?"_"+b.jgrid.jqID(a.p.pager.substr(1)):"",n=a.p.toppager?"_"+a.p.toppager.substr(1):"";g=parseInt(a.p.page,10)-1;g<0&&(g=0);g=g*parseInt(a.p.rowNum,10);i=g+a.p.reccount;if(a.p.scroll){e=b("tbody:first > tr:gt(0)",a.grid.bDiv);g=i-e.length;a.p.reccount=e.length;if(f=e.outerHeight()||a.grid.prevRowHeight){e=g*f;f=parseInt(a.p.records,10)*f;b(">div:first",a.grid.bDiv).css({height:f}).children("div:first").css({height:e,display:e?"":"none"})}a.grid.bDiv.scrollLeft=a.grid.hDiv.scrollLeft}l=
a.p.pager?a.p.pager:"";if(l=l+(a.p.toppager?l?","+a.p.toppager:a.p.toppager:"")){k=b.jgrid.formatter.integer||{};e=o(a.p.page);f=o(a.p.lastpage);b(".selbox",l)[this.p.useProp?"prop":"attr"]("disabled",false);if(a.p.pginput===true){b(".ui-pg-input",l).val(a.p.page);h=a.p.toppager?"#sp_1"+m+",#sp_1"+n:"#sp_1"+m;b(h).html(b.fmatter?b.fmatter.util.NumberFormat(a.p.lastpage,k):a.p.lastpage)}if(a.p.viewrecords)if(a.p.reccount===0)b(".ui-paging-info",l).html(a.p.emptyrecords);else{h=g+1;j=a.p.records;if(b.fmatter){h=
b.fmatter.util.NumberFormat(h,k);i=b.fmatter.util.NumberFormat(i,k);j=b.fmatter.util.NumberFormat(j,k)}b(".ui-paging-info",l).html(b.jgrid.format(a.p.recordtext,h,i,j))}if(a.p.pgbuttons===true){e<=0&&(e=f=0);if(e==1||e===0){b("#first"+m+", #prev"+m).addClass("ui-state-disabled").removeClass("ui-state-hover");a.p.toppager&&b("#first_t"+n+", #prev_t"+n).addClass("ui-state-disabled").removeClass("ui-state-hover")}else{b("#first"+m+", #prev"+m).removeClass("ui-state-disabled");a.p.toppager&&b("#first_t"+
n+", #prev_t"+n).removeClass("ui-state-disabled")}if(e==f||e===0){b("#next"+m+", #last"+m).addClass("ui-state-disabled").removeClass("ui-state-hover");a.p.toppager&&b("#next_t"+n+", #last_t"+n).addClass("ui-state-disabled").removeClass("ui-state-hover")}else{b("#next"+m+", #last"+m).removeClass("ui-state-disabled");a.p.toppager&&b("#next_t"+n+", #last_t"+n).removeClass("ui-state-disabled")}}}c===true&&a.p.rownumbers===true&&b("td.jqgrid-rownum",a.rows).each(function(a){b(this).html(g+1+a)});d&&a.p.jqgdnd&&
b(a).jqGrid("gridDnD","updateDnD");b(a).triggerHandler("jqGridGridComplete");b.isFunction(a.p.gridComplete)&&a.p.gridComplete.call(a);b(a).triggerHandler("jqGridAfterGridComplete")};a.refreshIndex=S;a.setHeadCheckBox=da;a.constructTr=J;a.formatter=function(a,b,c,d,e){return u(a,b,c,d,e)};b.extend(c,{populate:I,emptyRows:N});this.grid=c;a.addXmlData=function(b){$(b,a.grid.bDiv)};a.addJSONData=function(b){aa(b,a.grid.bDiv)};this.grid.cols=this.rows[0].cells;I();a.p.hiddengrid=!1;b(window).unload(function(){a=
null})}}}})};b.jgrid.extend({getGridParam:function(b){var e=this[0];return!e||!e.grid?void 0:b?"undefined"!=typeof e.p[b]?e.p[b]:null:e.p},setGridParam:function(f){return this.each(function(){this.grid&&"object"===typeof f&&b.extend(!0,this.p,f)})},getDataIDs:function(){var f=[],e=0,c,d=0;this.each(function(){if((c=this.rows.length)&&0<c)for(;e<c;)b(this.rows[e]).hasClass("jqgrow")&&(f[d]=this.rows[e].id,d++),e++});return f},setSelection:function(f,e,c){return this.each(function(){var d,a,h,g,i,j;
if(void 0!==f&&(e=!1===e?!1:!0,(a=this.rows.namedItem(f+""))&&a.className&&!(-1<a.className.indexOf("ui-state-disabled"))))(!0===this.p.scrollrows&&(h=this.rows.namedItem(f).rowIndex,0<=h&&(d=b(this.grid.bDiv)[0].clientHeight,g=b(this.grid.bDiv)[0].scrollTop,i=this.rows[h].offsetTop,h=this.rows[h].clientHeight,i+h>=d+g?b(this.grid.bDiv)[0].scrollTop=i-(d+g)+h+g:i<d+g&&i<g&&(b(this.grid.bDiv)[0].scrollTop=i))),!0===this.p.frozenColumns&&(j=this.p.id+"_frozen"),this.p.multiselect)?(this.setHeadCheckBox(!1),
this.p.selrow=a.id,g=b.inArray(this.p.selrow,this.p.selarrrow),-1===g?("ui-subgrid"!==a.className&&b(a).addClass("ui-state-highlight").attr("aria-selected","true"),d=!0,this.p.selarrrow.push(this.p.selrow)):("ui-subgrid"!==a.className&&b(a).removeClass("ui-state-highlight").attr("aria-selected","false"),d=!1,this.p.selarrrow.splice(g,1),i=this.p.selarrrow[0],this.p.selrow=void 0===i?null:i),b("#jqg_"+b.jgrid.jqID(this.p.id)+"_"+b.jgrid.jqID(a.id))[this.p.useProp?"prop":"attr"]("checked",d),j&&(-1===
g?b("#"+b.jgrid.jqID(f),"#"+b.jgrid.jqID(j)).addClass("ui-state-highlight"):b("#"+b.jgrid.jqID(f),"#"+b.jgrid.jqID(j)).removeClass("ui-state-highlight"),b("#jqg_"+b.jgrid.jqID(this.p.id)+"_"+b.jgrid.jqID(f),"#"+b.jgrid.jqID(j))[this.p.useProp?"prop":"attr"]("checked",d)),b(this).triggerHandler("jqGridSelectRow",[a.id,d,c]),this.p.onSelectRow&&e&&this.p.onSelectRow.call(this,a.id,d,c)):"ui-subgrid"!==a.className&&(this.p.selrow!=a.id?(b(this.rows.namedItem(this.p.selrow)).removeClass("ui-state-highlight").attr({"aria-selected":"false",
tabindex:"-1"}),b(a).addClass("ui-state-highlight").attr({"aria-selected":"true",tabindex:"0"}),j&&(b("#"+b.jgrid.jqID(this.p.selrow),"#"+b.jgrid.jqID(j)).removeClass("ui-state-highlight"),b("#"+b.jgrid.jqID(f),"#"+b.jgrid.jqID(j)).addClass("ui-state-highlight")),d=!0):d=!1,this.p.selrow=a.id,b(this).triggerHandler("jqGridSelectRow",[a.id,d,c]),this.p.onSelectRow&&e&&this.p.onSelectRow.call(this,a.id,d,c))})},resetSelection:function(f){return this.each(function(){var e=this,c,d,a;!0===e.p.frozenColumns&&
(a=e.p.id+"_frozen");if("undefined"!==typeof f){d=f===e.p.selrow?e.p.selrow:f;b("#"+b.jgrid.jqID(e.p.id)+" tbody:first tr#"+b.jgrid.jqID(d)).removeClass("ui-state-highlight").attr("aria-selected","false");a&&b("#"+b.jgrid.jqID(d),"#"+b.jgrid.jqID(a)).removeClass("ui-state-highlight");if(e.p.multiselect){b("#jqg_"+b.jgrid.jqID(e.p.id)+"_"+b.jgrid.jqID(d),"#"+b.jgrid.jqID(e.p.id))[e.p.useProp?"prop":"attr"]("checked",!1);if(a)b("#jqg_"+b.jgrid.jqID(e.p.id)+"_"+b.jgrid.jqID(d),"#"+b.jgrid.jqID(a))[e.p.useProp?
"prop":"attr"]("checked",!1);e.setHeadCheckBox(!1)}d=null}else e.p.multiselect?(b(e.p.selarrrow).each(function(d,f){c=e.rows.namedItem(f);b(c).removeClass("ui-state-highlight").attr("aria-selected","false");b("#jqg_"+b.jgrid.jqID(e.p.id)+"_"+b.jgrid.jqID(f))[e.p.useProp?"prop":"attr"]("checked",!1);a&&(b("#"+b.jgrid.jqID(f),"#"+b.jgrid.jqID(a)).removeClass("ui-state-highlight"),b("#jqg_"+b.jgrid.jqID(e.p.id)+"_"+b.jgrid.jqID(f),"#"+b.jgrid.jqID(a))[e.p.useProp?"prop":"attr"]("checked",!1))}),e.setHeadCheckBox(!1),
e.p.selarrrow=[]):e.p.selrow&&(b("#"+b.jgrid.jqID(e.p.id)+" tbody:first tr#"+b.jgrid.jqID(e.p.selrow)).removeClass("ui-state-highlight").attr("aria-selected","false"),a&&b("#"+b.jgrid.jqID(e.p.selrow),"#"+b.jgrid.jqID(a)).removeClass("ui-state-highlight"),e.p.selrow=null);!0===e.p.cellEdit&&0<=parseInt(e.p.iCol,10)&&0<=parseInt(e.p.iRow,10)&&(b("td:eq("+e.p.iCol+")",e.rows[e.p.iRow]).removeClass("edit-cell ui-state-highlight"),b(e.rows[e.p.iRow]).removeClass("selected-row ui-state-hover"));e.p.savedRow=
[]})},getRowData:function(f){var e={},c,d=!1,a,h=0;this.each(function(){var g=this,i,j;if("undefined"==typeof f)d=!0,c=[],a=g.rows.length;else{j=g.rows.namedItem(f);if(!j)return e;a=2}for(;h<a;)d&&(j=g.rows[h]),b(j).hasClass("jqgrow")&&(b('td[role="gridcell"]',j).each(function(a){i=g.p.colModel[a].name;if("cb"!==i&&"subgrid"!==i&&"rn"!==i)if(!0===g.p.treeGrid&&i==g.p.ExpandColumn)e[i]=b.jgrid.htmlDecode(b("span:first",this).html());else try{e[i]=b.unformat.call(g,this,{rowId:j.id,colModel:g.p.colModel[a]},
a)}catch(c){e[i]=b.jgrid.htmlDecode(b(this).html())}}),d&&(c.push(e),e={})),h++});return c?c:e},delRowData:function(f){var e=!1,c,d;this.each(function(){if(c=this.rows.namedItem(f)){if(b(c).remove(),this.p.records--,this.p.reccount--,this.updatepager(!0,!1),e=!0,this.p.multiselect&&(d=b.inArray(f,this.p.selarrrow),-1!=d&&this.p.selarrrow.splice(d,1)),f==this.p.selrow)this.p.selrow=null}else return!1;if("local"==this.p.datatype){var a=this.p._index[b.jgrid.stripPref(this.p.idPrefix,f)];"undefined"!=
typeof a&&(this.p.data.splice(a,1),this.refreshIndex())}if(!0===this.p.altRows&&e){var h=this.p.altclass;b(this.rows).each(function(a){1==a%2?b(this).addClass(h):b(this).removeClass(h)})}});return e},setRowData:function(f,e,c){var d,a=!0,h;this.each(function(){if(!this.grid)return!1;var g=this,i,j,l=typeof c,k={};j=g.rows.namedItem(f);if(!j)return!1;if(e)try{if(b(this.p.colModel).each(function(a){d=this.name;void 0!==e[d]&&(k[d]=this.formatter&&"string"===typeof this.formatter&&"date"==this.formatter?
b.unformat.date.call(g,e[d],this):e[d],i=g.formatter(f,e[d],a,e,"edit"),h=this.title?{title:b.jgrid.stripHtml(i)}:{},!0===g.p.treeGrid&&d==g.p.ExpandColumn?b("td:eq("+a+") > span:first",j).html(i).attr(h):b("td:eq("+a+")",j).html(i).attr(h))}),"local"==g.p.datatype){var m=b.jgrid.stripPref(g.p.idPrefix,f),o=g.p._index[m];if(g.p.treeGrid)for(var p in g.p.treeReader)k.hasOwnProperty(g.p.treeReader[p])&&delete k[g.p.treeReader[p]];"undefined"!=typeof o&&(g.p.data[o]=b.extend(!0,g.p.data[o],k));k=null}}catch(v){a=
!1}a&&("string"===l?b(j).addClass(c):"object"===l&&b(j).css(c),b(g).triggerHandler("jqGridAfterGridComplete"))});return a},addRowData:function(f,e,c,d){c||(c="last");var a=!1,h,g,i,j,l,k,m,o,p="",v,u,M,F,Z,U;e&&(b.isArray(e)?(v=!0,c="last",u=f):(e=[e],v=!1),this.each(function(){var V=e.length;l=this.p.rownumbers===true?1:0;i=this.p.multiselect===true?1:0;j=this.p.subGrid===true?1:0;if(!v)if(typeof f!="undefined")f=f+"";else{f=b.jgrid.randId();if(this.p.keyIndex!==false){u=this.p.colModel[this.p.keyIndex+
i+j+l].name;typeof e[0][u]!="undefined"&&(f=e[0][u])}}M=this.p.altclass;for(var N=0,S="",J={},$=b.isFunction(this.p.afterInsertRow)?true:false;N<V;){F=e[N];g=[];if(v){try{f=F[u]}catch(aa){f=b.jgrid.randId()}S=this.p.altRows===true?(this.rows.length-1)%2===0?M:"":""}U=f;f=this.p.idPrefix+f;if(l){p=this.formatCol(0,1,"",null,f,true);g[g.length]='<td role="gridcell" class="ui-state-default jqgrid-rownum" '+p+">0</td>"}if(i){o='<input role="checkbox" type="checkbox" id="jqg_'+this.p.id+"_"+f+'" class="cbox"/>';
p=this.formatCol(l,1,"",null,f,true);g[g.length]='<td role="gridcell" '+p+">"+o+"</td>"}j&&(g[g.length]=b(this).jqGrid("addSubGridCell",i+l,1));for(m=i+j+l;m<this.p.colModel.length;m++){Z=this.p.colModel[m];h=Z.name;J[h]=F[h];o=this.formatter(f,b.jgrid.getAccessor(F,h),m,F);p=this.formatCol(m,1,o,F,f,true);g[g.length]='<td role="gridcell" '+p+">"+o+"</td>"}g.unshift(this.constructTr(f,false,S,J,J));g[g.length]="</tr>";if(this.rows.length===0)b("table:first",this.grid.bDiv).append(g.join(""));else switch(c){case "last":b(this.rows[this.rows.length-
1]).after(g.join(""));k=this.rows.length-1;break;case "first":b(this.rows[0]).after(g.join(""));k=1;break;case "after":(k=this.rows.namedItem(d))&&(b(this.rows[k.rowIndex+1]).hasClass("ui-subgrid")?b(this.rows[k.rowIndex+1]).after(g):b(k).after(g.join("")));k++;break;case "before":if(k=this.rows.namedItem(d)){b(k).before(g.join(""));k=k.rowIndex}k--}this.p.subGrid===true&&b(this).jqGrid("addSubGrid",i+l,k);this.p.records++;this.p.reccount++;b(this).triggerHandler("jqGridAfterInsertRow",[f,F,F]);$&&
this.p.afterInsertRow.call(this,f,F,F);N++;if(this.p.datatype=="local"){J[this.p.localReader.id]=U;this.p._index[U]=this.p.data.length;this.p.data.push(J);J={}}}this.p.altRows===true&&!v&&(c=="last"?(this.rows.length-1)%2==1&&b(this.rows[this.rows.length-1]).addClass(M):b(this.rows).each(function(a){a%2==1?b(this).addClass(M):b(this).removeClass(M)}));this.updatepager(true,true);a=true}));return a},footerData:function(f,e,c){function d(a){for(var b in a)if(a.hasOwnProperty(b))return!1;return!0}var a,
h=!1,g={},i;"undefined"==typeof f&&(f="get");"boolean"!=typeof c&&(c=!0);f=f.toLowerCase();this.each(function(){var j=this,l;if(!j.grid||!j.p.footerrow||"set"==f&&d(e))return!1;h=!0;b(this.p.colModel).each(function(d){a=this.name;"set"==f?void 0!==e[a]&&(l=c?j.formatter("",e[a],d,e,"edit"):e[a],i=this.title?{title:b.jgrid.stripHtml(l)}:{},b("tr.footrow td:eq("+d+")",j.grid.sDiv).html(l).attr(i),h=!0):"get"==f&&(g[a]=b("tr.footrow td:eq("+d+")",j.grid.sDiv).html())})});return"get"==f?g:h},showHideCol:function(f,
e){return this.each(function(){var c=this,d=!1,a=b.jgrid.cellWidth()?0:c.p.cellLayout,h;if(c.grid){"string"===typeof f&&(f=[f]);e="none"!=e?"":"none";var g=""===e?!0:!1,i=c.p.groupHeader&&("object"===typeof c.p.groupHeader||b.isFunction(c.p.groupHeader));i&&b(c).jqGrid("destroyGroupHeader",!1);b(this.p.colModel).each(function(i){if(-1!==b.inArray(this.name,f)&&this.hidden===g){if(!0===c.p.frozenColumns&&!0===this.frozen)return!0;b("tr",c.grid.hDiv).each(function(){b(this.cells[i]).css("display",e)});
b(c.rows).each(function(){b(this).hasClass("jqgroup")||b(this.cells[i]).css("display",e)});c.p.footerrow&&b("tr.footrow td:eq("+i+")",c.grid.sDiv).css("display",e);h=parseInt(this.width,10);c.p.tblwidth="none"===e?c.p.tblwidth-(h+a):c.p.tblwidth+(h+a);this.hidden=!g;d=!0;b(c).triggerHandler("jqGridShowHideCol",[g,this.name,i])}});!0===d&&(!0===c.p.shrinkToFit&&!isNaN(c.p.height)&&(c.p.tblwidth+=parseInt(c.p.scrollOffset,10)),b(c).jqGrid("setGridWidth",!0===c.p.shrinkToFit?c.p.tblwidth:c.p.width));
i&&b(c).jqGrid("setGroupHeaders",c.p.groupHeader)}})},hideCol:function(f){return this.each(function(){b(this).jqGrid("showHideCol",f,"none")})},showCol:function(f){return this.each(function(){b(this).jqGrid("showHideCol",f,"")})},remapColumns:function(f,e,c){function d(a){var c;c=a.length?b.makeArray(a):b.extend({},a);b.each(f,function(b){a[b]=c[this]})}function a(a,c){b(">tr"+(c||""),a).each(function(){var a=this,c=b.makeArray(a.cells);b.each(f,function(){var b=c[this];b&&a.appendChild(b)})})}var h=
this.get(0);d(h.p.colModel);d(h.p.colNames);d(h.grid.headers);a(b("thead:first",h.grid.hDiv),c&&":not(.ui-jqgrid-labels)");e&&a(b("#"+b.jgrid.jqID(h.p.id)+" tbody:first"),".jqgfirstrow, tr.jqgrow, tr.jqfoot");h.p.footerrow&&a(b("tbody:first",h.grid.sDiv));h.p.remapColumns&&(h.p.remapColumns.length?d(h.p.remapColumns):h.p.remapColumns=b.makeArray(f));h.p.lastsort=b.inArray(h.p.lastsort,f);h.p.treeGrid&&(h.p.expColInd=b.inArray(h.p.expColInd,f));b(h).triggerHandler("jqGridRemapColumns",[f,e,c])},setGridWidth:function(f,
e){return this.each(function(){if(this.grid){var c=this,d,a=0,h=b.jgrid.cellWidth()?0:c.p.cellLayout,g,i=0,j=!1,l=c.p.scrollOffset,k,m=0,o=0,p;"boolean"!=typeof e&&(e=c.p.shrinkToFit);if(!isNaN(f)){f=parseInt(f,10);c.grid.width=c.p.width=f;b("#gbox_"+b.jgrid.jqID(c.p.id)).css("width",f+"px");b("#gview_"+b.jgrid.jqID(c.p.id)).css("width",f+"px");b(c.grid.bDiv).css("width",f+"px");b(c.grid.hDiv).css("width",f+"px");c.p.pager&&b(c.p.pager).css("width",f+"px");c.p.toppager&&b(c.p.toppager).css("width",
f+"px");!0===c.p.toolbar[0]&&(b(c.grid.uDiv).css("width",f+"px"),"both"==c.p.toolbar[1]&&b(c.grid.ubDiv).css("width",f+"px"));c.p.footerrow&&b(c.grid.sDiv).css("width",f+"px");!1===e&&!0===c.p.forceFit&&(c.p.forceFit=!1);if(!0===e){b.each(c.p.colModel,function(){if(this.hidden===false){d=this.widthOrg;a=a+(d+h);this.fixed?m=m+(d+h):i++;o++}});if(0===i)return;c.p.tblwidth=a;k=f-h*i-m;if(!isNaN(c.p.height)&&(b(c.grid.bDiv)[0].clientHeight<b(c.grid.bDiv)[0].scrollHeight||1===c.rows.length))j=!0,k-=l;
var a=0,v=0<c.grid.cols.length;b.each(c.p.colModel,function(b){if(this.hidden===false&&!this.fixed){d=this.widthOrg;d=Math.round(k*d/(c.p.tblwidth-h*i-m));if(!(d<0)){this.width=d;a=a+d;c.grid.headers[b].width=d;c.grid.headers[b].el.style.width=d+"px";if(c.p.footerrow)c.grid.footers[b].style.width=d+"px";if(v)c.grid.cols[b].style.width=d+"px";g=b}}});if(!g)return;p=0;j?f-m-(a+h*i)!==l&&(p=f-m-(a+h*i)-l):1!==Math.abs(f-m-(a+h*i))&&(p=f-m-(a+h*i));c.p.colModel[g].width+=p;c.p.tblwidth=a+p+h*i+m;c.p.tblwidth>
f?(j=c.p.tblwidth-parseInt(f,10),c.p.tblwidth=f,d=c.p.colModel[g].width-=j):d=c.p.colModel[g].width;c.grid.headers[g].width=d;c.grid.headers[g].el.style.width=d+"px";v&&(c.grid.cols[g].style.width=d+"px");c.p.footerrow&&(c.grid.footers[g].style.width=d+"px")}c.p.tblwidth&&(b("table:first",c.grid.bDiv).css("width",c.p.tblwidth+"px"),b("table:first",c.grid.hDiv).css("width",c.p.tblwidth+"px"),c.grid.hDiv.scrollLeft=c.grid.bDiv.scrollLeft,c.p.footerrow&&b("table:first",c.grid.sDiv).css("width",c.p.tblwidth+
"px"))}}})},setGridHeight:function(f){return this.each(function(){if(this.grid){var e=b(this.grid.bDiv);e.css({height:f+(isNaN(f)?"":"px")});!0===this.p.frozenColumns&&b("#"+b.jgrid.jqID(this.p.id)+"_frozen").parent().height(e.height()-16);this.p.height=f;this.p.scroll&&this.grid.populateVisible()}})},setCaption:function(f){return this.each(function(){this.p.caption=f;b("span.ui-jqgrid-title, span.ui-jqgrid-title-rtl",this.grid.cDiv).html(f);b(this.grid.cDiv).show()})},setLabel:function(f,e,c,d){return this.each(function(){var a=
-1;if(this.grid&&"undefined"!=typeof f&&(b(this.p.colModel).each(function(b){if(this.name==f)return a=b,!1}),0<=a)){var h=b("tr.ui-jqgrid-labels th:eq("+a+")",this.grid.hDiv);if(e){var g=b(".s-ico",h);b("[id^=jqgh_]",h).empty().html(e).append(g);this.p.colNames[a]=e}c&&("string"===typeof c?b(h).addClass(c):b(h).css(c));"object"===typeof d&&b(h).attr(d)}})},setCell:function(f,e,c,d,a,h){return this.each(function(){var g=-1,i,j;if(this.grid&&(isNaN(e)?b(this.p.colModel).each(function(a){if(this.name==
e)return g=a,!1}):g=parseInt(e,10),0<=g&&(i=this.rows.namedItem(f)))){var l=b("td:eq("+g+")",i);if(""!==c||!0===h)i=this.formatter(f,c,g,i,"edit"),j=this.p.colModel[g].title?{title:b.jgrid.stripHtml(i)}:{},this.p.treeGrid&&0<b(".tree-wrap",b(l)).length?b("span",b(l)).html(i).attr(j):b(l).html(i).attr(j),"local"==this.p.datatype&&(i=this.p.colModel[g],c=i.formatter&&"string"===typeof i.formatter&&"date"==i.formatter?b.unformat.date.call(this,c,i):c,j=this.p._index[f],"undefined"!=typeof j&&(this.p.data[j][i.name]=
c));"string"===typeof d?b(l).addClass(d):d&&b(l).css(d);"object"===typeof a&&b(l).attr(a)}})},getCell:function(f,e){var c=!1;this.each(function(){var d=-1;if(this.grid&&(isNaN(e)?b(this.p.colModel).each(function(a){if(this.name===e)return d=a,!1}):d=parseInt(e,10),0<=d)){var a=this.rows.namedItem(f);if(a)try{c=b.unformat.call(this,b("td:eq("+d+")",a),{rowId:a.id,colModel:this.p.colModel[d]},d)}catch(h){c=b.jgrid.htmlDecode(b("td:eq("+d+")",a).html())}}});return c},getCol:function(f,e,c){var d=[],
a,h=0,g,i,j,e="boolean"!=typeof e?!1:e;"undefined"==typeof c&&(c=!1);this.each(function(){var l=-1;if(this.grid&&(isNaN(f)?b(this.p.colModel).each(function(a){if(this.name===f)return l=a,!1}):l=parseInt(f,10),0<=l)){var k=this.rows.length,m=0;if(k&&0<k){for(;m<k;){if(b(this.rows[m]).hasClass("jqgrow")){try{a=b.unformat.call(this,b(this.rows[m].cells[l]),{rowId:this.rows[m].id,colModel:this.p.colModel[l]},l)}catch(o){a=b.jgrid.htmlDecode(this.rows[m].cells[l].innerHTML)}c?(j=parseFloat(a),h+=j,0===
m?i=g=j:(g=Math.min(g,j),i=Math.max(i,j))):e?d.push({id:this.rows[m].id,value:a}):d.push(a)}m++}if(c)switch(c.toLowerCase()){case "sum":d=h;break;case "avg":d=h/k;break;case "count":d=k;break;case "min":d=g;break;case "max":d=i}}}});return d},clearGridData:function(f){return this.each(function(){if(this.grid){"boolean"!=typeof f&&(f=!1);if(this.p.deepempty)b("#"+b.jgrid.jqID(this.p.id)+" tbody:first tr:gt(0)").remove();else{var e=b("#"+b.jgrid.jqID(this.p.id)+" tbody:first tr:first")[0];b("#"+b.jgrid.jqID(this.p.id)+
" tbody:first").empty().append(e)}this.p.footerrow&&f&&b(".ui-jqgrid-ftable td",this.grid.sDiv).html("&#160;");this.p.selrow=null;this.p.selarrrow=[];this.p.savedRow=[];this.p.records=0;this.p.page=1;this.p.lastpage=0;this.p.reccount=0;this.p.data=[];this.p._index={};this.updatepager(!0,!1)}})},getInd:function(b,e){var c=!1,d;this.each(function(){(d=this.rows.namedItem(b))&&(c=!0===e?d:d.rowIndex)});return c},bindKeys:function(f){var e=b.extend({onEnter:null,onSpace:null,onLeftKey:null,onRightKey:null,
scrollingRows:!0},f||{});return this.each(function(){var c=this;b("body").is("[role]")||b("body").attr("role","application");c.p.scrollrows=e.scrollingRows;b(c).keydown(function(d){var a=b(c).find("tr[tabindex=0]")[0],f,g,i,j=c.p.treeReader.expanded_field;if(a)if(i=c.p._index[a.id],37===d.keyCode||38===d.keyCode||39===d.keyCode||40===d.keyCode){if(38===d.keyCode){g=a.previousSibling;f="";if(g)if(b(g).is(":hidden"))for(;g;){if(g=g.previousSibling,!b(g).is(":hidden")&&b(g).hasClass("jqgrow")){f=g.id;
break}}else f=g.id;b(c).jqGrid("setSelection",f,!0,d)}if(40===d.keyCode){g=a.nextSibling;f="";if(g)if(b(g).is(":hidden"))for(;g;){if(g=g.nextSibling,!b(g).is(":hidden")&&b(g).hasClass("jqgrow")){f=g.id;break}}else f=g.id;b(c).jqGrid("setSelection",f,!0,d)}37===d.keyCode&&(c.p.treeGrid&&c.p.data[i][j]&&b(a).find("div.treeclick").trigger("click"),b(c).triggerHandler("jqGridKeyLeft",[c.p.selrow]),b.isFunction(e.onLeftKey)&&e.onLeftKey.call(c,c.p.selrow));39===d.keyCode&&(c.p.treeGrid&&!c.p.data[i][j]&&
b(a).find("div.treeclick").trigger("click"),b(c).triggerHandler("jqGridKeyRight",[c.p.selrow]),b.isFunction(e.onRightKey)&&e.onRightKey.call(c,c.p.selrow))}else 13===d.keyCode?(b(c).triggerHandler("jqGridKeyEnter",[c.p.selrow]),b.isFunction(e.onEnter)&&e.onEnter.call(c,c.p.selrow)):32===d.keyCode&&(b(c).triggerHandler("jqGridKeySpace",[c.p.selrow]),b.isFunction(e.onSpace)&&e.onSpace.call(c,c.p.selrow))})})},unbindKeys:function(){return this.each(function(){b(this).unbind("keydown")})},getLocalRow:function(b){var e=
!1,c;this.each(function(){"undefined"!==typeof b&&(c=this.p._index[b],0<=c&&(e=this.p.data[c]))});return e}})})(jQuery);
(function(c){c.fmatter={};c.extend(c.fmatter,{isBoolean:function(a){return"boolean"===typeof a},isObject:function(a){return a&&("object"===typeof a||c.isFunction(a))||!1},isString:function(a){return"string"===typeof a},isNumber:function(a){return"number"===typeof a&&isFinite(a)},isNull:function(a){return null===a},isUndefined:function(a){return"undefined"===typeof a},isValue:function(a){return this.isObject(a)||this.isString(a)||this.isNumber(a)||this.isBoolean(a)},isEmpty:function(a){if(!this.isString(a)&&
this.isValue(a))return!1;if(!this.isValue(a))return!0;a=c.trim(a).replace(/\&nbsp\;/ig,"").replace(/\&#160\;/ig,"");return""===a}});c.fn.fmatter=function(a,b,f,d,e){var g=b,f=c.extend({},c.jgrid.formatter,f);try{g=c.fn.fmatter[a].call(this,b,f,d,e)}catch(h){}return g};c.fmatter.util={NumberFormat:function(a,b){c.fmatter.isNumber(a)||(a*=1);if(c.fmatter.isNumber(a)){var f=0>a,d=a+"",e=b.decimalSeparator?b.decimalSeparator:".",g;if(c.fmatter.isNumber(b.decimalPlaces)){var h=b.decimalPlaces,d=Math.pow(10,
h),d=Math.round(a*d)/d+"";g=d.lastIndexOf(".");if(0<h){0>g?(d+=e,g=d.length-1):"."!==e&&(d=d.replace(".",e));for(;d.length-1-g<h;)d+="0"}}if(b.thousandsSeparator){h=b.thousandsSeparator;g=d.lastIndexOf(e);g=-1<g?g:d.length;for(var e=d.substring(g),i=-1,j=g;0<j;j--){i++;if(0===i%3&&j!==g&&(!f||1<j))e=h+e;e=d.charAt(j-1)+e}d=e}d=b.prefix?b.prefix+d:d;return d=b.suffix?d+b.suffix:d}return a},DateFormat:function(a,b,f,d){var e=/^\/Date\((([-+])?[0-9]+)(([-+])([0-9]{2})([0-9]{2}))?\)\/$/,g="string"===
typeof b?b.match(e):null,e=function(a,b){a=""+a;for(b=parseInt(b,10)||2;a.length<b;)a="0"+a;return a},h={m:1,d:1,y:1970,h:0,i:0,s:0,u:0},i=0,j,k=["i18n"];k.i18n={dayNames:d.dayNames,monthNames:d.monthNames};a in d.masks&&(a=d.masks[a]);if(!isNaN(b-0)&&"u"==(""+a).toLowerCase())i=new Date(1E3*parseFloat(b));else if(b.constructor===Date)i=b;else if(null!==g)i=new Date(parseInt(g[1],10)),g[3]&&(a=60*Number(g[5])+Number(g[6]),a*="-"==g[4]?1:-1,a-=i.getTimezoneOffset(),i.setTime(Number(Number(i)+6E4*a)));
else{b=(""+b).split(/[\\\/:_;.,\t\T\s-]/);a=a.split(/[\\\/:_;.,\t\T\s-]/);g=0;for(j=a.length;g<j;g++)"M"==a[g]&&(i=c.inArray(b[g],k.i18n.monthNames),-1!==i&&12>i&&(b[g]=i+1)),"F"==a[g]&&(i=c.inArray(b[g],k.i18n.monthNames),-1!==i&&11<i&&(b[g]=i+1-12)),b[g]&&(h[a[g].toLowerCase()]=parseInt(b[g],10));h.f&&(h.m=h.f);if(0===h.m&&0===h.y&&0===h.d)return"&#160;";h.m=parseInt(h.m,10)-1;i=h.y;70<=i&&99>=i?h.y=1900+h.y:0<=i&&69>=i&&(h.y=2E3+h.y);i=new Date(h.y,h.m,h.d,h.h,h.i,h.s,h.u)}f in d.masks?f=d.masks[f]:
f||(f="Y-m-d");a=i.getHours();b=i.getMinutes();h=i.getDate();g=i.getMonth()+1;j=i.getTimezoneOffset();var l=i.getSeconds(),r=i.getMilliseconds(),n=i.getDay(),m=i.getFullYear(),o=(n+6)%7+1,p=(new Date(m,g-1,h)-new Date(m,0,1))/864E5,q={d:e(h),D:k.i18n.dayNames[n],j:h,l:k.i18n.dayNames[n+7],N:o,S:d.S(h),w:n,z:p,W:5>o?Math.floor((p+o-1)/7)+1:Math.floor((p+o-1)/7)||(4>((new Date(m-1,0,1)).getDay()+6)%7?53:52),F:k.i18n.monthNames[g-1+12],m:e(g),M:k.i18n.monthNames[g-1],n:g,t:"?",L:"?",o:"?",Y:m,y:(""+
m).substring(2),a:12>a?d.AmPm[0]:d.AmPm[1],A:12>a?d.AmPm[2]:d.AmPm[3],B:"?",g:a%12||12,G:a,h:e(a%12||12),H:e(a),i:e(b),s:e(l),u:r,e:"?",I:"?",O:(0<j?"-":"+")+e(100*Math.floor(Math.abs(j)/60)+Math.abs(j)%60,4),P:"?",T:((""+i).match(/\b(?:[PMCEA][SDP]T|(?:Pacific|Mountain|Central|Eastern|Atlantic) (?:Standard|Daylight|Prevailing) Time|(?:GMT|UTC)(?:[-+]\d{4})?)\b/g)||[""]).pop().replace(/[^-+\dA-Z]/g,""),Z:"?",c:"?",r:"?",U:Math.floor(i/1E3)};return f.replace(/\\.|[dDjlNSwzWFmMntLoYyaABgGhHisueIOPTZcrU]/g,
function(a){return a in q?q[a]:a.substring(1)})}};c.fn.fmatter.defaultFormat=function(a,b){return c.fmatter.isValue(a)&&""!==a?a:b.defaultValue?b.defaultValue:"&#160;"};c.fn.fmatter.email=function(a,b){return c.fmatter.isEmpty(a)?c.fn.fmatter.defaultFormat(a,b):'<a href="mailto:'+a+'">'+a+"</a>"};c.fn.fmatter.checkbox=function(a,b){var f=c.extend({},b.checkbox),d;void 0!==b.colModel&&!c.fmatter.isUndefined(b.colModel.formatoptions)&&(f=c.extend({},f,b.colModel.formatoptions));d=!0===f.disabled?'disabled="disabled"':
"";if(c.fmatter.isEmpty(a)||c.fmatter.isUndefined(a))a=c.fn.fmatter.defaultFormat(a,f);a=(a+"").toLowerCase();return'<input type="checkbox" '+(0>a.search(/(false|0|no|off)/i)?" checked='checked' ":"")+' value="'+a+'" offval="no" '+d+"/>"};c.fn.fmatter.link=function(a,b){var f={target:b.target},d="";void 0!==b.colModel&&!c.fmatter.isUndefined(b.colModel.formatoptions)&&(f=c.extend({},f,b.colModel.formatoptions));f.target&&(d="target="+f.target);return!c.fmatter.isEmpty(a)?"<a "+d+' href="'+a+'">'+
a+"</a>":c.fn.fmatter.defaultFormat(a,b)};c.fn.fmatter.showlink=function(a,b){var f={baseLinkUrl:b.baseLinkUrl,showAction:b.showAction,addParam:b.addParam||"",target:b.target,idName:b.idName},d="";void 0!==b.colModel&&!c.fmatter.isUndefined(b.colModel.formatoptions)&&(f=c.extend({},f,b.colModel.formatoptions));f.target&&(d="target="+f.target);f=f.baseLinkUrl+f.showAction+"?"+f.idName+"="+b.rowId+f.addParam;return c.fmatter.isString(a)||c.fmatter.isNumber(a)?"<a "+d+' href="'+f+'">'+a+"</a>":c.fn.fmatter.defaultFormat(a,
b)};c.fn.fmatter.integer=function(a,b){var f=c.extend({},b.integer);void 0!==b.colModel&&!c.fmatter.isUndefined(b.colModel.formatoptions)&&(f=c.extend({},f,b.colModel.formatoptions));return c.fmatter.isEmpty(a)?f.defaultValue:c.fmatter.util.NumberFormat(a,f)};c.fn.fmatter.number=function(a,b){var f=c.extend({},b.number);void 0!==b.colModel&&!c.fmatter.isUndefined(b.colModel.formatoptions)&&(f=c.extend({},f,b.colModel.formatoptions));return c.fmatter.isEmpty(a)?f.defaultValue:c.fmatter.util.NumberFormat(a,
f)};c.fn.fmatter.currency=function(a,b){var f=c.extend({},b.currency);void 0!==b.colModel&&!c.fmatter.isUndefined(b.colModel.formatoptions)&&(f=c.extend({},f,b.colModel.formatoptions));return c.fmatter.isEmpty(a)?f.defaultValue:c.fmatter.util.NumberFormat(a,f)};c.fn.fmatter.date=function(a,b,f,d){f=c.extend({},b.date);void 0!==b.colModel&&!c.fmatter.isUndefined(b.colModel.formatoptions)&&(f=c.extend({},f,b.colModel.formatoptions));return!f.reformatAfterEdit&&"edit"==d||c.fmatter.isEmpty(a)?c.fn.fmatter.defaultFormat(a,
b):c.fmatter.util.DateFormat(f.srcformat,a,f.newformat,f)};c.fn.fmatter.select=function(a,b){var a=a+"",f=!1,d=[],e,g;c.fmatter.isUndefined(b.colModel.formatoptions)?c.fmatter.isUndefined(b.colModel.editoptions)||(f=b.colModel.editoptions.value,e=void 0===b.colModel.editoptions.separator?":":b.colModel.editoptions.separator,g=void 0===b.colModel.editoptions.delimiter?";":b.colModel.editoptions.delimiter):(f=b.colModel.formatoptions.value,e=void 0===b.colModel.formatoptions.separator?":":b.colModel.formatoptions.separator,
g=void 0===b.colModel.formatoptions.delimiter?";":b.colModel.formatoptions.delimiter);if(f){var h=!0===b.colModel.editoptions.multiple?!0:!1,i=[];h&&(i=a.split(","),i=c.map(i,function(a){return c.trim(a)}));if(c.fmatter.isString(f))for(var j=f.split(g),k=0,l=0;l<j.length;l++)if(g=j[l].split(e),2<g.length&&(g[1]=c.map(g,function(a,b){if(b>0)return a}).join(e)),h)-1<c.inArray(g[0],i)&&(d[k]=g[1],k++);else{if(c.trim(g[0])==c.trim(a)){d[0]=g[1];break}}else c.fmatter.isObject(f)&&(h?d=c.map(i,function(a){return f[a]}):
d[0]=f[a]||"")}a=d.join(", ");return""===a?c.fn.fmatter.defaultFormat(a,b):a};c.fn.fmatter.rowactions=function(a,b,f,d){var e={keys:!1,onEdit:null,onSuccess:null,afterSave:null,onError:null,afterRestore:null,extraparam:{},url:null,restoreAfterError:!0,mtype:"POST",delOptions:{},editOptions:{}},a=c.jgrid.jqID(a),b=c.jgrid.jqID(b),d=c("#"+b)[0].p.colModel[d];c.fmatter.isUndefined(d.formatoptions)||(e=c.extend(e,d.formatoptions));c.fmatter.isUndefined(c("#"+b)[0].p.editOptions)||(e.editOptions=c("#"+
b)[0].p.editOptions);c.fmatter.isUndefined(c("#"+b)[0].p.delOptions)||(e.delOptions=c("#"+b)[0].p.delOptions);var g=c("#"+b)[0],d=function(d){c.isFunction(e.afterRestore)&&e.afterRestore.call(g,d);c("tr#"+a+" div.ui-inline-edit, tr#"+a+" div.ui-inline-del","#"+b+".ui-jqgrid-btable:first").show();c("tr#"+a+" div.ui-inline-save, tr#"+a+" div.ui-inline-cancel","#"+b+".ui-jqgrid-btable:first").hide()};if(c("#"+a,"#"+b).hasClass("jqgrid-new-row")){var h=g.p.prmNames;e.extraparam[h.oper]=h.addoper}h={keys:e.keys,
oneditfunc:e.onEdit,successfunc:e.onSuccess,url:e.url,extraparam:e.extraparam,aftersavefunc:function(d,f){c.isFunction(e.afterSave)&&e.afterSave.call(g,d,f);c("tr#"+a+" div.ui-inline-edit, tr#"+a+" div.ui-inline-del","#"+b+".ui-jqgrid-btable:first").show();c("tr#"+a+" div.ui-inline-save, tr#"+a+" div.ui-inline-cancel","#"+b+".ui-jqgrid-btable:first").hide()},errorfunc:e.onError,afterrestorefunc:d,restoreAfterError:e.restoreAfterError,mtype:e.mtype};switch(f){case "edit":c("#"+b).jqGrid("editRow",
a,h);c("tr#"+a+" div.ui-inline-edit, tr#"+a+" div.ui-inline-del","#"+b+".ui-jqgrid-btable:first").hide();c("tr#"+a+" div.ui-inline-save, tr#"+a+" div.ui-inline-cancel","#"+b+".ui-jqgrid-btable:first").show();c(g).triggerHandler("jqGridAfterGridComplete");break;case "save":c("#"+b).jqGrid("saveRow",a,h)&&(c("tr#"+a+" div.ui-inline-edit, tr#"+a+" div.ui-inline-del","#"+b+".ui-jqgrid-btable:first").show(),c("tr#"+a+" div.ui-inline-save, tr#"+a+" div.ui-inline-cancel","#"+b+".ui-jqgrid-btable:first").hide(),
c(g).triggerHandler("jqGridAfterGridComplete"));break;case "cancel":c("#"+b).jqGrid("restoreRow",a,d);c("tr#"+a+" div.ui-inline-edit, tr#"+a+" div.ui-inline-del","#"+b+".ui-jqgrid-btable:first").show();c("tr#"+a+" div.ui-inline-save, tr#"+a+" div.ui-inline-cancel","#"+b+".ui-jqgrid-btable:first").hide();c(g).triggerHandler("jqGridAfterGridComplete");break;case "del":c("#"+b).jqGrid("delGridRow",a,e.delOptions);break;case "formedit":c("#"+b).jqGrid("setSelection",a),c("#"+b).jqGrid("editGridRow",a,
e.editOptions)}};c.fn.fmatter.actions=function(a,b){var f={keys:!1,editbutton:!0,delbutton:!0,editformbutton:!1};c.fmatter.isUndefined(b.colModel.formatoptions)||(f=c.extend(f,b.colModel.formatoptions));var d=b.rowId,e="",g;if("undefined"==typeof d||c.fmatter.isEmpty(d))return"";f.editformbutton?(g="onclick=jQuery.fn.fmatter.rowactions('"+d+"','"+b.gid+"','formedit',"+b.pos+"); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ",e=e+"<div title='"+
c.jgrid.nav.edittitle+"' style='float:left;cursor:pointer;' class='ui-pg-div ui-inline-edit' "+g+"><span class='ui-icon ui-icon-pencil'></span></div>"):f.editbutton&&(g="onclick=jQuery.fn.fmatter.rowactions('"+d+"','"+b.gid+"','edit',"+b.pos+"); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover') ",e=e+"<div title='"+c.jgrid.nav.edittitle+"' style='float:left;cursor:pointer;' class='ui-pg-div ui-inline-edit' "+g+"><span class='ui-icon ui-icon-pencil'></span></div>");
f.delbutton&&(g="onclick=jQuery.fn.fmatter.rowactions('"+d+"','"+b.gid+"','del',"+b.pos+"); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ",e=e+"<div title='"+c.jgrid.nav.deltitle+"' style='float:left;margin-left:5px;' class='ui-pg-div ui-inline-del' "+g+"><span class='ui-icon ui-icon-trash'></span></div>");g="onclick=jQuery.fn.fmatter.rowactions('"+d+"','"+b.gid+"','save',"+b.pos+"); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ";
e=e+"<div title='"+c.jgrid.edit.bSubmit+"' style='float:left;display:none' class='ui-pg-div ui-inline-save' "+g+"><span class='ui-icon ui-icon-disk'></span></div>";g="onclick=jQuery.fn.fmatter.rowactions('"+d+"','"+b.gid+"','cancel',"+b.pos+"); onmouseover=jQuery(this).addClass('ui-state-hover'); onmouseout=jQuery(this).removeClass('ui-state-hover'); ";e=e+"<div title='"+c.jgrid.edit.bCancel+"' style='float:left;display:none;margin-left:5px;' class='ui-pg-div ui-inline-cancel' "+g+"><span class='ui-icon ui-icon-cancel'></span></div>";
return"<div style='margin-left:8px;'>"+e+"</div>"};c.unformat=function(a,b,f,d){var e,g=b.colModel.formatter,h=b.colModel.formatoptions||{},i=/([\.\*\_\'\(\)\{\}\+\?\\])/g,j=b.colModel.unformat||c.fn.fmatter[g]&&c.fn.fmatter[g].unformat;if("undefined"!==typeof j&&c.isFunction(j))e=j.call(this,c(a).text(),b,a);else if(!c.fmatter.isUndefined(g)&&c.fmatter.isString(g))switch(e=c.jgrid.formatter||{},g){case "integer":h=c.extend({},e.integer,h);b=h.thousandsSeparator.replace(i,"\\$1");b=RegExp(b,"g");
e=c(a).text().replace(b,"");break;case "number":h=c.extend({},e.number,h);b=h.thousandsSeparator.replace(i,"\\$1");b=RegExp(b,"g");e=c(a).text().replace(b,"").replace(h.decimalSeparator,".");break;case "currency":h=c.extend({},e.currency,h);b=h.thousandsSeparator.replace(i,"\\$1");b=RegExp(b,"g");e=c(a).text();h.prefix&&h.prefix.length&&(e=e.substr(h.prefix.length));h.suffix&&h.suffix.length&&(e=e.substr(0,e.length-h.suffix.length));e=e.replace(b,"").replace(h.decimalSeparator,".");break;case "checkbox":h=
b.colModel.editoptions?b.colModel.editoptions.value.split(":"):["Yes","No"];e=c("input",a).is(":checked")?h[0]:h[1];break;case "select":e=c.unformat.select(a,b,f,d);break;case "actions":return"";default:e=c(a).text()}return void 0!==e?e:!0===d?c(a).text():c.jgrid.htmlDecode(c(a).html())};c.unformat.select=function(a,b,f,d){f=[];a=c(a).text();if(!0===d)return a;var d=c.extend({},!c.fmatter.isUndefined(b.colModel.formatoptions)?b.colModel.formatoptions:b.colModel.editoptions),b=void 0===d.separator?
":":d.separator,e=void 0===d.delimiter?";":d.delimiter;if(d.value){var g=d.value,d=!0===d.multiple?!0:!1,h=[];d&&(h=a.split(","),h=c.map(h,function(a){return c.trim(a)}));if(c.fmatter.isString(g))for(var i=g.split(e),j=0,k=0;k<i.length;k++)if(e=i[k].split(b),2<e.length&&(e[1]=c.map(e,function(a,b){if(b>0)return a}).join(b)),d)-1<c.inArray(e[1],h)&&(f[j]=e[0],j++);else{if(c.trim(e[1])==c.trim(a)){f[0]=e[0];break}}else if(c.fmatter.isObject(g)||c.isArray(g))d||(h[0]=a),f=c.map(h,function(a){var b;c.each(g,
function(c,d){if(d==a){b=c;return false}});if(typeof b!="undefined")return b});return f.join(", ")}return a||""};c.unformat.date=function(a,b){var f=c.jgrid.formatter.date||{};c.fmatter.isUndefined(b.formatoptions)||(f=c.extend({},f,b.formatoptions));return!c.fmatter.isEmpty(a)?c.fmatter.util.DateFormat(f.newformat,a,f.srcformat,f):c.fn.fmatter.defaultFormat(a,b)}})(jQuery);
(function(a){a.jgrid.extend({getColProp:function(a){var d={},c=this[0];if(!c.grid)return!1;for(var c=c.p.colModel,e=0;e<c.length;e++)if(c[e].name==a){d=c[e];break}return d},setColProp:function(b,d){return this.each(function(){if(this.grid&&d)for(var c=this.p.colModel,e=0;e<c.length;e++)if(c[e].name==b){a.extend(this.p.colModel[e],d);break}})},sortGrid:function(a,d,c){return this.each(function(){var e=-1;if(this.grid){a||(a=this.p.sortname);for(var h=0;h<this.p.colModel.length;h++)if(this.p.colModel[h].index==
a||this.p.colModel[h].name==a){e=h;break}-1!=e&&(h=this.p.colModel[e].sortable,"boolean"!==typeof h&&(h=!0),"boolean"!==typeof d&&(d=!1),h&&this.sortData("jqgh_"+this.p.id+"_"+a,e,d,c))}})},GridDestroy:function(){return this.each(function(){if(this.grid){this.p.pager&&a(this.p.pager).remove();try{a("#gbox_"+a.jgrid.jqID(this.id)).remove()}catch(b){}}})},GridUnload:function(){return this.each(function(){if(this.grid){var b=a(this).attr("id"),d=a(this).attr("class");this.p.pager&&a(this.p.pager).empty().removeClass("ui-state-default ui-jqgrid-pager corner-bottom");
var c=document.createElement("table");a(c).attr({id:b});c.className=d;b=a.jgrid.jqID(this.id);a(c).removeClass("ui-jqgrid-btable");1===a(this.p.pager).parents("#gbox_"+b).length?(a(c).insertBefore("#gbox_"+b).show(),a(this.p.pager).insertBefore("#gbox_"+b)):a(c).insertBefore("#gbox_"+b).show();a("#gbox_"+b).remove()}})},setGridState:function(b){return this.each(function(){this.grid&&("hidden"==b?(a(".ui-jqgrid-bdiv, .ui-jqgrid-hdiv","#gview_"+a.jgrid.jqID(this.p.id)).slideUp("fast"),this.p.pager&&
a(this.p.pager).slideUp("fast"),this.p.toppager&&a(this.p.toppager).slideUp("fast"),!0===this.p.toolbar[0]&&("both"==this.p.toolbar[1]&&a(this.grid.ubDiv).slideUp("fast"),a(this.grid.uDiv).slideUp("fast")),this.p.footerrow&&a(".ui-jqgrid-sdiv","#gbox_"+a.jgrid.jqID(this.p.id)).slideUp("fast"),a(".ui-jqgrid-titlebar-close span",this.grid.cDiv).removeClass("ui-icon-circle-triangle-n").addClass("ui-icon-circle-triangle-s"),this.p.gridstate="hidden"):"visible"==b&&(a(".ui-jqgrid-hdiv, .ui-jqgrid-bdiv",
"#gview_"+a.jgrid.jqID(this.p.id)).slideDown("fast"),this.p.pager&&a(this.p.pager).slideDown("fast"),this.p.toppager&&a(this.p.toppager).slideDown("fast"),!0===this.p.toolbar[0]&&("both"==this.p.toolbar[1]&&a(this.grid.ubDiv).slideDown("fast"),a(this.grid.uDiv).slideDown("fast")),this.p.footerrow&&a(".ui-jqgrid-sdiv","#gbox_"+a.jgrid.jqID(this.p.id)).slideDown("fast"),a(".ui-jqgrid-titlebar-close span",this.grid.cDiv).removeClass("ui-icon-circle-triangle-s").addClass("ui-icon-circle-triangle-n"),
this.p.gridstate="visible"))})},filterToolbar:function(b){b=a.extend({autosearch:!0,searchOnEnter:!0,beforeSearch:null,afterSearch:null,beforeClear:null,afterClear:null,searchurl:"",stringResult:!1,groupOp:"AND",defaultSearch:"bw"},b||{});return this.each(function(){function d(b,c){var d=a(b);d[0]&&jQuery.each(c,function(){void 0!==this.data?d.bind(this.type,this.data,this.fn):d.bind(this.type,this.fn)})}var c=this;if(!this.ftoolbar){var e=function(){var d={},j=0,g,f,h={},m;a.each(c.p.colModel,function(){f=
this.index||this.name;m=this.searchoptions&&this.searchoptions.sopt?this.searchoptions.sopt[0]:"select"==this.stype?"eq":b.defaultSearch;if(g=a("#gs_"+a.jgrid.jqID(this.name),!0===this.frozen&&!0===c.p.frozenColumns?c.grid.fhDiv:c.grid.hDiv).val())d[f]=g,h[f]=m,j++;else try{delete c.p.postData[f]}catch(e){}});var e=0<j?!0:!1;if(!0===b.stringResult||"local"==c.p.datatype){var k='{"groupOp":"'+b.groupOp+'","rules":[',l=0;a.each(d,function(a,b){0<l&&(k+=",");k+='{"field":"'+a+'",';k+='"op":"'+h[a]+'",';
k+='"data":"'+(b+"").replace(/\\/g,"\\\\").replace(/\"/g,'\\"')+'"}';l++});k+="]}";a.extend(c.p.postData,{filters:k});a.each(["searchField","searchString","searchOper"],function(a,b){c.p.postData.hasOwnProperty(b)&&delete c.p.postData[b]})}else a.extend(c.p.postData,d);var p;c.p.searchurl&&(p=c.p.url,a(c).jqGrid("setGridParam",{url:c.p.searchurl}));var r="stop"===a(c).triggerHandler("jqGridToolbarBeforeSearch")?!0:!1;!r&&a.isFunction(b.beforeSearch)&&(r=b.beforeSearch.call(c));r||a(c).jqGrid("setGridParam",
{search:e}).trigger("reloadGrid",[{page:1}]);p&&a(c).jqGrid("setGridParam",{url:p});a(c).triggerHandler("jqGridToolbarAfterSearch");a.isFunction(b.afterSearch)&&b.afterSearch.call(c)},h=a("<tr class='ui-search-toolbar' role='rowheader'></tr>"),g;a.each(c.p.colModel,function(){var i=this,j,q,f,n;q=a("<th role='columnheader' class='ui-state-default ui-th-column ui-th-"+c.p.direction+"'></th>");j=a("<div style='width:100%;position:relative;height:100%;padding-right:0.3em;'></div>");!0===this.hidden&&
a(q).css("display","none");this.search=!1===this.search?!1:!0;"undefined"==typeof this.stype&&(this.stype="text");f=a.extend({},this.searchoptions||{});if(this.search)switch(this.stype){case "select":if(n=this.surl||f.dataUrl)a.ajax(a.extend({url:n,dataType:"html",success:function(c){if(f.buildSelect!==void 0)(c=f.buildSelect(c))&&a(j).append(c);else a(j).append(c);f.defaultValue!==void 0&&a("select",j).val(f.defaultValue);a("select",j).attr({name:i.index||i.name,id:"gs_"+i.name});f.attr&&a("select",
j).attr(f.attr);a("select",j).css({width:"100%"});f.dataInit!==void 0&&f.dataInit(a("select",j)[0]);f.dataEvents!==void 0&&d(a("select",j)[0],f.dataEvents);b.autosearch===true&&a("select",j).change(function(){e();return false});c=null}},a.jgrid.ajaxOptions,c.p.ajaxSelectOptions||{}));else{var m,o,k;i.searchoptions?(m=void 0===i.searchoptions.value?"":i.searchoptions.value,o=void 0===i.searchoptions.separator?":":i.searchoptions.separator,k=void 0===i.searchoptions.delimiter?";":i.searchoptions.delimiter):
i.editoptions&&(m=void 0===i.editoptions.value?"":i.editoptions.value,o=void 0===i.editoptions.separator?":":i.editoptions.separator,k=void 0===i.editoptions.delimiter?";":i.editoptions.delimiter);if(m){n=document.createElement("select");n.style.width="100%";a(n).attr({name:i.index||i.name,id:"gs_"+i.name});var l;if("string"===typeof m){m=m.split(k);for(var p=0;p<m.length;p++)l=m[p].split(o),k=document.createElement("option"),k.value=l[0],k.innerHTML=l[1],n.appendChild(k)}else if("object"===typeof m)for(l in m)m.hasOwnProperty(l)&&
(k=document.createElement("option"),k.value=l,k.innerHTML=m[l],n.appendChild(k));void 0!==f.defaultValue&&a(n).val(f.defaultValue);f.attr&&a(n).attr(f.attr);void 0!==f.dataInit&&f.dataInit(n);void 0!==f.dataEvents&&d(n,f.dataEvents);a(j).append(n);!0===b.autosearch&&a(n).change(function(){e();return false})}}break;case "text":o=void 0!==f.defaultValue?f.defaultValue:"",a(j).append("<input type='text' style='width:95%;padding:0px;' name='"+(i.index||i.name)+"' id='gs_"+i.name+"' value='"+o+"'/>"),
f.attr&&a("input",j).attr(f.attr),void 0!==f.dataInit&&f.dataInit(a("input",j)[0]),void 0!==f.dataEvents&&d(a("input",j)[0],f.dataEvents),!0===b.autosearch&&(b.searchOnEnter?a("input",j).keypress(function(a){if((a.charCode?a.charCode:a.keyCode?a.keyCode:0)==13){e();return false}return this}):a("input",j).keydown(function(a){switch(a.which){case 13:return false;case 9:case 16:case 37:case 38:case 39:case 40:case 27:break;default:g&&clearTimeout(g);g=setTimeout(function(){e()},500)}}))}a(q).append(j);
a(h).append(q)});a("table thead",c.grid.hDiv).append(h);this.ftoolbar=!0;this.triggerToolbar=e;this.clearToolbar=function(d){var j={},g=0,f,d="boolean"!=typeof d?!0:d;a.each(c.p.colModel,function(){var b;this.searchoptions&&void 0!==this.searchoptions.defaultValue&&(b=this.searchoptions.defaultValue);f=this.index||this.name;switch(this.stype){case "select":a("#gs_"+a.jgrid.jqID(this.name)+" option",!0===this.frozen&&!0===c.p.frozenColumns?c.grid.fhDiv:c.grid.hDiv).each(function(c){if(c===0)this.selected=
true;if(a(this).val()==b){this.selected=true;return false}});if(void 0!==b)j[f]=b,g++;else try{delete c.p.postData[f]}catch(d){}break;case "text":if(a("#gs_"+a.jgrid.jqID(this.name),!0===this.frozen&&!0===c.p.frozenColumns?c.grid.fhDiv:c.grid.hDiv).val(b),void 0!==b)j[f]=b,g++;else try{delete c.p.postData[f]}catch(e){}}});var h=0<g?!0:!1;if(!0===b.stringResult||"local"==c.p.datatype){var e='{"groupOp":"'+b.groupOp+'","rules":[',o=0;a.each(j,function(a,b){0<o&&(e+=",");e+='{"field":"'+a+'",';e+='"op":"eq",';
e+='"data":"'+(b+"").replace(/\\/g,"\\\\").replace(/\"/g,'\\"')+'"}';o++});e+="]}";a.extend(c.p.postData,{filters:e});a.each(["searchField","searchString","searchOper"],function(a,b){c.p.postData.hasOwnProperty(b)&&delete c.p.postData[b]})}else a.extend(c.p.postData,j);var k;c.p.searchurl&&(k=c.p.url,a(c).jqGrid("setGridParam",{url:c.p.searchurl}));var l="stop"===a(c).triggerHandler("jqGridToolbarBeforeClear")?!0:!1;!l&&a.isFunction(b.beforeClear)&&(l=b.beforeClear.call(c));l||d&&a(c).jqGrid("setGridParam",
{search:h}).trigger("reloadGrid",[{page:1}]);k&&a(c).jqGrid("setGridParam",{url:k});a(c).triggerHandler("jqGridToolbarAfterClear");a.isFunction(b.afterClear)&&b.afterClear()};this.toggleToolbar=function(){var b=a("tr.ui-search-toolbar",c.grid.hDiv),d=!0===c.p.frozenColumns?a("tr.ui-search-toolbar",c.grid.fhDiv):!1;"none"==b.css("display")?(b.show(),d&&d.show()):(b.hide(),d&&d.hide())}}})},destroyGroupHeader:function(b){"undefined"==typeof b&&(b=!0);return this.each(function(){var d,c,e,h,g,i;c=this.grid;
var j=a("table.ui-jqgrid-htable thead",c.hDiv),q=this.p.colModel;if(c){a(this).unbind(".setGroupHeaders");d=a("<tr>",{role:"rowheader"}).addClass("ui-jqgrid-labels");h=c.headers;c=0;for(e=h.length;c<e;c++){g=q[c].hidden?"none":"";g=a(h[c].el).width(h[c].width).css("display",g);try{g.removeAttr("rowSpan")}catch(f){g.attr("rowSpan",1)}d.append(g);i=g.children("span.ui-jqgrid-resize");0<i.length&&(i[0].style.height="");g.children("div")[0].style.top=""}a(j).children("tr.ui-jqgrid-labels").remove();a(j).prepend(d);
!0===b&&a(this).jqGrid("setGridParam",{groupHeader:null})}})},setGroupHeaders:function(b){b=a.extend({useColSpanStyle:!1,groupHeaders:[]},b||{});return this.each(function(){this.p.groupHeader=b;var d,c,e=0,h,g,i,j,q,f=this.p.colModel,n=f.length,m=this.grid.headers,o=a("table.ui-jqgrid-htable",this.grid.hDiv),k=o.children("thead").children("tr.ui-jqgrid-labels:last").addClass("jqg-second-row-header");h=o.children("thead");var l=o.find(".jqg-first-row-header");null===l.html()?l=a("<tr>",{role:"row",
"aria-hidden":"true"}).addClass("jqg-first-row-header").css("height","auto"):l.empty();var p,r=function(a,b){for(var c=0,d=b.length;c<d;c++)if(b[c].startColumnName===a)return c;return-1};a(this).prepend(h);h=a("<tr>",{role:"rowheader"}).addClass("ui-jqgrid-labels jqg-third-row-header");for(d=0;d<n;d++)if(i=m[d].el,j=a(i),c=f[d],g={height:"0px",width:m[d].width+"px",display:c.hidden?"none":""},a("<th>",{role:"gridcell"}).css(g).addClass("ui-first-th-"+this.p.direction).appendTo(l),i.style.width="",
g=r(c.name,b.groupHeaders),0<=g){g=b.groupHeaders[g];e=g.numberOfColumns;q=g.titleText;for(g=c=0;g<e&&d+g<n;g++)f[d+g].hidden||c++;g=a("<th>").attr({role:"columnheader"}).addClass("ui-state-default ui-th-column-header ui-th-"+this.p.direction).css({height:"22px","border-top":"0px none"}).html(q);0<c&&g.attr("colspan",""+c);this.p.headertitles&&g.attr("title",g.text());0===c&&g.hide();j.before(g);h.append(i);e-=1}else 0===e?b.useColSpanStyle?j.attr("rowspan","2"):(a("<th>",{role:"columnheader"}).addClass("ui-state-default ui-th-column-header ui-th-"+
this.p.direction).css({display:c.hidden?"none":"","border-top":"0px none"}).insertBefore(j),h.append(i)):(h.append(i),e--);f=a(this).children("thead");f.prepend(l);h.insertAfter(k);o.append(f);b.useColSpanStyle&&(o.find("span.ui-jqgrid-resize").each(function(){var b=a(this).parent();b.is(":visible")&&(this.style.cssText="height: "+b.height()+"px !important; cursor: col-resize;")}),o.find("div.ui-jqgrid-sortable").each(function(){var b=a(this),c=b.parent();c.is(":visible")&&c.is(":has(span.ui-jqgrid-resize)")&&
b.css("top",(c.height()-b.outerHeight())/2+"px")}));p=f.find("tr.jqg-first-row-header");a(this).bind("jqGridResizeStop.setGroupHeaders",function(a,b,c){p.find("th").eq(c).width(b)})})},setFrozenColumns:function(){return this.each(function(){if(this.grid){var b=this,d=b.p.colModel,c=0,e=d.length,h=-1,g=!1;if(!(!0===b.p.subGrid||!0===b.p.treeGrid||!0===b.p.cellEdit||b.p.sortable||b.p.scroll||b.p.grouping)){b.p.rownumbers&&c++;for(b.p.multiselect&&c++;c<e;){if(!0===d[c].frozen)g=!0,h=c;else break;c++}if(0<=
h&&g){d=b.p.caption?a(b.grid.cDiv).outerHeight():0;c=a(".ui-jqgrid-htable","#gview_"+a.jgrid.jqID(b.p.id)).height();b.p.toppager&&(d+=a(b.grid.topDiv).outerHeight());!0===b.p.toolbar[0]&&"bottom"!=b.p.toolbar[1]&&(d+=a(b.grid.uDiv).outerHeight());b.grid.fhDiv=a('<div style="position:absolute;left:0px;top:'+d+"px;height:"+c+'px;" class="frozen-div ui-state-default ui-jqgrid-hdiv"></div>');b.grid.fbDiv=a('<div style="position:absolute;left:0px;top:'+(parseInt(d,10)+parseInt(c,10)+1)+'px;overflow-y:hidden" class="frozen-bdiv ui-jqgrid-bdiv"></div>');
a("#gview_"+a.jgrid.jqID(b.p.id)).append(b.grid.fhDiv);d=a(".ui-jqgrid-htable","#gview_"+a.jgrid.jqID(b.p.id)).clone(!0);if(b.p.groupHeader){a("tr.jqg-first-row-header, tr.jqg-third-row-header",d).each(function(){a("th:gt("+h+")",this).remove()});var i=-1,j=-1;a("tr.jqg-second-row-header th",d).each(function(){var b=parseInt(a(this).attr("colspan"),10);b&&(i+=b,j++);if(i===h)return!1});i!==h&&(j=h);a("tr.jqg-second-row-header",d).each(function(){a("th:gt("+j+")",this).remove()})}else a("tr",d).each(function(){a("th:gt("+
h+")",this).remove()});a(d).width(1);a(b.grid.fhDiv).append(d).mousemove(function(a){if(b.grid.resizing)return b.grid.dragMove(a),!1});a(b).bind("jqGridResizeStop.setFrozenColumns",function(c,d,e){c=a(".ui-jqgrid-htable",b.grid.fhDiv);a("th:eq("+e+")",c).width(d);c=a(".ui-jqgrid-btable",b.grid.fbDiv);a("tr:first td:eq("+e+")",c).width(d)});a(b).bind("jqGridOnSortCol.setFrozenColumns",function(c,d){var e=a("tr.ui-jqgrid-labels:last th:eq("+b.p.lastsort+")",b.grid.fhDiv),g=a("tr.ui-jqgrid-labels:last th:eq("+
d+")",b.grid.fhDiv);a("span.ui-grid-ico-sort",e).addClass("ui-state-disabled");a(e).attr("aria-selected","false");a("span.ui-icon-"+b.p.sortorder,g).removeClass("ui-state-disabled");a(g).attr("aria-selected","true");!b.p.viewsortcols[0]&&b.p.lastsort!=d&&(a("span.s-ico",e).hide(),a("span.s-ico",g).show())});a("#gview_"+a.jgrid.jqID(b.p.id)).append(b.grid.fbDiv);jQuery(b.grid.bDiv).scroll(function(){jQuery(b.grid.fbDiv).scrollTop(jQuery(this).scrollTop())});!0===b.p.hoverrows&&a("#"+a.jgrid.jqID(b.p.id)).unbind("mouseover").unbind("mouseout");
a(b).bind("jqGridAfterGridComplete.setFrozenColumns",function(){a("#"+a.jgrid.jqID(b.p.id)+"_frozen").remove();jQuery(b.grid.fbDiv).height(jQuery(b.grid.bDiv).height()-16);var c=a("#"+a.jgrid.jqID(b.p.id)).clone(!0);a("tr",c).each(function(){a("td:gt("+h+")",this).remove()});a(c).width(1).attr("id",b.p.id+"_frozen");a(b.grid.fbDiv).append(c);!0===b.p.hoverrows&&(a("tr.jqgrow",c).hover(function(){a(this).addClass("ui-state-hover");a("#"+a.jgrid.jqID(this.id),"#"+a.jgrid.jqID(b.p.id)).addClass("ui-state-hover")},
function(){a(this).removeClass("ui-state-hover");a("#"+a.jgrid.jqID(this.id),"#"+a.jgrid.jqID(b.p.id)).removeClass("ui-state-hover")}),a("tr.jqgrow","#"+a.jgrid.jqID(b.p.id)).hover(function(){a(this).addClass("ui-state-hover");a("#"+a.jgrid.jqID(this.id),"#"+a.jgrid.jqID(b.p.id)+"_frozen").addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover");a("#"+a.jgrid.jqID(this.id),"#"+a.jgrid.jqID(b.p.id)+"_frozen").removeClass("ui-state-hover")}));c=null});b.p.frozenColumns=!0}}}})},
destroyFrozenColumns:function(){return this.each(function(){if(this.grid&&!0===this.p.frozenColumns){a(this.grid.fhDiv).remove();a(this.grid.fbDiv).remove();this.grid.fhDiv=null;this.grid.fbDiv=null;a(this).unbind(".setFrozenColumns");if(!0===this.p.hoverrows){var b;a("#"+a.jgrid.jqID(this.p.id)).bind("mouseover",function(d){b=a(d.target).closest("tr.jqgrow");"ui-subgrid"!==a(b).attr("class")&&a(b).addClass("ui-state-hover")}).bind("mouseout",function(d){b=a(d.target).closest("tr.jqgrow");a(b).removeClass("ui-state-hover")})}this.p.frozenColumns=
!1}})}})})(jQuery);
(function(a){a.extend(a.jgrid,{showModal:function(a){a.w.show()},closeModal:function(a){a.w.hide().attr("aria-hidden","true");a.o&&a.o.remove()},hideModal:function(d,b){b=a.extend({jqm:!0,gb:""},b||{});if(b.onClose){var c=b.onClose(d);if("boolean"==typeof c&&!c)return}if(a.fn.jqm&&!0===b.jqm)a(d).attr("aria-hidden","true").jqmHide();else{if(""!==b.gb)try{a(".jqgrid-overlay:first",b.gb).hide()}catch(f){}a(d).hide().attr("aria-hidden","true")}},findPos:function(a){var b=0,c=0;if(a.offsetParent){do b+=
a.offsetLeft,c+=a.offsetTop;while(a=a.offsetParent)}return[b,c]},createModal:function(d,b,c,f,g,h,i){var e=document.createElement("div"),l,j=this,i=a.extend({},i||{});l="rtl"==a(c.gbox).attr("dir")?!0:!1;e.className="ui-widget ui-widget-content ui-corner-all ui-jqdialog";e.id=d.themodal;var k=document.createElement("div");k.className="ui-jqdialog-titlebar ui-widget-header ui-corner-all ui-helper-clearfix";k.id=d.modalhead;a(k).append("<span class='ui-jqdialog-title'>"+c.caption+"</span>");var n=a("<a href='javascript:void(0)' class='ui-jqdialog-titlebar-close ui-corner-all'></a>").hover(function(){n.addClass("ui-state-hover")},
function(){n.removeClass("ui-state-hover")}).append("<span class='ui-icon ui-icon-closethick'></span>");a(k).append(n);l?(e.dir="rtl",a(".ui-jqdialog-title",k).css("float","right"),a(".ui-jqdialog-titlebar-close",k).css("left","0.3em")):(e.dir="ltr",a(".ui-jqdialog-title",k).css("float","left"),a(".ui-jqdialog-titlebar-close",k).css("right","0.3em"));var m=document.createElement("div");a(m).addClass("ui-jqdialog-content ui-widget-content").attr("id",d.modalcontent);a(m).append(b);e.appendChild(m);
a(e).prepend(k);!0===h?a("body").append(e):"string"==typeof h?a(h).append(e):a(e).insertBefore(f);a(e).css(i);"undefined"===typeof c.jqModal&&(c.jqModal=!0);b={};if(a.fn.jqm&&!0===c.jqModal)0===c.left&&(0===c.top&&c.overlay)&&(i=[],i=a.jgrid.findPos(g),c.left=i[0]+4,c.top=i[1]+4),b.top=c.top+"px",b.left=c.left;else if(0!==c.left||0!==c.top)b.left=c.left,b.top=c.top+"px";a("a.ui-jqdialog-titlebar-close",k).click(function(){var b=a("#"+a.jgrid.jqID(d.themodal)).data("onClose")||c.onClose,e=a("#"+a.jgrid.jqID(d.themodal)).data("gbox")||
c.gbox;j.hideModal("#"+a.jgrid.jqID(d.themodal),{gb:e,jqm:c.jqModal,onClose:b});return false});if(0===c.width||!c.width)c.width=300;if(0===c.height||!c.height)c.height=200;c.zIndex||(f=a(f).parents("*[role=dialog]").filter(":first").css("z-index"),c.zIndex=f?parseInt(f,10)+2:950);f=0;l&&(b.left&&!h)&&(f=a(c.gbox).width()-(!isNaN(c.width)?parseInt(c.width,10):0)-8,b.left=parseInt(b.left,10)+parseInt(f,10));b.left&&(b.left+="px");a(e).css(a.extend({width:isNaN(c.width)?"auto":c.width+"px",height:isNaN(c.height)?
"auto":c.height+"px",zIndex:c.zIndex,overflow:"hidden"},b)).attr({tabIndex:"-1",role:"dialog","aria-labelledby":d.modalhead,"aria-hidden":"true"});"undefined"==typeof c.drag&&(c.drag=!0);"undefined"==typeof c.resize&&(c.resize=!0);if(c.drag)if(a(k).css("cursor","move"),a.fn.jqDrag)a(e).jqDrag(k);else try{a(e).draggable({handle:a("#"+a.jgrid.jqID(k.id))})}catch(o){}if(c.resize)if(a.fn.jqResize)a(e).append("<div class='jqResize ui-resizable-handle ui-resizable-se ui-icon ui-icon-gripsmall-diagonal-se ui-icon-grip-diagonal-se'></div>"),
a("#"+a.jgrid.jqID(d.themodal)).jqResize(".jqResize",d.scrollelm?"#"+a.jgrid.jqID(d.scrollelm):!1);else try{a(e).resizable({handles:"se, sw",alsoResize:d.scrollelm?"#"+a.jgrid.jqID(d.scrollelm):!1})}catch(p){}!0===c.closeOnEscape&&a(e).keydown(function(b){if(b.which==27){b=a("#"+a.jgrid.jqID(d.themodal)).data("onClose")||c.onClose;j.hideModal(this,{gb:c.gbox,jqm:c.jqModal,onClose:b})}})},viewModal:function(d,b){b=a.extend({toTop:!0,overlay:10,modal:!1,overlayClass:"ui-widget-overlay",onShow:a.jgrid.showModal,
onHide:a.jgrid.closeModal,gbox:"",jqm:!0,jqM:!0},b||{});if(a.fn.jqm&&!0===b.jqm)b.jqM?a(d).attr("aria-hidden","false").jqm(b).jqmShow():a(d).attr("aria-hidden","false").jqmShow();else{""!==b.gbox&&(a(".jqgrid-overlay:first",b.gbox).show(),a(d).data("gbox",b.gbox));a(d).show().attr("aria-hidden","false");try{a(":input:visible",d)[0].focus()}catch(c){}}},info_dialog:function(d,b,c,f){var g={width:290,height:"auto",dataheight:"auto",drag:!0,resize:!1,caption:"<b>"+d+"</b>",left:250,top:170,zIndex:1E3,
jqModal:!0,modal:!1,closeOnEscape:!0,align:"center",buttonalign:"center",buttons:[]};a.extend(g,f||{});var h=g.jqModal,i=this;a.fn.jqm&&!h&&(h=!1);d="";if(0<g.buttons.length)for(f=0;f<g.buttons.length;f++)"undefined"==typeof g.buttons[f].id&&(g.buttons[f].id="info_button_"+f),d+="<a href='javascript:void(0)' id='"+g.buttons[f].id+"' class='fm-button ui-state-default ui-corner-all'>"+g.buttons[f].text+"</a>";f=isNaN(g.dataheight)?g.dataheight:g.dataheight+"px";b="<div id='info_id'>"+("<div id='infocnt' style='margin:0px;padding-bottom:1em;width:100%;overflow:auto;position:relative;height:"+
f+";"+("text-align:"+g.align+";")+"'>"+b+"</div>");b+=c?"<div class='ui-widget-content ui-helper-clearfix' style='text-align:"+g.buttonalign+";padding-bottom:0.8em;padding-top:0.5em;background-image: none;border-width: 1px 0 0 0;'><a href='javascript:void(0)' id='closedialog' class='fm-button ui-state-default ui-corner-all'>"+c+"</a>"+d+"</div>":""!==d?"<div class='ui-widget-content ui-helper-clearfix' style='text-align:"+g.buttonalign+";padding-bottom:0.8em;padding-top:0.5em;background-image: none;border-width: 1px 0 0 0;'>"+
d+"</div>":"";b+="</div>";try{"false"==a("#info_dialog").attr("aria-hidden")&&a.jgrid.hideModal("#info_dialog",{jqm:h}),a("#info_dialog").remove()}catch(e){}a.jgrid.createModal({themodal:"info_dialog",modalhead:"info_head",modalcontent:"info_content",scrollelm:"infocnt"},b,g,"","",!0);d&&a.each(g.buttons,function(b){a("#"+a.jgrid.jqID(this.id),"#info_id").bind("click",function(){g.buttons[b].onClick.call(a("#info_dialog"));return!1})});a("#closedialog","#info_id").click(function(){i.hideModal("#info_dialog",
{jqm:h});return!1});a(".fm-button","#info_dialog").hover(function(){a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")});a.isFunction(g.beforeOpen)&&g.beforeOpen();a.jgrid.viewModal("#info_dialog",{onHide:function(a){a.w.hide().remove();a.o&&a.o.remove()},modal:g.modal,jqm:h});a.isFunction(g.afterOpen)&&g.afterOpen();try{a("#info_dialog").focus()}catch(l){}},createEl:function(d,b,c,f,g){function h(b,d){a.isFunction(d.dataInit)&&d.dataInit.call(l,b);d.dataEvents&&
a.each(d.dataEvents,function(){void 0!==this.data?a(b).bind(this.type,this.data,this.fn):a(b).bind(this.type,this.fn)});return d}function i(b,d,c){var e="dataInit dataEvents dataUrl buildSelect sopt searchhidden defaultValue attr".split(" ");"undefined"!=typeof c&&a.isArray(c)&&a.merge(e,c);a.each(d,function(d,c){-1===a.inArray(d,e)&&a(b).attr(d,c)});d.hasOwnProperty("id")||a(b).attr("id",a.jgrid.randId())}var e="",l=this;switch(d){case "textarea":e=document.createElement("textarea");f?b.cols||a(e).css({width:"98%"}):
b.cols||(b.cols=20);b.rows||(b.rows=2);if("&nbsp;"==c||"&#160;"==c||1==c.length&&160==c.charCodeAt(0))c="";e.value=c;i(e,b);b=h(e,b);a(e).attr({role:"textbox",multiline:"true"});break;case "checkbox":e=document.createElement("input");e.type="checkbox";b.value?(d=b.value.split(":"),c===d[0]&&(e.checked=!0,e.defaultChecked=!0),e.value=d[0],a(e).attr("offval",d[1])):(d=c.toLowerCase(),0>d.search(/(false|0|no|off|undefined)/i)&&""!==d?(e.checked=!0,e.defaultChecked=!0,e.value=c):e.value="on",a(e).attr("offval",
"off"));i(e,b,["value"]);b=h(e,b);a(e).attr("role","checkbox");break;case "select":e=document.createElement("select");e.setAttribute("role","select");f=[];!0===b.multiple?(d=!0,e.multiple="multiple",a(e).attr("aria-multiselectable","true")):d=!1;if("undefined"!=typeof b.dataUrl)a.ajax(a.extend({url:b.dataUrl,type:"GET",dataType:"html",context:{elem:e,options:b,vl:c},success:function(d){var b=[],c=this.elem,e=this.vl,f=a.extend({},this.options),g=f.multiple===true;a.isFunction(f.buildSelect)&&(d=f.buildSelect.call(l,
d));if(d=a(d).html()){a(c).append(d);i(c,f);f=h(c,f);if(typeof f.size==="undefined")f.size=g?3:1;if(g){b=e.split(",");b=a.map(b,function(b){return a.trim(b)})}else b[0]=a.trim(e);setTimeout(function(){a("option",c).each(function(d){if(d===0&&c.multiple)this.selected=false;a(this).attr("role","option");if(a.inArray(a.trim(a(this).text()),b)>-1||a.inArray(a.trim(a(this).val()),b)>-1)this.selected="selected"})},0)}}},g||{}));else if(b.value){var j;"undefined"===typeof b.size&&(b.size=d?3:1);d&&(f=c.split(","),
f=a.map(f,function(b){return a.trim(b)}));"function"===typeof b.value&&(b.value=b.value());var k,n,m=void 0===b.separator?":":b.separator,g=void 0===b.delimiter?";":b.delimiter;if("string"===typeof b.value){k=b.value.split(g);for(j=0;j<k.length;j++){n=k[j].split(m);2<n.length&&(n[1]=a.map(n,function(a,b){if(b>0)return a}).join(m));g=document.createElement("option");g.setAttribute("role","option");g.value=n[0];g.innerHTML=n[1];e.appendChild(g);if(!d&&(a.trim(n[0])==a.trim(c)||a.trim(n[1])==a.trim(c)))g.selected=
"selected";if(d&&(-1<a.inArray(a.trim(n[1]),f)||-1<a.inArray(a.trim(n[0]),f)))g.selected="selected"}}else if("object"===typeof b.value)for(j in m=b.value,m)if(m.hasOwnProperty(j)){g=document.createElement("option");g.setAttribute("role","option");g.value=j;g.innerHTML=m[j];e.appendChild(g);if(!d&&(a.trim(j)==a.trim(c)||a.trim(m[j])==a.trim(c)))g.selected="selected";if(d&&(-1<a.inArray(a.trim(m[j]),f)||-1<a.inArray(a.trim(j),f)))g.selected="selected"}i(e,b,["value"]);b=h(e,b)}break;case "text":case "password":case "button":j=
"button"==d?"button":"textbox";e=document.createElement("input");e.type=d;e.value=c;i(e,b);b=h(e,b);"button"!=d&&(f?b.size||a(e).css({width:"98%"}):b.size||(b.size=20));a(e).attr("role",j);break;case "image":case "file":e=document.createElement("input");e.type=d;i(e,b);b=h(e,b);break;case "custom":e=document.createElement("span");try{if(a.isFunction(b.custom_element))if(m=b.custom_element.call(l,c,b))m=a(m).addClass("customelement").attr({id:b.id,name:b.name}),a(e).empty().append(m);else throw"e2";
else throw"e1";}catch(o){"e1"==o&&a.jgrid.info_dialog(a.jgrid.errors.errcap,"function 'custom_element' "+a.jgrid.edit.msg.nodefined,a.jgrid.edit.bClose),"e2"==o?a.jgrid.info_dialog(a.jgrid.errors.errcap,"function 'custom_element' "+a.jgrid.edit.msg.novalue,a.jgrid.edit.bClose):a.jgrid.info_dialog(a.jgrid.errors.errcap,"string"===typeof o?o:o.message,a.jgrid.edit.bClose)}}return e},checkDate:function(a,b){var c={},f,a=a.toLowerCase();f=-1!=a.indexOf("/")?"/":-1!=a.indexOf("-")?"-":-1!=a.indexOf(".")?
".":"/";a=a.split(f);b=b.split(f);if(3!=b.length)return!1;f=-1;for(var g,h=-1,i=-1,e=0;e<a.length;e++)g=isNaN(b[e])?0:parseInt(b[e],10),c[a[e]]=g,g=a[e],-1!=g.indexOf("y")&&(f=e),-1!=g.indexOf("m")&&(i=e),-1!=g.indexOf("d")&&(h=e);g="y"==a[f]||"yyyy"==a[f]?4:"yy"==a[f]?2:-1;var e=function(a){for(var b=1;b<=a;b++){this[b]=31;if(4==b||6==b||9==b||11==b)this[b]=30;2==b&&(this[b]=29)}return this}(12),l;if(-1===f)return!1;l=c[a[f]].toString();2==g&&1==l.length&&(g=1);if(l.length!=g||0===c[a[f]]&&"00"!=
b[f]||-1===i)return!1;l=c[a[i]].toString();if(1>l.length||(1>c[a[i]]||12<c[a[i]])||-1===h)return!1;l=c[a[h]].toString();return 1>l.length||1>c[a[h]]||31<c[a[h]]||2==c[a[i]]&&c[a[h]]>(0===c[a[f]]%4&&(0!==c[a[f]]%100||0===c[a[f]]%400)?29:28)||c[a[h]]>e[c[a[i]]]?!1:!0},isEmpty:function(a){return a.match(/^\s+$/)||""===a?!0:!1},checkTime:function(d){var b=/^(\d{1,2}):(\d{2})([ap]m)?$/;if(!a.jgrid.isEmpty(d))if(d=d.match(b)){if(d[3]){if(1>d[1]||12<d[1])return!1}else if(23<d[1])return!1;if(59<d[2])return!1}else return!1;
return!0},checkValues:function(d,b,c,f,g){var h,i;if("undefined"===typeof f)if("string"==typeof b){f=0;for(g=c.p.colModel.length;f<g;f++)if(c.p.colModel[f].name==b){h=c.p.colModel[f].editrules;b=f;try{i=c.p.colModel[f].formoptions.label}catch(e){}break}}else 0<=b&&(h=c.p.colModel[b].editrules);else h=f,i=void 0===g?"_":g;if(h){i||(i=c.p.colNames[b]);if(!0===h.required&&a.jgrid.isEmpty(d))return[!1,i+": "+a.jgrid.edit.msg.required,""];f=!1===h.required?!1:!0;if(!0===h.number&&!(!1===f&&a.jgrid.isEmpty(d))&&
isNaN(d))return[!1,i+": "+a.jgrid.edit.msg.number,""];if("undefined"!=typeof h.minValue&&!isNaN(h.minValue)&&parseFloat(d)<parseFloat(h.minValue))return[!1,i+": "+a.jgrid.edit.msg.minValue+" "+h.minValue,""];if("undefined"!=typeof h.maxValue&&!isNaN(h.maxValue)&&parseFloat(d)>parseFloat(h.maxValue))return[!1,i+": "+a.jgrid.edit.msg.maxValue+" "+h.maxValue,""];if(!0===h.email&&!(!1===f&&a.jgrid.isEmpty(d))&&(g=/^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?$/i,
!g.test(d)))return[!1,i+": "+a.jgrid.edit.msg.email,""];if(!0===h.integer&&!(!1===f&&a.jgrid.isEmpty(d))&&(isNaN(d)||0!==d%1||-1!=d.indexOf(".")))return[!1,i+": "+a.jgrid.edit.msg.integer,""];if(!0===h.date&&!(!1===f&&a.jgrid.isEmpty(d))&&(b=c.p.colModel[b].formatoptions&&c.p.colModel[b].formatoptions.newformat?c.p.colModel[b].formatoptions.newformat:c.p.colModel[b].datefmt||"Y-m-d",!a.jgrid.checkDate(b,d)))return[!1,i+": "+a.jgrid.edit.msg.date+" - "+b,""];if(!0===h.time&&!(!1===f&&a.jgrid.isEmpty(d))&&
!a.jgrid.checkTime(d))return[!1,i+": "+a.jgrid.edit.msg.date+" - hh:mm (am/pm)",""];if(!0===h.url&&!(!1===f&&a.jgrid.isEmpty(d))&&(g=/^(((https?)|(ftp)):\/\/([\-\w]+\.)+\w{2,3}(\/[%\-\w]+(\.\w{2,})?)*(([\w\-\.\?\\\/+@&#;`~=%!]*)(\.\w{2,})?)*\/?)/i,!g.test(d)))return[!1,i+": "+a.jgrid.edit.msg.url,""];if(!0===h.custom&&!(!1===f&&a.jgrid.isEmpty(d)))return a.isFunction(h.custom_func)?(d=h.custom_func.call(c,d,i),a.isArray(d)?d:[!1,a.jgrid.edit.msg.customarray,""]):[!1,a.jgrid.edit.msg.customfcheck,
""]}return[!0,"",""]}})})(jQuery);
(function(a){var c={};a.jgrid.extend({searchGrid:function(c){c=a.extend({recreateFilter:!1,drag:!0,sField:"searchField",sValue:"searchString",sOper:"searchOper",sFilter:"filters",loadDefaults:!0,beforeShowSearch:null,afterShowSearch:null,onInitializeSearch:null,afterRedraw:null,afterChange:null,closeAfterSearch:!1,closeAfterReset:!1,closeOnEscape:!1,searchOnEnter:!1,multipleSearch:!1,multipleGroup:!1,top:0,left:0,jqModal:!0,modal:!1,resize:!0,width:450,height:"auto",dataheight:"auto",showQuery:!1,
errorcheck:!0,sopt:null,stringResult:void 0,onClose:null,onSearch:null,onReset:null,toTop:!0,overlay:30,columns:[],tmplNames:null,tmplFilters:null,tmplLabel:" Template: ",showOnLoad:!1,layer:null},a.jgrid.search,c||{});return this.each(function(){function d(b){r=a(e).triggerHandler("jqGridFilterBeforeShow",[b]);"undefined"===typeof r&&(r=!0);r&&a.isFunction(c.beforeShowSearch)&&(r=c.beforeShowSearch.call(e,b));r&&(a.jgrid.viewModal("#"+a.jgrid.jqID(t.themodal),{gbox:"#gbox_"+a.jgrid.jqID(l),jqm:c.jqModal,
modal:c.modal,overlay:c.overlay,toTop:c.toTop}),a(e).triggerHandler("jqGridFilterAfterShow",[b]),a.isFunction(c.afterShowSearch)&&c.afterShowSearch.call(e,b))}var e=this;if(e.grid){var l="fbox_"+e.p.id,r=!0,t={themodal:"searchmod"+l,modalhead:"searchhd"+l,modalcontent:"searchcnt"+l,scrollelm:l},s=e.p.postData[c.sFilter];"string"===typeof s&&(s=a.jgrid.parse(s));!0===c.recreateFilter&&a("#"+a.jgrid.jqID(t.themodal)).remove();if(null!==a("#"+a.jgrid.jqID(t.themodal)).html())d(a("#fbox_"+a.jgrid.jqID(+e.p.id)));
else{var p=a("<div><div id='"+l+"' class='searchFilter' style='overflow:auto'></div></div>").insertBefore("#gview_"+a.jgrid.jqID(e.p.id)),g="left",f="";"rtl"==e.p.direction&&(g="right",f=" style='text-align:left'",p.attr("dir","rtl"));var n=a.extend([],e.p.colModel),w="<a href='javascript:void(0)' id='"+l+"_search' class='fm-button ui-state-default ui-corner-all fm-button-icon-right ui-reset'><span class='ui-icon ui-icon-search'></span>"+c.Find+"</a>",b="<a href='javascript:void(0)' id='"+l+"_reset' class='fm-button ui-state-default ui-corner-all fm-button-icon-left ui-search'><span class='ui-icon ui-icon-arrowreturnthick-1-w'></span>"+
c.Reset+"</a>",m="",h="",k,j=!1,o=-1;c.showQuery&&(m="<a href='javascript:void(0)' id='"+l+"_query' class='fm-button ui-state-default ui-corner-all fm-button-icon-left'><span class='ui-icon ui-icon-comment'></span>Query</a>");c.columns.length?n=c.columns:a.each(n,function(a,b){if(!b.label)b.label=e.p.colNames[a];if(!j){var c=typeof b.search==="undefined"?true:b.search,d=b.hidden===true;if(b.searchoptions&&b.searchoptions.searchhidden===true&&c||c&&!d){j=true;k=b.index||b.name;o=a}}});if(!s&&k||!1===
c.multipleSearch){var y="eq";0<=o&&n[o].searchoptions&&n[o].searchoptions.sopt?y=n[o].searchoptions.sopt[0]:c.sopt&&c.sopt.length&&(y=c.sopt[0]);s={groupOp:"AND",rules:[{field:k,op:y,data:""}]}}j=!1;c.tmplNames&&c.tmplNames.length&&(j=!0,h=c.tmplLabel,h+="<select class='ui-template'>",h+="<option value='default'>Default</option>",a.each(c.tmplNames,function(a,b){h=h+("<option value='"+a+"'>"+b+"</option>")}),h+="</select>");g="<table class='EditTable' style='border:0px none;margin-top:5px' id='"+
l+"_2'><tbody><tr><td colspan='2'><hr class='ui-widget-content' style='margin:1px'/></td></tr><tr><td class='EditButton' style='text-align:"+g+"'>"+b+h+"</td><td class='EditButton' "+f+">"+m+w+"</td></tr></tbody></table>";l=a.jgrid.jqID(l);a("#"+l).jqFilter({columns:n,filter:c.loadDefaults?s:null,showQuery:c.showQuery,errorcheck:c.errorcheck,sopt:c.sopt,groupButton:c.multipleGroup,ruleButtons:c.multipleSearch,afterRedraw:c.afterRedraw,_gridsopt:a.jgrid.search.odata,ajaxSelectOptions:e.p.ajaxSelectOptions,
groupOps:c.groupOps,onChange:function(){this.p.showQuery&&a(".query",this).html(this.toUserFriendlyString());a.isFunction(c.afterChange)&&c.afterChange.call(e,a("#"+l),c)},direction:e.p.direction});p.append(g);j&&(c.tmplFilters&&c.tmplFilters.length)&&a(".ui-template",p).bind("change",function(){var b=a(this).val();b=="default"?a("#"+l).jqFilter("addFilter",s):a("#"+l).jqFilter("addFilter",c.tmplFilters[parseInt(b,10)]);return false});!0===c.multipleGroup&&(c.multipleSearch=!0);a(e).triggerHandler("jqGridFilterInitialize",
[a("#"+l)]);a.isFunction(c.onInitializeSearch)&&c.onInitializeSearch.call(e,a("#"+l));c.gbox="#gbox_"+l;c.layer?a.jgrid.createModal(t,p,c,"#gview_"+a.jgrid.jqID(e.p.id),a("#gbox_"+a.jgrid.jqID(e.p.id))[0],"#"+a.jgrid.jqID(c.layer),{position:"relative"}):a.jgrid.createModal(t,p,c,"#gview_"+a.jgrid.jqID(e.p.id),a("#gbox_"+a.jgrid.jqID(e.p.id))[0]);(c.searchOnEnter||c.closeOnEscape)&&a("#"+a.jgrid.jqID(t.themodal)).keydown(function(b){var d=a(b.target);if(c.searchOnEnter&&b.which===13&&!d.hasClass("add-group")&&
!d.hasClass("add-rule")&&!d.hasClass("delete-group")&&!d.hasClass("delete-rule")&&(!d.hasClass("fm-button")||!d.is("[id$=_query]"))){a("#"+l+"_search").focus().click();return false}if(c.closeOnEscape&&b.which===27){a("#"+a.jgrid.jqID(t.modalhead)).find(".ui-jqdialog-titlebar-close").focus().click();return false}});m&&a("#"+l+"_query").bind("click",function(){a(".queryresult",p).toggle();return false});void 0===c.stringResult&&(c.stringResult=c.multipleSearch);a("#"+l+"_search").bind("click",function(){var b=
a("#"+l),d={},h,q=b.jqFilter("filterData");if(c.errorcheck){b[0].hideError();c.showQuery||b.jqFilter("toSQLString");if(b[0].p.error){b[0].showError();return false}}if(c.stringResult){try{h=xmlJsonClass.toJson(q,"","",false)}catch(f){try{h=JSON.stringify(q)}catch(g){}}if(typeof h==="string"){d[c.sFilter]=h;a.each([c.sField,c.sValue,c.sOper],function(){d[this]=""})}}else if(c.multipleSearch){d[c.sFilter]=q;a.each([c.sField,c.sValue,c.sOper],function(){d[this]=""})}else{d[c.sField]=q.rules[0].field;
d[c.sValue]=q.rules[0].data;d[c.sOper]=q.rules[0].op;d[c.sFilter]=""}e.p.search=true;a.extend(e.p.postData,d);a(e).triggerHandler("jqGridFilterSearch");a.isFunction(c.onSearch)&&c.onSearch.call(e);a(e).trigger("reloadGrid",[{page:1}]);c.closeAfterSearch&&a.jgrid.hideModal("#"+a.jgrid.jqID(t.themodal),{gb:"#gbox_"+a.jgrid.jqID(e.p.id),jqm:c.jqModal,onClose:c.onClose});return false});a("#"+l+"_reset").bind("click",function(){var b={},d=a("#"+l);e.p.search=false;c.multipleSearch===false?b[c.sField]=
b[c.sValue]=b[c.sOper]="":b[c.sFilter]="";d[0].resetFilter();j&&a(".ui-template",p).val("default");a.extend(e.p.postData,b);a(e).triggerHandler("jqGridFilterReset");a.isFunction(c.onReset)&&c.onReset.call(e);a(e).trigger("reloadGrid",[{page:1}]);return false});d(a("#"+l));a(".fm-button:not(.ui-state-disabled)",p).hover(function(){a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")})}}})},editGridRow:function(u,d){d=a.extend({top:0,left:0,width:300,height:"auto",dataheight:"auto",
modal:!1,overlay:30,drag:!0,resize:!0,url:null,mtype:"POST",clearAfterAdd:!0,closeAfterEdit:!1,reloadAfterSubmit:!0,onInitializeForm:null,beforeInitData:null,beforeShowForm:null,afterShowForm:null,beforeSubmit:null,afterSubmit:null,onclickSubmit:null,afterComplete:null,onclickPgButtons:null,afterclickPgButtons:null,editData:{},recreateForm:!1,jqModal:!0,closeOnEscape:!1,addedrow:"first",topinfo:"",bottominfo:"",saveicon:[],closeicon:[],savekey:[!1,13],navkeys:[!1,38,40],checkOnSubmit:!1,checkOnUpdate:!1,
_savedData:{},processing:!1,onClose:null,ajaxEditOptions:{},serializeEditData:null,viewPagerButtons:!0},a.jgrid.edit,d||{});c[a(this)[0].p.id]=d;return this.each(function(){function e(){a(j+" > tbody > tr > td > .FormElement").each(function(){var d=a(".customelement",this);if(d.length){var c=a(d[0]).attr("name");a.each(b.p.colModel,function(){if(this.name===c&&this.editoptions&&a.isFunction(this.editoptions.custom_value)){try{if(i[c]=this.editoptions.custom_value.call(b,a("#"+a.jgrid.jqID(c),j),"get"),
void 0===i[c])throw"e1";}catch(d){"e1"===d?a.jgrid.info_dialog(jQuery.jgrid.errors.errcap,"function 'custom_value' "+a.jgrid.edit.msg.novalue,jQuery.jgrid.edit.bClose):a.jgrid.info_dialog(jQuery.jgrid.errors.errcap,d.message,jQuery.jgrid.edit.bClose)}return!0}})}else{switch(a(this).get(0).type){case "checkbox":a(this).is(":checked")?i[this.name]=a(this).val():(d=a(this).attr("offval"),i[this.name]=d);break;case "select-one":i[this.name]=a("option:selected",this).val();B[this.name]=a("option:selected",
this).text();break;case "select-multiple":i[this.name]=a(this).val();i[this.name]=i[this.name]?i[this.name].join(","):"";var e=[];a("option:selected",this).each(function(b,d){e[b]=a(d).text()});B[this.name]=e.join(",");break;case "password":case "text":case "textarea":case "button":i[this.name]=a(this).val()}b.p.autoencode&&(i[this.name]=a.jgrid.htmlEncode(i[this.name]))}});return!0}function l(d,e,h,q){var i,f,g,k=0,j,o,l,p=[],n=!1,u="",m;for(m=1;m<=q;m++)u+="<td class='CaptionTD'>&#160;</td><td class='DataTD'>&#160;</td>";
"_empty"!=d&&(n=a(e).jqGrid("getInd",d));a(e.p.colModel).each(function(m){i=this.name;o=(f=this.editrules&&!0===this.editrules.edithidden?!1:!0===this.hidden?!0:!1)?"style='display:none'":"";if("cb"!==i&&"subgrid"!==i&&!0===this.editable&&"rn"!==i){if(!1===n)j="";else if(i==e.p.ExpandColumn&&!0===e.p.treeGrid)j=a("td:eq("+m+")",e.rows[n]).text();else{try{j=a.unformat.call(e,a("td:eq("+m+")",e.rows[n]),{rowId:d,colModel:this},m)}catch(r){j=this.edittype&&"textarea"==this.edittype?a("td:eq("+m+")",
e.rows[n]).text():a("td:eq("+m+")",e.rows[n]).html()}if(!j||"&nbsp;"==j||"&#160;"==j||1==j.length&&160==j.charCodeAt(0))j=""}var v=a.extend({},this.editoptions||{},{id:i,name:i}),s=a.extend({},{elmprefix:"",elmsuffix:"",rowabove:!1,rowcontent:""},this.formoptions||{}),t=parseInt(s.rowpos,10)||k+1,y=parseInt(2*(parseInt(s.colpos,10)||1),10);"_empty"==d&&v.defaultValue&&(j=a.isFunction(v.defaultValue)?v.defaultValue.call(b):v.defaultValue);this.edittype||(this.edittype="text");b.p.autoencode&&(j=a.jgrid.htmlDecode(j));
l=a.jgrid.createEl.call(b,this.edittype,v,j,!1,a.extend({},a.jgrid.ajaxOptions,e.p.ajaxSelectOptions||{}));""===j&&"checkbox"==this.edittype&&(j=a(l).attr("offval"));""===j&&"select"==this.edittype&&(j=a("option:eq(0)",l).text());if(c[b.p.id].checkOnSubmit||c[b.p.id].checkOnUpdate)c[b.p.id]._savedData[i]=j;a(l).addClass("FormElement");("text"==this.edittype||"textarea"==this.edittype)&&a(l).addClass("ui-widget-content ui-corner-all");g=a(h).find("tr[rowpos="+t+"]");s.rowabove&&(v=a("<tr><td class='contentinfo' colspan='"+
2*q+"'>"+s.rowcontent+"</td></tr>"),a(h).append(v),v[0].rp=t);0===g.length&&(g=a("<tr "+o+" rowpos='"+t+"'></tr>").addClass("FormData").attr("id","tr_"+i),a(g).append(u),a(h).append(g),g[0].rp=t);a("td:eq("+(y-2)+")",g[0]).html("undefined"===typeof s.label?e.p.colNames[m]:s.label);a("td:eq("+(y-1)+")",g[0]).append(s.elmprefix).append(l).append(s.elmsuffix);p[k]=m;k++}});if(0<k&&(m=a("<tr class='FormData' style='display:none'><td class='CaptionTD'></td><td colspan='"+(2*q-1)+"' class='DataTD'><input class='FormElement' id='id_g' type='text' name='"+
e.p.id+"_id' value='"+d+"'/></td></tr>"),m[0].rp=k+999,a(h).append(m),c[b.p.id].checkOnSubmit||c[b.p.id].checkOnUpdate))c[b.p.id]._savedData[e.p.id+"_id"]=d;return p}function r(d,e,h){var i,q=0,g,f,k,o,l;if(c[b.p.id].checkOnSubmit||c[b.p.id].checkOnUpdate)c[b.p.id]._savedData={},c[b.p.id]._savedData[e.p.id+"_id"]=d;var m=e.p.colModel;if("_empty"==d)a(m).each(function(){i=this.name;k=a.extend({},this.editoptions||{});if((f=a("#"+a.jgrid.jqID(i),"#"+h))&&f.length&&null!==f[0])if(o="",k.defaultValue?
(o=a.isFunction(k.defaultValue)?k.defaultValue.call(b):k.defaultValue,"checkbox"==f[0].type?(l=o.toLowerCase(),0>l.search(/(false|0|no|off|undefined)/i)&&""!==l?(f[0].checked=!0,f[0].defaultChecked=!0,f[0].value=o):(f[0].checked=!1,f[0].defaultChecked=!1)):f.val(o)):"checkbox"==f[0].type?(f[0].checked=!1,f[0].defaultChecked=!1,o=a(f).attr("offval")):f[0].type&&"select"==f[0].type.substr(0,6)?f[0].selectedIndex=0:f.val(o),!0===c[b.p.id].checkOnSubmit||c[b.p.id].checkOnUpdate)c[b.p.id]._savedData[i]=
o}),a("#id_g","#"+h).val(d);else{var n=a(e).jqGrid("getInd",d,!0);n&&(a('td[role="gridcell"]',n).each(function(f){i=m[f].name;if("cb"!==i&&"subgrid"!==i&&"rn"!==i&&!0===m[f].editable){if(i==e.p.ExpandColumn&&!0===e.p.treeGrid)g=a(this).text();else try{g=a.unformat.call(e,a(this),{rowId:d,colModel:m[f]},f)}catch(j){g="textarea"==m[f].edittype?a(this).text():a(this).html()}b.p.autoencode&&(g=a.jgrid.htmlDecode(g));if(!0===c[b.p.id].checkOnSubmit||c[b.p.id].checkOnUpdate)c[b.p.id]._savedData[i]=g;i=
a.jgrid.jqID(i);switch(m[f].edittype){case "password":case "text":case "button":case "image":case "textarea":if("&nbsp;"==g||"&#160;"==g||1==g.length&&160==g.charCodeAt(0))g="";a("#"+i,"#"+h).val(g);break;case "select":var k=g.split(","),k=a.map(k,function(b){return a.trim(b)});a("#"+i+" option","#"+h).each(function(){this.selected=!m[f].editoptions.multiple&&(a.trim(g)==a.trim(a(this).text())||k[0]==a.trim(a(this).text())||k[0]==a.trim(a(this).val()))?!0:m[f].editoptions.multiple?-1<a.inArray(a.trim(a(this).text()),
k)||-1<a.inArray(a.trim(a(this).val()),k)?!0:!1:!1});break;case "checkbox":g+="";m[f].editoptions&&m[f].editoptions.value?m[f].editoptions.value.split(":")[0]==g?(a("#"+i,"#"+h)[b.p.useProp?"prop":"attr"]("checked",!0),a("#"+i,"#"+h)[b.p.useProp?"prop":"attr"]("defaultChecked",!0)):(a("#"+i,"#"+h)[b.p.useProp?"prop":"attr"]("checked",!1),a("#"+i,"#"+h)[b.p.useProp?"prop":"attr"]("defaultChecked",!1)):(g=g.toLowerCase(),0>g.search(/(false|0|no|off|undefined)/i)&&""!==g?(a("#"+i,"#"+h)[b.p.useProp?
"prop":"attr"]("checked",!0),a("#"+i,"#"+h)[b.p.useProp?"prop":"attr"]("defaultChecked",!0)):(a("#"+i,"#"+h)[b.p.useProp?"prop":"attr"]("checked",!1),a("#"+i,"#"+h)[b.p.useProp?"prop":"attr"]("defaultChecked",!1)));break;case "custom":try{if(m[f].editoptions&&a.isFunction(m[f].editoptions.custom_value))m[f].editoptions.custom_value.call(b,a("#"+i,"#"+h),"set",g);else throw"e1";}catch(o){"e1"==o?a.jgrid.info_dialog(jQuery.jgrid.errors.errcap,"function 'custom_value' "+a.jgrid.edit.msg.nodefined,jQuery.jgrid.edit.bClose):
a.jgrid.info_dialog(jQuery.jgrid.errors.errcap,o.message,jQuery.jgrid.edit.bClose)}}q++}}),0<q&&a("#id_g",j).val(d))}}function t(){a.each(b.p.colModel,function(a,b){b.editoptions&&!0===b.editoptions.NullIfEmpty&&i.hasOwnProperty(b.name)&&""===i[b.name]&&(i[b.name]="null")})}function s(){var e,f=[!0,"",""],g={},q=b.p.prmNames,k,l,n,p,v,u=a(b).triggerHandler("jqGridAddEditBeforeCheckValues",[a("#"+h),z]);u&&"object"===typeof u&&(i=u);a.isFunction(c[b.p.id].beforeCheckValues)&&(u=c[b.p.id].beforeCheckValues.call(b,
i,a("#"+h),"_empty"==i[b.p.id+"_id"]?q.addoper:q.editoper))&&"object"===typeof u&&(i=u);for(n in i)if(i.hasOwnProperty(n)&&(f=a.jgrid.checkValues.call(b,i[n],n,b),!1===f[0]))break;t();f[0]&&(g=a(b).triggerHandler("jqGridAddEditClickSubmit",[c[b.p.id],i,z]),void 0===g&&a.isFunction(c[b.p.id].onclickSubmit)&&(g=c[b.p.id].onclickSubmit.call(b,c[b.p.id],i)||{}),f=a(b).triggerHandler("jqGridAddEditBeforeSubmit",[i,a("#"+h),z]),void 0===f&&(f=[!0,"",""]),f[0]&&a.isFunction(c[b.p.id].beforeSubmit)&&(f=c[b.p.id].beforeSubmit.call(b,
i,a("#"+h))));if(f[0]&&!c[b.p.id].processing){c[b.p.id].processing=!0;a("#sData",j+"_2").addClass("ui-state-active");l=q.oper;k=q.id;i[l]="_empty"==a.trim(i[b.p.id+"_id"])?q.addoper:q.editoper;i[l]!=q.addoper?i[k]=i[b.p.id+"_id"]:void 0===i[k]&&(i[k]=i[b.p.id+"_id"]);delete i[b.p.id+"_id"];i=a.extend(i,c[b.p.id].editData,g);if(!0===b.p.treeGrid)for(v in i[l]==q.addoper&&(p=a(b).jqGrid("getGridParam","selrow"),i["adjacency"==b.p.treeGridModel?b.p.treeReader.parent_id_field:"parent_id"]=p),b.p.treeReader)b.p.treeReader.hasOwnProperty(v)&&
(g=b.p.treeReader[v],i.hasOwnProperty(g)&&!(i[l]==q.addoper&&"parent_id_field"===v)&&delete i[g]);i[k]=a.jgrid.stripPref(b.p.idPrefix,i[k]);v=a.extend({url:c[b.p.id].url?c[b.p.id].url:a(b).jqGrid("getGridParam","editurl"),type:c[b.p.id].mtype,data:a.isFunction(c[b.p.id].serializeEditData)?c[b.p.id].serializeEditData.call(b,i):i,complete:function(g,n){i[k]=b.p.idPrefix+i[k];if(n!="success"){f[0]=false;f[1]=a(b).triggerHandler("jqGridAddEditErrorTextFormat",[g,z]);f[1]=a.isFunction(c[b.p.id].errorTextFormat)?
c[b.p.id].errorTextFormat.call(b,g):n+" Status: '"+g.statusText+"'. Error code: "+g.status}else{f=a(b).triggerHandler("jqGridAddEditAfterSubmit",[g,i,z]);f===void 0&&(f=[true,"",""]);f[0]&&a.isFunction(c[b.p.id].afterSubmit)&&(f=c[b.p.id].afterSubmit.call(b,g,i))}if(f[0]===false){a("#FormError>td",j).html(f[1]);a("#FormError",j).show()}else{a.each(b.p.colModel,function(){if(B[this.name]&&this.formatter&&this.formatter=="select")try{delete B[this.name]}catch(a){}});i=a.extend(i,B);b.p.autoencode&&
a.each(i,function(b,d){i[b]=a.jgrid.htmlDecode(d)});if(i[l]==q.addoper){f[2]||(f[2]=a.jgrid.randId());i[k]=f[2];if(c[b.p.id].closeAfterAdd){if(c[b.p.id].reloadAfterSubmit)a(b).trigger("reloadGrid");else if(b.p.treeGrid===true)a(b).jqGrid("addChildNode",f[2],p,i);else{a(b).jqGrid("addRowData",f[2],i,d.addedrow);a(b).jqGrid("setSelection",f[2])}a.jgrid.hideModal("#"+a.jgrid.jqID(o.themodal),{gb:"#gbox_"+a.jgrid.jqID(m),jqm:d.jqModal,onClose:c[b.p.id].onClose})}else if(c[b.p.id].clearAfterAdd){c[b.p.id].reloadAfterSubmit?
a(b).trigger("reloadGrid"):b.p.treeGrid===true?a(b).jqGrid("addChildNode",f[2],p,i):a(b).jqGrid("addRowData",f[2],i,d.addedrow);r("_empty",b,h)}else c[b.p.id].reloadAfterSubmit?a(b).trigger("reloadGrid"):b.p.treeGrid===true?a(b).jqGrid("addChildNode",f[2],p,i):a(b).jqGrid("addRowData",f[2],i,d.addedrow)}else{if(c[b.p.id].reloadAfterSubmit){a(b).trigger("reloadGrid");c[b.p.id].closeAfterEdit||setTimeout(function(){a(b).jqGrid("setSelection",i[k])},1E3)}else b.p.treeGrid===true?a(b).jqGrid("setTreeRow",
i[k],i):a(b).jqGrid("setRowData",i[k],i);c[b.p.id].closeAfterEdit&&a.jgrid.hideModal("#"+a.jgrid.jqID(o.themodal),{gb:"#gbox_"+a.jgrid.jqID(m),jqm:d.jqModal,onClose:c[b.p.id].onClose})}if(a.isFunction(c[b.p.id].afterComplete)){e=g;setTimeout(function(){a(b).triggerHandler("jqGridAddEditAfterComplete",[e,i,a("#"+h),z]);c[b.p.id].afterComplete.call(b,e,i,a("#"+h));e=null},500)}if(c[b.p.id].checkOnSubmit||c[b.p.id].checkOnUpdate){a("#"+h).data("disabled",false);if(c[b.p.id]._savedData[b.p.id+"_id"]!=
"_empty")for(var v in c[b.p.id]._savedData)i[v]&&(c[b.p.id]._savedData[v]=i[v])}}c[b.p.id].processing=false;a("#sData",j+"_2").removeClass("ui-state-active");try{a(":input:visible","#"+h)[0].focus()}catch(u){}}},a.jgrid.ajaxOptions,c[b.p.id].ajaxEditOptions);!v.url&&!c[b.p.id].useDataProxy&&(a.isFunction(b.p.dataProxy)?c[b.p.id].useDataProxy=!0:(f[0]=!1,f[1]+=" "+a.jgrid.errors.nourl));f[0]&&(c[b.p.id].useDataProxy?(g=b.p.dataProxy.call(b,v,"set_"+b.p.id),"undefined"==typeof g&&(g=[!0,""]),!1===g[0]?
(f[0]=!1,f[1]=g[1]||"Error deleting the selected row!"):(v.data.oper==q.addoper&&c[b.p.id].closeAfterAdd&&a.jgrid.hideModal("#"+a.jgrid.jqID(o.themodal),{gb:"#gbox_"+a.jgrid.jqID(m),jqm:d.jqModal,onClose:c[b.p.id].onClose}),v.data.oper==q.editoper&&c[b.p.id].closeAfterEdit&&a.jgrid.hideModal("#"+a.jgrid.jqID(o.themodal),{gb:"#gbox_"+a.jgrid.jqID(m),jqm:d.jqModal,onClose:c[b.p.id].onClose}))):a.ajax(v))}!1===f[0]&&(a("#FormError>td",j).html(f[1]),a("#FormError",j).show())}function p(a,b){var d=!1,
c;for(c in a)if(a[c]!=b[c]){d=!0;break}return d}function g(){var d=!0;a("#FormError",j).hide();if(c[b.p.id].checkOnUpdate&&(i={},B={},e(),F=a.extend({},i,B),M=p(F,c[b.p.id]._savedData)))a("#"+h).data("disabled",!0),a(".confirm","#"+o.themodal).show(),d=!1;return d}function f(){if("_empty"!==u&&"undefined"!==typeof b.p.savedRow&&0<b.p.savedRow.length&&a.isFunction(a.fn.jqGrid.restoreRow))for(var d=0;d<b.p.savedRow.length;d++)if(b.p.savedRow[d].id==u){a(b).jqGrid("restoreRow",u);break}}function n(b,
d){0===b?a("#pData",j+"_2").addClass("ui-state-disabled"):a("#pData",j+"_2").removeClass("ui-state-disabled");b==d?a("#nData",j+"_2").addClass("ui-state-disabled"):a("#nData",j+"_2").removeClass("ui-state-disabled")}function w(){var d=a(b).jqGrid("getDataIDs"),c=a("#id_g",j).val();return[a.inArray(c,d),d]}var b=this;if(b.grid&&u){var m=b.p.id,h="FrmGrid_"+m,k="TblGrid_"+m,j="#"+a.jgrid.jqID(k),o={themodal:"editmod"+m,modalhead:"edithd"+m,modalcontent:"editcnt"+m,scrollelm:h},y=a.isFunction(c[b.p.id].beforeShowForm)?
c[b.p.id].beforeShowForm:!1,A=a.isFunction(c[b.p.id].afterShowForm)?c[b.p.id].afterShowForm:!1,x=a.isFunction(c[b.p.id].beforeInitData)?c[b.p.id].beforeInitData:!1,E=a.isFunction(c[b.p.id].onInitializeForm)?c[b.p.id].onInitializeForm:!1,q=!0,v=1,H=0,i,B,F,M,z,h=a.jgrid.jqID(h);"new"===u?(u="_empty",z="add",d.caption=c[b.p.id].addCaption):(d.caption=c[b.p.id].editCaption,z="edit");!0===d.recreateForm&&null!==a("#"+a.jgrid.jqID(o.themodal)).html()&&a("#"+a.jgrid.jqID(o.themodal)).remove();var I=!0;
d.checkOnUpdate&&(d.jqModal&&!d.modal)&&(I=!1);if(null!==a("#"+a.jgrid.jqID(o.themodal)).html()){q=a(b).triggerHandler("jqGridAddEditBeforeInitData",[a("#"+a.jgrid.jqID(h))]);"undefined"==typeof q&&(q=!0);q&&x&&(q=x.call(b,a("#"+h)));if(!1===q)return;f();a(".ui-jqdialog-title","#"+a.jgrid.jqID(o.modalhead)).html(d.caption);a("#FormError",j).hide();c[b.p.id].topinfo?(a(".topinfo",j).html(c[b.p.id].topinfo),a(".tinfo",j).show()):a(".tinfo",j).hide();c[b.p.id].bottominfo?(a(".bottominfo",j+"_2").html(c[b.p.id].bottominfo),
a(".binfo",j+"_2").show()):a(".binfo",j+"_2").hide();r(u,b,h);"_empty"==u||!c[b.p.id].viewPagerButtons?a("#pData, #nData",j+"_2").hide():a("#pData, #nData",j+"_2").show();!0===c[b.p.id].processing&&(c[b.p.id].processing=!1,a("#sData",j+"_2").removeClass("ui-state-active"));!0===a("#"+h).data("disabled")&&(a(".confirm","#"+a.jgrid.jqID(o.themodal)).hide(),a("#"+h).data("disabled",!1));a(b).triggerHandler("jqGridAddEditBeforeShowForm",[a("#"+h),z]);y&&y.call(b,a("#"+h));a("#"+a.jgrid.jqID(o.themodal)).data("onClose",
c[b.p.id].onClose);a.jgrid.viewModal("#"+a.jgrid.jqID(o.themodal),{gbox:"#gbox_"+a.jgrid.jqID(m),jqm:d.jqModal,jqM:!1,overlay:d.overlay,modal:d.modal});I||a(".jqmOverlay").click(function(){if(!g())return false;a.jgrid.hideModal("#"+a.jgrid.jqID(o.themodal),{gb:"#gbox_"+a.jgrid.jqID(m),jqm:d.jqModal,onClose:c[b.p.id].onClose});return false});a(b).triggerHandler("jqGridAddEditAfterShowForm",[a("#"+h),z]);A&&A.call(b,a("#"+h))}else{var G=isNaN(d.dataheight)?d.dataheight:d.dataheight+"px",G=a("<form name='FormPost' id='"+
h+"' class='FormGrid' onSubmit='return false;' style='width:100%;overflow:auto;position:relative;height:"+G+";'></form>").data("disabled",!1),C=a("<table id='"+k+"' class='EditTable' cellspacing='0' cellpadding='0' border='0'><tbody></tbody></table>"),q=a(b).triggerHandler("jqGridAddEditBeforeInitData",[a("#"+h),z]);"undefined"==typeof q&&(q=!0);q&&x&&(q=x.call(b,a("#"+h)));if(!1===q)return;f();a(b.p.colModel).each(function(){var a=this.formoptions;v=Math.max(v,a?a.colpos||0:0);H=Math.max(H,a?a.rowpos||
0:0)});a(G).append(C);x=a("<tr id='FormError' style='display:none'><td class='ui-state-error' colspan='"+2*v+"'></td></tr>");x[0].rp=0;a(C).append(x);x=a("<tr style='display:none' class='tinfo'><td class='topinfo' colspan='"+2*v+"'>"+c[b.p.id].topinfo+"</td></tr>");x[0].rp=0;a(C).append(x);var q=(x="rtl"==b.p.direction?!0:!1)?"nData":"pData",D=x?"pData":"nData";l(u,b,C,v);var q="<a href='javascript:void(0)' id='"+q+"' class='fm-button ui-state-default ui-corner-left'><span class='ui-icon ui-icon-triangle-1-w'></span></a>",
D="<a href='javascript:void(0)' id='"+D+"' class='fm-button ui-state-default ui-corner-right'><span class='ui-icon ui-icon-triangle-1-e'></span></a>",J="<a href='javascript:void(0)' id='sData' class='fm-button ui-state-default ui-corner-all'>"+d.bSubmit+"</a>",K="<a href='javascript:void(0)' id='cData' class='fm-button ui-state-default ui-corner-all'>"+d.bCancel+"</a>",k="<table border='0' cellspacing='0' cellpadding='0' class='EditTable' id='"+k+"_2'><tbody><tr><td colspan='2'><hr class='ui-widget-content' style='margin:1px'/></td></tr><tr id='Act_Buttons'><td class='navButton'>"+
(x?D+q:q+D)+"</td><td class='EditButton'>"+J+K+"</td></tr>"+("<tr style='display:none' class='binfo'><td class='bottominfo' colspan='2'>"+c[b.p.id].bottominfo+"</td></tr>"),k=k+"</tbody></table>";if(0<H){var L=[];a.each(a(C)[0].rows,function(a,b){L[a]=b});L.sort(function(a,b){return a.rp>b.rp?1:a.rp<b.rp?-1:0});a.each(L,function(b,d){a("tbody",C).append(d)})}d.gbox="#gbox_"+a.jgrid.jqID(m);var N=!1;!0===d.closeOnEscape&&(d.closeOnEscape=!1,N=!0);k=a("<span></span>").append(G).append(k);a.jgrid.createModal(o,
k,d,"#gview_"+a.jgrid.jqID(b.p.id),a("#gbox_"+a.jgrid.jqID(b.p.id))[0]);x&&(a("#pData, #nData",j+"_2").css("float","right"),a(".EditButton",j+"_2").css("text-align","left"));c[b.p.id].topinfo&&a(".tinfo",j).show();c[b.p.id].bottominfo&&a(".binfo",j+"_2").show();k=k=null;a("#"+a.jgrid.jqID(o.themodal)).keydown(function(e){var f=e.target;if(a("#"+h).data("disabled")===true)return false;if(c[b.p.id].savekey[0]===true&&e.which==c[b.p.id].savekey[1]&&f.tagName!="TEXTAREA"){a("#sData",j+"_2").trigger("click");
return false}if(e.which===27){if(!g())return false;N&&a.jgrid.hideModal(this,{gb:d.gbox,jqm:d.jqModal,onClose:c[b.p.id].onClose});return false}if(c[b.p.id].navkeys[0]===true){if(a("#id_g",j).val()=="_empty")return true;if(e.which==c[b.p.id].navkeys[1]){a("#pData",j+"_2").trigger("click");return false}if(e.which==c[b.p.id].navkeys[2]){a("#nData",j+"_2").trigger("click");return false}}});d.checkOnUpdate&&(a("a.ui-jqdialog-titlebar-close span","#"+a.jgrid.jqID(o.themodal)).removeClass("jqmClose"),a("a.ui-jqdialog-titlebar-close",
"#"+a.jgrid.jqID(o.themodal)).unbind("click").click(function(){if(!g())return false;a.jgrid.hideModal("#"+a.jgrid.jqID(o.themodal),{gb:"#gbox_"+a.jgrid.jqID(m),jqm:d.jqModal,onClose:c[b.p.id].onClose});return false}));d.saveicon=a.extend([!0,"left","ui-icon-disk"],d.saveicon);d.closeicon=a.extend([!0,"left","ui-icon-close"],d.closeicon);!0===d.saveicon[0]&&a("#sData",j+"_2").addClass("right"==d.saveicon[1]?"fm-button-icon-right":"fm-button-icon-left").append("<span class='ui-icon "+d.saveicon[2]+
"'></span>");!0===d.closeicon[0]&&a("#cData",j+"_2").addClass("right"==d.closeicon[1]?"fm-button-icon-right":"fm-button-icon-left").append("<span class='ui-icon "+d.closeicon[2]+"'></span>");if(c[b.p.id].checkOnSubmit||c[b.p.id].checkOnUpdate)J="<a href='javascript:void(0)' id='sNew' class='fm-button ui-state-default ui-corner-all' style='z-index:1002'>"+d.bYes+"</a>",D="<a href='javascript:void(0)' id='nNew' class='fm-button ui-state-default ui-corner-all' style='z-index:1002'>"+d.bNo+"</a>",K="<a href='javascript:void(0)' id='cNew' class='fm-button ui-state-default ui-corner-all' style='z-index:1002'>"+
d.bExit+"</a>",k=d.zIndex||999,k++,a("<div class='ui-widget-overlay jqgrid-overlay confirm' style='z-index:"+k+";display:none;'>&#160;"+(a.browser.msie&&6==a.browser.version?'<iframe style="display:block;position:absolute;z-index:-1;filter:Alpha(Opacity=\'0\');" src="javascript:false;"></iframe>':"")+"</div><div class='confirm ui-widget-content ui-jqconfirm' style='z-index:"+(k+1)+"'>"+d.saveData+"<br/><br/>"+J+D+K+"</div>").insertAfter("#"+h),a("#sNew","#"+a.jgrid.jqID(o.themodal)).click(function(){s();
a("#"+h).data("disabled",false);a(".confirm","#"+a.jgrid.jqID(o.themodal)).hide();return false}),a("#nNew","#"+a.jgrid.jqID(o.themodal)).click(function(){a(".confirm","#"+a.jgrid.jqID(o.themodal)).hide();a("#"+h).data("disabled",false);setTimeout(function(){a(":input","#"+h)[0].focus()},0);return false}),a("#cNew","#"+a.jgrid.jqID(o.themodal)).click(function(){a(".confirm","#"+a.jgrid.jqID(o.themodal)).hide();a("#"+h).data("disabled",false);a.jgrid.hideModal("#"+a.jgrid.jqID(o.themodal),{gb:"#gbox_"+
a.jgrid.jqID(m),jqm:d.jqModal,onClose:c[b.p.id].onClose});return false});a(b).triggerHandler("jqGridAddEditInitializeForm",[a("#"+h),z]);E&&E.call(b,a("#"+h));"_empty"==u||!c[b.p.id].viewPagerButtons?a("#pData,#nData",j+"_2").hide():a("#pData,#nData",j+"_2").show();a(b).triggerHandler("jqGridAddEditBeforeShowForm",[a("#"+h),z]);y&&y.call(b,a("#"+h));a("#"+a.jgrid.jqID(o.themodal)).data("onClose",c[b.p.id].onClose);a.jgrid.viewModal("#"+a.jgrid.jqID(o.themodal),{gbox:"#gbox_"+a.jgrid.jqID(m),jqm:d.jqModal,
overlay:d.overlay,modal:d.modal});I||a(".jqmOverlay").click(function(){if(!g())return false;a.jgrid.hideModal("#"+a.jgrid.jqID(o.themodal),{gb:"#gbox_"+a.jgrid.jqID(m),jqm:d.jqModal,onClose:c[b.p.id].onClose});return false});a(b).triggerHandler("jqGridAddEditAfterShowForm",[a("#"+h),z]);A&&A.call(b,a("#"+h));a(".fm-button","#"+a.jgrid.jqID(o.themodal)).hover(function(){a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")});a("#sData",j+"_2").click(function(){i={};B=
{};a("#FormError",j).hide();e();if(i[b.p.id+"_id"]=="_empty")s();else if(d.checkOnSubmit===true){F=a.extend({},i,B);if(M=p(F,c[b.p.id]._savedData)){a("#"+h).data("disabled",true);a(".confirm","#"+a.jgrid.jqID(o.themodal)).show()}else s()}else s();return false});a("#cData",j+"_2").click(function(){if(!g())return false;a.jgrid.hideModal("#"+a.jgrid.jqID(o.themodal),{gb:"#gbox_"+a.jgrid.jqID(m),jqm:d.jqModal,onClose:c[b.p.id].onClose});return false});a("#nData",j+"_2").click(function(){if(!g())return false;
a("#FormError",j).hide();var c=w();c[0]=parseInt(c[0],10);if(c[0]!=-1&&c[1][c[0]+1]){a(b).triggerHandler("jqGridAddEditClickPgButtons",["next",a("#"+h),c[1][c[0]]]);a.isFunction(d.onclickPgButtons)&&d.onclickPgButtons.call(b,"next",a("#"+h),c[1][c[0]]);r(c[1][c[0]+1],b,h);a(b).jqGrid("setSelection",c[1][c[0]+1]);a(b).triggerHandler("jqGridAddEditAfterClickPgButtons",["next",a("#"+h),c[1][c[0]]]);a.isFunction(d.afterclickPgButtons)&&d.afterclickPgButtons.call(b,"next",a("#"+h),c[1][c[0]+1]);n(c[0]+
1,c[1].length-1)}return false});a("#pData",j+"_2").click(function(){if(!g())return false;a("#FormError",j).hide();var c=w();if(c[0]!=-1&&c[1][c[0]-1]){a(b).triggerHandler("jqGridAddEditClickPgButtons",["prev",a("#"+h),c[1][c[0]]]);a.isFunction(d.onclickPgButtons)&&d.onclickPgButtons.call(b,"prev",a("#"+h),c[1][c[0]]);r(c[1][c[0]-1],b,h);a(b).jqGrid("setSelection",c[1][c[0]-1]);a(b).triggerHandler("jqGridAddEditAfterClickPgButtons",["prev",a("#"+h),c[1][c[0]]]);a.isFunction(d.afterclickPgButtons)&&
d.afterclickPgButtons.call(b,"prev",a("#"+h),c[1][c[0]-1]);n(c[0]-1,c[1].length-1)}return false})}y=w();n(y[0],y[1].length-1)}})},viewGridRow:function(c,d){d=a.extend({top:0,left:0,width:0,height:"auto",dataheight:"auto",modal:!1,overlay:30,drag:!0,resize:!0,jqModal:!0,closeOnEscape:!1,labelswidth:"30%",closeicon:[],navkeys:[!1,38,40],onClose:null,beforeShowForm:null,beforeInitData:null,viewPagerButtons:!0},a.jgrid.view,d||{});return this.each(function(){function e(){(!0===d.closeOnEscape||!0===d.navkeys[0])&&
setTimeout(function(){a(".ui-jqdialog-titlebar-close","#"+a.jgrid.jqID(m.modalhead)).focus()},0)}function l(b,c,e,f){for(var g,h,k,j=0,o,m,l=[],n=!1,p="<td class='CaptionTD form-view-label ui-widget-content' width='"+d.labelswidth+"'>&#160;</td><td class='DataTD form-view-data ui-helper-reset ui-widget-content'>&#160;</td>",u="",s=["integer","number","currency"],r=0,t=0,y,x,w,A=1;A<=f;A++)u+=1==A?p:"<td class='CaptionTD form-view-label ui-widget-content'>&#160;</td><td class='DataTD form-view-data ui-widget-content'>&#160;</td>";
a(c.p.colModel).each(function(){h=this.editrules&&!0===this.editrules.edithidden?!1:!0===this.hidden?!0:!1;!h&&"right"===this.align&&(this.formatter&&-1!==a.inArray(this.formatter,s)?r=Math.max(r,parseInt(this.width,10)):t=Math.max(t,parseInt(this.width,10)))});y=0!==r?r:0!==t?t:0;n=a(c).jqGrid("getInd",b);a(c.p.colModel).each(function(b){g=this.name;x=!1;m=(h=this.editrules&&!0===this.editrules.edithidden?!1:!0===this.hidden?!0:!1)?"style='display:none'":"";w="boolean"!=typeof this.viewable?!0:this.viewable;
if("cb"!==g&&"subgrid"!==g&&"rn"!==g&&w){o=!1===n?"":g==c.p.ExpandColumn&&!0===c.p.treeGrid?a("td:eq("+b+")",c.rows[n]).text():a("td:eq("+b+")",c.rows[n]).html();x="right"===this.align&&0!==y?!0:!1;a.extend({},this.editoptions||{},{id:g,name:g});var d=a.extend({},{rowabove:!1,rowcontent:""},this.formoptions||{}),q=parseInt(d.rowpos,10)||j+1,p=parseInt(2*(parseInt(d.colpos,10)||1),10);if(d.rowabove){var r=a("<tr><td class='contentinfo' colspan='"+2*f+"'>"+d.rowcontent+"</td></tr>");a(e).append(r);
r[0].rp=q}k=a(e).find("tr[rowpos="+q+"]");0===k.length&&(k=a("<tr "+m+" rowpos='"+q+"'></tr>").addClass("FormData").attr("id","trv_"+g),a(k).append(u),a(e).append(k),k[0].rp=q);a("td:eq("+(p-2)+")",k[0]).html("<b>"+("undefined"===typeof d.label?c.p.colNames[b]:d.label)+"</b>");a("td:eq("+(p-1)+")",k[0]).append("<span>"+o+"</span>").attr("id","v_"+g);x&&a("td:eq("+(p-1)+") span",k[0]).css({"text-align":"right",width:y+"px"});l[j]=b;j++}});0<j&&(b=a("<tr class='FormData' style='display:none'><td class='CaptionTD'></td><td colspan='"+
(2*f-1)+"' class='DataTD'><input class='FormElement' id='id_g' type='text' name='id' value='"+b+"'/></td></tr>"),b[0].rp=j+99,a(e).append(b));return l}function r(b,c){var d,e,f=0,g,h;if(h=a(c).jqGrid("getInd",b,!0))a("td",h).each(function(b){d=c.p.colModel[b].name;e=c.p.colModel[b].editrules&&!0===c.p.colModel[b].editrules.edithidden?!1:!0===c.p.colModel[b].hidden?!0:!1;"cb"!==d&&("subgrid"!==d&&"rn"!==d)&&(g=d==c.p.ExpandColumn&&!0===c.p.treeGrid?a(this).text():a(this).html(),a.extend({},c.p.colModel[b].editoptions||
{}),d=a.jgrid.jqID("v_"+d),a("#"+d+" span","#"+n).html(g),e&&a("#"+d,"#"+n).parents("tr:first").hide(),f++)}),0<f&&a("#id_g","#"+n).val(b)}function t(b,c){0===b?a("#pData","#"+n+"_2").addClass("ui-state-disabled"):a("#pData","#"+n+"_2").removeClass("ui-state-disabled");b==c?a("#nData","#"+n+"_2").addClass("ui-state-disabled"):a("#nData","#"+n+"_2").removeClass("ui-state-disabled")}function s(){var b=a(p).jqGrid("getDataIDs"),c=a("#id_g","#"+n).val();return[a.inArray(c,b),b]}var p=this;if(p.grid&&
c){var g=p.p.id,f="ViewGrid_"+a.jgrid.jqID(g),n="ViewTbl_"+a.jgrid.jqID(g),w="ViewGrid_"+g,b="ViewTbl_"+g,m={themodal:"viewmod"+g,modalhead:"viewhd"+g,modalcontent:"viewcnt"+g,scrollelm:f},h=a.isFunction(d.beforeInitData)?d.beforeInitData:!1,k=!0,j=1,o=0;if(null!==a("#"+a.jgrid.jqID(m.themodal)).html()){h&&(k=h.call(p,a("#"+f)),"undefined"==typeof k&&(k=!0));if(!1===k)return;a(".ui-jqdialog-title","#"+a.jgrid.jqID(m.modalhead)).html(d.caption);a("#FormError","#"+n).hide();r(c,p);a.isFunction(d.beforeShowForm)&&
d.beforeShowForm.call(p,a("#"+f));a.jgrid.viewModal("#"+a.jgrid.jqID(m.themodal),{gbox:"#gbox_"+a.jgrid.jqID(g),jqm:d.jqModal,jqM:!1,overlay:d.overlay,modal:d.modal});e()}else{var y=isNaN(d.dataheight)?d.dataheight:d.dataheight+"px",w=a("<form name='FormPost' id='"+w+"' class='FormGrid' style='width:100%;overflow:auto;position:relative;height:"+y+";'></form>"),A=a("<table id='"+b+"' class='EditTable' cellspacing='1' cellpadding='2' border='0' style='table-layout:fixed'><tbody></tbody></table>");h&&
(k=h.call(p,a("#"+f)),"undefined"==typeof k&&(k=!0));if(!1===k)return;a(p.p.colModel).each(function(){var a=this.formoptions;j=Math.max(j,a?a.colpos||0:0);o=Math.max(o,a?a.rowpos||0:0)});a(w).append(A);l(c,p,A,j);b="rtl"==p.p.direction?!0:!1;h="<a href='javascript:void(0)' id='"+(b?"nData":"pData")+"' class='fm-button ui-state-default ui-corner-left'><span class='ui-icon ui-icon-triangle-1-w'></span></a>";k="<a href='javascript:void(0)' id='"+(b?"pData":"nData")+"' class='fm-button ui-state-default ui-corner-right'><span class='ui-icon ui-icon-triangle-1-e'></span></a>";
y="<a href='javascript:void(0)' id='cData' class='fm-button ui-state-default ui-corner-all'>"+d.bClose+"</a>";if(0<o){var x=[];a.each(a(A)[0].rows,function(a,b){x[a]=b});x.sort(function(a,b){return a.rp>b.rp?1:a.rp<b.rp?-1:0});a.each(x,function(b,c){a("tbody",A).append(c)})}d.gbox="#gbox_"+a.jgrid.jqID(g);var E=!1;!0===d.closeOnEscape&&(d.closeOnEscape=!1,E=!0);w=a("<span></span>").append(w).append("<table border='0' class='EditTable' id='"+n+"_2'><tbody><tr id='Act_Buttons'><td class='navButton' width='"+
d.labelswidth+"'>"+(b?k+h:h+k)+"</td><td class='EditButton'>"+y+"</td></tr></tbody></table>");a.jgrid.createModal(m,w,d,"#gview_"+a.jgrid.jqID(p.p.id),a("#gview_"+a.jgrid.jqID(p.p.id))[0]);b&&(a("#pData, #nData","#"+n+"_2").css("float","right"),a(".EditButton","#"+n+"_2").css("text-align","left"));d.viewPagerButtons||a("#pData, #nData","#"+n+"_2").hide();w=null;a("#"+m.themodal).keydown(function(b){if(b.which===27){E&&a.jgrid.hideModal(this,{gb:d.gbox,jqm:d.jqModal,onClose:d.onClose});return false}if(d.navkeys[0]===
true){if(b.which===d.navkeys[1]){a("#pData","#"+n+"_2").trigger("click");return false}if(b.which===d.navkeys[2]){a("#nData","#"+n+"_2").trigger("click");return false}}});d.closeicon=a.extend([!0,"left","ui-icon-close"],d.closeicon);!0===d.closeicon[0]&&a("#cData","#"+n+"_2").addClass("right"==d.closeicon[1]?"fm-button-icon-right":"fm-button-icon-left").append("<span class='ui-icon "+d.closeicon[2]+"'></span>");a.isFunction(d.beforeShowForm)&&d.beforeShowForm.call(p,a("#"+f));a.jgrid.viewModal("#"+
a.jgrid.jqID(m.themodal),{gbox:"#gbox_"+a.jgrid.jqID(g),jqm:d.jqModal,modal:d.modal});a(".fm-button:not(.ui-state-disabled)","#"+n+"_2").hover(function(){a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")});e();a("#cData","#"+n+"_2").click(function(){a.jgrid.hideModal("#"+a.jgrid.jqID(m.themodal),{gb:"#gbox_"+a.jgrid.jqID(g),jqm:d.jqModal,onClose:d.onClose});return false});a("#nData","#"+n+"_2").click(function(){a("#FormError","#"+n).hide();var b=s();b[0]=parseInt(b[0],
10);if(b[0]!=-1&&b[1][b[0]+1]){a.isFunction(d.onclickPgButtons)&&d.onclickPgButtons.call(p,"next",a("#"+f),b[1][b[0]]);r(b[1][b[0]+1],p);a(p).jqGrid("setSelection",b[1][b[0]+1]);a.isFunction(d.afterclickPgButtons)&&d.afterclickPgButtons.call(p,"next",a("#"+f),b[1][b[0]+1]);t(b[0]+1,b[1].length-1)}e();return false});a("#pData","#"+n+"_2").click(function(){a("#FormError","#"+n).hide();var b=s();if(b[0]!=-1&&b[1][b[0]-1]){a.isFunction(d.onclickPgButtons)&&d.onclickPgButtons.call(p,"prev",a("#"+f),b[1][b[0]]);
r(b[1][b[0]-1],p);a(p).jqGrid("setSelection",b[1][b[0]-1]);a.isFunction(d.afterclickPgButtons)&&d.afterclickPgButtons.call(p,"prev",a("#"+f),b[1][b[0]-1]);t(b[0]-1,b[1].length-1)}e();return false})}w=s();t(w[0],w[1].length-1)}})},delGridRow:function(u,d){d=a.extend({top:0,left:0,width:240,height:"auto",dataheight:"auto",modal:!1,overlay:30,drag:!0,resize:!0,url:"",mtype:"POST",reloadAfterSubmit:!0,beforeShowForm:null,beforeInitData:null,afterShowForm:null,beforeSubmit:null,onclickSubmit:null,afterSubmit:null,
jqModal:!0,closeOnEscape:!1,delData:{},delicon:[],cancelicon:[],onClose:null,ajaxDelOptions:{},processing:!1,serializeDelData:null,useDataProxy:!1},a.jgrid.del,d||{});c[a(this)[0].p.id]=d;return this.each(function(){var e=this;if(e.grid&&u){var l=a.isFunction(c[e.p.id].beforeShowForm),r=a.isFunction(c[e.p.id].afterShowForm),t=a.isFunction(c[e.p.id].beforeInitData)?c[e.p.id].beforeInitData:!1,s=e.p.id,p={},g=!0,f="DelTbl_"+a.jgrid.jqID(s),n,w,b,m,h="DelTbl_"+s,k={themodal:"delmod"+s,modalhead:"delhd"+
s,modalcontent:"delcnt"+s,scrollelm:f};jQuery.isArray(u)&&(u=u.join());if(null!==a("#"+a.jgrid.jqID(k.themodal)).html()){t&&(g=t.call(e,a("#"+f)),"undefined"==typeof g&&(g=!0));if(!1===g)return;a("#DelData>td","#"+f).text(u);a("#DelError","#"+f).hide();!0===c[e.p.id].processing&&(c[e.p.id].processing=!1,a("#dData","#"+f).removeClass("ui-state-active"));l&&c[e.p.id].beforeShowForm.call(e,a("#"+f));a.jgrid.viewModal("#"+a.jgrid.jqID(k.themodal),{gbox:"#gbox_"+a.jgrid.jqID(s),jqm:c[e.p.id].jqModal,jqM:!1,
overlay:c[e.p.id].overlay,modal:c[e.p.id].modal})}else{var j=isNaN(c[e.p.id].dataheight)?c[e.p.id].dataheight:c[e.p.id].dataheight+"px",h="<div id='"+h+"' class='formdata' style='width:100%;overflow:auto;position:relative;height:"+j+";'><table class='DelTable'><tbody><tr id='DelError' style='display:none'><td class='ui-state-error'></td></tr>"+("<tr id='DelData' style='display:none'><td >"+u+"</td></tr>"),h=h+('<tr><td class="delmsg" style="white-space:pre;">'+c[e.p.id].msg+"</td></tr><tr><td >&#160;</td></tr>"),
h=h+"</tbody></table></div>"+("<table cellspacing='0' cellpadding='0' border='0' class='EditTable' id='"+f+"_2'><tbody><tr><td><hr class='ui-widget-content' style='margin:1px'/></td></tr><tr><td class='DelButton EditButton'>"+("<a href='javascript:void(0)' id='dData' class='fm-button ui-state-default ui-corner-all'>"+d.bSubmit+"</a>")+"&#160;"+("<a href='javascript:void(0)' id='eData' class='fm-button ui-state-default ui-corner-all'>"+d.bCancel+"</a>")+"</td></tr></tbody></table>");d.gbox="#gbox_"+
a.jgrid.jqID(s);a.jgrid.createModal(k,h,d,"#gview_"+a.jgrid.jqID(e.p.id),a("#gview_"+a.jgrid.jqID(e.p.id))[0]);t&&(g=t.call(e,a("#"+f)),"undefined"==typeof g&&(g=!0));if(!1===g)return;a(".fm-button","#"+f+"_2").hover(function(){a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")});d.delicon=a.extend([!0,"left","ui-icon-scissors"],c[e.p.id].delicon);d.cancelicon=a.extend([!0,"left","ui-icon-cancel"],c[e.p.id].cancelicon);!0===d.delicon[0]&&a("#dData","#"+f+"_2").addClass("right"==
d.delicon[1]?"fm-button-icon-right":"fm-button-icon-left").append("<span class='ui-icon "+d.delicon[2]+"'></span>");!0===d.cancelicon[0]&&a("#eData","#"+f+"_2").addClass("right"==d.cancelicon[1]?"fm-button-icon-right":"fm-button-icon-left").append("<span class='ui-icon "+d.cancelicon[2]+"'></span>");a("#dData","#"+f+"_2").click(function(){var g=[true,""];p={};var h=a("#DelData>td","#"+f).text();a.isFunction(c[e.p.id].onclickSubmit)&&(p=c[e.p.id].onclickSubmit.call(e,c[e.p.id],h)||{});a.isFunction(c[e.p.id].beforeSubmit)&&
(g=c[e.p.id].beforeSubmit.call(e,h));if(g[0]&&!c[e.p.id].processing){c[e.p.id].processing=true;b=e.p.prmNames;n=a.extend({},c[e.p.id].delData,p);m=b.oper;n[m]=b.deloper;w=b.id;h=(""+h).split(",");if(!h.length)return false;for(var j in h)h.hasOwnProperty(j)&&(h[j]=a.jgrid.stripPref(e.p.idPrefix,h[j]));n[w]=h.join();a(this).addClass("ui-state-active");j=a.extend({url:c[e.p.id].url?c[e.p.id].url:a(e).jqGrid("getGridParam","editurl"),type:c[e.p.id].mtype,data:a.isFunction(c[e.p.id].serializeDelData)?
c[e.p.id].serializeDelData.call(e,n):n,complete:function(b,j){if(j!="success"){g[0]=false;g[1]=a.isFunction(c[e.p.id].errorTextFormat)?c[e.p.id].errorTextFormat.call(e,b):j+" Status: '"+b.statusText+"'. Error code: "+b.status}else a.isFunction(c[e.p.id].afterSubmit)&&(g=c[e.p.id].afterSubmit.call(e,b,n));if(g[0]===false){a("#DelError>td","#"+f).html(g[1]);a("#DelError","#"+f).show()}else{if(c[e.p.id].reloadAfterSubmit&&e.p.datatype!="local")a(e).trigger("reloadGrid");else{if(e.p.treeGrid===true)try{a(e).jqGrid("delTreeNode",
e.p.idPrefix+h[0])}catch(m){}else for(var l=0;l<h.length;l++)a(e).jqGrid("delRowData",e.p.idPrefix+h[l]);e.p.selrow=null;e.p.selarrrow=[]}a.isFunction(c[e.p.id].afterComplete)&&setTimeout(function(){c[e.p.id].afterComplete.call(e,b,h)},500)}c[e.p.id].processing=false;a("#dData","#"+f+"_2").removeClass("ui-state-active");g[0]&&a.jgrid.hideModal("#"+a.jgrid.jqID(k.themodal),{gb:"#gbox_"+a.jgrid.jqID(s),jqm:d.jqModal,onClose:c[e.p.id].onClose})}},a.jgrid.ajaxOptions,c[e.p.id].ajaxDelOptions);if(!j.url&&
!c[e.p.id].useDataProxy)if(a.isFunction(e.p.dataProxy))c[e.p.id].useDataProxy=true;else{g[0]=false;g[1]=g[1]+(" "+a.jgrid.errors.nourl)}if(g[0])if(c[e.p.id].useDataProxy){j=e.p.dataProxy.call(e,j,"del_"+e.p.id);typeof j=="undefined"&&(j=[true,""]);if(j[0]===false){g[0]=false;g[1]=j[1]||"Error deleting the selected row!"}else a.jgrid.hideModal("#"+a.jgrid.jqID(k.themodal),{gb:"#gbox_"+a.jgrid.jqID(s),jqm:d.jqModal,onClose:c[e.p.id].onClose})}else a.ajax(j)}if(g[0]===false){a("#DelError>td","#"+f).html(g[1]);
a("#DelError","#"+f).show()}return false});a("#eData","#"+f+"_2").click(function(){a.jgrid.hideModal("#"+a.jgrid.jqID(k.themodal),{gb:"#gbox_"+a.jgrid.jqID(s),jqm:c[e.p.id].jqModal,onClose:c[e.p.id].onClose});return false});l&&c[e.p.id].beforeShowForm.call(e,a("#"+f));a.jgrid.viewModal("#"+a.jgrid.jqID(k.themodal),{gbox:"#gbox_"+a.jgrid.jqID(s),jqm:c[e.p.id].jqModal,overlay:c[e.p.id].overlay,modal:c[e.p.id].modal})}r&&c[e.p.id].afterShowForm.call(e,a("#"+f));!0===c[e.p.id].closeOnEscape&&setTimeout(function(){a(".ui-jqdialog-titlebar-close",
"#"+a.jgrid.jqID(k.modalhead)).focus()},0)}})},navGrid:function(c,d,e,l,r,t,s){d=a.extend({edit:!0,editicon:"ui-icon-pencil",add:!0,addicon:"ui-icon-plus",del:!0,delicon:"ui-icon-trash",search:!0,searchicon:"ui-icon-search",refresh:!0,refreshicon:"ui-icon-refresh",refreshstate:"firstpage",view:!1,viewicon:"ui-icon-document",position:"left",closeOnEscape:!0,beforeRefresh:null,afterRefresh:null,cloneToTop:!1,alertwidth:200,alertheight:"auto",alerttop:null,alertleft:null,alertzIndex:null},a.jgrid.nav,
d||{});return this.each(function(){if(!this.nav){var p={themodal:"alertmod",modalhead:"alerthd",modalcontent:"alertcnt"},g=this,f;if(g.grid&&"string"==typeof c){null===a("#"+p.themodal).html()&&(!d.alerttop&&!d.alertleft&&("undefined"!=typeof window.innerWidth?(d.alertleft=window.innerWidth,d.alerttop=window.innerHeight):"undefined"!=typeof document.documentElement&&"undefined"!=typeof document.documentElement.clientWidth&&0!==document.documentElement.clientWidth?(d.alertleft=document.documentElement.clientWidth,
d.alerttop=document.documentElement.clientHeight):(d.alertleft=1024,d.alerttop=768),d.alertleft=d.alertleft/2-parseInt(d.alertwidth,10)/2,d.alerttop=d.alerttop/2-25),a.jgrid.createModal(p,"<div>"+d.alerttext+"</div><span tabindex='0'><span tabindex='-1' id='jqg_alrt'></span></span>",{gbox:"#gbox_"+a.jgrid.jqID(g.p.id),jqModal:!0,drag:!0,resize:!0,caption:d.alertcap,top:d.alerttop,left:d.alertleft,width:d.alertwidth,height:d.alertheight,closeOnEscape:d.closeOnEscape,zIndex:d.alertzIndex},"","",!0));
var n=1;d.cloneToTop&&g.p.toppager&&(n=2);for(var w=0;w<n;w++){var b=a("<table cellspacing='0' cellpadding='0' border='0' class='ui-pg-table navtable' style='float:left;table-layout:auto;'><tbody><tr></tr></tbody></table>"),m,h;0===w?(m=c,h=g.p.id,m==g.p.toppager&&(h+="_top",n=1)):(m=g.p.toppager,h=g.p.id+"_top");"rtl"==g.p.direction&&a(b).attr("dir","rtl").css("float","right");d.add&&(l=l||{},f=a("<td class='ui-pg-button ui-corner-all'></td>"),a(f).append("<div class='ui-pg-div'><span class='ui-icon "+
d.addicon+"'></span>"+d.addtext+"</div>"),a("tr",b).append(f),a(f,b).attr({title:d.addtitle||"",id:l.id||"add_"+h}).click(function(){a(this).hasClass("ui-state-disabled")||(a.isFunction(d.addfunc)?d.addfunc.call(g):a(g).jqGrid("editGridRow","new",l));return false}).hover(function(){a(this).hasClass("ui-state-disabled")||a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")}),f=null);d.edit&&(f=a("<td class='ui-pg-button ui-corner-all'></td>"),e=e||{},a(f).append("<div class='ui-pg-div'><span class='ui-icon "+
d.editicon+"'></span>"+d.edittext+"</div>"),a("tr",b).append(f),a(f,b).attr({title:d.edittitle||"",id:e.id||"edit_"+h}).click(function(){if(!a(this).hasClass("ui-state-disabled")){var b=g.p.selrow;if(b)a.isFunction(d.editfunc)?d.editfunc.call(g,b):a(g).jqGrid("editGridRow",b,e);else{a.jgrid.viewModal("#"+p.themodal,{gbox:"#gbox_"+a.jgrid.jqID(g.p.id),jqm:true});a("#jqg_alrt").focus()}}return false}).hover(function(){a(this).hasClass("ui-state-disabled")||a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")}),
f=null);d.view&&(f=a("<td class='ui-pg-button ui-corner-all'></td>"),s=s||{},a(f).append("<div class='ui-pg-div'><span class='ui-icon "+d.viewicon+"'></span>"+d.viewtext+"</div>"),a("tr",b).append(f),a(f,b).attr({title:d.viewtitle||"",id:s.id||"view_"+h}).click(function(){if(!a(this).hasClass("ui-state-disabled")){var b=g.p.selrow;if(b)a.isFunction(d.viewfunc)?d.viewfunc.call(g,b):a(g).jqGrid("viewGridRow",b,s);else{a.jgrid.viewModal("#"+p.themodal,{gbox:"#gbox_"+a.jgrid.jqID(g.p.id),jqm:true});a("#jqg_alrt").focus()}}return false}).hover(function(){a(this).hasClass("ui-state-disabled")||
a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")}),f=null);d.del&&(f=a("<td class='ui-pg-button ui-corner-all'></td>"),r=r||{},a(f).append("<div class='ui-pg-div'><span class='ui-icon "+d.delicon+"'></span>"+d.deltext+"</div>"),a("tr",b).append(f),a(f,b).attr({title:d.deltitle||"",id:r.id||"del_"+h}).click(function(){if(!a(this).hasClass("ui-state-disabled")){var b;if(g.p.multiselect){b=g.p.selarrrow;b.length===0&&(b=null)}else b=g.p.selrow;if(b)a.isFunction(d.delfunc)?
d.delfunc.call(g,b):a(g).jqGrid("delGridRow",b,r);else{a.jgrid.viewModal("#"+p.themodal,{gbox:"#gbox_"+a.jgrid.jqID(g.p.id),jqm:true});a("#jqg_alrt").focus()}}return false}).hover(function(){a(this).hasClass("ui-state-disabled")||a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")}),f=null);(d.add||d.edit||d.del||d.view)&&a("tr",b).append("<td class='ui-pg-button ui-state-disabled' style='width:4px;'><span class='ui-separator'></span></td>");d.search&&(f=a("<td class='ui-pg-button ui-corner-all'></td>"),
t=t||{},a(f).append("<div class='ui-pg-div'><span class='ui-icon "+d.searchicon+"'></span>"+d.searchtext+"</div>"),a("tr",b).append(f),a(f,b).attr({title:d.searchtitle||"",id:t.id||"search_"+h}).click(function(){a(this).hasClass("ui-state-disabled")||(a.isFunction(d.searchfunc)?d.searchfunc.call(g,t):a(g).jqGrid("searchGrid",t));return false}).hover(function(){a(this).hasClass("ui-state-disabled")||a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")}),t.showOnLoad&&
!0===t.showOnLoad&&a(f,b).click(),f=null);d.refresh&&(f=a("<td class='ui-pg-button ui-corner-all'></td>"),a(f).append("<div class='ui-pg-div'><span class='ui-icon "+d.refreshicon+"'></span>"+d.refreshtext+"</div>"),a("tr",b).append(f),a(f,b).attr({title:d.refreshtitle||"",id:"refresh_"+h}).click(function(){if(!a(this).hasClass("ui-state-disabled")){a.isFunction(d.beforeRefresh)&&d.beforeRefresh.call(g);g.p.search=false;try{var b=g.p.id;g.p.postData.filters="";a("#fbox_"+a.jgrid.jqID(b)).jqFilter("resetFilter");
a.isFunction(g.clearToolbar)&&g.clearToolbar.call(g,false)}catch(c){}switch(d.refreshstate){case "firstpage":a(g).trigger("reloadGrid",[{page:1}]);break;case "current":a(g).trigger("reloadGrid",[{current:true}])}a.isFunction(d.afterRefresh)&&d.afterRefresh.call(g)}return false}).hover(function(){a(this).hasClass("ui-state-disabled")||a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")}),f=null);f=a(".ui-jqgrid").css("font-size")||"11px";a("body").append("<div id='testpg2' class='ui-jqgrid ui-widget ui-widget-content' style='font-size:"+
f+";visibility:hidden;' ></div>");f=a(b).clone().appendTo("#testpg2").width();a("#testpg2").remove();a(m+"_"+d.position,m).append(b);g.p._nvtd&&(f>g.p._nvtd[0]&&(a(m+"_"+d.position,m).width(f),g.p._nvtd[0]=f),g.p._nvtd[1]=f);b=f=f=null;this.nav=!0}}}})},navButtonAdd:function(c,d){d=a.extend({caption:"newButton",title:"",buttonicon:"ui-icon-newwin",onClickButton:null,position:"last",cursor:"pointer"},d||{});return this.each(function(){if(this.grid){"string"===typeof c&&0!==c.indexOf("#")&&(c="#"+a.jgrid.jqID(c));
var e=a(".navtable",c)[0],l=this;if(e&&!(d.id&&null!==a("#"+a.jgrid.jqID(d.id),e).html())){var r=a("<td></td>");"NONE"==d.buttonicon.toString().toUpperCase()?a(r).addClass("ui-pg-button ui-corner-all").append("<div class='ui-pg-div'>"+d.caption+"</div>"):a(r).addClass("ui-pg-button ui-corner-all").append("<div class='ui-pg-div'><span class='ui-icon "+d.buttonicon+"'></span>"+d.caption+"</div>");d.id&&a(r).attr("id",d.id);"first"==d.position?0===e.rows[0].cells.length?a("tr",e).append(r):a("tr td:eq(0)",
e).before(r):a("tr",e).append(r);a(r,e).attr("title",d.title||"").click(function(c){a(this).hasClass("ui-state-disabled")||a.isFunction(d.onClickButton)&&d.onClickButton.call(l,c);return!1}).hover(function(){a(this).hasClass("ui-state-disabled")||a(this).addClass("ui-state-hover")},function(){a(this).removeClass("ui-state-hover")})}}})},navSeparatorAdd:function(c,d){d=a.extend({sepclass:"ui-separator",sepcontent:""},d||{});return this.each(function(){if(this.grid){"string"===typeof c&&0!==c.indexOf("#")&&
(c="#"+a.jgrid.jqID(c));var e=a(".navtable",c)[0];if(e){var l="<td class='ui-pg-button ui-state-disabled' style='width:4px;'><span class='"+d.sepclass+"'></span>"+d.sepcontent+"</td>";a("tr",e).append(l)}}})},GridToForm:function(c,d){return this.each(function(){var e=this;if(e.grid){var l=a(e).jqGrid("getRowData",c);if(l)for(var r in l)a("[name="+a.jgrid.jqID(r)+"]",d).is("input:radio")||a("[name="+a.jgrid.jqID(r)+"]",d).is("input:checkbox")?a("[name="+a.jgrid.jqID(r)+"]",d).each(function(){if(a(this).val()==
l[r])a(this)[e.p.useProp?"prop":"attr"]("checked",!0);else a(this)[e.p.useProp?"prop":"attr"]("checked",!1)}):a("[name="+a.jgrid.jqID(r)+"]",d).val(l[r])}})},FormToGrid:function(c,d,e,l){return this.each(function(){if(this.grid){e||(e="set");l||(l="first");var r=a(d).serializeArray(),t={};a.each(r,function(a,c){t[c.name]=c.value});"add"==e?a(this).jqGrid("addRowData",c,t,l):"set"==e&&a(this).jqGrid("setRowData",c,t)}})}})})(jQuery);
(function(a){a.fn.jqFilter=function(d){if("string"===typeof d){var n=a.fn.jqFilter[d];if(!n)throw"jqFilter - No such method: "+d;var u=a.makeArray(arguments).slice(1);return n.apply(this,u)}var o=a.extend(!0,{filter:null,columns:[],onChange:null,afterRedraw:null,checkValues:null,error:!1,errmsg:"",errorcheck:!0,showQuery:!0,sopt:null,ops:[{name:"eq",description:"equal",operator:"="},{name:"ne",description:"not equal",operator:"<>"},{name:"lt",description:"less",operator:"<"},{name:"le",description:"less or equal",
operator:"<="},{name:"gt",description:"greater",operator:">"},{name:"ge",description:"greater or equal",operator:">="},{name:"bw",description:"begins with",operator:"LIKE"},{name:"bn",description:"does not begin with",operator:"NOT LIKE"},{name:"in",description:"in",operator:"IN"},{name:"ni",description:"not in",operator:"NOT IN"},{name:"ew",description:"ends with",operator:"LIKE"},{name:"en",description:"does not end with",operator:"NOT LIKE"},{name:"cn",description:"contains",operator:"LIKE"},{name:"nc",
description:"does not contain",operator:"NOT LIKE"},{name:"nu",description:"is null",operator:"IS NULL"},{name:"nn",description:"is not null",operator:"IS NOT NULL"}],numopts:"eq ne lt le gt ge nu nn in ni".split(" "),stropts:"eq ne bw bn ew en cn nc nu nn in ni".split(" "),_gridsopt:[],groupOps:[{op:"AND",text:"AND"},{op:"OR",text:"OR"}],groupButton:!0,ruleButtons:!0,direction:"ltr"},a.jgrid.filter,d||{});return this.each(function(){if(!this.filter){this.p=o;if(null===this.p.filter||void 0===this.p.filter)this.p.filter=
{groupOp:this.p.groupOps[0].op,rules:[],groups:[]};var d,n=this.p.columns.length,f,t=/msie/i.test(navigator.userAgent)&&!window.opera;if(this.p._gridsopt.length)for(d=0;d<this.p._gridsopt.length;d++)this.p.ops[d].description=this.p._gridsopt[d];this.p.initFilter=a.extend(!0,{},this.p.filter);if(n){for(d=0;d<n;d++)if(f=this.p.columns[d],f.stype?f.inputtype=f.stype:f.inputtype||(f.inputtype="text"),f.sorttype?f.searchtype=f.sorttype:f.searchtype||(f.searchtype="string"),void 0===f.hidden&&(f.hidden=
!1),f.label||(f.label=f.name),f.index&&(f.name=f.index),f.hasOwnProperty("searchoptions")||(f.searchoptions={}),!f.hasOwnProperty("searchrules"))f.searchrules={};this.p.showQuery&&a(this).append("<table class='queryresult ui-widget ui-widget-content' style='display:block;max-width:440px;border:0px none;' dir='"+this.p.direction+"'><tbody><tr><td class='query'></td></tr></tbody></table>");var r=function(g,k){var b=[!0,""];if(a.isFunction(k.searchrules))b=k.searchrules(g,k);else if(a.jgrid&&a.jgrid.checkValues)try{b=
a.jgrid.checkValues(g,-1,null,k.searchrules,k.label)}catch(c){}b&&(b.length&&!1===b[0])&&(o.error=!b[0],o.errmsg=b[1])};this.onchange=function(){this.p.error=!1;this.p.errmsg="";return a.isFunction(this.p.onChange)?this.p.onChange.call(this,this.p):!1};this.reDraw=function(){a("table.group:first",this).remove();var g=this.createTableForGroup(o.filter,null);a(this).append(g);a.isFunction(this.p.afterRedraw)&&this.p.afterRedraw.call(this,this.p)};this.createTableForGroup=function(g,k){var b=this,c,
e=a("<table class='group ui-widget ui-widget-content' style='border:0px none;'><tbody></tbody></table>"),d="left";"rtl"==this.p.direction&&(d="right",e.attr("dir","rtl"));null===k&&e.append("<tr class='error' style='display:none;'><th colspan='5' class='ui-state-error' align='"+d+"'></th></tr>");var h=a("<tr></tr>");e.append(h);d=a("<th colspan='5' align='"+d+"'></th>");h.append(d);if(!0===this.p.ruleButtons){var i=a("<select class='opsel'></select>");d.append(i);var h="",f;for(c=0;c<o.groupOps.length;c++)f=
g.groupOp===b.p.groupOps[c].op?" selected='selected'":"",h+="<option value='"+b.p.groupOps[c].op+"'"+f+">"+b.p.groupOps[c].text+"</option>";i.append(h).bind("change",function(){g.groupOp=a(i).val();b.onchange()})}h="<span></span>";this.p.groupButton&&(h=a("<input type='button' value='+ {}' title='Add subgroup' class='add-group'/>"),h.bind("click",function(){if(g.groups===void 0)g.groups=[];g.groups.push({groupOp:o.groupOps[0].op,rules:[],groups:[]});b.reDraw();b.onchange();return false}));d.append(h);
if(!0===this.p.ruleButtons){var h=a("<input type='button' value='+' title='Add rule' class='add-rule ui-add'/>"),l;h.bind("click",function(){if(g.rules===void 0)g.rules=[];for(c=0;c<b.p.columns.length;c++){var a=typeof b.p.columns[c].search==="undefined"?true:b.p.columns[c].search,e=b.p.columns[c].hidden===true;if(b.p.columns[c].searchoptions.searchhidden===true&&a||a&&!e){l=b.p.columns[c];break}}g.rules.push({field:l.name,op:(l.searchoptions.sopt?l.searchoptions.sopt:b.p.sopt?b.p.sopt:l.searchtype===
"string"?b.p.stropts:b.p.numopts)[0],data:""});b.reDraw();return false});d.append(h)}null!==k&&(h=a("<input type='button' value='-' title='Delete group' class='delete-group'/>"),d.append(h),h.bind("click",function(){for(c=0;c<k.groups.length;c++)if(k.groups[c]===g){k.groups.splice(c,1);break}b.reDraw();b.onchange();return false}));if(void 0!==g.groups)for(c=0;c<g.groups.length;c++)d=a("<tr></tr>"),e.append(d),h=a("<td class='first'></td>"),d.append(h),h=a("<td colspan='4'></td>"),h.append(this.createTableForGroup(g.groups[c],
g)),d.append(h);void 0===g.groupOp&&(g.groupOp=b.p.groupOps[0].op);if(void 0!==g.rules)for(c=0;c<g.rules.length;c++)e.append(this.createTableRowForRule(g.rules[c],g));return e};this.createTableRowForRule=function(g,d){var b=this,c=a("<tr></tr>"),e,f,h,i,j="",l;c.append("<td class='first'></td>");var m=a("<td class='columns'></td>");c.append(m);var n=a("<select></select>"),p,q=[];m.append(n);n.bind("change",function(){g.field=a(n).val();h=a(this).parents("tr:first");for(e=0;e<b.p.columns.length;e++)if(b.p.columns[e].name===
g.field){i=b.p.columns[e];break}if(i){i.searchoptions.id=a.jgrid.randId();t&&"text"===i.inputtype&&!i.searchoptions.size&&(i.searchoptions.size=10);var c=a.jgrid.createEl(i.inputtype,i.searchoptions,"",!0,b.p.ajaxSelectOptions,!0);a(c).addClass("input-elm");f=i.searchoptions.sopt?i.searchoptions.sopt:b.p.sopt?b.p.sopt:"string"===i.searchtype?b.p.stropts:b.p.numopts;var d="",k=0;q=[];a.each(b.p.ops,function(){q.push(this.name)});for(e=0;e<f.length;e++)p=a.inArray(f[e],q),-1!==p&&(0===k&&(g.op=b.p.ops[p].name),
d+="<option value='"+b.p.ops[p].name+"'>"+b.p.ops[p].description+"</option>",k++);a(".selectopts",h).empty().append(d);a(".selectopts",h)[0].selectedIndex=0;a.browser.msie&&9>a.browser.version&&(d=parseInt(a("select.selectopts",h)[0].offsetWidth)+1,a(".selectopts",h).width(d),a(".selectopts",h).css("width","auto"));a(".data",h).empty().append(c);a(".input-elm",h).bind("change",function(c){var d=a(this).hasClass("ui-autocomplete-input")?200:0;setTimeout(function(){var d=c.target;g.data=d.nodeName.toUpperCase()===
"SPAN"&&i.searchoptions&&a.isFunction(i.searchoptions.custom_value)?i.searchoptions.custom_value(a(d).children(".customelement:first"),"get"):d.value;b.onchange()},d)});setTimeout(function(){g.data=a(c).val();b.onchange()},0)}});for(e=m=0;e<b.p.columns.length;e++){l="undefined"===typeof b.p.columns[e].search?!0:b.p.columns[e].search;var r=!0===b.p.columns[e].hidden;if(!0===b.p.columns[e].searchoptions.searchhidden&&l||l&&!r)l="",g.field===b.p.columns[e].name&&(l=" selected='selected'",m=e),j+="<option value='"+
b.p.columns[e].name+"'"+l+">"+b.p.columns[e].label+"</option>"}n.append(j);j=a("<td class='operators'></td>");c.append(j);i=o.columns[m];i.searchoptions.id=a.jgrid.randId();t&&"text"===i.inputtype&&!i.searchoptions.size&&(i.searchoptions.size=10);var m=a.jgrid.createEl(i.inputtype,i.searchoptions,g.data,!0,b.p.ajaxSelectOptions,!0),s=a("<select class='selectopts'></select>");j.append(s);s.bind("change",function(){g.op=a(s).val();h=a(this).parents("tr:first");var c=a(".input-elm",h)[0];if(g.op==="nu"||
g.op==="nn"){g.data="";c.value="";c.setAttribute("readonly","true");c.setAttribute("disabled","true")}else{c.removeAttribute("readonly");c.removeAttribute("disabled")}b.onchange()});f=i.searchoptions.sopt?i.searchoptions.sopt:b.p.sopt?b.p.sopt:"string"===i.searchtype?o.stropts:b.p.numopts;j="";a.each(b.p.ops,function(){q.push(this.name)});for(e=0;e<f.length;e++)p=a.inArray(f[e],q),-1!==p&&(l=g.op===b.p.ops[p].name?" selected='selected'":"",j+="<option value='"+b.p.ops[p].name+"'"+l+">"+b.p.ops[p].description+
"</option>");s.append(j);j=a("<td class='data'></td>");c.append(j);j.append(m);a(m).addClass("input-elm").bind("change",function(){g.data=i.inputtype==="custom"?i.searchoptions.custom_value(a(this).children(".customelement:first"),"get"):a(this).val();b.onchange()});j=a("<td></td>");c.append(j);!0===this.p.ruleButtons&&(m=a("<input type='button' value='-' title='Delete rule' class='delete-rule ui-del'/>"),j.append(m),m.bind("click",function(){for(e=0;e<d.rules.length;e++)if(d.rules[e]===g){d.rules.splice(e,
1);break}b.reDraw();b.onchange();return false}));return c};this.getStringForGroup=function(a){var d="(",b;if(void 0!==a.groups)for(b=0;b<a.groups.length;b++){1<d.length&&(d+=" "+a.groupOp+" ");try{d+=this.getStringForGroup(a.groups[b])}catch(c){alert(c)}}if(void 0!==a.rules)try{for(b=0;b<a.rules.length;b++)1<d.length&&(d+=" "+a.groupOp+" "),d+=this.getStringForRule(a.rules[b])}catch(e){alert(e)}d+=")";return"()"===d?"":d};this.getStringForRule=function(d){var f="",b="",c,e;for(c=0;c<this.p.ops.length;c++)if(this.p.ops[c].name===
d.op){f=this.p.ops[c].operator;b=this.p.ops[c].name;break}for(c=0;c<this.p.columns.length;c++)if(this.p.columns[c].name===d.field){e=this.p.columns[c];break}c=d.data;if("bw"===b||"bn"===b)c+="%";if("ew"===b||"en"===b)c="%"+c;if("cn"===b||"nc"===b)c="%"+c+"%";if("in"===b||"ni"===b)c=" ("+c+")";o.errorcheck&&r(d.data,e);return-1!==a.inArray(e.searchtype,["int","integer","float","number","currency"])||"nn"===b||"nu"===b?d.field+" "+f+" "+c:d.field+" "+f+' "'+c+'"'};this.resetFilter=function(){this.p.filter=
a.extend(!0,{},this.p.initFilter);this.reDraw();this.onchange()};this.hideError=function(){a("th.ui-state-error",this).html("");a("tr.error",this).hide()};this.showError=function(){a("th.ui-state-error",this).html(this.p.errmsg);a("tr.error",this).show()};this.toUserFriendlyString=function(){return this.getStringForGroup(o.filter)};this.toString=function(){function a(b){var c="(",e;if(void 0!==b.groups)for(e=0;e<b.groups.length;e++)1<c.length&&(c="OR"===b.groupOp?c+" || ":c+" && "),c+=a(b.groups[e]);
if(void 0!==b.rules)for(e=0;e<b.rules.length;e++){1<c.length&&(c="OR"===b.groupOp?c+" || ":c+" && ");var f=b.rules[e];if(d.p.errorcheck){for(var h=void 0,i=void 0,h=0;h<d.p.columns.length;h++)if(d.p.columns[h].name===f.field){i=d.p.columns[h];break}i&&r(f.data,i)}c+=f.op+"(item."+f.field+",'"+f.data+"')"}c+=")";return"()"===c?"":c}var d=this;return a(this.p.filter)};this.reDraw();if(this.p.showQuery)this.onchange();this.filter=!0}}})};a.extend(a.fn.jqFilter,{toSQLString:function(){var a="";this.each(function(){a=
this.toUserFriendlyString()});return a},filterData:function(){var a;this.each(function(){a=this.p.filter});return a},getParameter:function(a){return void 0!==a&&this.p.hasOwnProperty(a)?this.p[a]:this.p},resetFilter:function(){return this.each(function(){this.resetFilter()})},addFilter:function(a){"string"===typeof a&&(a=jQuery.jgrid.parse(a));this.each(function(){this.p.filter=a;this.reDraw();this.onchange()})}})})(jQuery);
(function(a){a.jgrid.inlineEdit=a.jgrid.inlineEdit||{};a.jgrid.extend({editRow:function(c,b,d,k,g,l,p,h,f){var j={},e=a.makeArray(arguments).slice(1);if("object"===a.type(e[0]))j=e[0];else if("undefined"!==typeof b&&(j.keys=b),a.isFunction(d)&&(j.oneditfunc=d),a.isFunction(k)&&(j.successfunc=k),"undefined"!==typeof g&&(j.url=g),"undefined"!==typeof l&&(j.extraparam=l),a.isFunction(p)&&(j.aftersavefunc=p),a.isFunction(h)&&(j.errorfunc=h),a.isFunction(f))j.afterrestorefunc=f;j=a.extend(!0,{keys:!1,
oneditfunc:null,successfunc:null,url:null,extraparam:{},aftersavefunc:null,errorfunc:null,afterrestorefunc:null,restoreAfterError:!0,mtype:"POST"},a.jgrid.inlineEdit,j);return this.each(function(){var b=this,f,d,e,g=0,h=null,l={},m,n;b.grid&&(m=a(b).jqGrid("getInd",c,!0),!1!==m&&(e=a(m).attr("editable")||"0","0"==e&&!a(m).hasClass("not-editable-row")&&(n=b.p.colModel,a('td[role="gridcell"]',m).each(function(e){f=n[e].name;var j=!0===b.p.treeGrid&&f==b.p.ExpandColumn;if(j)d=a("span:first",this).html();
else try{d=a.unformat.call(b,this,{rowId:c,colModel:n[e]},e)}catch(m){d=n[e].edittype&&"textarea"==n[e].edittype?a(this).text():a(this).html()}if("cb"!=f&&("subgrid"!=f&&"rn"!=f)&&(b.p.autoencode&&(d=a.jgrid.htmlDecode(d)),l[f]=d,!0===n[e].editable)){null===h&&(h=e);j?a("span:first",this).html(""):a(this).html("");var k=a.extend({},n[e].editoptions||{},{id:c+"_"+f,name:f});n[e].edittype||(n[e].edittype="text");if("&nbsp;"==d||"&#160;"==d||1==d.length&&160==d.charCodeAt(0))d="";k=a.jgrid.createEl.call(b,
n[e].edittype,k,d,!0,a.extend({},a.jgrid.ajaxOptions,b.p.ajaxSelectOptions||{}));a(k).addClass("editable");j?a("span:first",this).append(k):a(this).append(k);"select"==n[e].edittype&&("undefined"!==typeof n[e].editoptions&&!0===n[e].editoptions.multiple&&"undefined"===typeof n[e].editoptions.dataUrl&&a.browser.msie)&&a(k).width(a(k).width());g++}}),0<g&&(l.id=c,b.p.savedRow.push(l),a(m).attr("editable","1"),a("td:eq("+h+") input",m).focus(),!0===j.keys&&a(m).bind("keydown",function(e){if(27===e.keyCode){a(b).jqGrid("restoreRow",
c,j.afterrestorefunc);if(b.p._inlinenav)try{a(b).jqGrid("showAddEditButtons")}catch(d){}return!1}if(13===e.keyCode){if("TEXTAREA"==e.target.tagName)return!0;if(a(b).jqGrid("saveRow",c,j)&&b.p._inlinenav)try{a(b).jqGrid("showAddEditButtons")}catch(f){}return!1}}),a(b).triggerHandler("jqGridInlineEditRow",[c,j]),a.isFunction(j.oneditfunc)&&j.oneditfunc.call(b,c)))))})},saveRow:function(c,b,d,k,g,l,p){var h=a.makeArray(arguments).slice(1),f={};if("object"===a.type(h[0]))f=h[0];else if(a.isFunction(b)&&
(f.successfunc=b),"undefined"!==typeof d&&(f.url=d),"undefined"!==typeof k&&(f.extraparam=k),a.isFunction(g)&&(f.aftersavefunc=g),a.isFunction(l)&&(f.errorfunc=l),a.isFunction(p))f.afterrestorefunc=p;var f=a.extend(!0,{successfunc:null,url:null,extraparam:{},aftersavefunc:null,errorfunc:null,afterrestorefunc:null,restoreAfterError:!0,mtype:"POST"},a.jgrid.inlineEdit,f),j=!1,e=this[0],o,i={},u={},r={},t,s,q;if(!e.grid)return j;q=a(e).jqGrid("getInd",c,!0);if(!1===q)return j;h=a(q).attr("editable");
f.url=f.url?f.url:e.p.editurl;if("1"===h){var m;a('td[role="gridcell"]',q).each(function(b){m=e.p.colModel[b];o=m.name;if("cb"!=o&&"subgrid"!=o&&!0===m.editable&&"rn"!=o&&!a(this).hasClass("not-editable-cell")){switch(m.edittype){case "checkbox":var c=["Yes","No"];m.editoptions&&(c=m.editoptions.value.split(":"));i[o]=a("input",this).is(":checked")?c[0]:c[1];break;case "text":case "password":case "textarea":case "button":i[o]=a("input, textarea",this).val();break;case "select":if(m.editoptions.multiple){var c=
a("select",this),d=[];i[o]=a(c).val();i[o]=i[o]?i[o].join(","):"";a("select option:selected",this).each(function(b,c){d[b]=a(c).text()});u[o]=d.join(",")}else i[o]=a("select option:selected",this).val(),u[o]=a("select option:selected",this).text();m.formatter&&"select"==m.formatter&&(u={});break;case "custom":try{if(m.editoptions&&a.isFunction(m.editoptions.custom_value)){if(i[o]=m.editoptions.custom_value.call(e,a(".customelement",this),"get"),void 0===i[o])throw"e2";}else throw"e1";}catch(g){"e1"==
g&&a.jgrid.info_dialog(a.jgrid.errors.errcap,"function 'custom_value' "+a.jgrid.edit.msg.nodefined,a.jgrid.edit.bClose),"e2"==g?a.jgrid.info_dialog(a.jgrid.errors.errcap,"function 'custom_value' "+a.jgrid.edit.msg.novalue,a.jgrid.edit.bClose):a.jgrid.info_dialog(a.jgrid.errors.errcap,g.message,a.jgrid.edit.bClose)}}s=a.jgrid.checkValues(i[o],b,e);if(!1===s[0])return s[1]=i[o]+" "+s[1],!1;e.p.autoencode&&(i[o]=a.jgrid.htmlEncode(i[o]));"clientArray"!==f.url&&m.editoptions&&!0===m.editoptions.NullIfEmpty&&
""===i[o]&&(r[o]="null")}});if(!1===s[0]){try{var n=a.jgrid.findPos(a("#"+a.jgrid.jqID(c),e.grid.bDiv)[0]);a.jgrid.info_dialog(a.jgrid.errors.errcap,s[1],a.jgrid.edit.bClose,{left:n[0],top:n[1]})}catch(w){alert(s[1])}return j}var v,h=e.p.prmNames;v=h.oper;n=h.id;i&&(i[v]=h.editoper,i[n]=c,"undefined"==typeof e.p.inlineData&&(e.p.inlineData={}),i=a.extend({},i,e.p.inlineData,f.extraparam));if("clientArray"==f.url){i=a.extend({},i,u);e.p.autoencode&&a.each(i,function(b,c){i[b]=a.jgrid.htmlDecode(c)});
n=a(e).jqGrid("setRowData",c,i);a(q).attr("editable","0");for(h=0;h<e.p.savedRow.length;h++)if(e.p.savedRow[h].id==c){t=h;break}0<=t&&e.p.savedRow.splice(t,1);a(e).triggerHandler("jqGridInlineAfterSaveRow",[c,n,i,f]);a.isFunction(f.aftersavefunc)&&f.aftersavefunc.call(e,c,n);j=!0;a(q).unbind("keydown")}else a("#lui_"+a.jgrid.jqID(e.p.id)).show(),r=a.extend({},i,r),r[n]=a.jgrid.stripPref(e.p.idPrefix,r[n]),a.ajax(a.extend({url:f.url,data:a.isFunction(e.p.serializeRowData)?e.p.serializeRowData.call(e,
r):r,type:f.mtype,async:!1,complete:function(b,d){a("#lui_"+a.jgrid.jqID(e.p.id)).hide();if(d==="success"){var g=true,h;h=a(e).triggerHandler("jqGridInlineSuccessSaveRow",[b,c,f]);a.isArray(h)||(h=[true,i]);h[0]&&a.isFunction(f.successfunc)&&(h=f.successfunc.call(e,b));if(a.isArray(h)){g=h[0];i=h[1]?h[1]:i}else g=h;if(g===true){e.p.autoencode&&a.each(i,function(b,c){i[b]=a.jgrid.htmlDecode(c)});i=a.extend({},i,u);a(e).jqGrid("setRowData",c,i);a(q).attr("editable","0");for(g=0;g<e.p.savedRow.length;g++)if(e.p.savedRow[g].id==
c){t=g;break}t>=0&&e.p.savedRow.splice(t,1);a(e).triggerHandler("jqGridInlineAfterSaveRow",[c,b,i,f]);a.isFunction(f.aftersavefunc)&&f.aftersavefunc.call(e,c,b);j=true;a(q).unbind("keydown")}else{a(e).triggerHandler("jqGridInlineErrorSaveRow",[c,b,d,null,f]);a.isFunction(f.errorfunc)&&f.errorfunc.call(e,c,b,d,null);f.restoreAfterError===true&&a(e).jqGrid("restoreRow",c,f.afterrestorefunc)}}},error:function(b,d,g){a("#lui_"+a.jgrid.jqID(e.p.id)).hide();a(e).triggerHandler("jqGridInlineErrorSaveRow",
[c,b,d,g,f]);if(a.isFunction(f.errorfunc))f.errorfunc.call(e,c,b,d,g);else try{a.jgrid.info_dialog(a.jgrid.errors.errcap,'<div class="ui-state-error">'+b.responseText+"</div>",a.jgrid.edit.bClose,{buttonalign:"right"})}catch(h){alert(b.responseText)}f.restoreAfterError===true&&a(e).jqGrid("restoreRow",c,f.afterrestorefunc)}},a.jgrid.ajaxOptions,e.p.ajaxRowOptions||{}))}return j},restoreRow:function(c,b){var d=a.makeArray(arguments).slice(1),k={};"object"===a.type(d[0])?k=d[0]:a.isFunction(b)&&(k.afterrestorefunc=
b);k=a.extend(!0,a.jgrid.inlineEdit,k);return this.each(function(){var b=this,d,p,h={};if(b.grid){p=a(b).jqGrid("getInd",c,true);if(p!==false){for(var f=0;f<b.p.savedRow.length;f++)if(b.p.savedRow[f].id==c){d=f;break}if(d>=0){if(a.isFunction(a.fn.datepicker))try{a("input.hasDatepicker","#"+a.jgrid.jqID(p.id)).datepicker("hide")}catch(j){}a.each(b.p.colModel,function(){this.editable===true&&this.name in b.p.savedRow[d]&&(h[this.name]=b.p.savedRow[d][this.name])});a(b).jqGrid("setRowData",c,h);a(p).attr("editable",
"0").unbind("keydown");b.p.savedRow.splice(d,1);a("#"+a.jgrid.jqID(c),"#"+a.jgrid.jqID(b.p.id)).hasClass("jqgrid-new-row")&&setTimeout(function(){a(b).jqGrid("delRowData",c)},0)}a(b).triggerHandler("jqGridInlineAfterRestoreRow",[c]);a.isFunction(k.afterrestorefunc)&&k.afterrestorefunc.call(b,c)}}})},addRow:function(c){c=a.extend(!0,{rowID:"new_row",initdata:{},position:"first",useDefValues:!0,useFormatter:!1,addRowParams:{extraparam:{}}},c||{});return this.each(function(){if(this.grid){var b=this;
!0===c.useDefValues&&a(b.p.colModel).each(function(){if(this.editoptions&&this.editoptions.defaultValue){var d=this.editoptions.defaultValue,d=a.isFunction(d)?d.call(b):d;c.initdata[this.name]=d}});a(b).jqGrid("addRowData",c.rowID,c.initdata,c.position);c.rowID=b.p.idPrefix+c.rowID;a("#"+a.jgrid.jqID(c.rowID),"#"+a.jgrid.jqID(b.p.id)).addClass("jqgrid-new-row");if(c.useFormatter)a("#"+a.jgrid.jqID(c.rowID)+" .ui-inline-edit","#"+a.jgrid.jqID(b.p.id)).click();else{var d=b.p.prmNames;c.addRowParams.extraparam[d.oper]=
d.addoper;a(b).jqGrid("editRow",c.rowID,c.addRowParams);a(b).jqGrid("setSelection",c.rowID)}}})},inlineNav:function(c,b){b=a.extend({edit:!0,editicon:"ui-icon-pencil",add:!0,addicon:"ui-icon-plus",save:!0,saveicon:"ui-icon-disk",cancel:!0,cancelicon:"ui-icon-cancel",addParams:{useFormatter:!1,rowID:"new_row"},editParams:{},restoreAfterSelect:!0},a.jgrid.nav,b||{});return this.each(function(){if(this.grid){var d=this,k,g=a.jgrid.jqID(d.p.id);d.p._inlinenav=!0;if(!0===b.addParams.useFormatter){var l=
d.p.colModel,p;for(p=0;p<l.length;p++)if(l[p].formatter&&"actions"===l[p].formatter){l[p].formatoptions&&(l=a.extend({keys:!1,onEdit:null,onSuccess:null,afterSave:null,onError:null,afterRestore:null,extraparam:{},url:null},l[p].formatoptions),b.addParams.addRowParams={keys:l.keys,oneditfunc:l.onEdit,successfunc:l.onSuccess,url:l.url,extraparam:l.extraparam,aftersavefunc:l.afterSavef,errorfunc:l.onError,afterrestorefunc:l.afterRestore});break}}b.add&&a(d).jqGrid("navButtonAdd",c,{caption:b.addtext,
title:b.addtitle,buttonicon:b.addicon,id:d.p.id+"_iladd",onClickButton:function(){a(d).jqGrid("addRow",b.addParams);b.addParams.useFormatter||(a("#"+g+"_ilsave").removeClass("ui-state-disabled"),a("#"+g+"_ilcancel").removeClass("ui-state-disabled"),a("#"+g+"_iladd").addClass("ui-state-disabled"),a("#"+g+"_iledit").addClass("ui-state-disabled"))}});b.edit&&a(d).jqGrid("navButtonAdd",c,{caption:b.edittext,title:b.edittitle,buttonicon:b.editicon,id:d.p.id+"_iledit",onClickButton:function(){var c=a(d).jqGrid("getGridParam",
"selrow");c?(a(d).jqGrid("editRow",c,b.editParams),a("#"+g+"_ilsave").removeClass("ui-state-disabled"),a("#"+g+"_ilcancel").removeClass("ui-state-disabled"),a("#"+g+"_iladd").addClass("ui-state-disabled"),a("#"+g+"_iledit").addClass("ui-state-disabled")):(a.jgrid.viewModal("#alertmod",{gbox:"#gbox_"+g,jqm:!0}),a("#jqg_alrt").focus())}});b.save&&(a(d).jqGrid("navButtonAdd",c,{caption:b.savetext||"",title:b.savetitle||"Save row",buttonicon:b.saveicon,id:d.p.id+"_ilsave",onClickButton:function(){var c=
d.p.savedRow[0].id;if(c){var f=d.p.prmNames,j=f.oper;b.editParams.extraparam||(b.editParams.extraparam={});b.editParams.extraparam[j]=a("#"+a.jgrid.jqID(c),"#"+g).hasClass("jqgrid-new-row")?f.addoper:f.editoper;a(d).jqGrid("saveRow",c,b.editParams)&&a(d).jqGrid("showAddEditButtons")}else a.jgrid.viewModal("#alertmod",{gbox:"#gbox_"+g,jqm:!0}),a("#jqg_alrt").focus()}}),a("#"+g+"_ilsave").addClass("ui-state-disabled"));b.cancel&&(a(d).jqGrid("navButtonAdd",c,{caption:b.canceltext||"",title:b.canceltitle||
"Cancel row editing",buttonicon:b.cancelicon,id:d.p.id+"_ilcancel",onClickButton:function(){var c=d.p.savedRow[0].id;if(c){a(d).jqGrid("restoreRow",c,b.editParams);a(d).jqGrid("showAddEditButtons")}else{a.jgrid.viewModal("#alertmod",{gbox:"#gbox_"+g,jqm:true});a("#jqg_alrt").focus()}}}),a("#"+g+"_ilcancel").addClass("ui-state-disabled"));!0===b.restoreAfterSelect&&(k=a.isFunction(d.p.beforeSelectRow)?d.p.beforeSelectRow:!1,d.p.beforeSelectRow=function(c,f){var g=true;if(d.p.savedRow.length>0&&d.p._inlinenav===
true&&c!==d.p.selrow&&d.p.selrow!==null){d.p.selrow==b.addParams.rowID?a(d).jqGrid("delRowData",d.p.selrow):a(d).jqGrid("restoreRow",d.p.selrow,b.editParams);a(d).jqGrid("showAddEditButtons")}k&&(g=k.call(d,c,f));return g})}})},showAddEditButtons:function(){return this.each(function(){if(this.grid){var c=a.jgrid.jqID(this.p.id);a("#"+c+"_ilsave").addClass("ui-state-disabled");a("#"+c+"_ilcancel").addClass("ui-state-disabled");a("#"+c+"_iladd").removeClass("ui-state-disabled");a("#"+c+"_iledit").removeClass("ui-state-disabled")}})}})})(jQuery);
(function(b){b.jgrid.extend({editCell:function(d,f,a){return this.each(function(){var c=this,g,e,h,i;if(c.grid&&!0===c.p.cellEdit){f=parseInt(f,10);c.p.selrow=c.rows[d].id;c.p.knv||b(c).jqGrid("GridNav");if(0<c.p.savedRow.length){if(!0===a&&d==c.p.iRow&&f==c.p.iCol)return;b(c).jqGrid("saveCell",c.p.savedRow[0].id,c.p.savedRow[0].ic)}else window.setTimeout(function(){b("#"+b.jgrid.jqID(c.p.knv)).attr("tabindex","-1").focus()},0);i=c.p.colModel[f];g=i.name;if(!("subgrid"==g||"cb"==g||"rn"==g)){h=b("td:eq("+
f+")",c.rows[d]);if(!0===i.editable&&!0===a&&!h.hasClass("not-editable-cell")){0<=parseInt(c.p.iCol,10)&&0<=parseInt(c.p.iRow,10)&&(b("td:eq("+c.p.iCol+")",c.rows[c.p.iRow]).removeClass("edit-cell ui-state-highlight"),b(c.rows[c.p.iRow]).removeClass("selected-row ui-state-hover"));b(h).addClass("edit-cell ui-state-highlight");b(c.rows[d]).addClass("selected-row ui-state-hover");try{e=b.unformat.call(c,h,{rowId:c.rows[d].id,colModel:i},f)}catch(k){e=i.edittype&&"textarea"==i.edittype?b(h).text():b(h).html()}c.p.autoencode&&
(e=b.jgrid.htmlDecode(e));i.edittype||(i.edittype="text");c.p.savedRow.push({id:d,ic:f,name:g,v:e});if("&nbsp;"===e||"&#160;"===e||1===e.length&&160===e.charCodeAt(0))e="";if(b.isFunction(c.p.formatCell)){var j=c.p.formatCell.call(c,c.rows[d].id,g,e,d,f);void 0!==j&&(e=j)}var j=b.extend({},i.editoptions||{},{id:d+"_"+g,name:g}),n=b.jgrid.createEl.call(c,i.edittype,j,e,!0,b.extend({},b.jgrid.ajaxOptions,c.p.ajaxSelectOptions||{}));b(c).triggerHandler("jqGridBeforeEditCell",[c.rows[d].id,g,e,d,f]);
b.isFunction(c.p.beforeEditCell)&&c.p.beforeEditCell.call(c,c.rows[d].id,g,e,d,f);b(h).html("").append(n).attr("tabindex","0");window.setTimeout(function(){b(n).focus()},0);b("input, select, textarea",h).bind("keydown",function(a){a.keyCode===27&&(b("input.hasDatepicker",h).length>0?b(".ui-datepicker").is(":hidden")?b(c).jqGrid("restoreCell",d,f):b("input.hasDatepicker",h).datepicker("hide"):b(c).jqGrid("restoreCell",d,f));if(a.keyCode===13){b(c).jqGrid("saveCell",d,f);return false}if(a.keyCode===
9){if(c.grid.hDiv.loading)return false;a.shiftKey?b(c).jqGrid("prevCell",d,f):b(c).jqGrid("nextCell",d,f)}a.stopPropagation()});b(c).triggerHandler("jqGridAfterEditCell",[c.rows[d].id,g,e,d,f]);b.isFunction(c.p.afterEditCell)&&c.p.afterEditCell.call(c,c.rows[d].id,g,e,d,f)}else 0<=parseInt(c.p.iCol,10)&&0<=parseInt(c.p.iRow,10)&&(b("td:eq("+c.p.iCol+")",c.rows[c.p.iRow]).removeClass("edit-cell ui-state-highlight"),b(c.rows[c.p.iRow]).removeClass("selected-row ui-state-hover")),h.addClass("edit-cell ui-state-highlight"),
b(c.rows[d]).addClass("selected-row ui-state-hover"),e=h.html().replace(/\&#160\;/ig,""),b(c).triggerHandler("jqGridSelectCell",[c.rows[d].id,g,e,d,f]),b.isFunction(c.p.onSelectCell)&&c.p.onSelectCell.call(c,c.rows[d].id,g,e,d,f);c.p.iCol=f;c.p.iRow=d}}})},saveCell:function(d,f){return this.each(function(){var a=this,c;if(a.grid&&!0===a.p.cellEdit){c=1<=a.p.savedRow.length?0:null;if(null!==c){var g=b("td:eq("+f+")",a.rows[d]),e,h,i=a.p.colModel[f],k=i.name,j=b.jgrid.jqID(k);switch(i.edittype){case "select":if(i.editoptions.multiple){var j=
b("#"+d+"_"+j,a.rows[d]),n=[];(e=b(j).val())?e.join(","):e="";b("option:selected",j).each(function(a,c){n[a]=b(c).text()});h=n.join(",")}else e=b("#"+d+"_"+j+" option:selected",a.rows[d]).val(),h=b("#"+d+"_"+j+" option:selected",a.rows[d]).text();i.formatter&&(h=e);break;case "checkbox":var l=["Yes","No"];i.editoptions&&(l=i.editoptions.value.split(":"));h=e=b("#"+d+"_"+j,a.rows[d]).is(":checked")?l[0]:l[1];break;case "password":case "text":case "textarea":case "button":h=e=b("#"+d+"_"+j,a.rows[d]).val();
break;case "custom":try{if(i.editoptions&&b.isFunction(i.editoptions.custom_value)){e=i.editoptions.custom_value.call(a,b(".customelement",g),"get");if(void 0===e)throw"e2";h=e}else throw"e1";}catch(o){"e1"==o&&b.jgrid.info_dialog(jQuery.jgrid.errors.errcap,"function 'custom_value' "+b.jgrid.edit.msg.nodefined,jQuery.jgrid.edit.bClose),"e2"==o?b.jgrid.info_dialog(jQuery.jgrid.errors.errcap,"function 'custom_value' "+b.jgrid.edit.msg.novalue,jQuery.jgrid.edit.bClose):b.jgrid.info_dialog(jQuery.jgrid.errors.errcap,
o.message,jQuery.jgrid.edit.bClose)}}if(h!==a.p.savedRow[c].v){if(c=b(a).triggerHandler("jqGridBeforeSaveCell",[a.rows[d].id,k,e,d,f]))h=e=c;if(b.isFunction(a.p.beforeSaveCell)&&(c=a.p.beforeSaveCell.call(a,a.rows[d].id,k,e,d,f)))h=e=c;var p=b.jgrid.checkValues(e,f,a);if(!0===p[0]){c=b(a).triggerHandler("jqGridBeforeSubmitCell",[a.rows[d].id,k,e,d,f])||{};b.isFunction(a.p.beforeSubmitCell)&&((c=a.p.beforeSubmitCell.call(a,a.rows[d].id,k,e,d,f))||(c={}));0<b("input.hasDatepicker",g).length&&b("input.hasDatepicker",
g).datepicker("hide");if("remote"==a.p.cellsubmit)if(a.p.cellurl){var m={};a.p.autoencode&&(e=b.jgrid.htmlEncode(e));m[k]=e;l=a.p.prmNames;i=l.id;j=l.oper;m[i]=b.jgrid.stripPref(a.p.idPrefix,a.rows[d].id);m[j]=l.editoper;m=b.extend(c,m);b("#lui_"+b.jgrid.jqID(a.p.id)).show();a.grid.hDiv.loading=!0;b.ajax(b.extend({url:a.p.cellurl,data:b.isFunction(a.p.serializeCellData)?a.p.serializeCellData.call(a,m):m,type:"POST",complete:function(c,i){b("#lui_"+a.p.id).hide();a.grid.hDiv.loading=false;if(i=="success"){var j=
b(a).triggerHandler("jqGridAfterSubmitCell",[a,c,m.id,k,e,d,f])||[true,""];j[0]===true&&b.isFunction(a.p.afterSubmitCell)&&(j=a.p.afterSubmitCell.call(a,c,m.id,k,e,d,f));if(j[0]===true){b(g).empty();b(a).jqGrid("setCell",a.rows[d].id,f,h,false,false,true);b(g).addClass("dirty-cell");b(a.rows[d]).addClass("edited");b(a).triggerHandler("jqGridAfterSaveCell",[a.rows[d].id,k,e,d,f]);b.isFunction(a.p.afterSaveCell)&&a.p.afterSaveCell.call(a,a.rows[d].id,k,e,d,f);a.p.savedRow.splice(0,1)}else{b.jgrid.info_dialog(b.jgrid.errors.errcap,
j[1],b.jgrid.edit.bClose);b(a).jqGrid("restoreCell",d,f)}}},error:function(c,e,h){b("#lui_"+b.jgrid.jqID(a.p.id)).hide();a.grid.hDiv.loading=false;b(a).triggerHandler("jqGridErrorCell",[c,e,h]);b.isFunction(a.p.errorCell)?a.p.errorCell.call(a,c,e,h):b.jgrid.info_dialog(b.jgrid.errors.errcap,c.status+" : "+c.statusText+"<br/>"+e,b.jgrid.edit.bClose);b(a).jqGrid("restoreCell",d,f)}},b.jgrid.ajaxOptions,a.p.ajaxCellOptions||{}))}else try{b.jgrid.info_dialog(b.jgrid.errors.errcap,b.jgrid.errors.nourl,
b.jgrid.edit.bClose),b(a).jqGrid("restoreCell",d,f)}catch(q){}"clientArray"==a.p.cellsubmit&&(b(g).empty(),b(a).jqGrid("setCell",a.rows[d].id,f,h,!1,!1,!0),b(g).addClass("dirty-cell"),b(a.rows[d]).addClass("edited"),b(a).triggerHandler("jqGridAfterSaveCell",[a.rows[d].id,k,e,d,f]),b.isFunction(a.p.afterSaveCell)&&a.p.afterSaveCell.call(a,a.rows[d].id,k,e,d,f),a.p.savedRow.splice(0,1))}else try{window.setTimeout(function(){b.jgrid.info_dialog(b.jgrid.errors.errcap,e+" "+p[1],b.jgrid.edit.bClose)},
100),b(a).jqGrid("restoreCell",d,f)}catch(r){}}else b(a).jqGrid("restoreCell",d,f)}b.browser.opera?b("#"+b.jgrid.jqID(a.p.knv)).attr("tabindex","-1").focus():window.setTimeout(function(){b("#"+b.jgrid.jqID(a.p.knv)).attr("tabindex","-1").focus()},0)}})},restoreCell:function(d,f){return this.each(function(){var a=this,c;if(a.grid&&!0===a.p.cellEdit){c=1<=a.p.savedRow.length?0:null;if(null!==c){var g=b("td:eq("+f+")",a.rows[d]);if(b.isFunction(b.fn.datepicker))try{b("input.hasDatepicker",g).datepicker("hide")}catch(e){}b(g).empty().attr("tabindex",
"-1");b(a).jqGrid("setCell",a.rows[d].id,f,a.p.savedRow[c].v,!1,!1,!0);b(a).triggerHandler("jqGridAfterRestoreCell",[a.rows[d].id,a.p.savedRow[c].v,d,f]);b.isFunction(a.p.afterRestoreCell)&&a.p.afterRestoreCell.call(a,a.rows[d].id,a.p.savedRow[c].v,d,f);a.p.savedRow.splice(0,1)}window.setTimeout(function(){b("#"+a.p.knv).attr("tabindex","-1").focus()},0)}})},nextCell:function(d,f){return this.each(function(){var a=!1;if(this.grid&&!0===this.p.cellEdit){for(var c=f+1;c<this.p.colModel.length;c++)if(!0===
this.p.colModel[c].editable){a=c;break}!1!==a?b(this).jqGrid("editCell",d,a,!0):0<this.p.savedRow.length&&b(this).jqGrid("saveCell",d,f)}})},prevCell:function(d,f){return this.each(function(){var a=!1;if(this.grid&&!0===this.p.cellEdit){for(var c=f-1;0<=c;c--)if(!0===this.p.colModel[c].editable){a=c;break}!1!==a?b(this).jqGrid("editCell",d,a,!0):0<this.p.savedRow.length&&b(this).jqGrid("saveCell",d,f)}})},GridNav:function(){return this.each(function(){function d(c,d,e){if("v"==e.substr(0,1)){var f=
b(a.grid.bDiv)[0].clientHeight,g=b(a.grid.bDiv)[0].scrollTop,l=a.rows[c].offsetTop+a.rows[c].clientHeight,o=a.rows[c].offsetTop;"vd"==e&&l>=f&&(b(a.grid.bDiv)[0].scrollTop=b(a.grid.bDiv)[0].scrollTop+a.rows[c].clientHeight);"vu"==e&&o<g&&(b(a.grid.bDiv)[0].scrollTop=b(a.grid.bDiv)[0].scrollTop-a.rows[c].clientHeight)}"h"==e&&(e=b(a.grid.bDiv)[0].clientWidth,f=b(a.grid.bDiv)[0].scrollLeft,g=a.rows[c].cells[d].offsetLeft,a.rows[c].cells[d].offsetLeft+a.rows[c].cells[d].clientWidth>=e+parseInt(f,10)?
b(a.grid.bDiv)[0].scrollLeft=b(a.grid.bDiv)[0].scrollLeft+a.rows[c].cells[d].clientWidth:g<f&&(b(a.grid.bDiv)[0].scrollLeft=b(a.grid.bDiv)[0].scrollLeft-a.rows[c].cells[d].clientWidth))}function f(b,c){var d,e;if("lft"==c){d=b+1;for(e=b;0<=e;e--)if(!0!==a.p.colModel[e].hidden){d=e;break}}if("rgt"==c){d=b-1;for(e=b;e<a.p.colModel.length;e++)if(!0!==a.p.colModel[e].hidden){d=e;break}}return d}var a=this;if(a.grid&&!0===a.p.cellEdit){a.p.knv=a.p.id+"_kn";var c=b("<span style='width:0px;height:0px;background-color:black;' tabindex='0'><span tabindex='-1' style='width:0px;height:0px;background-color:grey' id='"+
a.p.knv+"'></span></span>"),g,e;b(c).insertBefore(a.grid.cDiv);b("#"+a.p.knv).focus().keydown(function(c){e=c.keyCode;"rtl"==a.p.direction&&(37===e?e=39:39===e&&(e=37));switch(e){case 38:0<a.p.iRow-1&&(d(a.p.iRow-1,a.p.iCol,"vu"),b(a).jqGrid("editCell",a.p.iRow-1,a.p.iCol,!1));break;case 40:a.p.iRow+1<=a.rows.length-1&&(d(a.p.iRow+1,a.p.iCol,"vd"),b(a).jqGrid("editCell",a.p.iRow+1,a.p.iCol,!1));break;case 37:0<=a.p.iCol-1&&(g=f(a.p.iCol-1,"lft"),d(a.p.iRow,g,"h"),b(a).jqGrid("editCell",a.p.iRow,g,
!1));break;case 39:a.p.iCol+1<=a.p.colModel.length-1&&(g=f(a.p.iCol+1,"rgt"),d(a.p.iRow,g,"h"),b(a).jqGrid("editCell",a.p.iRow,g,!1));break;case 13:0<=parseInt(a.p.iCol,10)&&0<=parseInt(a.p.iRow,10)&&b(a).jqGrid("editCell",a.p.iRow,a.p.iCol,!0);break;default:return!0}return!1})}})},getChangedCells:function(d){var f=[];d||(d="all");this.each(function(){var a=this,c;a.grid&&!0===a.p.cellEdit&&b(a.rows).each(function(g){var e={};b(this).hasClass("edited")&&(b("td",this).each(function(f){c=a.p.colModel[f].name;
if("cb"!==c&&"subgrid"!==c)if("dirty"==d){if(b(this).hasClass("dirty-cell"))try{e[c]=b.unformat.call(a,this,{rowId:a.rows[g].id,colModel:a.p.colModel[f]},f)}catch(i){e[c]=b.jgrid.htmlDecode(b(this).html())}}else try{e[c]=b.unformat.call(a,this,{rowId:a.rows[g].id,colModel:a.p.colModel[f]},f)}catch(k){e[c]=b.jgrid.htmlDecode(b(this).html())}}),e.id=this.id,f.push(e))})});return f}})})(jQuery);
(function(b){b.fn.jqm=function(a){var k={overlay:50,closeoverlay:!0,overlayClass:"jqmOverlay",closeClass:"jqmClose",trigger:".jqModal",ajax:d,ajaxText:"",target:d,modal:d,toTop:d,onShow:d,onHide:d,onLoad:d};return this.each(function(){if(this._jqm)return i[this._jqm].c=b.extend({},i[this._jqm].c,a);g++;this._jqm=g;i[g]={c:b.extend(k,b.jqm.params,a),a:d,w:b(this).addClass("jqmID"+g),s:g};k.trigger&&b(this).jqmAddTrigger(k.trigger)})};b.fn.jqmAddClose=function(a){return n(this,a,"jqmHide")};b.fn.jqmAddTrigger=
function(a){return n(this,a,"jqmShow")};b.fn.jqmShow=function(a){return this.each(function(){b.jqm.open(this._jqm,a)})};b.fn.jqmHide=function(a){return this.each(function(){b.jqm.close(this._jqm,a)})};b.jqm={hash:{},open:function(a,k){var c=i[a],e=c.c,l="."+e.closeClass,h=parseInt(c.w.css("z-index")),h=0<h?h:3E3,f=b("<div></div>").css({height:"100%",width:"100%",position:"fixed",left:0,top:0,"z-index":h-1,opacity:e.overlay/100});if(c.a)return d;c.t=k;c.a=!0;c.w.css("z-index",h);e.modal?(j[0]||setTimeout(function(){o("bind")},
1),j.push(a)):0<e.overlay?e.closeoverlay&&c.w.jqmAddClose(f):f=d;c.o=f?f.addClass(e.overlayClass).prependTo("body"):d;if(p&&(b("html,body").css({height:"100%",width:"100%"}),f)){var f=f.css({position:"absolute"})[0],g;for(g in{Top:1,Left:1})f.style.setExpression(g.toLowerCase(),"(_=(document.documentElement.scroll"+g+" || document.body.scroll"+g+"))+'px'")}e.ajax?(h=e.target||c.w,f=e.ajax,h="string"==typeof h?b(h,c.w):b(h),f="@"==f.substr(0,1)?b(k).attr(f.substring(1)):f,h.html(e.ajaxText).load(f,
function(){e.onLoad&&e.onLoad.call(this,c);l&&c.w.jqmAddClose(b(l,c.w));q(c)})):l&&c.w.jqmAddClose(b(l,c.w));e.toTop&&c.o&&c.w.before('<span id="jqmP'+c.w[0]._jqm+'"></span>').insertAfter(c.o);e.onShow?e.onShow(c):c.w.show();q(c);return d},close:function(a){a=i[a];if(!a.a)return d;a.a=d;j[0]&&(j.pop(),j[0]||o("unbind"));a.c.toTop&&a.o&&b("#jqmP"+a.w[0]._jqm).after(a.w).remove();if(a.c.onHide)a.c.onHide(a);else a.w.hide(),a.o&&a.o.remove();return d},params:{}};var g=0,i=b.jqm.hash,j=[],p=b.browser.msie&&
"6.0"==b.browser.version,d=!1,q=function(a){var d=b('<iframe src="javascript:false;document.write(\'\');" class="jqm"></iframe>').css({opacity:0});p&&(a.o?a.o.html('<p style="width:100%;height:100%"/>').prepend(d):b("iframe.jqm",a.w)[0]||a.w.prepend(d));r(a)},r=function(a){try{b(":input:visible",a.w)[0].focus()}catch(d){}},o=function(a){b(document)[a]("keypress",m)[a]("keydown",m)[a]("mousedown",m)},m=function(a){var d=i[j[j.length-1]];(a=!b(a.target).parents(".jqmID"+d.s)[0])&&r(d);return!a},n=function(a,
g,c){return a.each(function(){var a=this._jqm;b(g).each(function(){this[c]||(this[c]=[],b(this).click(function(){for(var a in{jqmShow:1,jqmHide:1})for(var b in this[a])if(i[this[a][b]])i[this[a][b]].w[a](this);return d}));this[c].push(a)})})}})(jQuery);
(function(b){b.fn.jqDrag=function(a){return h(this,a,"d")};b.fn.jqResize=function(a,b){return h(this,a,"r",b)};b.jqDnR={dnr:{},e:0,drag:function(a){"d"==d.k?e.css({left:d.X+a.pageX-d.pX,top:d.Y+a.pageY-d.pY}):(e.css({width:Math.max(a.pageX-d.pX+d.W,0),height:Math.max(a.pageY-d.pY+d.H,0)}),f&&g.css({width:Math.max(a.pageX-f.pX+f.W,0),height:Math.max(a.pageY-f.pY+f.H,0)}));return!1},stop:function(){b(document).unbind("mousemove",c.drag).unbind("mouseup",c.stop)}};var c=b.jqDnR,d=c.dnr,e=c.e,g,f,h=function(a,
c,h,l){return a.each(function(){c=c?b(c,a):a;c.bind("mousedown",{e:a,k:h},function(a){var c=a.data,i={};e=c.e;g=l?b(l):!1;if("relative"!=e.css("position"))try{e.position(i)}catch(h){}d={X:i.left||j("left")||0,Y:i.top||j("top")||0,W:j("width")||e[0].scrollWidth||0,H:j("height")||e[0].scrollHeight||0,pX:a.pageX,pY:a.pageY,k:c.k};f=g&&"d"!=c.k?{X:i.left||k("left")||0,Y:i.top||k("top")||0,W:g[0].offsetWidth||k("width")||0,H:g[0].offsetHeight||k("height")||0,pX:a.pageX,pY:a.pageY,k:c.k}:!1;if(b("input.hasDatepicker",
e[0])[0])try{b("input.hasDatepicker",e[0]).datepicker("hide")}catch(m){}b(document).mousemove(b.jqDnR.drag).mouseup(b.jqDnR.stop);return!1})})},j=function(a){return parseInt(e.css(a),10)||!1},k=function(a){return parseInt(g.css(a),10)||!1}})(jQuery);
(function(b){b.jgrid.extend({setSubGrid:function(){return this.each(function(){var e;this.p.subGridOptions=b.extend({plusicon:"ui-icon-plus",minusicon:"ui-icon-minus",openicon:"ui-icon-carat-1-sw",expandOnLoad:!1,delayOnLoad:50,selectOnExpand:!1,reloadOnExpand:!0},this.p.subGridOptions||{});this.p.colNames.unshift("");this.p.colModel.unshift({name:"subgrid",width:b.browser.safari?this.p.subGridWidth+this.p.cellLayout:this.p.subGridWidth,sortable:!1,resizable:!1,hidedlg:!0,search:!1,fixed:!0});e=this.p.subGridModel;
if(e[0]){e[0].align=b.extend([],e[0].align||[]);for(var c=0;c<e[0].name.length;c++)e[0].align[c]=e[0].align[c]||"left"}})},addSubGridCell:function(b,c){var a="",m,l;this.each(function(){a=this.formatCol(b,c);l=this.p.id;m=this.p.subGridOptions.plusicon});return'<td role="gridcell" aria-describedby="'+l+'_subgrid" class="ui-sgcollapsed sgcollapsed" '+a+"><a href='javascript:void(0);'><span class='ui-icon "+m+"'></span></a></td>"},addSubGrid:function(e,c){return this.each(function(){var a=this;if(a.grid){var m=
function(c,e,h){e=b("<td align='"+a.p.subGridModel[0].align[h]+"'></td>").html(e);b(c).append(e)},l=function(c,e){var h,f,n,d=b("<table cellspacing='0' cellpadding='0' border='0'><tbody></tbody></table>"),i=b("<tr></tr>");for(f=0;f<a.p.subGridModel[0].name.length;f++)h=b("<th class='ui-state-default ui-th-subgrid ui-th-column ui-th-"+a.p.direction+"'></th>"),b(h).html(a.p.subGridModel[0].name[f]),b(h).width(a.p.subGridModel[0].width[f]),b(i).append(h);b(d).append(i);c&&(n=a.p.xmlReader.subgrid,b(n.root+
" "+n.row,c).each(function(){i=b("<tr class='ui-widget-content ui-subtblcell'></tr>");if(!0===n.repeatitems)b(n.cell,this).each(function(a){m(i,b(this).text()||"&#160;",a)});else{var c=a.p.subGridModel[0].mapping||a.p.subGridModel[0].name;if(c)for(f=0;f<c.length;f++)m(i,b(c[f],this).text()||"&#160;",f)}b(d).append(i)}));h=b("table:first",a.grid.bDiv).attr("id")+"_";b("#"+b.jgrid.jqID(h+e)).append(d);a.grid.hDiv.loading=!1;b("#load_"+b.jgrid.jqID(a.p.id)).hide();return!1},p=function(c,e){var h,f,d,
g,i,k=b("<table cellspacing='0' cellpadding='0' border='0'><tbody></tbody></table>"),j=b("<tr></tr>");for(f=0;f<a.p.subGridModel[0].name.length;f++)h=b("<th class='ui-state-default ui-th-subgrid ui-th-column ui-th-"+a.p.direction+"'></th>"),b(h).html(a.p.subGridModel[0].name[f]),b(h).width(a.p.subGridModel[0].width[f]),b(j).append(h);b(k).append(j);if(c&&(g=a.p.jsonReader.subgrid,h=c[g.root],"undefined"!==typeof h))for(f=0;f<h.length;f++){d=h[f];j=b("<tr class='ui-widget-content ui-subtblcell'></tr>");
if(!0===g.repeatitems){g.cell&&(d=d[g.cell]);for(i=0;i<d.length;i++)m(j,d[i]||"&#160;",i)}else{var l=a.p.subGridModel[0].mapping||a.p.subGridModel[0].name;if(l.length)for(i=0;i<l.length;i++)m(j,d[l[i]]||"&#160;",i)}b(k).append(j)}f=b("table:first",a.grid.bDiv).attr("id")+"_";b("#"+b.jgrid.jqID(f+e)).append(k);a.grid.hDiv.loading=!1;b("#load_"+b.jgrid.jqID(a.p.id)).hide();return!1},t=function(c){var e,d,f,g;e=b(c).attr("id");d={nd_:(new Date).getTime()};d[a.p.prmNames.subgridid]=e;if(!a.p.subGridModel[0])return!1;
if(a.p.subGridModel[0].params)for(g=0;g<a.p.subGridModel[0].params.length;g++)for(f=0;f<a.p.colModel.length;f++)a.p.colModel[f].name===a.p.subGridModel[0].params[g]&&(d[a.p.colModel[f].name]=b("td:eq("+f+")",c).text().replace(/\&#160\;/ig,""));if(!a.grid.hDiv.loading)switch(a.grid.hDiv.loading=!0,b("#load_"+b.jgrid.jqID(a.p.id)).show(),a.p.subgridtype||(a.p.subgridtype=a.p.datatype),b.isFunction(a.p.subgridtype)?a.p.subgridtype.call(a,d):a.p.subgridtype=a.p.subgridtype.toLowerCase(),a.p.subgridtype){case "xml":case "json":b.ajax(b.extend({type:a.p.mtype,
url:a.p.subGridUrl,dataType:a.p.subgridtype,data:b.isFunction(a.p.serializeSubGridData)?a.p.serializeSubGridData.call(a,d):d,complete:function(c){a.p.subgridtype==="xml"?l(c.responseXML,e):p(b.jgrid.parse(c.responseText),e)}},b.jgrid.ajaxOptions,a.p.ajaxSubgridOptions||{}))}return!1},d,k,q,r=0,g,j;b.each(a.p.colModel,function(){(!0===this.hidden||"rn"===this.name||"cb"===this.name)&&r++});var s=a.rows.length,o=1;void 0!==c&&0<c&&(o=c,s=c+1);for(;o<s;)b(a.rows[o]).hasClass("jqgrow")&&b(a.rows[o].cells[e]).bind("click",
function(){var c=b(this).parent("tr")[0];j=c.nextSibling;if(b(this).hasClass("sgcollapsed")){k=a.p.id;d=c.id;if(a.p.subGridOptions.reloadOnExpand===true||a.p.subGridOptions.reloadOnExpand===false&&!b(j).hasClass("ui-subgrid")){q=e>=1?"<td colspan='"+e+"'>&#160;</td>":"";g=b(a).triggerHandler("jqGridSubGridBeforeExpand",[k+"_"+d,d]);(g=g===false||g==="stop"?false:true)&&b.isFunction(a.p.subGridBeforeExpand)&&(g=a.p.subGridBeforeExpand.call(a,k+"_"+d,d));if(g===false)return false;b(c).after("<tr role='row' class='ui-subgrid'>"+
q+"<td class='ui-widget-content subgrid-cell'><span class='ui-icon "+a.p.subGridOptions.openicon+"'></span></td><td colspan='"+parseInt(a.p.colNames.length-1-r,10)+"' class='ui-widget-content subgrid-data'><div id="+k+"_"+d+" class='tablediv'></div></td></tr>");b(a).triggerHandler("jqGridSubGridRowExpanded",[k+"_"+d,d]);b.isFunction(a.p.subGridRowExpanded)?a.p.subGridRowExpanded.call(a,k+"_"+d,d):t(c)}else b(j).show();b(this).html("<a href='javascript:void(0);'><span class='ui-icon "+a.p.subGridOptions.minusicon+
"'></span></a>").removeClass("sgcollapsed").addClass("sgexpanded");a.p.subGridOptions.selectOnExpand&&b(a).jqGrid("setSelection",d)}else if(b(this).hasClass("sgexpanded")){g=b(a).triggerHandler("jqGridSubGridRowColapsed",[k+"_"+d,d]);if((g=g===false||g==="stop"?false:true)&&b.isFunction(a.p.subGridRowColapsed)){d=c.id;g=a.p.subGridRowColapsed.call(a,k+"_"+d,d)}if(g===false)return false;a.p.subGridOptions.reloadOnExpand===true?b(j).remove(".ui-subgrid"):b(j).hasClass("ui-subgrid")&&b(j).hide();b(this).html("<a href='javascript:void(0);'><span class='ui-icon "+
a.p.subGridOptions.plusicon+"'></span></a>").removeClass("sgexpanded").addClass("sgcollapsed")}return false}),o++;!0===a.p.subGridOptions.expandOnLoad&&b(a.rows).filter(".jqgrow").each(function(a,c){b(c.cells[0]).click()});a.subGridXml=function(a,b){l(a,b)};a.subGridJson=function(a,b){p(a,b)}}})},expandSubGridRow:function(e){return this.each(function(){if((this.grid||e)&&!0===this.p.subGrid){var c=b(this).jqGrid("getInd",e,!0);c&&(c=b("td.sgcollapsed",c)[0])&&b(c).trigger("click")}})},collapseSubGridRow:function(e){return this.each(function(){if((this.grid||
e)&&!0===this.p.subGrid){var c=b(this).jqGrid("getInd",e,!0);c&&(c=b("td.sgexpanded",c)[0])&&b(c).trigger("click")}})},toggleSubGridRow:function(e){return this.each(function(){if((this.grid||e)&&!0===this.p.subGrid){var c=b(this).jqGrid("getInd",e,!0);if(c){var a=b("td.sgcollapsed",c)[0];a?b(a).trigger("click"):(a=b("td.sgexpanded",c)[0])&&b(a).trigger("click")}}})}})})(jQuery);
(function(b){b.extend(b.jgrid,{template:function(a){var d=b.makeArray(arguments).slice(1),e=1;void 0===a&&(a="");return a.replace(/\{([\w\-]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?\}/g,function(a,c){if(isNaN(parseInt(c,10))){for(var b=d[e],g=b.length;g--;)if(c===b[g].nm)return b[g].v;e++}else return e++,d[parseInt(c,10)]})}});b.jgrid.extend({groupingSetup:function(){return this.each(function(){var a=this.p.groupingView;if(null!==a&&("object"===typeof a||b.isFunction(a)))if(a.groupField.length){"undefined"===
typeof a.visibiltyOnNextGrouping&&(a.visibiltyOnNextGrouping=[]);a.lastvalues=[];a.groups=[];a.counters=[];for(var d=0;d<a.groupField.length;d++)a.groupOrder[d]||(a.groupOrder[d]="asc"),a.groupText[d]||(a.groupText[d]="{0}"),"boolean"!==typeof a.groupColumnShow[d]&&(a.groupColumnShow[d]=!0),"boolean"!==typeof a.groupSummary[d]&&(a.groupSummary[d]=!1),!0===a.groupColumnShow[d]?(a.visibiltyOnNextGrouping[d]=!0,b(this).jqGrid("showCol",a.groupField[d])):(a.visibiltyOnNextGrouping[d]=b("#"+b.jgrid.jqID(this.p.id+
"_"+a.groupField[d])).is(":visible"),b(this).jqGrid("hideCol",a.groupField[d]));a.summary=[];for(var d=this.p.colModel,e=0,f=d.length;e<f;e++)d[e].summaryType&&a.summary.push({nm:d[e].name,st:d[e].summaryType,v:"",sr:d[e].summaryRound,srt:d[e].summaryRoundType||"round"})}else this.p.grouping=!1;else this.p.grouping=!1})},groupingPrepare:function(a,d,e,f){this.each(function(){for(var c=this.p.groupingView,h=this,g=c.groupField.length,k,j,p=0,i=0;i<g;i++)k=c.groupField[i],j=e[k],void 0!==j&&(0===f?
(c.groups.push({idx:i,dataIndex:k,value:j,startRow:f,cnt:1,summary:[]}),c.lastvalues[i]=j,c.counters[i]={cnt:1,pos:c.groups.length-1,summary:b.extend(!0,[],c.summary)}):"object"!==typeof j&&c.lastvalues[i]!==j?(c.groups.push({idx:i,dataIndex:k,value:j,startRow:f,cnt:1,summary:[]}),c.lastvalues[i]=j,p=1,c.counters[i]={cnt:1,pos:c.groups.length-1,summary:b.extend(!0,[],c.summary)}):1===p?(c.groups.push({idx:i,dataIndex:k,value:j,startRow:f,cnt:1,summary:[]}),c.lastvalues[i]=j,c.counters[i]={cnt:1,pos:c.groups.length-
1,summary:b.extend(!0,[],c.summary)}):(c.counters[i].cnt+=1,c.groups[c.counters[i].pos].cnt=c.counters[i].cnt),b.each(c.counters[i].summary,function(){this.v=b.isFunction(this.st)?this.st.call(h,this.v,this.nm,e):b(h).jqGrid("groupingCalculations.handler",this.st,this.v,this.nm,this.sr,this.srt,e)}),c.groups[c.counters[i].pos].summary=c.counters[i].summary);d.push(a)});return d},groupingToggle:function(a){this.each(function(){var d=this.p.groupingView,e=a.split("_"),f=parseInt(e[e.length-2],10);e.splice(e.length-
2,2);var e=e.join("_"),c=d.minusicon,h=d.plusicon,g=b("#"+b.jgrid.jqID(a)),g=g.length?g[0].nextSibling:null,k=b("#"+b.jgrid.jqID(a)+" span.tree-wrap-"+this.p.direction),j=!1;if(k.hasClass(c)){if(d.showSummaryOnHide){if(g)for(;g&&!b(g).hasClass("jqfoot");)b(g).hide(),g=g.nextSibling}else if(g)for(;g&&!b(g).hasClass(e+"_"+(""+f))&&!b(g).hasClass(e+"_"+(""+(f-1)));)b(g).hide(),g=g.nextSibling;k.removeClass(c).addClass(h);j=!0}else{if(g)for(;g&&!b(g).hasClass(e+"_"+(""+f))&&!b(g).hasClass(e+"_"+(""+(f-
1)));)b(g).show(),g=g.nextSibling;k.removeClass(h).addClass(c)}b(this).triggerHandler("jqGridGroupingClickGroup",[a,j]);b.isFunction(this.p.onClickGroup)&&this.p.onClickGroup.call(this,a,j)});return!1},groupingRender:function(a,d){return this.each(function(){function e(a,c,b){if(0===c)return b[a];var d=b[a].idx;if(0===d)return b[a];for(;0<=a;a--)if(b[a].idx===d-c)return b[a]}var f=this,c=f.p.groupingView,h="",g="",k,j,p=c.groupCollapse?c.plusicon:c.minusicon,i,w=[],x=c.groupField.length,p=p+(" tree-wrap-"+
f.p.direction);b.each(f.p.colModel,function(a,b){for(var d=0;d<x;d++)if(c.groupField[d]===b.name){w[d]=a;break}});var s=0,y=c.groupSummary;y.reverse();b.each(c.groups,function(r,l){s++;j=f.p.id+"ghead_"+l.idx;k=j+"_"+r;g="<span style='cursor:pointer;' class='ui-icon "+p+"' onclick=\"jQuery('#"+b.jgrid.jqID(f.p.id)+"').jqGrid('groupingToggle','"+k+"');return false;\"></span>";try{i=f.formatter(k,l.value,w[l.idx],l.value)}catch(C){i=l.value}h+='<tr id="'+k+'" role="row" class= "ui-widget-content jqgroup ui-row-'+
f.p.direction+" "+j+'"><td style="padding-left:'+12*l.idx+'px;" colspan="'+d+'">'+g+b.jgrid.template(c.groupText[l.idx],i,l.cnt,l.summary)+"</td></tr>";if(x-1===l.idx){for(var m=c.groups[r+1],o=void 0!==m?c.groups[r+1].startRow:a.length,t=l.startRow;t<o;t++)h+=a[t].join("");var q;if(void 0!==m){for(q=0;q<c.groupField.length&&m.dataIndex!==c.groupField[q];q++);s=c.groupField.length-q}for(m=0;m<s;m++)if(y[m]){o="";c.groupCollapse&&!c.showSummaryOnHide&&(o=' style="display:none;"');h+="<tr"+o+' role="row" class="ui-widget-content jqfoot ui-row-'+
f.p.direction+'">';for(var o=e(r,m,c.groups),u=f.p.colModel,v,z=o.cnt,n=0;n<d;n++){var A="<td "+f.formatCol(n,1,"")+">&#160;</td>",B="{0}";b.each(o.summary,function(){if(this.nm===u[n].name){u[n].summaryTpl&&(B=u[n].summaryTpl);"avg"===this.st.toLowerCase()&&(this.v&&0<z)&&(this.v/=z);try{v=f.formatter("",this.v,n,this)}catch(a){v=this.v}A="<td "+f.formatCol(n,1,"")+">"+b.jgrid.format(B,v)+"</td>";return!1}});h+=A}h+="</tr>"}s=q}});b("#"+b.jgrid.jqID(f.p.id)+" tbody:first").append(h);h=null})},groupingGroupBy:function(a,
d){return this.each(function(){"string"===typeof a&&(a=[a]);var e=this.p.groupingView;this.p.grouping=!0;"undefined"===typeof e.visibiltyOnNextGrouping&&(e.visibiltyOnNextGrouping=[]);var f;for(f=0;f<e.groupField.length;f++)!e.groupColumnShow[f]&&e.visibiltyOnNextGrouping[f]&&b(this).jqGrid("showCol",e.groupField[f]);for(f=0;f<a.length;f++)e.visibiltyOnNextGrouping[f]=b("#"+b.jgrid.jqID(this.p.id)+"_"+b.jgrid.jqID(a[f])).is(":visible");this.p.groupingView=b.extend(this.p.groupingView,d||{});e.groupField=
a;b(this).trigger("reloadGrid")})},groupingRemove:function(a){return this.each(function(){"undefined"===typeof a&&(a=!0);this.p.grouping=!1;if(!0===a){for(var d=this.p.groupingView,e=0;e<d.groupField.length;e++)!d.groupColumnShow[e]&&d.visibiltyOnNextGrouping[e]&&b(this).jqGrid("showCol",d.groupField);b("tr.jqgroup, tr.jqfoot","#"+b.jgrid.jqID(this.p.id)+" tbody:first").remove();b("tr.jqgrow:hidden","#"+b.jgrid.jqID(this.p.id)+" tbody:first").show()}else b(this).trigger("reloadGrid")})},groupingCalculations:{handler:function(a,
b,e,f,c,h){var g={sum:function(){return parseFloat(b||0)+parseFloat(h[e]||0)},min:function(){return""===b?parseFloat(h[e]||0):Math.min(parseFloat(b),parseFloat(h[e]||0))},max:function(){return""===b?parseFloat(h[e]||0):Math.max(parseFloat(b),parseFloat(h[e]||0))},count:function(){""===b&&(b=0);return h.hasOwnProperty(e)?b+1:0},avg:function(){return g.sum()}};if(!g[a])throw"jqGrid Grouping No such method: "+a;a=g[a]();null!=f&&("fixed"==c?a=a.toFixed(f):(f=Math.pow(10,f),a=Math.round(a*f)/f));return a}}})})(jQuery);
(function(d){d.jgrid.extend({setTreeNode:function(a,c){return this.each(function(){var b=this;if(b.grid&&b.p.treeGrid)for(var e=b.p.expColInd,g=b.p.treeReader.expanded_field,h=b.p.treeReader.leaf_field,f=b.p.treeReader.level_field,l=b.p.treeReader.icon_field,j=b.p.treeReader.loaded,i,p,m,k;a<c;)k=b.p.data[b.p._index[b.rows[a].id]],"nested"==b.p.treeGridModel&&!k[h]&&(i=parseInt(k[b.p.treeReader.left_field],10),p=parseInt(k[b.p.treeReader.right_field],10),k[h]=p===i+1?"true":"false",b.rows[a].cells[b.p._treeleafpos].innerHTML=
k[h]),i=parseInt(k[f],10),0===b.p.tree_root_level?(m=i+1,p=i):(m=i,p=i-1),m="<div class='tree-wrap tree-wrap-"+b.p.direction+"' style='width:"+18*m+"px;'>",m+="<div style='"+("rtl"==b.p.direction?"right:":"left:")+18*p+"px;' class='ui-icon ",void 0!==k[j]&&(k[j]="true"==k[j]||!0===k[j]?!0:!1),"true"==k[h]||!0===k[h]?(m+=(void 0!==k[l]&&""!==k[l]?k[l]:b.p.treeIcons.leaf)+" tree-leaf treeclick",k[h]=!0,p="leaf"):(k[h]=!1,p=""),k[g]=("true"==k[g]||!0===k[g]?!0:!1)&&k[j],m=!1===k[g]?m+(!0===k[h]?"'":
b.p.treeIcons.plus+" tree-plus treeclick'"):m+(!0===k[h]?"'":b.p.treeIcons.minus+" tree-minus treeclick'"),m+="></div></div>",d(b.rows[a].cells[e]).wrapInner("<span class='cell-wrapper"+p+"'></span>").prepend(m),i!==parseInt(b.p.tree_root_level,10)&&((k=(k=d(b).jqGrid("getNodeParent",k))&&k.hasOwnProperty(g)?k[g]:!0)||d(b.rows[a]).css("display","none")),d(b.rows[a].cells[e]).find("div.treeclick").bind("click",function(a){a=d(a.target||a.srcElement,b.rows).closest("tr.jqgrow")[0].id;a=b.p._index[a];
if(!b.p.data[a][h])if(b.p.data[a][g]){d(b).jqGrid("collapseRow",b.p.data[a]);d(b).jqGrid("collapseNode",b.p.data[a])}else{d(b).jqGrid("expandRow",b.p.data[a]);d(b).jqGrid("expandNode",b.p.data[a])}return false}),!0===b.p.ExpandColClick&&d(b.rows[a].cells[e]).find("span.cell-wrapper").css("cursor","pointer").bind("click",function(a){var a=d(a.target||a.srcElement,b.rows).closest("tr.jqgrow")[0].id,c=b.p._index[a];if(!b.p.data[c][h])if(b.p.data[c][g]){d(b).jqGrid("collapseRow",b.p.data[c]);d(b).jqGrid("collapseNode",
b.p.data[c])}else{d(b).jqGrid("expandRow",b.p.data[c]);d(b).jqGrid("expandNode",b.p.data[c])}d(b).jqGrid("setSelection",a);return false}),a++})},setTreeGrid:function(){return this.each(function(){var a=this,c=0,b,e=!1,g,h=[];if(a.p.treeGrid){a.p.treedatatype||d.extend(a.p,{treedatatype:a.p.datatype});a.p.subGrid=!1;a.p.altRows=!1;a.p.pgbuttons=!1;a.p.pginput=!1;a.p.gridview=!0;null===a.p.rowTotal&&(a.p.rowNum=1E4);a.p.multiselect=!1;a.p.rowList=[];a.p.expColInd=0;b="ui-icon-triangle-1-"+("rtl"==a.p.direction?
"w":"e");a.p.treeIcons=d.extend({plus:b,minus:"ui-icon-triangle-1-s",leaf:"ui-icon-radio-off"},a.p.treeIcons||{});"nested"==a.p.treeGridModel?a.p.treeReader=d.extend({level_field:"level",left_field:"lft",right_field:"rgt",leaf_field:"isLeaf",expanded_field:"expanded",loaded:"loaded",icon_field:"icon"},a.p.treeReader):"adjacency"==a.p.treeGridModel&&(a.p.treeReader=d.extend({level_field:"level",parent_id_field:"parent",leaf_field:"isLeaf",expanded_field:"expanded",loaded:"loaded",icon_field:"icon"},
a.p.treeReader));for(g in a.p.colModel)if(a.p.colModel.hasOwnProperty(g)){b=a.p.colModel[g].name;b==a.p.ExpandColumn&&!e&&(e=!0,a.p.expColInd=c);c++;for(var f in a.p.treeReader)a.p.treeReader[f]==b&&h.push(b)}d.each(a.p.treeReader,function(b,e){if(e&&d.inArray(e,h)===-1){if(b==="leaf_field")a.p._treeleafpos=c;c++;a.p.colNames.push(e);a.p.colModel.push({name:e,width:1,hidden:true,sortable:false,resizable:false,hidedlg:true,editable:true,search:false})}})}})},expandRow:function(a){this.each(function(){var c=
this;if(c.grid&&c.p.treeGrid){var b=d(c).jqGrid("getNodeChildren",a),e=c.p.treeReader.expanded_field,g=c.rows;d(b).each(function(){var a=d.jgrid.getAccessor(this,c.p.localReader.id);d(g.namedItem(a)).css("display","");this[e]&&d(c).jqGrid("expandRow",this)})}})},collapseRow:function(a){this.each(function(){var c=this;if(c.grid&&c.p.treeGrid){var b=d(c).jqGrid("getNodeChildren",a),e=c.p.treeReader.expanded_field,g=c.rows;d(b).each(function(){var a=d.jgrid.getAccessor(this,c.p.localReader.id);d(g.namedItem(a)).css("display",
"none");this[e]&&d(c).jqGrid("collapseRow",this)})}})},getRootNodes:function(){var a=[];this.each(function(){var c=this;if(c.grid&&c.p.treeGrid)switch(c.p.treeGridModel){case "nested":var b=c.p.treeReader.level_field;d(c.p.data).each(function(){parseInt(this[b],10)===parseInt(c.p.tree_root_level,10)&&a.push(this)});break;case "adjacency":var e=c.p.treeReader.parent_id_field;d(c.p.data).each(function(){(null===this[e]||"null"==(""+this[e]).toLowerCase())&&a.push(this)})}});return a},getNodeDepth:function(a){var c=
null;this.each(function(){if(this.grid&&this.p.treeGrid)switch(this.p.treeGridModel){case "nested":c=parseInt(a[this.p.treeReader.level_field],10)-parseInt(this.p.tree_root_level,10);break;case "adjacency":c=d(this).jqGrid("getNodeAncestors",a).length}});return c},getNodeParent:function(a){var c=null;this.each(function(){if(this.grid&&this.p.treeGrid)switch(this.p.treeGridModel){case "nested":var b=this.p.treeReader.left_field,e=this.p.treeReader.right_field,g=this.p.treeReader.level_field,h=parseInt(a[b],
10),f=parseInt(a[e],10),l=parseInt(a[g],10);d(this.p.data).each(function(){if(parseInt(this[g],10)===l-1&&parseInt(this[b],10)<h&&parseInt(this[e],10)>f)return c=this,!1});break;case "adjacency":var j=this.p.treeReader.parent_id_field,i=this.p.localReader.id;d(this.p.data).each(function(){if(this[i]==a[j])return c=this,!1})}});return c},getNodeChildren:function(a){var c=[];this.each(function(){if(this.grid&&this.p.treeGrid)switch(this.p.treeGridModel){case "nested":var b=this.p.treeReader.left_field,
e=this.p.treeReader.right_field,g=this.p.treeReader.level_field,h=parseInt(a[b],10),f=parseInt(a[e],10),l=parseInt(a[g],10);d(this.p.data).each(function(){parseInt(this[g],10)===l+1&&(parseInt(this[b],10)>h&&parseInt(this[e],10)<f)&&c.push(this)});break;case "adjacency":var j=this.p.treeReader.parent_id_field,i=this.p.localReader.id;d(this.p.data).each(function(){this[j]==a[i]&&c.push(this)})}});return c},getFullTreeNode:function(a){var c=[];this.each(function(){var b;if(this.grid&&this.p.treeGrid)switch(this.p.treeGridModel){case "nested":var e=
this.p.treeReader.left_field,g=this.p.treeReader.right_field,h=this.p.treeReader.level_field,f=parseInt(a[e],10),l=parseInt(a[g],10),j=parseInt(a[h],10);d(this.p.data).each(function(){parseInt(this[h],10)>=j&&(parseInt(this[e],10)>=f&&parseInt(this[e],10)<=l)&&c.push(this)});break;case "adjacency":if(a){c.push(a);var i=this.p.treeReader.parent_id_field,p=this.p.localReader.id;d(this.p.data).each(function(a){b=c.length;for(a=0;a<b;a++)if(c[a][p]==this[i]){c.push(this);break}})}}});return c},getNodeAncestors:function(a){var c=
[];this.each(function(){if(this.grid&&this.p.treeGrid)for(var b=d(this).jqGrid("getNodeParent",a);b;)c.push(b),b=d(this).jqGrid("getNodeParent",b)});return c},isVisibleNode:function(a){var c=!0;this.each(function(){if(this.grid&&this.p.treeGrid){var b=d(this).jqGrid("getNodeAncestors",a),e=this.p.treeReader.expanded_field;d(b).each(function(){c=c&&this[e];if(!c)return!1})}});return c},isNodeLoaded:function(a){var c;this.each(function(){if(this.grid&&this.p.treeGrid){var b=this.p.treeReader.leaf_field;
c=void 0!==a?void 0!==a.loaded?a.loaded:a[b]||0<d(this).jqGrid("getNodeChildren",a).length?!0:!1:!1}});return c},expandNode:function(a){return this.each(function(){if(this.grid&&this.p.treeGrid){var c=this.p.treeReader.expanded_field,b=this.p.treeReader.parent_id_field,e=this.p.treeReader.loaded,g=this.p.treeReader.level_field,h=this.p.treeReader.left_field,f=this.p.treeReader.right_field;if(!a[c]){var l=d.jgrid.getAccessor(a,this.p.localReader.id),j=d("#"+d.jgrid.jqID(l),this.grid.bDiv)[0],i=this.p._index[l];
d(this).jqGrid("isNodeLoaded",this.p.data[i])?(a[c]=!0,d("div.treeclick",j).removeClass(this.p.treeIcons.plus+" tree-plus").addClass(this.p.treeIcons.minus+" tree-minus")):this.grid.hDiv.loading||(a[c]=!0,d("div.treeclick",j).removeClass(this.p.treeIcons.plus+" tree-plus").addClass(this.p.treeIcons.minus+" tree-minus"),this.p.treeANode=j.rowIndex,this.p.datatype=this.p.treedatatype,"nested"==this.p.treeGridModel?d(this).jqGrid("setGridParam",{postData:{nodeid:l,n_left:a[h],n_right:a[f],n_level:a[g]}}):
d(this).jqGrid("setGridParam",{postData:{nodeid:l,parentid:a[b],n_level:a[g]}}),d(this).trigger("reloadGrid"),a[e]=!0,"nested"==this.p.treeGridModel?d(this).jqGrid("setGridParam",{postData:{nodeid:"",n_left:"",n_right:"",n_level:""}}):d(this).jqGrid("setGridParam",{postData:{nodeid:"",parentid:"",n_level:""}}))}}})},collapseNode:function(a){return this.each(function(){if(this.grid&&this.p.treeGrid){var c=this.p.treeReader.expanded_field;a[c]&&(a[c]=!1,c=d.jgrid.getAccessor(a,this.p.localReader.id),
c=d("#"+d.jgrid.jqID(c),this.grid.bDiv)[0],d("div.treeclick",c).removeClass(this.p.treeIcons.minus+" tree-minus").addClass(this.p.treeIcons.plus+" tree-plus"))}})},SortTree:function(a,c,b,e){return this.each(function(){if(this.grid&&this.p.treeGrid){var g,h,f,l=[],j=this,i;g=d(this).jqGrid("getRootNodes");g=d.jgrid.from(g);g.orderBy(a,c,b,e);i=g.select();g=0;for(h=i.length;g<h;g++)f=i[g],l.push(f),d(this).jqGrid("collectChildrenSortTree",l,f,a,c,b,e);d.each(l,function(a){var b=d.jgrid.getAccessor(this,
j.p.localReader.id);d("#"+d.jgrid.jqID(j.p.id)+" tbody tr:eq("+a+")").after(d("tr#"+d.jgrid.jqID(b),j.grid.bDiv))});l=i=g=null}})},collectChildrenSortTree:function(a,c,b,e,g,h){return this.each(function(){if(this.grid&&this.p.treeGrid){var f,l,j,i;f=d(this).jqGrid("getNodeChildren",c);f=d.jgrid.from(f);f.orderBy(b,e,g,h);i=f.select();f=0;for(l=i.length;f<l;f++)j=i[f],a.push(j),d(this).jqGrid("collectChildrenSortTree",a,j,b,e,g,h)}})},setTreeRow:function(a,c){var b=!1;this.each(function(){this.grid&&
this.p.treeGrid&&(b=d(this).jqGrid("setRowData",a,c))});return b},delTreeNode:function(a){return this.each(function(){var c=this.p.localReader.id,b=this.p.treeReader.left_field,e=this.p.treeReader.right_field,g,h,f;if(this.grid&&this.p.treeGrid){var l=this.p._index[a];if(void 0!==l){g=parseInt(this.p.data[l][e],10);h=g-parseInt(this.p.data[l][b],10)+1;l=d(this).jqGrid("getFullTreeNode",this.p.data[l]);if(0<l.length)for(var j=0;j<l.length;j++)d(this).jqGrid("delRowData",l[j][c]);if("nested"===this.p.treeGridModel){c=
d.jgrid.from(this.p.data).greater(b,g,{stype:"integer"}).select();if(c.length)for(f in c)c.hasOwnProperty(f)&&(c[f][b]=parseInt(c[f][b],10)-h);c=d.jgrid.from(this.p.data).greater(e,g,{stype:"integer"}).select();if(c.length)for(f in c)c.hasOwnProperty(f)&&(c[f][e]=parseInt(c[f][e],10)-h)}}}})},addChildNode:function(a,c,b){var e=this[0];if(b){var g=e.p.treeReader.expanded_field,h=e.p.treeReader.leaf_field,f=e.p.treeReader.level_field,l=e.p.treeReader.parent_id_field,j=e.p.treeReader.left_field,i=e.p.treeReader.right_field,
p=e.p.treeReader.loaded,m,k,q,s,o;m=0;var r=c,t;if("undefined"===typeof a||null===a){o=e.p.data.length-1;if(0<=o)for(;0<=o;)m=Math.max(m,parseInt(e.p.data[o][e.p.localReader.id],10)),o--;a=m+1}var u=d(e).jqGrid("getInd",c);t=!1;if(void 0===c||null===c||""===c)r=c=null,m="last",s=e.p.tree_root_level,o=e.p.data.length+1;else if(m="after",k=e.p._index[c],q=e.p.data[k],c=q[e.p.localReader.id],s=parseInt(q[f],10)+1,o=d(e).jqGrid("getFullTreeNode",q),o.length?(r=o=o[o.length-1][e.p.localReader.id],o=d(e).jqGrid("getInd",
r)+1):o=d(e).jqGrid("getInd",c)+1,q[h])t=!0,q[g]=!0,d(e.rows[u]).find("span.cell-wrapperleaf").removeClass("cell-wrapperleaf").addClass("cell-wrapper").end().find("div.tree-leaf").removeClass(e.p.treeIcons.leaf+" tree-leaf").addClass(e.p.treeIcons.minus+" tree-minus"),e.p.data[k][h]=!1,q[p]=!0;k=o+1;b[g]=!1;b[p]=!0;b[f]=s;b[h]=!0;"adjacency"===e.p.treeGridModel&&(b[l]=c);if("nested"===e.p.treeGridModel){var n;if(null!==c){h=parseInt(q[i],10);f=d.jgrid.from(e.p.data);f=f.greaterOrEquals(i,h,{stype:"integer"});
f=f.select();if(f.length)for(n in f)f.hasOwnProperty(n)&&(f[n][j]=f[n][j]>h?parseInt(f[n][j],10)+2:f[n][j],f[n][i]=f[n][i]>=h?parseInt(f[n][i],10)+2:f[n][i]);b[j]=h;b[i]=h+1}else{h=parseInt(d(e).jqGrid("getCol",i,!1,"max"),10);f=d.jgrid.from(e.p.data).greater(j,h,{stype:"integer"}).select();if(f.length)for(n in f)f.hasOwnProperty(n)&&(f[n][j]=parseInt(f[n][j],10)+2);f=d.jgrid.from(e.p.data).greater(i,h,{stype:"integer"}).select();if(f.length)for(n in f)f.hasOwnProperty(n)&&(f[n][i]=parseInt(f[n][i],
10)+2);b[j]=h+1;b[i]=h+2}}if(null===c||d(e).jqGrid("isNodeLoaded",q)||t)d(e).jqGrid("addRowData",a,b,m,r),d(e).jqGrid("setTreeNode",o,k);q&&!q[g]&&d(e.rows[u]).find("div.treeclick").click()}}})})(jQuery);
(function(c){c.jgrid.extend({jqGridImport:function(a){a=c.extend({imptype:"xml",impstring:"",impurl:"",mtype:"GET",impData:{},xmlGrid:{config:"roots>grid",data:"roots>rows"},jsonGrid:{config:"grid",data:"data"},ajaxOptions:{}},a||{});return this.each(function(){var d=this,b=function(a,b){var e=c(b.xmlGrid.config,a)[0],h=c(b.xmlGrid.data,a)[0],f;if(xmlJsonClass.xml2json&&c.jgrid.parse){var e=xmlJsonClass.xml2json(e," "),e=c.jgrid.parse(e),g;for(g in e)e.hasOwnProperty(g)&&(f=e[g]);h?(h=e.grid.datatype,
e.grid.datatype="xmlstring",e.grid.datastr=a,c(d).jqGrid(f).jqGrid("setGridParam",{datatype:h})):c(d).jqGrid(f)}else alert("xml2json or parse are not present")},g=function(a,b){if(a&&"string"==typeof a){var e=!1;c.jgrid.useJSON&&(c.jgrid.useJSON=!1,e=!0);var f=c.jgrid.parse(a);e&&(c.jgrid.useJSON=!0);e=f[b.jsonGrid.config];if(f=f[b.jsonGrid.data]){var g=e.datatype;e.datatype="jsonstring";e.datastr=f;c(d).jqGrid(e).jqGrid("setGridParam",{datatype:g})}else c(d).jqGrid(e)}};switch(a.imptype){case "xml":c.ajax(c.extend({url:a.impurl,
type:a.mtype,data:a.impData,dataType:"xml",complete:function(f,g){"success"==g&&(b(f.responseXML,a),c(d).triggerHandler("jqGridImportComplete",[f,a]),c.isFunction(a.importComplete)&&a.importComplete(f))}},a.ajaxOptions));break;case "xmlstring":if(a.impstring&&"string"==typeof a.impstring){var f=c.jgrid.stringToDoc(a.impstring);f&&(b(f,a),c(d).triggerHandler("jqGridImportComplete",[f,a]),c.isFunction(a.importComplete)&&a.importComplete(f),a.impstring=null);f=null}break;case "json":c.ajax(c.extend({url:a.impurl,
type:a.mtype,data:a.impData,dataType:"json",complete:function(b){try{g(b.responseText,a),c(d).triggerHandler("jqGridImportComplete",[b,a]),c.isFunction(a.importComplete)&&a.importComplete(b)}catch(f){}}},a.ajaxOptions));break;case "jsonstring":a.impstring&&"string"==typeof a.impstring&&(g(a.impstring,a),c(d).triggerHandler("jqGridImportComplete",[a.impstring,a]),c.isFunction(a.importComplete)&&a.importComplete(a.impstring),a.impstring=null)}})},jqGridExport:function(a){var a=c.extend({exptype:"xmlstring",
root:"grid",ident:"\t"},a||{}),d=null;this.each(function(){if(this.grid){var b=c.extend(!0,{},c(this).jqGrid("getGridParam"));b.rownumbers&&(b.colNames.splice(0,1),b.colModel.splice(0,1));b.multiselect&&(b.colNames.splice(0,1),b.colModel.splice(0,1));b.subGrid&&(b.colNames.splice(0,1),b.colModel.splice(0,1));b.knv=null;if(b.treeGrid)for(var g in b.treeReader)b.treeReader.hasOwnProperty(g)&&(b.colNames.splice(b.colNames.length-1),b.colModel.splice(b.colModel.length-1));switch(a.exptype){case "xmlstring":d=
"<"+a.root+">"+xmlJsonClass.json2xml(b,a.ident)+"</"+a.root+">";break;case "jsonstring":d="{"+xmlJsonClass.toJson(b,a.root,a.ident,!1)+"}",void 0!==b.postData.filters&&(d=d.replace(/filters":"/,'filters":'),d=d.replace(/}]}"/,"}]}"))}}});return d},excelExport:function(a){a=c.extend({exptype:"remote",url:null,oper:"oper",tag:"excel",exportOptions:{}},a||{});return this.each(function(){if(this.grid){var d;"remote"==a.exptype&&(d=c.extend({},this.p.postData),d[a.oper]=a.tag,d=jQuery.param(d),d=-1!=a.url.indexOf("?")?
a.url+"&"+d:a.url+"?"+d,window.location=d)}})}})})(jQuery);
var xmlJsonClass={xml2json:function(a,b){9===a.nodeType&&(a=a.documentElement);var g=this.toJson(this.toObj(this.removeWhite(a)),a.nodeName,"\t");return"{\n"+b+(b?g.replace(/\t/g,b):g.replace(/\t|\n/g,""))+"\n}"},json2xml:function(a,b){var g=function(a,b,e){var d="",f,i;if(a instanceof Array)if(0===a.length)d+=e+"<"+b+">__EMPTY_ARRAY_</"+b+">\n";else{f=0;for(i=a.length;f<i;f+=1)var l=e+g(a[f],b,e+"\t")+"\n",d=d+l}else if("object"===typeof a){f=!1;d+=e+"<"+b;for(i in a)a.hasOwnProperty(i)&&("@"===
i.charAt(0)?d+=" "+i.substr(1)+'="'+a[i].toString()+'"':f=!0);d+=f?">":"/>";if(f){for(i in a)a.hasOwnProperty(i)&&("#text"===i?d+=a[i]:"#cdata"===i?d+="<![CDATA["+a[i]+"]]\>":"@"!==i.charAt(0)&&(d+=g(a[i],i,e+"\t")));d+=("\n"===d.charAt(d.length-1)?e:"")+"</"+b+">"}}else"function"===typeof a?d+=e+"<"+b+"><![CDATA["+a+"]]\></"+b+">":(void 0===a&&(a=""),d='""'===a.toString()||0===a.toString().length?d+(e+"<"+b+">__EMPTY_STRING_</"+b+">"):d+(e+"<"+b+">"+a.toString()+"</"+b+">"));return d},f="",e;for(e in a)a.hasOwnProperty(e)&&
(f+=g(a[e],e,""));return b?f.replace(/\t/g,b):f.replace(/\t|\n/g,"")},toObj:function(a){var b={},g=/function/i;if(1===a.nodeType){if(a.attributes.length){var f;for(f=0;f<a.attributes.length;f+=1)b["@"+a.attributes[f].nodeName]=(a.attributes[f].nodeValue||"").toString()}if(a.firstChild){var e=f=0,h=!1,c;for(c=a.firstChild;c;c=c.nextSibling)1===c.nodeType?h=!0:3===c.nodeType&&c.nodeValue.match(/[^ \f\n\r\t\v]/)?f+=1:4===c.nodeType&&(e+=1);if(h)if(2>f&&2>e){this.removeWhite(a);for(c=a.firstChild;c;c=
c.nextSibling)3===c.nodeType?b["#text"]=this.escape(c.nodeValue):4===c.nodeType?g.test(c.nodeValue)?b[c.nodeName]=[b[c.nodeName],c.nodeValue]:b["#cdata"]=this.escape(c.nodeValue):b[c.nodeName]?b[c.nodeName]instanceof Array?b[c.nodeName][b[c.nodeName].length]=this.toObj(c):b[c.nodeName]=[b[c.nodeName],this.toObj(c)]:b[c.nodeName]=this.toObj(c)}else a.attributes.length?b["#text"]=this.escape(this.innerXml(a)):b=this.escape(this.innerXml(a));else if(f)a.attributes.length?b["#text"]=this.escape(this.innerXml(a)):
(b=this.escape(this.innerXml(a)),"__EMPTY_ARRAY_"===b?b="[]":"__EMPTY_STRING_"===b&&(b=""));else if(e)if(1<e)b=this.escape(this.innerXml(a));else for(c=a.firstChild;c;c=c.nextSibling)if(g.test(a.firstChild.nodeValue)){b=a.firstChild.nodeValue;break}else b["#cdata"]=this.escape(c.nodeValue)}!a.attributes.length&&!a.firstChild&&(b=null)}else 9===a.nodeType?b=this.toObj(a.documentElement):alert("unhandled node type: "+a.nodeType);return b},toJson:function(a,b,g,f){void 0===f&&(f=!0);var e=b?'"'+b+'"':
"",h="\t",c="\n";f||(c=h="");if("[]"===a)e+=b?":[]":"[]";else if(a instanceof Array){var j,d,k=[];d=0;for(j=a.length;d<j;d+=1)k[d]=this.toJson(a[d],"",g+h,f);e+=(b?":[":"[")+(1<k.length?c+g+h+k.join(","+c+g+h)+c+g:k.join(""))+"]"}else if(null===a)e+=(b&&":")+"null";else if("object"===typeof a){j=[];for(d in a)a.hasOwnProperty(d)&&(j[j.length]=this.toJson(a[d],d,g+h,f));e+=(b?":{":"{")+(1<j.length?c+g+h+j.join(","+c+g+h)+c+g:j.join(""))+"}"}else e="string"===typeof a?e+((b&&":")+'"'+a.replace(/\\/g,
"\\\\").replace(/\"/g,'\\"')+'"'):e+((b&&":")+a.toString());return e},innerXml:function(a){var b="";if("innerHTML"in a)b=a.innerHTML;else for(var g=function(a){var b="",h;if(1===a.nodeType){b+="<"+a.nodeName;for(h=0;h<a.attributes.length;h+=1)b+=" "+a.attributes[h].nodeName+'="'+(a.attributes[h].nodeValue||"").toString()+'"';if(a.firstChild){b+=">";for(h=a.firstChild;h;h=h.nextSibling)b+=g(h);b+="</"+a.nodeName+">"}else b+="/>"}else 3===a.nodeType?b+=a.nodeValue:4===a.nodeType&&(b+="<![CDATA["+a.nodeValue+
"]]\>");return b},a=a.firstChild;a;a=a.nextSibling)b+=g(a);return b},escape:function(a){return a.replace(/[\\]/g,"\\\\").replace(/[\"]/g,'\\"').replace(/[\n]/g,"\\n").replace(/[\r]/g,"\\r")},removeWhite:function(a){a.normalize();var b;for(b=a.firstChild;b;)if(3===b.nodeType)if(b.nodeValue.match(/[^ \f\n\r\t\v]/))b=b.nextSibling;else{var g=b.nextSibling;a.removeChild(b);b=g}else 1===b.nodeType&&this.removeWhite(b),b=b.nextSibling;return a}};
function tableToGrid(j,k){jQuery(j).each(function(){if(!this.grid){jQuery(this).width("99%");var b=jQuery(this).width(),c=jQuery("tr td:first-child input[type=checkbox]:first",jQuery(this)),a=jQuery("tr td:first-child input[type=radio]:first",jQuery(this)),c=0<c.length,a=!c&&0<a.length,i=c||a,d=[],e=[];jQuery("th",jQuery(this)).each(function(){0===d.length&&i?(d.push({name:"__selection__",index:"__selection__",width:0,hidden:!0}),e.push("__selection__")):(d.push({name:jQuery(this).attr("id")||jQuery.trim(jQuery.jgrid.stripHtml(jQuery(this).html())).split(" ").join("_"),
index:jQuery(this).attr("id")||jQuery.trim(jQuery.jgrid.stripHtml(jQuery(this).html())).split(" ").join("_"),width:jQuery(this).width()||150}),e.push(jQuery(this).html()))});var f=[],g=[],h=[];jQuery("tbody > tr",jQuery(this)).each(function(){var b={},a=0;jQuery("td",jQuery(this)).each(function(){if(0===a&&i){var c=jQuery("input",jQuery(this)),e=c.attr("value");g.push(e||f.length);c.is(":checked")&&h.push(e);b[d[a].name]=c.attr("value")}else b[d[a].name]=jQuery(this).html();a++});0<a&&f.push(b)});
jQuery(this).empty();jQuery(this).addClass("scroll");jQuery(this).jqGrid(jQuery.extend({datatype:"local",width:b,colNames:e,colModel:d,multiselect:c},k||{}));for(b=0;b<f.length;b++)a=null,0<g.length&&(a=g[b])&&a.replace&&(a=encodeURIComponent(a).replace(/[.\-%]/g,"_")),null===a&&(a=b+1),jQuery(this).jqGrid("addRowData",a,f[b]);for(b=0;b<h.length;b++)jQuery(this).jqGrid("setSelection",h[b])}})};
(function(b){b.browser.msie&&8==b.browser.version&&(b.expr[":"].hidden=function(b){return 0===b.offsetWidth||0===b.offsetHeight||"none"==b.style.display});b.jgrid._multiselect=!1;if(b.ui&&b.ui.multiselect){if(b.ui.multiselect.prototype._setSelected){var m=b.ui.multiselect.prototype._setSelected;b.ui.multiselect.prototype._setSelected=function(a,e){var c=m.call(this,a,e);if(e&&this.selectedList){var d=this.element;this.selectedList.find("li").each(function(){b(this).data("optionLink")&&b(this).data("optionLink").remove().appendTo(d)})}return c}}b.ui.multiselect.prototype.destroy&&
(b.ui.multiselect.prototype.destroy=function(){this.element.show();this.container.remove();b.Widget===void 0?b.widget.prototype.destroy.apply(this,arguments):b.Widget.prototype.destroy.apply(this,arguments)});b.jgrid._multiselect=!0}b.jgrid.extend({sortableColumns:function(a){return this.each(function(){function e(){c.p.disableClick=true}var c=this,d=b.jgrid.jqID(c.p.id),d={tolerance:"pointer",axis:"x",scrollSensitivity:"1",items:">th:not(:has(#jqgh_"+d+"_cb,#jqgh_"+d+"_rn,#jqgh_"+d+"_subgrid),:hidden)",
placeholder:{element:function(a){return b(document.createElement(a[0].nodeName)).addClass(a[0].className+" ui-sortable-placeholder ui-state-highlight").removeClass("ui-sortable-helper")[0]},update:function(b,a){a.height(b.currentItem.innerHeight()-parseInt(b.currentItem.css("paddingTop")||0,10)-parseInt(b.currentItem.css("paddingBottom")||0,10));a.width(b.currentItem.innerWidth()-parseInt(b.currentItem.css("paddingLeft")||0,10)-parseInt(b.currentItem.css("paddingRight")||0,10))}},update:function(a,
g){var d=b(g.item).parent(),d=b(">th",d),e={},i=c.p.id+"_";b.each(c.p.colModel,function(b){e[this.name]=b});var h=[];d.each(function(){var a=b(">div",this).get(0).id.replace(/^jqgh_/,"").replace(i,"");a in e&&h.push(e[a])});b(c).jqGrid("remapColumns",h,true,true);b.isFunction(c.p.sortable.update)&&c.p.sortable.update(h);setTimeout(function(){c.p.disableClick=false},50)}};if(c.p.sortable.options)b.extend(d,c.p.sortable.options);else if(b.isFunction(c.p.sortable))c.p.sortable={update:c.p.sortable};
if(d.start){var g=d.start;d.start=function(b,a){e();g.call(this,b,a)}}else d.start=e;if(c.p.sortable.exclude)d.items=d.items+(":not("+c.p.sortable.exclude+")");a.sortable(d).data("sortable").floating=true})},columnChooser:function(a){function e(a,c){a&&(typeof a=="string"?b.fn[a]&&b.fn[a].apply(c,b.makeArray(arguments).slice(2)):b.isFunction(a)&&a.apply(c,b.makeArray(arguments).slice(2)))}var c=this;if(!b("#colchooser_"+b.jgrid.jqID(c[0].p.id)).length){var d=b('<div id="colchooser_'+c[0].p.id+'" style="position:relative;overflow:hidden"><div><select multiple="multiple"></select></div></div>'),
g=b("select",d),a=b.extend({width:420,height:240,classname:null,done:function(b){b&&c.jqGrid("remapColumns",b,true)},msel:"multiselect",dlog:"dialog",dialog_opts:{minWidth:470},dlog_opts:function(a){var c={};c[a.bSubmit]=function(){a.apply_perm();a.cleanup(false)};c[a.bCancel]=function(){a.cleanup(true)};return b.extend(true,{buttons:c,close:function(){a.cleanup(true)},modal:a.modal?a.modal:false,resizable:a.resizable?a.resizable:true,width:a.width+20},a.dialog_opts||{})},apply_perm:function(){b("option",
g).each(function(){this.selected?c.jqGrid("showCol",k[this.value].name):c.jqGrid("hideCol",k[this.value].name)});var d=[];b("option:selected",g).each(function(){d.push(parseInt(this.value,10))});b.each(d,function(){delete f[k[parseInt(this,10)].name]});b.each(f,function(){var b=parseInt(this,10);var a=d,c=b;if(c>=0){var g=a.slice(),e=g.splice(c,Math.max(a.length-c,c));if(c>a.length)c=a.length;g[c]=b;d=g.concat(e)}else d=void 0});a.done&&a.done.call(c,d)},cleanup:function(b){e(a.dlog,d,"destroy");
e(a.msel,g,"destroy");d.remove();b&&a.done&&a.done.call(c)},msel_opts:{}},b.jgrid.col,a||{});if(b.ui&&b.ui.multiselect&&a.msel=="multiselect"){if(!b.jgrid._multiselect){alert("Multiselect plugin loaded after jqGrid. Please load the plugin before the jqGrid!");return}a.msel_opts=b.extend(b.ui.multiselect.defaults,a.msel_opts)}a.caption&&d.attr("title",a.caption);if(a.classname){d.addClass(a.classname);g.addClass(a.classname)}if(a.width){b(">div",d).css({width:a.width,margin:"0 auto"});g.css("width",
a.width)}if(a.height){b(">div",d).css("height",a.height);g.css("height",a.height-10)}var k=c.jqGrid("getGridParam","colModel"),p=c.jqGrid("getGridParam","colNames"),f={},j=[];g.empty();b.each(k,function(b){f[this.name]=b;this.hidedlg?this.hidden||j.push(b):g.append("<option value='"+b+"' "+(this.hidden?"":"selected='selected'")+">"+jQuery.jgrid.stripHtml(p[b])+"</option>")});var i=b.isFunction(a.dlog_opts)?a.dlog_opts.call(c,a):a.dlog_opts;e(a.dlog,d,i);i=b.isFunction(a.msel_opts)?a.msel_opts.call(c,
a):a.msel_opts;e(a.msel,g,i)}},sortableRows:function(a){return this.each(function(){var e=this;if(e.grid&&!e.p.treeGrid&&b.fn.sortable){a=b.extend({cursor:"move",axis:"y",items:".jqgrow"},a||{});if(a.start&&b.isFunction(a.start)){a._start_=a.start;delete a.start}else a._start_=false;if(a.update&&b.isFunction(a.update)){a._update_=a.update;delete a.update}else a._update_=false;a.start=function(c,d){b(d.item).css("border-width","0px");b("td",d.item).each(function(b){this.style.width=e.grid.cols[b].style.width});
if(e.p.subGrid){var g=b(d.item).attr("id");try{b(e).jqGrid("collapseSubGridRow",g)}catch(k){}}a._start_&&a._start_.apply(this,[c,d])};a.update=function(c,d){b(d.item).css("border-width","");e.p.rownumbers===true&&b("td.jqgrid-rownum",e.rows).each(function(a){b(this).html(a+1+(parseInt(e.p.page,10)-1)*parseInt(e.p.rowNum,10))});a._update_&&a._update_.apply(this,[c,d])};b("tbody:first",e).sortable(a);b("tbody:first",e).disableSelection()}})},gridDnD:function(a){return this.each(function(){function e(){var a=
b.data(c,"dnd");b("tr.jqgrow:not(.ui-draggable)",c).draggable(b.isFunction(a.drag)?a.drag.call(b(c),a):a.drag)}var c=this;if(c.grid&&!c.p.treeGrid&&b.fn.draggable&&b.fn.droppable){b("#jqgrid_dnd").html()===null&&b("body").append("<table id='jqgrid_dnd' class='ui-jqgrid-dnd'></table>");if(typeof a=="string"&&a=="updateDnD"&&c.p.jqgdnd===true)e();else{a=b.extend({drag:function(a){return b.extend({start:function(d,e){if(c.p.subGrid){var f=b(e.helper).attr("id");try{b(c).jqGrid("collapseSubGridRow",f)}catch(j){}}for(f=
0;f<b.data(c,"dnd").connectWith.length;f++)b(b.data(c,"dnd").connectWith[f]).jqGrid("getGridParam","reccount")=="0"&&b(b.data(c,"dnd").connectWith[f]).jqGrid("addRowData","jqg_empty_row",{});e.helper.addClass("ui-state-highlight");b("td",e.helper).each(function(b){this.style.width=c.grid.headers[b].width+"px"});a.onstart&&b.isFunction(a.onstart)&&a.onstart.call(b(c),d,e)},stop:function(d,e){if(e.helper.dropped&&!a.dragcopy){var f=b(e.helper).attr("id");f===void 0&&(f=b(this).attr("id"));b(c).jqGrid("delRowData",
f)}for(f=0;f<b.data(c,"dnd").connectWith.length;f++)b(b.data(c,"dnd").connectWith[f]).jqGrid("delRowData","jqg_empty_row");a.onstop&&b.isFunction(a.onstop)&&a.onstop.call(b(c),d,e)}},a.drag_opts||{})},drop:function(a){return b.extend({accept:function(a){if(!b(a).hasClass("jqgrow"))return a;a=b(a).closest("table.ui-jqgrid-btable");if(a.length>0&&b.data(a[0],"dnd")!==void 0){a=b.data(a[0],"dnd").connectWith;return b.inArray("#"+b.jgrid.jqID(this.id),a)!=-1?true:false}return false},drop:function(d,e){if(b(e.draggable).hasClass("jqgrow")){var f=
b(e.draggable).attr("id"),f=e.draggable.parent().parent().jqGrid("getRowData",f);if(!a.dropbyname){var j=0,i={},h,n=b("#"+b.jgrid.jqID(this.id)).jqGrid("getGridParam","colModel");try{for(var o in f){h=n[j].name;h=="cb"||(h=="rn"||h=="subgrid")||f.hasOwnProperty(o)&&n[j]&&(i[h]=f[o]);j++}f=i}catch(m){}}e.helper.dropped=true;if(a.beforedrop&&b.isFunction(a.beforedrop)){h=a.beforedrop.call(this,d,e,f,b("#"+b.jgrid.jqID(c.p.id)),b(this));typeof h!="undefined"&&(h!==null&&typeof h=="object")&&(f=h)}if(e.helper.dropped){var l;
if(a.autoid)if(b.isFunction(a.autoid))l=a.autoid.call(this,f);else{l=Math.ceil(Math.random()*1E3);l=a.autoidprefix+l}b("#"+b.jgrid.jqID(this.id)).jqGrid("addRowData",l,f,a.droppos)}a.ondrop&&b.isFunction(a.ondrop)&&a.ondrop.call(this,d,e,f)}}},a.drop_opts||{})},onstart:null,onstop:null,beforedrop:null,ondrop:null,drop_opts:{activeClass:"ui-state-active",hoverClass:"ui-state-hover"},drag_opts:{revert:"invalid",helper:"clone",cursor:"move",appendTo:"#jqgrid_dnd",zIndex:5E3},dragcopy:false,dropbyname:false,
droppos:"first",autoid:true,autoidprefix:"dnd_"},a||{});if(a.connectWith){a.connectWith=a.connectWith.split(",");a.connectWith=b.map(a.connectWith,function(a){return b.trim(a)});b.data(c,"dnd",a);c.p.reccount!="0"&&!c.p.jqgdnd&&e();c.p.jqgdnd=true;for(var d=0;d<a.connectWith.length;d++)b(a.connectWith[d]).droppable(b.isFunction(a.drop)?a.drop.call(b(c),a):a.drop)}}}})},gridResize:function(a){return this.each(function(){var e=this,c=b.jgrid.jqID(e.p.id);if(e.grid&&b.fn.resizable){a=b.extend({},a||
{});if(a.alsoResize){a._alsoResize_=a.alsoResize;delete a.alsoResize}else a._alsoResize_=false;if(a.stop&&b.isFunction(a.stop)){a._stop_=a.stop;delete a.stop}else a._stop_=false;a.stop=function(d,g){b(e).jqGrid("setGridParam",{height:b("#gview_"+c+" .ui-jqgrid-bdiv").height()});b(e).jqGrid("setGridWidth",g.size.width,a.shrinkToFit);a._stop_&&a._stop_.call(e,d,g)};a.alsoResize=a._alsoResize_?eval("("+("{'#gview_"+c+" .ui-jqgrid-bdiv':true,'"+a._alsoResize_+"':true}")+")"):b(".ui-jqgrid-bdiv","#gview_"+
c);delete a._alsoResize_;b("#gbox_"+c).resizable(a)}})}})})(jQuery);
(function ($) {
    $.fn.paginate = function (options) {
        var opts = $.extend({}, $.fn.paginate.defaults, options);
        return this.each(function () {
            $this = $(this);
            var o = $.meta ? $.extend({}, opts, $this.data()) : opts;
            var selectedpage = o.start;
            $.fn.draw(o, $this, selectedpage);
        });
    };
    var outsidewidth_tmp = 0;
    var insidewidth = 0;
    var bName = navigator.appName;
    var bVer = navigator.appVersion;
    if (bVer.indexOf('MSIE 7.0') > 0)
        var ver = "ie7";
    $.fn.paginate.defaults = {
        count: 5,
        start: 12,
        display: 5,
        border: true,
        border_color: '#fff',
        text_color: '#8cc59d',
        background_color: 'black',
        border_hover_color: '#fff',
        text_hover_color: '#fff',
        background_hover_color: '#fff',
        rotate: true,
        images: true,
        mouse: 'slide',
        onChange: function () {
            return false;
        }
    };
    $.fn.draw = function (o, obj, selectedpage) {
        if (o.display > o.count)
            o.display = o.count;
        $this.empty();

        if (o.images) {
            var spreviousclass = 'jPag-sprevious-img';
            var previousclass = 'jPag-previous-img';
            var snextclass = 'jPag-snext-img';
            var nextclass = 'jPag-next-img';
        }
        else {
            var spreviousclass = 'jPag-sprevious';
            var previousclass = 'jPag-previous';
            var snextclass = 'jPag-snext';
            var nextclass = 'jPag-next';
        }
        var _first = $(document.createElement('a')).addClass('jPag-first').html(messages['common.pagefirst']);

        if (o.rotate) {
            if (o.images) var _rotleft = $(document.createElement('span')).addClass(spreviousclass);
            else var _rotleft = $(document.createElement('span')).addClass(spreviousclass).html('&laquo;');
        }

        var _divwrapleft = $(document.createElement('div')).addClass('jPag-control-back');
        _divwrapleft.append(_first).append(_rotleft);

        var _ulwrapdiv = $(document.createElement('div')).css('overflow', 'hidden');
        var _ul = $(document.createElement('ul')).addClass('jPag-pages');
        var c = (o.display - 1) / 2;
        var first = selectedpage - c;
        var selobj;
        for (var i = 0; i < o.count; i++) {
            var val = i + 1;
            if (val == selectedpage) {
                var _obj = $(document.createElement('li')).html('<span class="jPag-current">' + val + '</span>');
                selobj = _obj;
                _ul.append(_obj);
            }
            else {
                var _obj = $(document.createElement('li')).html('<a>' + val + '</a>');
                _ul.append(_obj);
            }
        }
        _ulwrapdiv.append(_ul);

        if (o.rotate) {
            if (o.images) var _rotright = $(document.createElement('span')).addClass(snextclass);
            else var _rotright = $(document.createElement('span')).addClass(snextclass).html('&raquo;');
        }

        var _last = $(document.createElement('a')).addClass('jPag-last').html(messages['common.pagelast']);
        var _divwrapright = $(document.createElement('div')).addClass('jPag-control-front');
        var _divinfo = $(document.createElement('span')).addClass('jPag-control-additional');
        _divwrapright.append(_rotright).append(_last).append(_divinfo);

        //append all:
        $this.addClass('jPaginate').append(_divwrapleft).append(_ulwrapdiv).append(_divwrapright);

        if (!o.border) {
            if (o.background_color == 'none') var a_css = {'color': o.text_color};
            else var a_css = {'color': o.text_color, 'background-color': o.background_color};
            if (o.background_hover_color == 'none')    var hover_css = {'color': o.text_hover_color};
            else var hover_css = {'color': o.text_hover_color, 'background-color': o.background_hover_color};
        }
        else {
            if (o.background_color == 'none') var a_css = {'color': o.text_color, 'border': '1px solid ' + o.border_color};
            else var a_css = {'color': o.text_color, 'background-color': o.background_color, 'border': '1px solid ' + o.border_color};
            if (o.background_hover_color == 'none')    var hover_css = {'color': o.text_hover_color, 'border': '1px solid ' + o.border_hover_color};
            else var hover_css = {'color': o.text_hover_color, 'background-color': o.background_hover_color, 'border': '1px solid ' + o.border_hover_color};
        }

        $.fn.applystyle(o, $this, a_css, hover_css, _first, _ul, _ulwrapdiv, _divwrapright);
        //calculate width of the ones displayed:
        var outsidewidth = outsidewidth_tmp - _first.parent().width() - 3;
        if (ver == 'ie7') {
            _ulwrapdiv.css('width', outsidewidth + 72 + 'px');
            _divwrapright.css('left', outsidewidth_tmp + 6 + 72 + 'px');
        }
        else {
            _ulwrapdiv.css('width', outsidewidth + 'px');
            _divwrapright.css('left', outsidewidth_tmp + 6 + 'px');
        }

        if (o.rotate) {
            _rotright.hover(
                function () {
                    thumbs_scroll_interval = setInterval(
                        function () {
                            var left = _ulwrapdiv.scrollLeft() + 1;
                            _ulwrapdiv.scrollLeft(left);
                        },
                        20
                    );
                },
                function () {
                    clearInterval(thumbs_scroll_interval);
                }
            );
            _rotleft.hover(
                function () {
                    thumbs_scroll_interval = setInterval(
                        function () {
                            var left = _ulwrapdiv.scrollLeft() - 1;
                            _ulwrapdiv.scrollLeft(left);
                        },
                        20
                    );
                },
                function () {
                    clearInterval(thumbs_scroll_interval);
                }
            );
            if (o.mouse == 'press') {
                _rotright.mousedown(
                    function () {
                        thumbs_mouse_interval = setInterval(
                            function () {
                                var left = _ulwrapdiv.scrollLeft() + 5;
                                _ulwrapdiv.scrollLeft(left);
                            },
                            20
                        );
                    }
                ).mouseup(
                    function () {
                        clearInterval(thumbs_mouse_interval);
                    }
                );
                _rotleft.mousedown(
                    function () {
                        thumbs_mouse_interval = setInterval(
                            function () {
                                var left = _ulwrapdiv.scrollLeft() - 5;
                                _ulwrapdiv.scrollLeft(left);
                            },
                            20
                        );
                    }
                ).mouseup(
                    function () {
                        clearInterval(thumbs_mouse_interval);
                    }
                );
            }
            else {
                _rotleft.click(function (e) {
                    var width = outsidewidth - 10;
                    var left = _ulwrapdiv.scrollLeft() - width;
                    _ulwrapdiv.animate({scrollLeft: left + 'px'});
                });

                _rotright.click(function (e) {
                    var width = outsidewidth - 10;
                    var left = _ulwrapdiv.scrollLeft() + width;
                    _ulwrapdiv.animate({scrollLeft: left + 'px'});
                });
            }
        }

        //first and last:
        _first.click(function (e) {
            _ulwrapdiv.animate({scrollLeft: '0px'});
            _ulwrapdiv.find('li').eq(0).click();
        });
        _last.click(function (e) {
            _ulwrapdiv.animate({scrollLeft: insidewidth + 'px'});
            _ulwrapdiv.find('li').eq(o.count - 1).click();
        });

        //click a page
        _ulwrapdiv.find('li').click(function (e) {
            selobj.html('<a>' + selobj.find('.jPag-current').html() + '</a>');
            var currval = $(this).find('a').html();
            $(this).html('<span class="jPag-current">' + currval + '</span>');
            selobj = $(this);
            $.fn.applystyle(o, $(this).parent().parent().parent(), a_css, hover_css, _first, _ul, _ulwrapdiv, _divwrapright);
            var left = (this.offsetLeft) / 2;
            var left2 = _ulwrapdiv.scrollLeft() + left;
            var tmp = left - (outsidewidth / 2);
            if (ver == 'ie7')
                _ulwrapdiv.animate({scrollLeft: left + tmp - _first.parent().width() + 52 + 'px'});
            else
                _ulwrapdiv.animate({scrollLeft: left + tmp - _first.parent().width() + 'px'});
            o.onChange(currval);
        });

        var last = _ulwrapdiv.find('li').eq(o.start - 1);
        last.attr('id', 'tmp');
        var left = document.getElementById('tmp').offsetLeft / 2;
        last.removeAttr('id');
        var tmp = left - (outsidewidth / 2);
        if (ver == 'ie7') _ulwrapdiv.animate({scrollLeft: left + tmp - _first.parent().width() + 52 + 'px'});
        else _ulwrapdiv.animate({scrollLeft: left + tmp - _first.parent().width() + 'px'});
    };

    $.fn.applystyle = function (o, obj, a_css, hover_css, _first, _ul, _ulwrapdiv, _divwrapright) {
        obj.find('a').css(a_css);
        obj.find('span.jPag-current').css(hover_css);
        obj.find('a').hover(
            function () {
                $(this).css(hover_css);
            },
            function () {
                $(this).css(a_css);
            }
        );
        obj.css('padding-left', (_first.parent().width() ? _first.parent().width() : o.customElementLeft) + 5 + 'px');
        insidewidth = 0;

        obj.find('li').each(function (i, n) {
            if (i == (o.display - 1)) {
                outsidewidth_tmp = (this.offsetLeft ? this.offsetLeft : o.customElementLeft) + (this.offsetWidth ? this.offsetWidth : o.customElementWidth * o.count /*o.customParentWidth*/);
            }
            insidewidth += this.offsetWidth ? this.offsetWidth : o.customElementWidth;
        });
        _ul.css('width', (insidewidth + 2) + 'px');
    }
})(jQuery);/**
 * jQuery.ScrollTo
 * Copyright (c) 2007-2009 Ariel Flesler - aflesler(at)gmail(dot)com | http://flesler.blogspot.com
 * Dual licensed under MIT and GPL.
 * Date: 5/25/2009
 *
 * @projectDescription Easy element scrolling using jQuery.
 * http://flesler.blogspot.com/2007/10/jqueryscrollto.html
 * Works with jQuery +1.2.6. Tested on FF 2/3, IE 6/7/8, Opera 9.5/6, Safari 3, Chrome 1 on WinXP.
 *
 * @author Ariel Flesler
 * @version 1.4.2
 *
 * @id jQuery.scrollTo
 * @id jQuery.fn.scrollTo
 * @param {String, Number, DOMElement, jQuery, Object} target Where to scroll the matched elements.
 *	  The different options for target are:
 *		- A number position (will be applied to all axes).
 *		- A string position ('44', '100px', '+=90', etc ) will be applied to all axes
 *		- A jQuery/DOM element ( logically, child of the element to scroll )
 *		- A string selector, that will be relative to the element to scroll ( 'li:eq(2)', etc )
 *		- A hash { top:x, left:y }, x and y can be any kind of number/string like above.
*		- A percentage of the container's dimension/s, for example: 50% to go to the middle.
 *		- The string 'max' for go-to-end. 
 * @param {Number} duration The OVERALL length of the animation, this argument can be the settings object instead.
 * @param {Object,Function} settings Optional set of settings or the onAfter callback.
 *	 @option {String} axis Which axis must be scrolled, use 'x', 'y', 'xy' or 'yx'.
 *	 @option {Number} duration The OVERALL length of the animation.
 *	 @option {String} easing The easing method for the animation.
 *	 @option {Boolean} margin If true, the margin of the target element will be deducted from the final position.
 *	 @option {Object, Number} offset Add/deduct from the end position. One number for both axes or { top:x, left:y }.
 *	 @option {Object, Number} over Add/deduct the height/width multiplied by 'over', can be { top:x, left:y } when using both axes.
 *	 @option {Boolean} queue If true, and both axis are given, the 2nd axis will only be animated after the first one ends.
 *	 @option {Function} onAfter Function to be called after the scrolling ends. 
 *	 @option {Function} onAfterFirst If queuing is activated, this function will be called after the first scrolling ends.
 * @return {jQuery} Returns the same jQuery object, for chaining.
 *
 * @desc Scroll to a fixed position
 * @example $('div').scrollTo( 340 );
 *
 * @desc Scroll relatively to the actual position
 * @example $('div').scrollTo( '+=340px', { axis:'y' } );
 *
 * @dec Scroll using a selector (relative to the scrolled element)
 * @example $('div').scrollTo( 'p.paragraph:eq(2)', 500, { easing:'swing', queue:true, axis:'xy' } );
 *
 * @ Scroll to a DOM element (same for jQuery object)
 * @example var second_child = document.getElementById('container').firstChild.nextSibling;
 *			$('#container').scrollTo( second_child, { duration:500, axis:'x', onAfter:function(){
 *				alert('scrolled!!');																   
 *			}});
 *
 * @desc Scroll on both axes, to different values
 * @example $('div').scrollTo( { top: 300, left:'+=200' }, { axis:'xy', offset:-20 } );
 */
;(function( $ ){
	
	var $scrollTo = $.scrollTo = function( target, duration, settings ){
		$(window).scrollTo( target, duration, settings );
	};

	$scrollTo.defaults = {
		axis:'xy',
		duration: parseFloat($.fn.jquery) >= 1.3 ? 0 : 1
	};

	// Returns the element that needs to be animated to scroll the window.
	// Kept for backwards compatibility (specially for localScroll & serialScroll)
	$scrollTo.window = function( scope ){
		return $(window)._scrollable();
	};

	// Hack, hack, hack :)
	// Returns the real elements to scroll (supports window/iframes, documents and regular nodes)
	$.fn._scrollable = function(){
		return this.map(function(){
			var elem = this,
				isWin = !elem.nodeName || $.inArray( elem.nodeName.toLowerCase(), ['iframe','#document','html','body'] ) != -1;

				if( !isWin )
					return elem;

			var doc = (elem.contentWindow || elem).document || elem.ownerDocument || elem;
			
			return $.browser.safari || doc.compatMode == 'BackCompat' ?
				doc.body : 
				doc.documentElement;
		});
	};

	$.fn.scrollTo = function( target, duration, settings ){
		if( typeof duration == 'object' ){
			settings = duration;
			duration = 0;
		}
		if( typeof settings == 'function' )
			settings = { onAfter:settings };
			
		if( target == 'max' )
			target = 9e9;
			
		settings = $.extend( {}, $scrollTo.defaults, settings );
		// Speed is still recognized for backwards compatibility
		duration = duration || settings.speed || settings.duration;
		// Make sure the settings are given right
		settings.queue = settings.queue && settings.axis.length > 1;
		
		if( settings.queue )
			// Let's keep the overall duration
			duration /= 2;
		settings.offset = both( settings.offset );
		settings.over = both( settings.over );

		return this._scrollable().each(function(){
			var elem = this,
				$elem = $(elem),
				targ = target, toff, attr = {},
				win = $elem.is('html,body');

			switch( typeof targ ){
				// A number will pass the regex
				case 'number':
				case 'string':
					if( /^([+-]=)?\d+(\.\d+)?(px|%)?$/.test(targ) ){
						targ = both( targ );
						// We are done
						break;
					}
					// Relative selector, no break!
					targ = $(targ,this);
				case 'object':
					// DOMElement / jQuery
					if( targ.is || targ.style )
						// Get the real position of the target 
						toff = (targ = $(targ)).offset();
			}
			$.each( settings.axis.split(''), function( i, axis ){
				var Pos	= axis == 'x' ? 'Left' : 'Top',
					pos = Pos.toLowerCase(),
					key = 'scroll' + Pos,
					old = elem[key],
					max = $scrollTo.max(elem, axis);

				if( toff ){// jQuery / DOMElement
					attr[key] = toff[pos] + ( win ? 0 : old - $elem.offset()[pos] );

					// If it's a dom element, reduce the margin
					if( settings.margin ){
						attr[key] -= parseInt(targ.css('margin'+Pos)) || 0;
						attr[key] -= parseInt(targ.css('border'+Pos+'Width')) || 0;
					}
					
					attr[key] += settings.offset[pos] || 0;
					
					if( settings.over[pos] )
						// Scroll to a fraction of its width/height
						attr[key] += targ[axis=='x'?'width':'height']() * settings.over[pos];
				}else{ 
					var val = targ[pos];
					// Handle percentage values
					attr[key] = val.slice && val.slice(-1) == '%' ? 
						parseFloat(val) / 100 * max
						: val;
				}

				// Number or 'number'
				if( /^\d+$/.test(attr[key]) )
					// Check the limits
					attr[key] = attr[key] <= 0 ? 0 : Math.min( attr[key], max );

				// Queueing axes
				if( !i && settings.queue ){
					// Don't waste time animating, if there's no need.
					if( old != attr[key] )
						// Intermediate animation
						animate( settings.onAfterFirst );
					// Don't animate this axis again in the next iteration.
					delete attr[key];
				}
			});

			animate( settings.onAfter );			

			function animate( callback ){
				$elem.animate( attr, duration, settings.easing, callback && function(){
					callback.call(this, target, settings);
				});
			};

		}).end();
	};
	
	// Max scrolling position, works on quirks mode
	// It only fails (not too badly) on IE, quirks mode.
	$scrollTo.max = function( elem, axis ){
		var Dim = axis == 'x' ? 'Width' : 'Height',
			scroll = 'scroll'+Dim;
		
		if( !$(elem).is('html,body') )
			return elem[scroll] - $(elem)[Dim.toLowerCase()]();
		
		var size = 'client' + Dim,
			html = elem.ownerDocument.documentElement,
			body = elem.ownerDocument.body;

		return Math.max( html[scroll], body[scroll] ) 
			 - Math.min( html[size]  , body[size]   );
			
	};

	function both( val ){
		return typeof val == 'object' ? val : { top:val, left:val };
	};

})( jQuery );/*!
 * jQuery Tools v1.2.7 - The missing UI library for the Web
 * 
 * overlay/overlay.js
 * toolbox/toolbox.expose.js
 * 
 * NO COPYRIGHTS OR LICENSES. DO WHAT YOU LIKE.
 * 
 * http://flowplayer.org/tools/
 * 
 */
(function(a){a.tools=a.tools||{version:"v1.2.7"},a.tools.overlay={addEffect:function(a,b,d){c[a]=[b,d]},conf:{close:null,closeOnClick:!0,closeOnEsc:!0,closeSpeed:"fast",effect:"default",fixed:!a.browser.msie||a.browser.version>6,left:"center",load:!1,mask:null,oneInstance:!0,speed:"normal",target:null,top:"10%"}};var b=[],c={};a.tools.overlay.addEffect("default",function(b,c){var d=this.getConf(),e=a(window);d.fixed||(b.top+=e.scrollTop(),b.left+=e.scrollLeft()),b.position=d.fixed?"fixed":"absolute",this.getOverlay().css(b).fadeIn(d.speed,c)},function(a){this.getOverlay().fadeOut(this.getConf().closeSpeed,a)});function d(d,e){var f=this,g=d.add(f),h=a(window),i,j,k,l=a.tools.expose&&(e.mask||e.expose),m=Math.random().toString().slice(10);l&&(typeof l=="string"&&(l={color:l}),l.closeOnClick=l.closeOnEsc=!1);var n=e.target||d.attr("rel");j=n?a(n):null||d;if(!j.length)throw"Could not find Overlay: "+n;d&&d.index(j)==-1&&d.click(function(a){f.load(a);return a.preventDefault()}),a.extend(f,{load:function(d){if(f.isOpened())return f;var i=c[e.effect];if(!i)throw"Overlay: cannot find effect : \""+e.effect+"\"";e.oneInstance&&a.each(b,function(){this.close(d)}),d=d||a.Event(),d.type="onBeforeLoad",g.trigger(d);if(d.isDefaultPrevented())return f;k=!0,l&&a(j).expose(l);var n=e.top,o=e.left,p=j.outerWidth({margin:!0}),q=j.outerHeight({margin:!0});typeof n=="string"&&(n=n=="center"?Math.max((h.height()-q)/2,0):parseInt(n,10)/100*h.height()),o=="center"&&(o=Math.max((h.width()-p)/2,0)),i[0].call(f,{top:n,left:o},function(){k&&(d.type="onLoad",g.trigger(d))}),l&&e.closeOnClick&&a.mask.getMask().one("click",f.close),e.closeOnClick&&a(document).on("click."+m,function(b){a(b.target).parents(j).length||f.close(b)}),e.closeOnEsc&&a(document).on("keydown."+m,function(a){a.keyCode==27&&f.close(a)});return f},close:function(b){if(!f.isOpened())return f;b=b||a.Event(),b.type="onBeforeClose",g.trigger(b);if(!b.isDefaultPrevented()){k=!1,c[e.effect][1].call(f,function(){b.type="onClose",g.trigger(b)}),a(document).off("click."+m+" keydown."+m),l&&a.mask.close();return f}},getOverlay:function(){return j},getTrigger:function(){return d},getClosers:function(){return i},isOpened:function(){return k},getConf:function(){return e}}),a.each("onBeforeLoad,onStart,onLoad,onBeforeClose,onClose".split(","),function(b,c){a.isFunction(e[c])&&a(f).on(c,e[c]),f[c]=function(b){b&&a(f).on(c,b);return f}}),i=j.find(e.close||".close"),!i.length&&!e.close&&(i=a("<a class=\"close\"></a>"),j.prepend(i)),i.click(function(a){f.close(a)}),e.load&&f.load()}a.fn.overlay=function(c){var e=this.data("overlay");if(e)return e;a.isFunction(c)&&(c={onBeforeLoad:c}),c=a.extend(!0,{},a.tools.overlay.conf,c),this.each(function(){e=new d(a(this),c),b.push(e),a(this).data("overlay",e)});return c.api?e:this}})(jQuery);
(function(a){a.tools=a.tools||{version:"v1.2.7"};var b;b=a.tools.expose={conf:{maskId:"exposeMask",loadSpeed:"slow",closeSpeed:"fast",closeOnClick:!0,closeOnEsc:!0,zIndex:9998,opacity:.8,startOpacity:0,color:"#fff",onLoad:null,onClose:null}};function c(){if(a.browser.msie){var b=a(document).height(),c=a(window).height();return[window.innerWidth||document.documentElement.clientWidth||document.body.clientWidth,b-c<20?c:b]}return[a(document).width(),a(document).height()]}function d(b){if(b)return b.call(a.mask)}var e,f,g,h,i;a.mask={load:function(j,k){if(g)return this;typeof j=="string"&&(j={color:j}),j=j||h,h=j=a.extend(a.extend({},b.conf),j),e=a("#"+j.maskId),e.length||(e=a("<div/>").attr("id",j.maskId),a("body").append(e));var l=c();e.css({position:"absolute",top:0,left:0,width:l[0],height:l[1],display:"none",opacity:j.startOpacity,zIndex:j.zIndex}),j.color&&e.css("backgroundColor",j.color);if(d(j.onBeforeLoad)===!1)return this;j.closeOnEsc&&a(document).on("keydown.mask",function(b){b.keyCode==27&&a.mask.close(b)}),j.closeOnClick&&e.on("click.mask",function(b){a.mask.close(b)}),a(window).on("resize.mask",function(){a.mask.fit()}),k&&k.length&&(i=k.eq(0).css("zIndex"),a.each(k,function(){var b=a(this);/relative|absolute|fixed/i.test(b.css("position"))||b.css("position","relative")}),f=k.css({zIndex:Math.max(j.zIndex+1,i=="auto"?0:i)})),e.css({display:"block"}).fadeTo(j.loadSpeed,j.opacity,function(){a.mask.fit(),d(j.onLoad),g="full"}),g=!0;return this},close:function(){if(g){if(d(h.onBeforeClose)===!1)return this;e.fadeOut(h.closeSpeed,function(){d(h.onClose),f&&f.css({zIndex:i}),g=!1}),a(document).off("keydown.mask"),e.off("click.mask"),a(window).off("resize.mask")}return this},fit:function(){if(g){var a=c();e.css({width:a[0],height:a[1]})}},getMask:function(){return e},isLoaded:function(a){return a?g=="full":g},getConf:function(){return h},getExposed:function(){return f}},a.fn.mask=function(b){a.mask.load(b);return this},a.fn.expose=function(b){a.mask.load(b,this);return this}})(jQuery);
/*!
 * jQuery UI Position v1.10.0
 * http://jqueryui.com
 *
 * Copyright 2013 jQuery Foundation and other contributors
 * Released under the MIT license.
 * http://jquery.org/license
 *
 * http://api.jqueryui.com/position/
 */
(function( $, undefined ) {

$.ui = $.ui || {};

var cachedScrollbarWidth,
	max = Math.max,
	abs = Math.abs,
	round = Math.round,
	rhorizontal = /left|center|right/,
	rvertical = /top|center|bottom/,
	roffset = /[\+\-]\d+%?/,
	rposition = /^\w+/,
	rpercent = /%$/,
	_position = $.fn.position;

function getOffsets( offsets, width, height ) {
	return [
		parseInt( offsets[ 0 ], 10 ) * ( rpercent.test( offsets[ 0 ] ) ? width / 100 : 1 ),
		parseInt( offsets[ 1 ], 10 ) * ( rpercent.test( offsets[ 1 ] ) ? height / 100 : 1 )
	];
}

function parseCss( element, property ) {
	return parseInt( $.css( element, property ), 10 ) || 0;
}

function getDimensions( elem ) {
	var raw = elem[0];
	if ( raw.nodeType === 9 ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: 0, left: 0 }
		};
	}
	if ( $.isWindow( raw ) ) {
		return {
			width: elem.width(),
			height: elem.height(),
			offset: { top: elem.scrollTop(), left: elem.scrollLeft() }
		};
	}
	if ( raw.preventDefault ) {
		return {
			width: 0,
			height: 0,
			offset: { top: raw.pageY, left: raw.pageX }
		};
	}
	return {
		width: elem.outerWidth(),
		height: elem.outerHeight(),
		offset: elem.offset()
	};
}

$.position = {
	scrollbarWidth: function() {
		if ( cachedScrollbarWidth !== undefined ) {
			return cachedScrollbarWidth;
		}
		var w1, w2,
			div = $( "<div style='display:block;width:50px;height:50px;overflow:hidden;'><div style='height:100px;width:auto;'></div></div>" ),
			innerDiv = div.children()[0];

		$( "body" ).append( div );
		w1 = innerDiv.offsetWidth;
		div.css( "overflow", "scroll" );

		w2 = innerDiv.offsetWidth;

		if ( w1 === w2 ) {
			w2 = div[0].clientWidth;
		}

		div.remove();

		return (cachedScrollbarWidth = w1 - w2);
	},
	getScrollInfo: function( within ) {
		var overflowX = within.isWindow ? "" : within.element.css( "overflow-x" ),
			overflowY = within.isWindow ? "" : within.element.css( "overflow-y" ),
			hasOverflowX = overflowX === "scroll" ||
				( overflowX === "auto" && within.width < within.element[0].scrollWidth ),
			hasOverflowY = overflowY === "scroll" ||
				( overflowY === "auto" && within.height < within.element[0].scrollHeight );
		return {
			width: hasOverflowX ? $.position.scrollbarWidth() : 0,
			height: hasOverflowY ? $.position.scrollbarWidth() : 0
		};
	},
	getWithinInfo: function( element ) {
		var withinElement = $( element || window ),
			isWindow = $.isWindow( withinElement[0] );
		return {
			element: withinElement,
			isWindow: isWindow,
			offset: withinElement.offset() || { left: 0, top: 0 },
			scrollLeft: withinElement.scrollLeft(),
			scrollTop: withinElement.scrollTop(),
			width: isWindow ? withinElement.width() : withinElement.outerWidth(),
			height: isWindow ? withinElement.height() : withinElement.outerHeight()
		};
	}
};

$.fn.position = function( options ) {
	if ( !options || !options.of ) {
		return _position.apply( this, arguments );
	}

	// make a copy, we don't want to modify arguments
	options = $.extend( {}, options );

	var atOffset, targetWidth, targetHeight, targetOffset, basePosition, dimensions,
		target = $( options.of ),
		within = $.position.getWithinInfo( options.within ),
		scrollInfo = $.position.getScrollInfo( within ),
		collision = ( options.collision || "flip" ).split( " " ),
		offsets = {};

	dimensions = getDimensions( target );
	if ( target[0].preventDefault ) {
		// force left top to allow flipping
		options.at = "left top";
	}
	targetWidth = dimensions.width;
	targetHeight = dimensions.height;
	targetOffset = dimensions.offset;
	// clone to reuse original targetOffset later
	basePosition = $.extend( {}, targetOffset );

	// force my and at to have valid horizontal and vertical positions
	// if a value is missing or invalid, it will be converted to center
	$.each( [ "my", "at" ], function() {
		var pos = ( options[ this ] || "" ).split( " " ),
			horizontalOffset,
			verticalOffset;

		if ( pos.length === 1) {
			pos = rhorizontal.test( pos[ 0 ] ) ?
				pos.concat( [ "center" ] ) :
				rvertical.test( pos[ 0 ] ) ?
					[ "center" ].concat( pos ) :
					[ "center", "center" ];
		}
		pos[ 0 ] = rhorizontal.test( pos[ 0 ] ) ? pos[ 0 ] : "center";
		pos[ 1 ] = rvertical.test( pos[ 1 ] ) ? pos[ 1 ] : "center";

		// calculate offsets
		horizontalOffset = roffset.exec( pos[ 0 ] );
		verticalOffset = roffset.exec( pos[ 1 ] );
		offsets[ this ] = [
			horizontalOffset ? horizontalOffset[ 0 ] : 0,
			verticalOffset ? verticalOffset[ 0 ] : 0
		];

		// reduce to just the positions without the offsets
		options[ this ] = [
			rposition.exec( pos[ 0 ] )[ 0 ],
			rposition.exec( pos[ 1 ] )[ 0 ]
		];
	});

	// normalize collision option
	if ( collision.length === 1 ) {
		collision[ 1 ] = collision[ 0 ];
	}

	if ( options.at[ 0 ] === "right" ) {
		basePosition.left += targetWidth;
	} else if ( options.at[ 0 ] === "center" ) {
		basePosition.left += targetWidth / 2;
	}

	if ( options.at[ 1 ] === "bottom" ) {
		basePosition.top += targetHeight;
	} else if ( options.at[ 1 ] === "center" ) {
		basePosition.top += targetHeight / 2;
	}

	atOffset = getOffsets( offsets.at, targetWidth, targetHeight );
	basePosition.left += atOffset[ 0 ];
	basePosition.top += atOffset[ 1 ];

	return this.each(function() {
		var collisionPosition, using,
			elem = $( this ),
			elemWidth = elem.outerWidth(),
			elemHeight = elem.outerHeight(),
			marginLeft = parseCss( this, "marginLeft" ),
			marginTop = parseCss( this, "marginTop" ),
			collisionWidth = elemWidth + marginLeft + parseCss( this, "marginRight" ) + scrollInfo.width,
			collisionHeight = elemHeight + marginTop + parseCss( this, "marginBottom" ) + scrollInfo.height,
			position = $.extend( {}, basePosition ),
			myOffset = getOffsets( offsets.my, elem.outerWidth(), elem.outerHeight() );

		if ( options.my[ 0 ] === "right" ) {
			position.left -= elemWidth;
		} else if ( options.my[ 0 ] === "center" ) {
			position.left -= elemWidth / 2;
		}

		if ( options.my[ 1 ] === "bottom" ) {
			position.top -= elemHeight;
		} else if ( options.my[ 1 ] === "center" ) {
			position.top -= elemHeight / 2;
		}

		position.left += myOffset[ 0 ];
		position.top += myOffset[ 1 ];

		// if the browser doesn't support fractions, then round for consistent results
		if ( !$.support.offsetFractions ) {
			position.left = round( position.left );
			position.top = round( position.top );
		}

		collisionPosition = {
			marginLeft: marginLeft,
			marginTop: marginTop
		};

		$.each( [ "left", "top" ], function( i, dir ) {
			if ( $.ui.position[ collision[ i ] ] ) {
				$.ui.position[ collision[ i ] ][ dir ]( position, {
					targetWidth: targetWidth,
					targetHeight: targetHeight,
					elemWidth: elemWidth,
					elemHeight: elemHeight,
					collisionPosition: collisionPosition,
					collisionWidth: collisionWidth,
					collisionHeight: collisionHeight,
					offset: [ atOffset[ 0 ] + myOffset[ 0 ], atOffset [ 1 ] + myOffset[ 1 ] ],
					my: options.my,
					at: options.at,
					within: within,
					elem : elem
				});
			}
		});

		if ( options.using ) {
			// adds feedback as second argument to using callback, if present
			using = function( props ) {
				var left = targetOffset.left - position.left,
					right = left + targetWidth - elemWidth,
					top = targetOffset.top - position.top,
					bottom = top + targetHeight - elemHeight,
					feedback = {
						target: {
							element: target,
							left: targetOffset.left,
							top: targetOffset.top,
							width: targetWidth,
							height: targetHeight
						},
						element: {
							element: elem,
							left: position.left,
							top: position.top,
							width: elemWidth,
							height: elemHeight
						},
						horizontal: right < 0 ? "left" : left > 0 ? "right" : "center",
						vertical: bottom < 0 ? "top" : top > 0 ? "bottom" : "middle"
					};
				if ( targetWidth < elemWidth && abs( left + right ) < targetWidth ) {
					feedback.horizontal = "center";
				}
				if ( targetHeight < elemHeight && abs( top + bottom ) < targetHeight ) {
					feedback.vertical = "middle";
				}
				if ( max( abs( left ), abs( right ) ) > max( abs( top ), abs( bottom ) ) ) {
					feedback.important = "horizontal";
				} else {
					feedback.important = "vertical";
				}
				options.using.call( this, props, feedback );
			};
		}

		elem.offset( $.extend( position, { using: using } ) );
	});
};

$.ui.position = {
	fit: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollLeft : within.offset.left,
				outerWidth = within.width,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = withinOffset - collisionPosLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - withinOffset,
				newOverRight;

			// element is wider than within
			if ( data.collisionWidth > outerWidth ) {
				// element is initially over the left side of within
				if ( overLeft > 0 && overRight <= 0 ) {
					newOverRight = position.left + overLeft + data.collisionWidth - outerWidth - withinOffset;
					position.left += overLeft - newOverRight;
				// element is initially over right side of within
				} else if ( overRight > 0 && overLeft <= 0 ) {
					position.left = withinOffset;
				// element is initially over both left and right sides of within
				} else {
					if ( overLeft > overRight ) {
						position.left = withinOffset + outerWidth - data.collisionWidth;
					} else {
						position.left = withinOffset;
					}
				}
			// too far left -> align with left edge
			} else if ( overLeft > 0 ) {
				position.left += overLeft;
			// too far right -> align with right edge
			} else if ( overRight > 0 ) {
				position.left -= overRight;
			// adjust based on position and margin
			} else {
				position.left = max( position.left - collisionPosLeft, position.left );
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.isWindow ? within.scrollTop : within.offset.top,
				outerHeight = data.within.height,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = withinOffset - collisionPosTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - withinOffset,
				newOverBottom;

			// element is taller than within
			if ( data.collisionHeight > outerHeight ) {
				// element is initially over the top of within
				if ( overTop > 0 && overBottom <= 0 ) {
					newOverBottom = position.top + overTop + data.collisionHeight - outerHeight - withinOffset;
					position.top += overTop - newOverBottom;
				// element is initially over bottom of within
				} else if ( overBottom > 0 && overTop <= 0 ) {
					position.top = withinOffset;
				// element is initially over both top and bottom of within
				} else {
					if ( overTop > overBottom ) {
						position.top = withinOffset + outerHeight - data.collisionHeight;
					} else {
						position.top = withinOffset;
					}
				}
			// too far up -> align with top
			} else if ( overTop > 0 ) {
				position.top += overTop;
			// too far down -> align with bottom edge
			} else if ( overBottom > 0 ) {
				position.top -= overBottom;
			// adjust based on position and margin
			} else {
				position.top = max( position.top - collisionPosTop, position.top );
			}
		}
	},
	flip: {
		left: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.left + within.scrollLeft,
				outerWidth = within.width,
				offsetLeft = within.isWindow ? within.scrollLeft : within.offset.left,
				collisionPosLeft = position.left - data.collisionPosition.marginLeft,
				overLeft = collisionPosLeft - offsetLeft,
				overRight = collisionPosLeft + data.collisionWidth - outerWidth - offsetLeft,
				myOffset = data.my[ 0 ] === "left" ?
					-data.elemWidth :
					data.my[ 0 ] === "right" ?
						data.elemWidth :
						0,
				atOffset = data.at[ 0 ] === "left" ?
					data.targetWidth :
					data.at[ 0 ] === "right" ?
						-data.targetWidth :
						0,
				offset = -2 * data.offset[ 0 ],
				newOverRight,
				newOverLeft;

			if ( overLeft < 0 ) {
				newOverRight = position.left + myOffset + atOffset + offset + data.collisionWidth - outerWidth - withinOffset;
				if ( newOverRight < 0 || newOverRight < abs( overLeft ) ) {
					position.left += myOffset + atOffset + offset;
				}
			}
			else if ( overRight > 0 ) {
				newOverLeft = position.left - data.collisionPosition.marginLeft + myOffset + atOffset + offset - offsetLeft;
				if ( newOverLeft > 0 || abs( newOverLeft ) < overRight ) {
					position.left += myOffset + atOffset + offset;
				}
			}
		},
		top: function( position, data ) {
			var within = data.within,
				withinOffset = within.offset.top + within.scrollTop,
				outerHeight = within.height,
				offsetTop = within.isWindow ? within.scrollTop : within.offset.top,
				collisionPosTop = position.top - data.collisionPosition.marginTop,
				overTop = collisionPosTop - offsetTop,
				overBottom = collisionPosTop + data.collisionHeight - outerHeight - offsetTop,
				top = data.my[ 1 ] === "top",
				myOffset = top ?
					-data.elemHeight :
					data.my[ 1 ] === "bottom" ?
						data.elemHeight :
						0,
				atOffset = data.at[ 1 ] === "top" ?
					data.targetHeight :
					data.at[ 1 ] === "bottom" ?
						-data.targetHeight :
						0,
				offset = -2 * data.offset[ 1 ],
				newOverTop,
				newOverBottom;
			if ( overTop < 0 ) {
				newOverBottom = position.top + myOffset + atOffset + offset + data.collisionHeight - outerHeight - withinOffset;
				if ( ( position.top + myOffset + atOffset + offset) > overTop && ( newOverBottom < 0 || newOverBottom < abs( overTop ) ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
			else if ( overBottom > 0 ) {
				newOverTop = position.top -  data.collisionPosition.marginTop + myOffset + atOffset + offset - offsetTop;
				if ( ( position.top + myOffset + atOffset + offset) > overBottom && ( newOverTop > 0 || abs( newOverTop ) < overBottom ) ) {
					position.top += myOffset + atOffset + offset;
				}
			}
		}
	},
	flipfit: {
		left: function() {
			$.ui.position.flip.left.apply( this, arguments );
			$.ui.position.fit.left.apply( this, arguments );
		},
		top: function() {
			$.ui.position.flip.top.apply( this, arguments );
			$.ui.position.fit.top.apply( this, arguments );
		}
	}
};

// fraction support test
(function () {
	var testElement, testElementParent, testElementStyle, offsetLeft, i,
		body = document.getElementsByTagName( "body" )[ 0 ],
		div = document.createElement( "div" );

	//Create a "fake body" for testing based on method used in jQuery.support
	testElement = document.createElement( body ? "div" : "body" );
	testElementStyle = {
		visibility: "hidden",
		width: 0,
		height: 0,
		border: 0,
		margin: 0,
		background: "none"
	};
	if ( body ) {
		$.extend( testElementStyle, {
			position: "absolute",
			left: "-1000px",
			top: "-1000px"
		});
	}
	for ( i in testElementStyle ) {
		testElement.style[ i ] = testElementStyle[ i ];
	}
	testElement.appendChild( div );
	testElementParent = body || document.documentElement;
	testElementParent.insertBefore( testElement, testElementParent.firstChild );

	div.style.cssText = "position: absolute; left: 10.7432222px;";

	offsetLeft = $( div ).offset().left;
	$.support.offsetFractions = offsetLeft > 10 && offsetLeft < 11;

	testElement.innerHTML = "";
	testElementParent.removeChild( testElement );
})();

}( jQuery ) );
/*
 * jQuery UI Timepicker 0.2.9
 *
 * Copyright 2010-2011, Francois Gelinas
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://fgelinas.com/code/timepicker
 *
 * Depends:
 *	jquery.ui.core.js
 *  jquery.ui.position.js (only if position settngs are used)
 *
 * Change version 0.1.0 - moved the t-rex up here
 *
                                                  ____
       ___                                      .-~. /_"-._
      `-._~-.                                  / /_ "~o\  :Y
          \  \                                / : \~x.  ` ')
           ]  Y                              /  |  Y< ~-.__j
          /   !                        _.--~T : l  l<  /.-~
         /   /                 ____.--~ .   ` l /~\ \<|Y
        /   /             .-~~"        /| .    ',-~\ \L|
       /   /             /     .^   \ Y~Y \.^>/l_   "--'
      /   Y           .-"(  .  l__  j_j l_/ /~_.-~    .
     Y    l          /    \  )    ~~~." / `/"~ / \.__/l_
     |     \     _.-"      ~-{__     l  :  l._Z~-.___.--~
     |      ~---~           /   ~~"---\_  ' __[>
     l  .                _.^   ___     _>-y~
      \  \     .      .-~   .-~   ~>--"  /
       \  ~---"            /     ./  _.-'
        "-.,_____.,_  _.--~\     _.-~
                    ~~     (   _}       -Row
                           `. ~(
                             )  \
                            /,`--'~\--'~\
                  ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
                             ->T-Rex<-
*/

(function ($, undefined) {

    $.extend($.ui, { timepicker: { version: "0.2.9"} });

    var PROP_NAME = 'timepicker';
    var tpuuid = new Date().getTime();

    /* Time picker manager.
    Use the singleton instance of this class, $.timepicker, to interact with the time picker.
    Settings for (groups of) time pickers are maintained in an instance object,
    allowing multiple different settings on the same page. */

    function Timepicker() {
        this.debug = true; // Change this to true to start debugging
        this._curInst = null; // The current instance in use
        this._isInline = false; // true if the instance is displayed inline
        this._disabledInputs = []; // List of time picker inputs that have been disabled
        this._timepickerShowing = false; // True if the popup picker is showing , false if not
        this._inDialog = false; // True if showing within a "dialog", false if not
        this._dialogClass = 'ui-timepicker-dialog'; // The name of the dialog marker class
        this._mainDivId = 'ui-timepicker-div'; // The ID of the main timepicker division
        this._inlineClass = 'ui-timepicker-inline'; // The name of the inline marker class
        this._currentClass = 'ui-timepicker-current'; // The name of the current hour / minutes marker class
        this._dayOverClass = 'ui-timepicker-days-cell-over'; // The name of the day hover marker class

        this.regional = []; // Available regional settings, indexed by language code
        this.regional[''] = { // Default regional settings
            hourText: 'Hour',           // Display text for hours section
            minuteText: 'Minute',       // Display text for minutes link
            amPmText: ['AM', 'PM'],     // Display text for AM PM
            closeButtonText: 'Done',        // Text for the confirmation button (ok button)
            nowButtonText: 'Now',           // Text for the now button
            deselectButtonText: 'Deselect'  // Text for the deselect button
        };
        this._defaults = { // Global defaults for all the time picker instances
            showOn: 'focus',    // 'focus' for popup on focus,
                                // 'button' for trigger button, or 'both' for either (not yet implemented)
            button: null,                   // 'button' element that will trigger the timepicker
            showAnim: 'fadeIn',             // Name of jQuery animation for popup
            showOptions: {},                // Options for enhanced animations
            appendText: '',                 // Display text following the input box, e.g. showing the format

            beforeShow: null,               // Define a callback function executed before the timepicker is shown
            onSelect: null,                 // Define a callback function when a hour / minutes is selected
            onClose: null,                  // Define a callback function when the timepicker is closed

            timeSeparator: ':',             // The character to use to separate hours and minutes.
            periodSeparator: ' ',           // The character to use to separate the time from the time period.
            showPeriod: false,              // Define whether or not to show AM/PM with selected time
            showPeriodLabels: true,         // Show the AM/PM labels on the left of the time picker
            showLeadingZero: true,          // Define whether or not to show a leading zero for hours < 10. [true/false]
            showMinutesLeadingZero: true,   // Define whether or not to show a leading zero for minutes < 10.
            altField: '',                   // Selector for an alternate field to store selected time into
            defaultTime: 'now',             // Used as default time when input field is empty or for inline timePicker
                                            // (set to 'now' for the current time, '' for no highlighted time)
            myPosition: 'left top',         // Position of the dialog relative to the input.
                                            // see the position utility for more info : http://jqueryui.com/demos/position/
            atPosition: 'left bottom',      // Position of the input element to match
                                            // Note : if the position utility is not loaded, the timepicker will attach left top to left bottom
            //NEW: 2011-02-03
            onHourShow: null,			    // callback for enabling / disabling on selectable hours  ex : function(hour) { return true; }
            onMinuteShow: null,             // callback for enabling / disabling on time selection  ex : function(hour,minute) { return true; }

            hours: {
                starts: 0,                  // first displayed hour
                ends: 23                    // last displayed hour
            },
            minutes: {
                starts: 0,                  // first displayed minute
                ends: 55,                   // last displayed minute
                interval: 5                 // interval of displayed minutes
            },
            rows: 4,                        // number of rows for the input tables, minimum 2, makes more sense if you use multiple of 2
            // 2011-08-05 0.2.4
            showHours: true,                // display the hours section of the dialog
            showMinutes: true,              // display the minute section of the dialog
            optionalMinutes: false,         // optionally parse inputs of whole hours with minutes omitted
						
            // buttons
            showCloseButton: false,         // shows an OK button to confirm the edit
            showNowButton: false,           // Shows the 'now' button
            showDeselectButton: false       // Shows the deselect time button

        };
        $.extend(this._defaults, this.regional['']);

        this.tpDiv = $('<div id="' + this._mainDivId + '" class="ui-timepicker ui-widget ui-helper-clearfix ui-corner-all " style="display: none"></div>');
    }

    $.extend(Timepicker.prototype, {
        /* Class name added to elements to indicate already configured with a time picker. */
        markerClassName: 'hasTimepicker',

        /* Debug logging (if enabled). */
        log: function () {
            if (this.debug)
                console.log.apply('', arguments);
        },

        _widgetTimepicker: function () {
            return this.tpDiv;
        },

        /* Override the default settings for all instances of the time picker.
        @param  settings  object - the new settings to use as defaults (anonymous object)
        @return the manager object */
        setDefaults: function (settings) {
            extendRemove(this._defaults, settings || {});
            return this;
        },

        /* Attach the time picker to a jQuery selection.
        @param  target    element - the target input field or division or span
        @param  settings  object - the new settings to use for this time picker instance (anonymous) */
        _attachTimepicker: function (target, settings) {
            // check for settings on the control itself - in namespace 'time:'
            var inlineSettings = null;
            for (var attrName in this._defaults) {
                var attrValue = target.getAttribute('time:' + attrName);
                if (attrValue) {
                    inlineSettings = inlineSettings || {};
                    try {
                        inlineSettings[attrName] = eval(attrValue);
                    } catch (err) {
                        inlineSettings[attrName] = attrValue;
                    }
                }
            }
            var nodeName = target.nodeName.toLowerCase();
            var inline = (nodeName == 'div' || nodeName == 'span');

            if (!target.id) {
                this.uuid += 1;
                target.id = 'tp' + this.uuid;
            }
            var inst = this._newInst($(target), inline);
            inst.settings = $.extend({}, settings || {}, inlineSettings || {});
            if (nodeName == 'input') {
                this._connectTimepicker(target, inst);
                // init inst.hours and inst.minutes from the input value
                this._setTimeFromField(inst);
            } else if (inline) {
                this._inlineTimepicker(target, inst);
            }


        },

        /* Create a new instance object. */
        _newInst: function (target, inline) {
            var id = target[0].id.replace(/([^A-Za-z0-9_-])/g, '\\\\$1'); // escape jQuery meta chars
            return {
                id: id, input: target, // associated target
                inline: inline, // is timepicker inline or not :
                tpDiv: (!inline ? this.tpDiv : // presentation div
                    $('<div class="' + this._inlineClass + ' ui-timepicker ui-widget  ui-helper-clearfix"></div>'))
            };
        },

        /* Attach the time picker to an input field. */
        _connectTimepicker: function (target, inst) {
            var input = $(target);
            inst.append = $([]);
            inst.trigger = $([]);
            if (input.hasClass(this.markerClassName)) { return; }
            this._attachments(input, inst);
            input.addClass(this.markerClassName).
                keydown(this._doKeyDown).
                keyup(this._doKeyUp).
                bind("setData.timepicker", function (event, key, value) {
                    inst.settings[key] = value;
                }).
                bind("getData.timepicker", function (event, key) {
                    return this._get(inst, key);
                });
            $.data(target, PROP_NAME, inst);
        },

        /* Handle keystrokes. */
        _doKeyDown: function (event) {
            var inst = $.timepicker._getInst(event.target);
            var handled = true;
            inst._keyEvent = true;
            if ($.timepicker._timepickerShowing) {
                switch (event.keyCode) {
                    case 9: $.timepicker._hideTimepicker();
                        handled = false;
                        break; // hide on tab out
                    case 13:
                        $.timepicker._updateSelectedValue(inst);
                        $.timepicker._hideTimepicker();
                            
						return false; // don't submit the form
						break; // select the value on enter
                    case 27: $.timepicker._hideTimepicker();
                        break; // hide on escape
                    default: handled = false;
                }
            }
            else if (event.keyCode == 36 && event.ctrlKey) { // display the time picker on ctrl+home
                $.timepicker._showTimepicker(this);
            }
            else {
                handled = false;
            }
            if (handled) {
                event.preventDefault();
                event.stopPropagation();
            }
        },

        /* Update selected time on keyUp */
        /* Added verion 0.0.5 */
        _doKeyUp: function (event) {
            var inst = $.timepicker._getInst(event.target);
            $.timepicker._setTimeFromField(inst);
            $.timepicker._updateTimepicker(inst);
        },

        /* Make attachments based on settings. */
        _attachments: function (input, inst) {
            var appendText = this._get(inst, 'appendText');
            var isRTL = this._get(inst, 'isRTL');
            if (inst.append) { inst.append.remove(); }
            if (appendText) {
                inst.append = $('<span class="' + this._appendClass + '">' + appendText + '</span>');
                input[isRTL ? 'before' : 'after'](inst.append);
            }
            input.unbind('focus.timepicker', this._showTimepicker);
            if (inst.trigger) { inst.trigger.remove(); }

            var showOn = this._get(inst, 'showOn');
            if (showOn == 'focus' || showOn == 'both') { // pop-up time picker when in the marked field
                input.bind("focus.timepicker", this._showTimepicker);
            }
            if (showOn == 'button' || showOn == 'both') { // pop-up time picker when 'button' element is clicked
                var button = this._get(inst, 'button');
                $(button).bind("click.timepicker", function () {
                    if ($.timepicker._timepickerShowing && $.timepicker._lastInput == input[0]) { $.timepicker._hideTimepicker(); }
                    else { $.timepicker._showTimepicker(input[0]); }
                    return false;
                });

            }
        },


        /* Attach an inline time picker to a div. */
        _inlineTimepicker: function(target, inst) {
            var divSpan = $(target);
            if (divSpan.hasClass(this.markerClassName))
                return;
            divSpan.addClass(this.markerClassName).append(inst.tpDiv).
                bind("setData.timepicker", function(event, key, value){
                    inst.settings[key] = value;
                }).bind("getData.timepicker", function(event, key){
                    return this._get(inst, key);
                });
            $.data(target, PROP_NAME, inst);

            this._setTimeFromField(inst);
            this._updateTimepicker(inst);
            inst.tpDiv.show();
        },

        /* Pop-up the time picker for a given input field.
        @param  input  element - the input field attached to the time picker or
        event - if triggered by focus */
        _showTimepicker: function (input) {
            input = input.target || input;
            if (input.nodeName.toLowerCase() != 'input') { input = $('input', input.parentNode)[0]; } // find from button/image trigger
            if ($.timepicker._isDisabledTimepicker(input) || $.timepicker._lastInput == input) { return; } // already here

            // fix v 0.0.8 - close current timepicker before showing another one
            $.timepicker._hideTimepicker();

            var inst = $.timepicker._getInst(input);
            if ($.timepicker._curInst && $.timepicker._curInst != inst) {
                $.timepicker._curInst.tpDiv.stop(true, true);
            }
            var beforeShow = $.timepicker._get(inst, 'beforeShow');
            extendRemove(inst.settings, (beforeShow ? beforeShow.apply(input, [input, inst]) : {}));
            inst.lastVal = null;
            $.timepicker._lastInput = input;

            $.timepicker._setTimeFromField(inst);

            // calculate default position
            if ($.timepicker._inDialog) { input.value = ''; } // hide cursor
            if (!$.timepicker._pos) { // position below input
                $.timepicker._pos = $.timepicker._findPos(input);
                $.timepicker._pos[1] += input.offsetHeight; // add the height
            }
            var isFixed = false;
            $(input).parents().each(function () {
                isFixed |= $(this).css('position') == 'fixed';
                return !isFixed;
            });
            if (isFixed && $.browser.opera) { // correction for Opera when fixed and scrolled
                $.timepicker._pos[0] -= document.documentElement.scrollLeft;
                $.timepicker._pos[1] -= document.documentElement.scrollTop;
            }

            var offset = { left: $.timepicker._pos[0], top: $.timepicker._pos[1] };

            $.timepicker._pos = null;
            // determine sizing offscreen
            inst.tpDiv.css({ position: 'absolute', display: 'block', top: '-1000px' });
            $.timepicker._updateTimepicker(inst);


            // position with the ui position utility, if loaded
            if ( ( ! inst.inline )  && ( typeof $.ui.position == 'object' ) ) {
                inst.tpDiv.position({
                    of: inst.input,
                    my: $.timepicker._get( inst, 'myPosition' ),
                    at: $.timepicker._get( inst, 'atPosition' ),
                    // offset: $( "#offset" ).val(),
                    // using: using,
                    collision: 'flip'
                });
                var offset = inst.tpDiv.offset();
                $.timepicker._pos = [offset.top, offset.left];
            }


            // reset clicked state
            inst._hoursClicked = false;
            inst._minutesClicked = false;

            // fix width for dynamic number of time pickers
            // and adjust position before showing
            offset = $.timepicker._checkOffset(inst, offset, isFixed);
            inst.tpDiv.css({ position: ($.timepicker._inDialog && $.blockUI ?
			    'static' : (isFixed ? 'fixed' : 'absolute')), display: 'none',
                left: offset.left + 'px', top: offset.top + 'px'
            });
            if ( ! inst.inline ) {
                var showAnim = $.timepicker._get(inst, 'showAnim');
                var duration = $.timepicker._get(inst, 'duration');

                var postProcess = function () {
                    $.timepicker._timepickerShowing = true;
                    var borders = $.timepicker._getBorders(inst.tpDiv);
                    inst.tpDiv.find('iframe.ui-timepicker-cover'). // IE6- only
					css({ left: -borders[0], top: -borders[1],
					    width: inst.tpDiv.outerWidth(), height: inst.tpDiv.outerHeight()
					});
                };

                // Fixed the zIndex problem for real (I hope) - FG - v 0.2.9
                inst.tpDiv.css('zIndex', $.timepicker._getZIndex(input) +1);

                if ($.effects && $.effects[showAnim]) {
                    inst.tpDiv.show(showAnim, $.timepicker._get(inst, 'showOptions'), duration, postProcess);
                }
                else {
                    inst.tpDiv[showAnim || 'show']((showAnim ? duration : null), postProcess);
                }
                if (!showAnim || !duration) { postProcess(); }
                if (inst.input.is(':visible') && !inst.input.is(':disabled')) { inst.input.focus(); }
                $.timepicker._curInst = inst;
            }
        },

        // This is a copy of the zIndex function of UI core 1.8.??
        // Copied in the timepicker to stay backward compatible.
        _getZIndex: function (target) {
            var elem = $( target ), position, value;
            while ( elem.length && elem[ 0 ] !== document ) {
                position = elem.css( "position" );
                if ( position === "absolute" || position === "relative" || position === "fixed" ) {
                    value = parseInt( elem.css( "zIndex" ), 10 );
                    if ( !isNaN( value ) && value !== 0 ) {
                        return value;
                    }
                }
                elem = elem.parent();
            }
        },

        /* Generate the time picker content. */
        _updateTimepicker: function (inst) {
            inst.tpDiv.empty().append(this._generateHTML(inst));
            this._rebindDialogEvents(inst);

        },

        _rebindDialogEvents: function (inst) {
            var borders = $.timepicker._getBorders(inst.tpDiv),
                self = this;
            inst.tpDiv
			.find('iframe.ui-timepicker-cover') // IE6- only
				.css({ left: -borders[0], top: -borders[1],
				    width: inst.tpDiv.outerWidth(), height: inst.tpDiv.outerHeight()
				})
			.end()
            // after the picker html is appended bind the click & double click events (faster in IE this way
            // then letting the browser interpret the inline events)
            // the binding for the minute cells also exists in _updateMinuteDisplay
            .find('.ui-timepicker-minute-cell')
                .unbind()
                .bind("click", { fromDoubleClick:false }, $.proxy($.timepicker.selectMinutes, this))
                .bind("dblclick", { fromDoubleClick:true }, $.proxy($.timepicker.selectMinutes, this))
            .end()
            .find('.ui-timepicker-hour-cell')
                .unbind()
                .bind("click", { fromDoubleClick:false }, $.proxy($.timepicker.selectHours, this))
                .bind("dblclick", { fromDoubleClick:true }, $.proxy($.timepicker.selectHours, this))
            .end()
			.find('.ui-timepicker td a')
                .unbind()
				.bind('mouseout', function () {
				    $(this).removeClass('ui-state-hover');
				    if (this.className.indexOf('ui-timepicker-prev') != -1) $(this).removeClass('ui-timepicker-prev-hover');
				    if (this.className.indexOf('ui-timepicker-next') != -1) $(this).removeClass('ui-timepicker-next-hover');
				})
				.bind('mouseover', function () {
				    if ( ! self._isDisabledTimepicker(inst.inline ? inst.tpDiv.parent()[0] : inst.input[0])) {
				        $(this).parents('.ui-timepicker-calendar').find('a').removeClass('ui-state-hover');
				        $(this).addClass('ui-state-hover');
				        if (this.className.indexOf('ui-timepicker-prev') != -1) $(this).addClass('ui-timepicker-prev-hover');
				        if (this.className.indexOf('ui-timepicker-next') != -1) $(this).addClass('ui-timepicker-next-hover');
				    }
				})
			.end()
			.find('.' + this._dayOverClass + ' a')
				.trigger('mouseover')
			.end()
            .find('.ui-timepicker-now').bind("click",function(e) {
                    $.timepicker.selectNow(e);
            }).end()
            .find('.ui-timepicker-deselect').bind("click",function(e) {
                    $.timepicker.deselectTime(e);
            }).end()
            .find('.ui-timepicker-close').bind("click",function(e) {
                    $.timepicker._hideTimepicker();
            }).end();
        },

        /* Generate the HTML for the current state of the time picker. */
        _generateHTML: function (inst) {

            var h, m, row, col, html, hoursHtml, minutesHtml = '',
                showPeriod = (this._get(inst, 'showPeriod') == true),
                showPeriodLabels = (this._get(inst, 'showPeriodLabels') == true),
                showLeadingZero = (this._get(inst, 'showLeadingZero') == true),
                showHours = (this._get(inst, 'showHours') == true),
                showMinutes = (this._get(inst, 'showMinutes') == true),
                amPmText = this._get(inst, 'amPmText'),
                rows = this._get(inst, 'rows'),
                amRows = 0,
                pmRows = 0,
                amItems = 0,
                pmItems = 0,
                amFirstRow = 0,
                pmFirstRow = 0,
                hours = Array(),
                hours_options = this._get(inst, 'hours'),
                hoursPerRow = null,
                hourCounter = 0,
                hourLabel = this._get(inst, 'hourText'),
                showCloseButton = this._get(inst, 'showCloseButton'),
                closeButtonText = this._get(inst, 'closeButtonText'),
                showNowButton = this._get(inst, 'showNowButton'),
                nowButtonText = this._get(inst, 'nowButtonText'),
                showDeselectButton = this._get(inst, 'showDeselectButton'),
                deselectButtonText = this._get(inst, 'deselectButtonText'),
                showButtonPanel = showCloseButton || showNowButton || showDeselectButton;
            


            // prepare all hours and minutes, makes it easier to distribute by rows
            for (h = hours_options.starts; h <= hours_options.ends; h++) {
                hours.push (h);
            }
            hoursPerRow = Math.ceil(hours.length / rows); // always round up

            if (showPeriodLabels) {
                for (hourCounter = 0; hourCounter < hours.length; hourCounter++) {
                    if (hours[hourCounter] < 12) {
                        amItems++;
                    }
                    else {
                        pmItems++;
                    }
                }
                hourCounter = 0; 

                amRows = Math.floor(amItems / hours.length * rows);
                pmRows = Math.floor(pmItems / hours.length * rows);

                // assign the extra row to the period that is more densly populated
                if (rows != amRows + pmRows) {
                    // Make sure: AM Has Items and either PM Does Not, AM has no rows yet, or AM is more dense
                    if (amItems && (!pmItems || !amRows || (pmRows && amItems / amRows >= pmItems / pmRows))) {
                        amRows++;
                    } else {
                        pmRows++;
                    }
                }
                amFirstRow = Math.min(amRows, 1);
                pmFirstRow = amRows + 1;
                hoursPerRow = Math.ceil(Math.max(amItems / amRows, pmItems / pmRows));
            }


            html = '<table class="ui-timepicker-table ui-widget-content ui-corner-all"><tr>';

            if (showHours) {

                html += '<td class="ui-timepicker-hours">' +
                        '<div class="ui-timepicker-title ui-widget-header ui-helper-clearfix ui-corner-all">' +
                        hourLabel +
                        '</div>' +
                        '<table class="ui-timepicker">';

                for (row = 1; row <= rows; row++) {
                    html += '<tr>';
                    // AM
                    if (row == amFirstRow && showPeriodLabels) {
                        html += '<th rowspan="' + amRows.toString() + '" class="periods" scope="row">' + amPmText[0] + '</th>';
                    }
                    // PM
                    if (row == pmFirstRow && showPeriodLabels) {
                        html += '<th rowspan="' + pmRows.toString() + '" class="periods" scope="row">' + amPmText[1] + '</th>';
                    }
                    for (col = 1; col <= hoursPerRow; col++) {
                        if (showPeriodLabels && row < pmFirstRow && hours[hourCounter] >= 12) {
                            html += this._generateHTMLHourCell(inst, undefined, showPeriod, showLeadingZero);
                        } else {
                            html += this._generateHTMLHourCell(inst, hours[hourCounter], showPeriod, showLeadingZero);
                            hourCounter++;
                        }
                    }
                    html += '</tr>';
                }
                html += '</tr></table>' + // Close the hours cells table
                        '</td>';          // Close the Hour td
            }

            if (showMinutes) {
                html += '<td class="ui-timepicker-minutes">';
                html += this._generateHTMLMinutes(inst);
                html += '</td>';
            }
            
            html += '</tr>';


            if (showButtonPanel) {
                var buttonPanel = '<tr><td colspan="3"><div class="ui-timepicker-buttonpane ui-widget-content">';
                if (showNowButton) {
                    buttonPanel += '<button type="button" class="ui-timepicker-now ui-state-default ui-corner-all" '
                                   + ' data-timepicker-instance-id="#' + inst.id.replace(/\\\\/g,"\\") + '" >'
                                   + nowButtonText + '</button>';
                }
                if (showDeselectButton) {
                    buttonPanel += '<button type="button" class="ui-timepicker-deselect ui-state-default ui-corner-all" '
                                   + ' data-timepicker-instance-id="#' + inst.id.replace(/\\\\/g,"\\") + '" >'
                                   + deselectButtonText + '</button>';
                }
                if (showCloseButton) {
                    buttonPanel += '<button type="button" class="ui-timepicker-close ui-state-default ui-corner-all" '
                                   + ' data-timepicker-instance-id="#' + inst.id.replace(/\\\\/g,"\\") + '" >'
                                   + closeButtonText + '</button>';
                }

                html += buttonPanel + '</div></td></tr>';
            }
            html += '</table>';

             /* IE6 IFRAME FIX (taken from datepicker 1.5.3, fixed in 0.1.2 */
            html += ($.browser.msie && parseInt($.browser.version,10) < 7 && !inst.inline ?
                '<iframe src="javascript:false;" class="ui-timepicker-cover" frameborder="0"></iframe>' : '');

            return html;
        },

        /* Special function that update the minutes selection in currently visible timepicker
         * called on hour selection when onMinuteShow is defined  */
        _updateMinuteDisplay: function (inst) {
            var newHtml = this._generateHTMLMinutes(inst);
            inst.tpDiv.find('td.ui-timepicker-minutes').html(newHtml);
            this._rebindDialogEvents(inst);
                // after the picker html is appended bind the click & double click events (faster in IE this way
                // then letting the browser interpret the inline events)
                // yes I know, duplicate code, sorry
/*                .find('.ui-timepicker-minute-cell')
                    .bind("click", { fromDoubleClick:false }, $.proxy($.timepicker.selectMinutes, this))
                    .bind("dblclick", { fromDoubleClick:true }, $.proxy($.timepicker.selectMinutes, this));
*/

        },

        /*
         * Generate the minutes table
         * This is separated from the _generateHTML function because is can be called separately (when hours changes)
         */
        _generateHTMLMinutes: function (inst) {

            var m, row, html = '',
                rows = this._get(inst, 'rows'),
                minutes = Array(),
                minutes_options = this._get(inst, 'minutes'),
                minutesPerRow = null,
                minuteCounter = 0,
                showMinutesLeadingZero = (this._get(inst, 'showMinutesLeadingZero') == true),
                onMinuteShow = this._get(inst, 'onMinuteShow'),
                minuteLabel = this._get(inst, 'minuteText');

            if ( ! minutes_options.starts) {
                minutes_options.starts = 0;
            }
            if ( ! minutes_options.ends) {
                minutes_options.ends = 59;
            }
            for (m = minutes_options.starts; m <= minutes_options.ends; m += minutes_options.interval) {
                minutes.push(m);
            }
            minutesPerRow = Math.round(minutes.length / rows + 0.49); // always round up

            /*
             * The minutes table
             */
            // if currently selected minute is not enabled, we have a problem and need to select a new minute.
            if (onMinuteShow &&
                (onMinuteShow.apply((inst.input ? inst.input[0] : null), [inst.hours , inst.minutes]) == false) ) {
                // loop minutes and select first available
                for (minuteCounter = 0; minuteCounter < minutes.length; minuteCounter += 1) {
                    m = minutes[minuteCounter];
                    if (onMinuteShow.apply((inst.input ? inst.input[0] : null), [inst.hours, m])) {
                        inst.minutes = m;
                        break;
                    }
                }
            }



            html += '<div class="ui-timepicker-title ui-widget-header ui-helper-clearfix ui-corner-all">' +
                    minuteLabel +
                    '</div>' +
                    '<table class="ui-timepicker">';
            
            minuteCounter = 0;
            for (row = 1; row <= rows; row++) {
                html += '<tr>';
                while (minuteCounter < row * minutesPerRow) {
                    var m = minutes[minuteCounter];
                    var displayText = '';
                    if (m !== undefined ) {
                        displayText = (m < 10) && showMinutesLeadingZero ? "0" + m.toString() : m.toString();
                    }
                    html += this._generateHTMLMinuteCell(inst, m, displayText);
                    minuteCounter++;
                }
                html += '</tr>';
            }

            html += '</table>';

            return html;
        },

        /* Generate the content of a "Hour" cell */
        _generateHTMLHourCell: function (inst, hour, showPeriod, showLeadingZero) {

            var displayHour = hour;
            if ((hour > 12) && showPeriod) {
                displayHour = hour - 12;
            }
            if ((displayHour == 0) && showPeriod) {
                displayHour = 12;
            }
            if ((displayHour < 10) && showLeadingZero) {
                displayHour = '0' + displayHour;
            }

            var html = "";
            var enabled = true;
            var onHourShow = this._get(inst, 'onHourShow');		//custom callback

            if (hour == undefined) {
                html = '<td><span class="ui-state-default ui-state-disabled">&nbsp;</span></td>';
                return html;
            }

            if (onHourShow) {
            	enabled = onHourShow.apply((inst.input ? inst.input[0] : null), [hour]);
            }

            if (enabled) {
                html = '<td class="ui-timepicker-hour-cell" data-timepicker-instance-id="#' + inst.id.replace(/\\\\/g,"\\") + '" data-hour="' + hour.toString() + '">' +
                   '<a class="ui-state-default ' +
                   (hour == inst.hours ? 'ui-state-active' : '') +
                   '">' +
                   displayHour.toString() +
                   '</a></td>';
            }
            else {
            	html =
            		'<td>' +
		                '<span class="ui-state-default ui-state-disabled ' +
		                (hour == inst.hours ? ' ui-state-active ' : ' ') +
		                '">' +
		                displayHour.toString() +
		                '</span>' +
		            '</td>';
            }
            return html;
        },

        /* Generate the content of a "Hour" cell */
        _generateHTMLMinuteCell: function (inst, minute, displayText) {
        	 var html = "";
             var enabled = true;
             var onMinuteShow = this._get(inst, 'onMinuteShow');		//custom callback
             if (onMinuteShow) {
            	 //NEW: 2011-02-03  we should give the hour as a parameter as well!
             	enabled = onMinuteShow.apply((inst.input ? inst.input[0] : null), [inst.hours,minute]);		//trigger callback
             }

             if (minute == undefined) {
                 html = '<td><span class="ui-state-default ui-state-disabled">&nbsp;</span></td>';
                 return html;
             }

             if (enabled) {
	             html = '<td class="ui-timepicker-minute-cell" data-timepicker-instance-id="#' + inst.id.replace(/\\\\/g,"\\") + '" data-minute="' + minute.toString() + '" >' +
	                   '<a class="ui-state-default ' +
	                   (minute == inst.minutes ? 'ui-state-active' : '') +
	                   '" >' +
	                   displayText +
	                   '</a></td>';
             }
             else {

            	html = '<td>' +
	                 '<span class="ui-state-default ui-state-disabled" >' +
	                 	displayText +
	                 '</span>' +
                 '</td>';
             }
             return html;
        },


        /* Enable the date picker to a jQuery selection.
           @param  target    element - the target input field or division or span */
        _enableTimepicker: function(target) {
            var $target = $(target),
                target_id = $target.attr('id'),
                inst = $.data(target, PROP_NAME);
            
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            var nodeName = target.nodeName.toLowerCase();
            if (nodeName == 'input') {
                target.disabled = false;
                inst.trigger.filter('button').
                    each(function() { this.disabled = false; }).end();
            }
            else if (nodeName == 'div' || nodeName == 'span') {
                var inline = $target.children('.' + this._inlineClass);
                inline.children().removeClass('ui-state-disabled');
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function(value) { return (value == target_id ? null : value); }); // delete entry
        },

        /* Disable the time picker to a jQuery selection.
           @param  target    element - the target input field or division or span */
        _disableTimepicker: function(target) {
            var $target = $(target);
            var inst = $.data(target, PROP_NAME);
            if (!$target.hasClass(this.markerClassName)) {
                return;
            }
            var nodeName = target.nodeName.toLowerCase();
            if (nodeName == 'input') {
                target.disabled = true;

                inst.trigger.filter('button').
                    each(function() { this.disabled = true; }).end();

            }
            else if (nodeName == 'div' || nodeName == 'span') {
                var inline = $target.children('.' + this._inlineClass);
                inline.children().addClass('ui-state-disabled');
            }
            this._disabledInputs = $.map(this._disabledInputs,
                function(value) { return (value == target ? null : value); }); // delete entry
            this._disabledInputs[this._disabledInputs.length] = $target.attr('id');
        },

        /* Is the first field in a jQuery collection disabled as a timepicker?
        @param  target_id element - the target input field or division or span
        @return boolean - true if disabled, false if enabled */
        _isDisabledTimepicker: function (target_id) {
            if ( ! target_id) { return false; }
            for (var i = 0; i < this._disabledInputs.length; i++) {
                if (this._disabledInputs[i] == target_id) { return true; }
            }
            return false;
        },

        /* Check positioning to remain on screen. */
        _checkOffset: function (inst, offset, isFixed) {
            var tpWidth = inst.tpDiv.outerWidth();
            var tpHeight = inst.tpDiv.outerHeight();
            var inputWidth = inst.input ? inst.input.outerWidth() : 0;
            var inputHeight = inst.input ? inst.input.outerHeight() : 0;
            var viewWidth = document.documentElement.clientWidth + $(document).scrollLeft();
            var viewHeight = document.documentElement.clientHeight + $(document).scrollTop();

            offset.left -= (this._get(inst, 'isRTL') ? (tpWidth - inputWidth) : 0);
            offset.left -= (isFixed && offset.left == inst.input.offset().left) ? $(document).scrollLeft() : 0;
            offset.top -= (isFixed && offset.top == (inst.input.offset().top + inputHeight)) ? $(document).scrollTop() : 0;

            // now check if datepicker is showing outside window viewport - move to a better place if so.
            offset.left -= Math.min(offset.left, (offset.left + tpWidth > viewWidth && viewWidth > tpWidth) ?
			Math.abs(offset.left + tpWidth - viewWidth) : 0);
            offset.top -= Math.min(offset.top, (offset.top + tpHeight > viewHeight && viewHeight > tpHeight) ?
			Math.abs(tpHeight + inputHeight) : 0);

            return offset;
        },

        /* Find an object's position on the screen. */
        _findPos: function (obj) {
            var inst = this._getInst(obj);
            var isRTL = this._get(inst, 'isRTL');
            while (obj && (obj.type == 'hidden' || obj.nodeType != 1)) {
                obj = obj[isRTL ? 'previousSibling' : 'nextSibling'];
            }
            var position = $(obj).offset();
            return [position.left, position.top];
        },

        /* Retrieve the size of left and top borders for an element.
        @param  elem  (jQuery object) the element of interest
        @return  (number[2]) the left and top borders */
        _getBorders: function (elem) {
            var convert = function (value) {
                return { thin: 1, medium: 2, thick: 3}[value] || value;
            };
            return [parseFloat(convert(elem.css('border-left-width'))),
			parseFloat(convert(elem.css('border-top-width')))];
        },


        /* Close time picker if clicked elsewhere. */
        _checkExternalClick: function (event) {
            if (!$.timepicker._curInst) { return; }
            var $target = $(event.target);
            if ($target[0].id != $.timepicker._mainDivId &&
				$target.parents('#' + $.timepicker._mainDivId).length == 0 &&
				!$target.hasClass($.timepicker.markerClassName) &&
				!$target.hasClass($.timepicker._triggerClass) &&
				$.timepicker._timepickerShowing && !($.timepicker._inDialog && $.blockUI))
                $.timepicker._hideTimepicker();
        },

        /* Hide the time picker from view.
        @param  input  element - the input field attached to the time picker */
        _hideTimepicker: function (input) {
            var inst = this._curInst;
            if (!inst || (input && inst != $.data(input, PROP_NAME))) { return; }
            if (this._timepickerShowing) {
                var showAnim = this._get(inst, 'showAnim');
                var duration = this._get(inst, 'duration');
                var postProcess = function () {
                    $.timepicker._tidyDialog(inst);
                    this._curInst = null;
                };
                if ($.effects && $.effects[showAnim]) {
                    inst.tpDiv.hide(showAnim, $.timepicker._get(inst, 'showOptions'), duration, postProcess);
                }
                else {
                    inst.tpDiv[(showAnim == 'slideDown' ? 'slideUp' :
					    (showAnim == 'fadeIn' ? 'fadeOut' : 'hide'))]((showAnim ? duration : null), postProcess);
                }
                if (!showAnim) { postProcess(); }
                var onClose = this._get(inst, 'onClose');
                if (onClose) {
                    onClose.apply(
                        (inst.input ? inst.input[0] : null),
					    [(inst.input ? inst.input.val() : ''), inst]);  // trigger custom callback
                }
                this._timepickerShowing = false;
                this._lastInput = null;
                if (this._inDialog) {
                    this._dialogInput.css({ position: 'absolute', left: '0', top: '-100px' });
                    if ($.blockUI) {
                        $.unblockUI();
                        $('body').append(this.tpDiv);
                    }
                }
                this._inDialog = false;
            }
        },



        /* Tidy up after a dialog display. */
        _tidyDialog: function (inst) {
            inst.tpDiv.removeClass(this._dialogClass).unbind('.ui-timepicker');
        },

        /* Retrieve the instance data for the target control.
        @param  target  element - the target input field or division or span
        @return  object - the associated instance data
        @throws  error if a jQuery problem getting data */
        _getInst: function (target) {
            try {
                return $.data(target, PROP_NAME);
            }
            catch (err) {
                throw 'Missing instance data for this timepicker';
            }
        },

        /* Get a setting value, defaulting if necessary. */
        _get: function (inst, name) {
            return inst.settings[name] !== undefined ?
			inst.settings[name] : this._defaults[name];
        },

        /* Parse existing time and initialise time picker. */
        _setTimeFromField: function (inst) {
            if (inst.input.val() == inst.lastVal) { return; }
            var defaultTime = this._get(inst, 'defaultTime');

            var timeToParse = defaultTime == 'now' ? this._getCurrentTimeRounded(inst) : defaultTime;
            if ((inst.inline == false) && (inst.input.val() != '')) { timeToParse = inst.input.val() }

            if (timeToParse instanceof Date) {
                inst.hours = timeToParse.getHours();
                inst.minutes = timeToParse.getMinutes();
            } else {
                var timeVal = inst.lastVal = timeToParse;
                if (timeToParse == '') {
                    inst.hours = -1;
                    inst.minutes = -1;
                } else {
                    var time = this.parseTime(inst, timeVal);
                    inst.hours = time.hours;
                    inst.minutes = time.minutes;
                }
            }


            $.timepicker._updateTimepicker(inst);
        },

        /* Update or retrieve the settings for an existing time picker.
           @param  target  element - the target input field or division or span
           @param  name    object - the new settings to update or
                           string - the name of the setting to change or retrieve,
                           when retrieving also 'all' for all instance settings or
                           'defaults' for all global defaults
           @param  value   any - the new value for the setting
                       (omit if above is an object or to retrieve a value) */
        _optionTimepicker: function(target, name, value) {
            var inst = this._getInst(target);
            if (arguments.length == 2 && typeof name == 'string') {
                return (name == 'defaults' ? $.extend({}, $.timepicker._defaults) :
                    (inst ? (name == 'all' ? $.extend({}, inst.settings) :
                    this._get(inst, name)) : null));
            }
            var settings = name || {};
            if (typeof name == 'string') {
                settings = {};
                settings[name] = value;
            }
            if (inst) {
                if (this._curInst == inst) {
                    this._hideTimepicker();
                }
                extendRemove(inst.settings, settings);
                this._updateTimepicker(inst);
            }
        },


        /* Set the time for a jQuery selection.
	    @param  target  element - the target input field or division or span
	    @param  time    String - the new time */
	    _setTimeTimepicker: function(target, time) {
		    var inst = this._getInst(target);
		    if (inst) {
			    this._setTime(inst, time);
    			this._updateTimepicker(inst);
	    		this._updateAlternate(inst, time);
		    }
	    },

        /* Set the time directly. */
        _setTime: function(inst, time, noChange) {
            var origHours = inst.hours;
            var origMinutes = inst.minutes;
            var time = this.parseTime(inst, time);
            inst.hours = time.hours;
            inst.minutes = time.minutes;

            if ((origHours != inst.hours || origMinutes != inst.minuts) && !noChange) {
                inst.input.trigger('change');
            }
            this._updateTimepicker(inst);
            this._updateSelectedValue(inst);
        },

        /* Return the current time, ready to be parsed, rounded to the closest 5 minute */
        _getCurrentTimeRounded: function (inst) {
            var currentTime = new Date(),
                currentMinutes = currentTime.getMinutes(),
                // round to closest 5
                adjustedMinutes = Math.round( currentMinutes / 5 ) * 5;
            currentTime.setMinutes(adjustedMinutes);
            return currentTime;
        },

        /*
        * Parse a time string into hours and minutes
        */
        parseTime: function (inst, timeVal) {
            var retVal = new Object();
            retVal.hours = -1;
            retVal.minutes = -1;

            var timeSeparator = this._get(inst, 'timeSeparator'),
                amPmText = this._get(inst, 'amPmText'),
                showHours = this._get(inst, 'showHours'),
                showMinutes = this._get(inst, 'showMinutes'),
                optionalMinutes = this._get(inst, 'optionalMinutes'),
                showPeriod = (this._get(inst, 'showPeriod') == true),
                p = timeVal.indexOf(timeSeparator);

            // check if time separator found
            if (p != -1) {
                retVal.hours = parseInt(timeVal.substr(0, p), 10);
                retVal.minutes = parseInt(timeVal.substr(p + 1), 10);
            }
            // check for hours only
            else if ( (showHours) && ( !showMinutes || optionalMinutes ) ) {
                retVal.hours = parseInt(timeVal, 10);
            }
            // check for minutes only
            else if ( ( ! showHours) && (showMinutes) ) {
                retVal.minutes = parseInt(timeVal, 10);
            }

            if (showHours) {
                var timeValUpper = timeVal.toUpperCase();
                if ((retVal.hours < 12) && (showPeriod) && (timeValUpper.indexOf(amPmText[1].toUpperCase()) != -1)) {
                    retVal.hours += 12;
                }
                // fix for 12 AM
                if ((retVal.hours == 12) && (showPeriod) && (timeValUpper.indexOf(amPmText[0].toUpperCase()) != -1)) {
                    retVal.hours = 0;
                }
            }
            
            return retVal;
        },

        selectNow: function(e) {

            var id = $(e.target).attr("data-timepicker-instance-id"),
                $target = $(id),
                inst = this._getInst($target[0]);

            //if (!inst || (input && inst != $.data(input, PROP_NAME))) { return; }
            var currentTime = new Date();
            inst.hours = currentTime.getHours();
            inst.minutes = currentTime.getMinutes();
            this._updateSelectedValue(inst);
            this._updateTimepicker(inst);
            this._hideTimepicker();
        },

        deselectTime: function(e) {
            var id = $(e.target).attr("data-timepicker-instance-id"),
                $target = $(id),
                inst = this._getInst($target[0]);
            inst.hours = -1;
            inst.minutes = -1;
            this._updateSelectedValue(inst);
            this._hideTimepicker();
        },


        selectHours: function (event) {
            var $td = $(event.currentTarget),
                id = $td.attr("data-timepicker-instance-id"),
                newHours = $td.attr("data-hour"),
                fromDoubleClick = event.data.fromDoubleClick,
                $target = $(id),
                inst = this._getInst($target[0]),
                showMinutes = (this._get(inst, 'showMinutes') == true);

            // don't select if disabled
            if ( $.timepicker._isDisabledTimepicker($target.attr('id')) ) { return false }

            $td.parents('.ui-timepicker-hours:first').find('a').removeClass('ui-state-active');
            $td.children('a').addClass('ui-state-active');
            inst.hours = newHours;

            // added for onMinuteShow callback
            var onMinuteShow = this._get(inst, 'onMinuteShow');
            if (onMinuteShow) {
                // this will trigger a callback on selected hour to make sure selected minute is allowed. 
                this._updateMinuteDisplay(inst);
            }

            this._updateSelectedValue(inst);

            inst._hoursClicked = true;
            if ((inst._minutesClicked) || (fromDoubleClick) || (showMinutes == false)) {
                $.timepicker._hideTimepicker();
            }
            // return false because if used inline, prevent the url to change to a hashtag
            return false;
        },

        selectMinutes: function (event) {
            var $td = $(event.currentTarget),
                id = $td.attr("data-timepicker-instance-id"),
                newMinutes = $td.attr("data-minute"),
                fromDoubleClick = event.data.fromDoubleClick,
                $target = $(id),
                inst = this._getInst($target[0]),
                showHours = (this._get(inst, 'showHours') == true);

            // don't select if disabled
            if ( $.timepicker._isDisabledTimepicker($target.attr('id')) ) { return false }

            $td.parents('.ui-timepicker-minutes:first').find('a').removeClass('ui-state-active');
            $td.children('a').addClass('ui-state-active');

            inst.minutes = newMinutes;
            this._updateSelectedValue(inst);

            inst._minutesClicked = true;
            if ((inst._hoursClicked) || (fromDoubleClick) || (showHours == false)) {
                $.timepicker._hideTimepicker();
                // return false because if used inline, prevent the url to change to a hashtag
                return false;
            }

            // return false because if used inline, prevent the url to change to a hashtag
            return false;
        },

        _updateSelectedValue: function (inst) {
            var newTime = this._getParsedTime(inst);
            if (inst.input) {
                inst.input.val(newTime);
                inst.input.trigger('change');
            }
            var onSelect = this._get(inst, 'onSelect');
            if (onSelect) { onSelect.apply((inst.input ? inst.input[0] : null), [newTime, inst]); } // trigger custom callback
            this._updateAlternate(inst, newTime);
            return newTime;
        },
        
        /* this function process selected time and return it parsed according to instance options */
        _getParsedTime: function(inst) {

            if (inst.hours == -1 && inst.minutes == -1) {
                return '';
            }

            if ((inst.hours < 0) || (inst.hours > 23)) { inst.hours = 12; }
            if ((inst.minutes < 0) || (inst.minutes > 59)) { inst.minutes = 0; }

            var period = "",
                showPeriod = (this._get(inst, 'showPeriod') == true),
                showLeadingZero = (this._get(inst, 'showLeadingZero') == true),
                showHours = (this._get(inst, 'showHours') == true),
                showMinutes = (this._get(inst, 'showMinutes') == true),
                optionalMinutes = (this._get(inst, 'optionalMinutes') == true),
                amPmText = this._get(inst, 'amPmText'),
                selectedHours = inst.hours ? inst.hours : 0,
                selectedMinutes = inst.minutes ? inst.minutes : 0,
                displayHours = selectedHours ? selectedHours : 0,
                parsedTime = '';

            if (showPeriod) { 
                if (inst.hours == 0) {
                    displayHours = 12;
                }
                if (inst.hours < 12) {
                    period = amPmText[0];
                }
                else {
                    period = amPmText[1];
                    if (displayHours > 12) {
                        displayHours -= 12;
                    }
                }
            }

            var h = displayHours.toString();
            if (showLeadingZero && (displayHours < 10)) { h = '0' + h; }

            var m = selectedMinutes.toString();
            if (selectedMinutes < 10) { m = '0' + m; }

            if (showHours) {
                parsedTime += h;
            }
            if (showHours && showMinutes && (!optionalMinutes || m != 0)) {
                parsedTime += this._get(inst, 'timeSeparator');
            }
            if (showMinutes && (!optionalMinutes || m != 0)) {
                parsedTime += m;
            }
            if (showHours) {
                if (period.length > 0) { parsedTime += this._get(inst, 'periodSeparator') + period; }
            }
            
            return parsedTime;
        },
        
        /* Update any alternate field to synchronise with the main field. */
        _updateAlternate: function(inst, newTime) {
            var altField = this._get(inst, 'altField');
            if (altField) { // update alternate field too
                $(altField).each(function(i,e) {
                    $(e).val(newTime);
                });
            }
        },

        /* This might look unused but it's called by the $.fn.timepicker function with param getTime */
        /* added v 0.2.3 - gitHub issue #5 - Thanks edanuff */
        _getTimeTimepicker : function(input) {
            var inst = this._getInst(input);
            return this._getParsedTime(inst);
        },
        _getHourTimepicker: function(input) {
            var inst = this._getInst(input);
            if ( inst == undefined) { return -1; }
            return inst.hours;
        },
        _getMinuteTimepicker: function(input) {
            var inst= this._getInst(input);
            if ( inst == undefined) { return -1; }
            return inst.minutes;
        }

    });



    /* Invoke the timepicker functionality.
    @param  options  string - a command, optionally followed by additional parameters or
    Object - settings for attaching new timepicker functionality
    @return  jQuery object */
    $.fn.timepicker = function (options) {

        /* Initialise the time picker. */
        if (!$.timepicker.initialized) {
            $(document).mousedown($.timepicker._checkExternalClick).
			find('body').append($.timepicker.tpDiv);
            $.timepicker.initialized = true;
        }

        var otherArgs = Array.prototype.slice.call(arguments, 1);
        if (typeof options == 'string' && (options == 'getTime' || options == 'getHour' || options == 'getMinute' ))
            return $.timepicker['_' + options + 'Timepicker'].
			    apply($.timepicker, [this[0]].concat(otherArgs));
        if (options == 'option' && arguments.length == 2 && typeof arguments[1] == 'string')
            return $.timepicker['_' + options + 'Timepicker'].
                apply($.timepicker, [this[0]].concat(otherArgs));
        return this.each(function () {
            typeof options == 'string' ?
			$.timepicker['_' + options + 'Timepicker'].
				apply($.timepicker, [this].concat(otherArgs)) :
			$.timepicker._attachTimepicker(this, options);
        });
    };

    /* jQuery extend now ignores nulls! */
    function extendRemove(target, props) {
        $.extend(target, props);
        for (var name in props)
            if (props[name] == null || props[name] == undefined)
                target[name] = props[name];
        return target;
    };

    $.timepicker = new Timepicker(); // singleton instance
    $.timepicker.initialized = false;
    $.timepicker.uuid = new Date().getTime();
    $.timepicker.version = "0.2.9";

    // Workaround for #4055
    // Add another global to avoid noConflict issues with inline event handlers
    window['TP_jQuery_' + tpuuid] = $;

})(jQuery);
/**
 * jQuery Validation Plugin 1.9.0
 *
 * http://bassistance.de/jquery-plugins/jquery-plugin-validation/
 * http://docs.jquery.com/Plugins/Validation
 *
 * Copyright (c) 2006 - 2011 Jörn Zaefferer
 *
 * Dual licensed under the MIT and GPL licenses:
 *   http://www.opensource.org/licenses/mit-license.php
 *   http://www.gnu.org/licenses/gpl.html
 */

(function($) {

$.extend($.fn, {
	// http://docs.jquery.com/Plugins/Validation/validate
	validate: function( options ) {

		// if nothing is selected, return nothing; can't chain anyway
		if (!this.length) {
			options && options.debug && window.console && console.warn( "nothing selected, can't validate, returning nothing" );
			return;
		}

		// check if a validator for this form was already created
		var validator = $.data(this[0], 'validator');
		if ( validator ) {
			return validator;
		}

		// Add novalidate tag if HTML5.
		this.attr('novalidate', 'novalidate');

		validator = new $.validator( options, this[0] );
		$.data(this[0], 'validator', validator);

		if ( validator.settings.onsubmit ) {

			var inputsAndButtons = this.find("input, button");

			// allow suppresing validation by adding a cancel class to the submit button
			inputsAndButtons.filter(".cancel").click(function () {
				validator.cancelSubmit = true;
			});

			// when a submitHandler is used, capture the submitting button
			if (validator.settings.submitHandler) {
				inputsAndButtons.filter(":submit").click(function () {
					validator.submitButton = this;
				});
			}

			// validate the form on submit
			this.submit( function( event ) {
				if ( validator.settings.debug )
					// prevent form submit to be able to see console output
					event.preventDefault();

				function handle() {
					if ( validator.settings.submitHandler ) {
						if (validator.submitButton) {
							// insert a hidden input as a replacement for the missing submit button
							var hidden = $("<input type='hidden'/>").attr("name", validator.submitButton.name).val(validator.submitButton.value).appendTo(validator.currentForm);
						}
						validator.settings.submitHandler.call( validator, validator.currentForm );
						if (validator.submitButton) {
							// and clean up afterwards; thanks to no-block-scope, hidden can be referenced
							hidden.remove();
						}
						return false;
					}
					return true;
				}

				// prevent submit for invalid forms or custom submit handlers
				if ( validator.cancelSubmit ) {
					validator.cancelSubmit = false;
					return handle();
				}
				if ( validator.form() ) {
					if ( validator.pendingRequest ) {
						validator.formSubmitted = true;
						return false;
					}
					return handle();
				} else {
					validator.focusInvalid();
					return false;
				}
			});
		}

		return validator;
	},
	// http://docs.jquery.com/Plugins/Validation/valid
	valid: function() {
        if ( $(this[0]).is('form')) {
            return this.validate().form();
        } else {
            var valid = true;
            var validator = $(this[0].form).validate();
            this.each(function() {
				valid &= validator.element(this);
            });
            return valid;
        }
    },
	// attributes: space seperated list of attributes to retrieve and remove
	removeAttrs: function(attributes) {
		var result = {},
			$element = this;
		$.each(attributes.split(/\s/), function(index, value) {
			result[value] = $element.attr(value);
			$element.removeAttr(value);
		});
		return result;
	},
	// http://docs.jquery.com/Plugins/Validation/rules
	rules: function(command, argument) {
		var element = this[0];

		if (command) {
			var settings = $.data(element.form, 'validator').settings;
			var staticRules = settings.rules;
			var existingRules = $.validator.staticRules(element);
			switch(command) {
			case "add":
				$.extend(existingRules, $.validator.normalizeRule(argument));
				staticRules[element.name] = existingRules;
				if (argument.messages)
					settings.messages[element.name] = $.extend( settings.messages[element.name], argument.messages );
				break;
			case "remove":
				if (!argument) {
					delete staticRules[element.name];
					return existingRules;
				}
				var filtered = {};
				$.each(argument.split(/\s/), function(index, method) {
					filtered[method] = existingRules[method];
					delete existingRules[method];
				});
				return filtered;
			}
		}

		var data = $.validator.normalizeRules(
		$.extend(
			{},
			$.validator.metadataRules(element),
			$.validator.classRules(element),
			$.validator.attributeRules(element),
			$.validator.staticRules(element)
		), element);

		// make sure required is at front
		if (data.required) {
			var param = data.required;
			delete data.required;
			data = $.extend({required: param}, data);
		}

		return data;
	}
});

// Custom selectors
$.extend($.expr[":"], {
	// http://docs.jquery.com/Plugins/Validation/blank
	blank: function(a) {return !$.trim("" + a.value);},
	// http://docs.jquery.com/Plugins/Validation/filled
	filled: function(a) {return !!$.trim("" + a.value);},
	// http://docs.jquery.com/Plugins/Validation/unchecked
	unchecked: function(a) {return !a.checked;}
});

// constructor for validator
$.validator = function( options, form ) {
	this.settings = $.extend( true, {}, $.validator.defaults, options );
	this.currentForm = form;
	this.init();
};

$.validator.format = function(source, params) {
	if ( arguments.length == 1 )
		return function() {
			var args = $.makeArray(arguments);
			args.unshift(source);
			return $.validator.format.apply( this, args );
		};
	if ( arguments.length > 2 && params.constructor != Array  ) {
		params = $.makeArray(arguments).slice(1);
	}
	if ( params.constructor != Array ) {
		params = [ params ];
	}
	$.each(params, function(i, n) {
		source = source.replace(new RegExp("\\{" + i + "\\}", "g"), n);
	});
	return source;
};

$.extend($.validator, {

	defaults: {
		messages: {},
		groups: {},
		rules: {},
		errorClass: "error",
		validClass: "valid",
		errorElement: "label",
		focusInvalid: true,
		errorContainer: $( [] ),
		errorLabelContainer: $( [] ),
		onsubmit: true,
		ignore: ":hidden",
		ignoreTitle: false,
		onfocusin: function(element, event) {
			this.lastActive = element;

			// hide error label and remove error class on focus if enabled
			if ( this.settings.focusCleanup && !this.blockFocusCleanup ) {
				this.settings.unhighlight && this.settings.unhighlight.call( this, element, this.settings.errorClass, this.settings.validClass );
				this.addWrapper(this.errorsFor(element)).hide();
			}
		},
		onfocusout: function(element, event) {
			if ( !this.checkable(element) && (element.name in this.submitted || !this.optional(element)) ) {
				this.element(element);
			}
		},
		onkeyup: function(element, event) {
			if ( element.name in this.submitted || element == this.lastElement ) {
				this.element(element);
			}
		},
		onclick: function(element, event) {
			// click on selects, radiobuttons and checkboxes
			if ( element.name in this.submitted )
				this.element(element);
			// or option elements, check parent select in that case
			else if (element.parentNode.name in this.submitted)
				this.element(element.parentNode);
		},
		highlight: function(element, errorClass, validClass) {
			if (element.type === 'radio') {
				this.findByName(element.name).addClass(errorClass).removeClass(validClass);
			} else {
				$(element).addClass(errorClass).removeClass(validClass);
			}
		},
		unhighlight: function(element, errorClass, validClass) {
			if (element.type === 'radio') {
				this.findByName(element.name).removeClass(errorClass).addClass(validClass);
			} else {
				$(element).removeClass(errorClass).addClass(validClass);
			}
		}
	},

	// http://docs.jquery.com/Plugins/Validation/Validator/setDefaults
	setDefaults: function(settings) {
		$.extend( $.validator.defaults, settings );
	},

	messages: {
		required: "This field is required.",
		remote: "Please fix this field.",
		email: "Please enter a valid email address.",
		url: "Please enter a valid URL.",
		date: "Please enter a valid date.",
		dateISO: "Please enter a valid date (ISO).",
		number: "Please enter a valid number.",
		digits: "Please enter only digits.",
		creditcard: "Please enter a valid credit card number.",
		equalTo: "Please enter the same value again.",
		accept: "Please enter a value with a valid extension.",
		maxlength: $.validator.format("Please enter no more than {0} characters."),
		minlength: $.validator.format("Please enter at least {0} characters."),
		rangelength: $.validator.format("Please enter a value between {0} and {1} characters long."),
		range: $.validator.format("Please enter a value between {0} and {1}."),
		max: $.validator.format("Please enter a value less than or equal to {0}."),
		min: $.validator.format("Please enter a value greater than or equal to {0}.")
	},

	autoCreateRanges: false,

	prototype: {

		init: function() {
			this.labelContainer = $(this.settings.errorLabelContainer);
			this.errorContext = this.labelContainer.length && this.labelContainer || $(this.currentForm);
			this.containers = $(this.settings.errorContainer).add( this.settings.errorLabelContainer );
			this.submitted = {};
			this.valueCache = {};
			this.pendingRequest = 0;
			this.pending = {};
			this.invalid = {};
			this.reset();

			var groups = (this.groups = {});
			$.each(this.settings.groups, function(key, value) {
				$.each(value.split(/\s/), function(index, name) {
					groups[name] = key;
				});
			});
			var rules = this.settings.rules;
			$.each(rules, function(key, value) {
				rules[key] = $.validator.normalizeRule(value);
			});

			function delegate(event) {
				var validator = $.data(this[0].form, "validator"),
					eventType = "on" + event.type.replace(/^validate/, "");
				validator.settings[eventType] && validator.settings[eventType].call(validator, this[0], event);
			}
			$(this.currentForm)
			       .validateDelegate("[type='text'], [type='password'], [type='file'], select, textarea, " +
						"[type='number'], [type='search'] ,[type='tel'], [type='url'], " +
						"[type='email'], [type='datetime'], [type='date'], [type='month'], " +
						"[type='week'], [type='time'], [type='datetime-local'], " +
						"[type='range'], [type='color'] ",
						"focusin focusout keyup", delegate)
				.validateDelegate("[type='radio'], [type='checkbox'], select, option", "click", delegate);

			if (this.settings.invalidHandler)
				$(this.currentForm).bind("invalid-form.validate", this.settings.invalidHandler);
		},

		// http://docs.jquery.com/Plugins/Validation/Validator/form
		form: function() {
			this.checkForm();
			$.extend(this.submitted, this.errorMap);
			this.invalid = $.extend({}, this.errorMap);
			if (!this.valid())
				$(this.currentForm).triggerHandler("invalid-form", [this]);
			this.showErrors();
			return this.valid();
		},

		checkForm: function() {
			this.prepareForm();
			for ( var i = 0, elements = (this.currentElements = this.elements()); elements[i]; i++ ) {
				this.check( elements[i] );
			}
			return this.valid();
		},

		// http://docs.jquery.com/Plugins/Validation/Validator/element
		element: function( element ) {
			element = this.validationTargetFor( this.clean( element ) );
			this.lastElement = element;
			this.prepareElement( element );
			this.currentElements = $(element);
			var result = this.check( element );
			if ( result ) {
				delete this.invalid[element.name];
			} else {
				this.invalid[element.name] = true;
			}
			if ( !this.numberOfInvalids() ) {
				// Hide error containers on last error
				this.toHide = this.toHide.add( this.containers );
			}
			this.showErrors();
			return result;
		},

		// http://docs.jquery.com/Plugins/Validation/Validator/showErrors
		showErrors: function(errors) {
			if(errors) {
				// add items to error list and map
				$.extend( this.errorMap, errors );
				this.errorList = [];
				for ( var name in errors ) {
					this.errorList.push({
						message: errors[name],
						element: this.findByName(name)[0]
					});
				}
				// remove items from success list
				this.successList = $.grep( this.successList, function(element) {
					return !(element.name in errors);
				});
			}
			this.settings.showErrors
				? this.settings.showErrors.call( this, this.errorMap, this.errorList )
				: this.defaultShowErrors();
		},

		// http://docs.jquery.com/Plugins/Validation/Validator/resetForm
		resetForm: function() {
			if ( $.fn.resetForm )
				$( this.currentForm ).resetForm();
			this.submitted = {};
			this.lastElement = null;
			this.prepareForm();
			this.hideErrors();
			this.elements().removeClass( this.settings.errorClass );
		},

		numberOfInvalids: function() {
			return this.objectLength(this.invalid);
		},

		objectLength: function( obj ) {
			var count = 0;
			for ( var i in obj )
				count++;
			return count;
		},

		hideErrors: function() {
			this.addWrapper( this.toHide ).hide();
		},

		valid: function() {
			return this.size() == 0;
		},

		size: function() {
			return this.errorList.length;
		},

		focusInvalid: function() {
			if( this.settings.focusInvalid ) {
				try {
					$(this.findLastActive() || this.errorList.length && this.errorList[0].element || [])
					.filter(":visible")
					.focus()
					// manually trigger focusin event; without it, focusin handler isn't called, findLastActive won't have anything to find
					.trigger("focusin");
				} catch(e) {
					// ignore IE throwing errors when focusing hidden elements
				}
			}
		},

		findLastActive: function() {
			var lastActive = this.lastActive;
			return lastActive && $.grep(this.errorList, function(n) {
				return n.element.name == lastActive.name;
			}).length == 1 && lastActive;
		},

		elements: function() {
			var validator = this,
				rulesCache = {};

			// select all valid inputs inside the form (no submit or reset buttons)
			return $(this.currentForm)
			.find("input, select, textarea")
			.not(":submit, :reset, :image, [disabled]")
			.not( this.settings.ignore )
			.filter(function() {
				!this.name && validator.settings.debug && window.console && console.error( "%o has no name assigned", this);

				// select only the first element for each name, and only those with rules specified
				if ( this.name in rulesCache || !validator.objectLength($(this).rules()) )
					return false;

				rulesCache[this.name] = true;
				return true;
			});
		},

		clean: function( selector ) {
			return $( selector )[0];
		},

		errors: function() {
			return $( this.settings.errorElement + "." + this.settings.errorClass, this.errorContext );
		},

		reset: function() {
			this.successList = [];
			this.errorList = [];
			this.errorMap = {};
			this.toShow = $([]);
			this.toHide = $([]);
			this.currentElements = $([]);
		},

		prepareForm: function() {
			this.reset();
			this.toHide = this.errors().add( this.containers );
		},

		prepareElement: function( element ) {
			this.reset();
			this.toHide = this.errorsFor(element);
		},

		check: function( element ) {
			element = this.validationTargetFor( this.clean( element ) );

			var rules = $(element).rules();
			var dependencyMismatch = false;
			for (var method in rules ) {
				var rule = { method: method, parameters: rules[method] };
				try {
					var result = $.validator.methods[method].call( this, element.value.replace(/\r/g, ""), element, rule.parameters );

					// if a method indicates that the field is optional and therefore valid,
					// don't mark it as valid when there are no other rules
					if ( result == "dependency-mismatch" ) {
						dependencyMismatch = true;
						continue;
					}
					dependencyMismatch = false;

					if ( result == "pending" ) {
						this.toHide = this.toHide.not( this.errorsFor(element) );
						return;
					}

					if( !result ) {
						this.formatAndAdd( element, rule );
						return false;
					}
				} catch(e) {
					this.settings.debug && window.console && console.log("exception occured when checking element " + element.id
						 + ", check the '" + rule.method + "' method", e);
					throw e;
				}
			}
			if (dependencyMismatch)
				return;
			if ( this.objectLength(rules) )
				this.successList.push(element);
			return true;
		},

		// return the custom message for the given element and validation method
		// specified in the element's "messages" metadata
		customMetaMessage: function(element, method) {
			if (!$.metadata)
				return;

			var meta = this.settings.meta
				? $(element).metadata()[this.settings.meta]
				: $(element).metadata();

			return meta && meta.messages && meta.messages[method];
		},

		// return the custom message for the given element name and validation method
		customMessage: function( name, method ) {
			var m = this.settings.messages[name];
			return m && (m.constructor == String
				? m
				: m[method]);
		},

		// return the first defined argument, allowing empty strings
		findDefined: function() {
			for(var i = 0; i < arguments.length; i++) {
				if (arguments[i] !== undefined)
					return arguments[i];
			}
			return undefined;
		},

		defaultMessage: function( element, method) {
			return this.findDefined(
				this.customMessage( element.name, method ),
				this.customMetaMessage( element, method ),
				// title is never undefined, so handle empty string as undefined
				!this.settings.ignoreTitle && element.title || undefined,
				$.validator.messages[method],
				"<strong>Warning: No message defined for " + element.name + "</strong>"
			);
		},

		formatAndAdd: function( element, rule ) {
			var message = this.defaultMessage( element, rule.method ),
				theregex = /\$?\{(\d+)\}/g;
			if ( typeof message == "function" ) {
				message = message.call(this, rule.parameters, element);
			} else if (theregex.test(message)) {
				message = jQuery.format(message.replace(theregex, '{$1}'), rule.parameters);
			}
			this.errorList.push({
				message: message,
				element: element
			});

			this.errorMap[element.name] = message;
			this.submitted[element.name] = message;
		},

		addWrapper: function(toToggle) {
			if ( this.settings.wrapper )
				toToggle = toToggle.add( toToggle.parent( this.settings.wrapper ) );
			return toToggle;
		},

		defaultShowErrors: function() {
			for ( var i = 0; this.errorList[i]; i++ ) {
				var error = this.errorList[i];
				this.settings.highlight && this.settings.highlight.call( this, error.element, this.settings.errorClass, this.settings.validClass );
				this.showLabel( error.element, error.message );
			}
			if( this.errorList.length ) {
				this.toShow = this.toShow.add( this.containers );
			}
			if (this.settings.success) {
				for ( var i = 0; this.successList[i]; i++ ) {
					this.showLabel( this.successList[i] );
				}
			}
			if (this.settings.unhighlight) {
				for ( var i = 0, elements = this.validElements(); elements[i]; i++ ) {
					this.settings.unhighlight.call( this, elements[i], this.settings.errorClass, this.settings.validClass );
				}
			}
			this.toHide = this.toHide.not( this.toShow );
			this.hideErrors();
			this.addWrapper( this.toShow ).show();
		},

		validElements: function() {
			return this.currentElements.not(this.invalidElements());
		},

		invalidElements: function() {
			return $(this.errorList).map(function() {
				return this.element;
			});
		},

		showLabel: function(element, message) {
			var label = this.errorsFor( element );
			if ( label.length ) {
				// refresh error/success class
				label.removeClass( this.settings.validClass ).addClass( this.settings.errorClass );

				// check if we have a generated label, replace the message then
				label.attr("generated") && label.html(message);
			} else {
				// create label
				label = $("<" + this.settings.errorElement + "/>")
					.attr({"for":  this.idOrName(element), generated: true})
					.addClass(this.settings.errorClass)
					.html(message || "");
				if ( this.settings.wrapper ) {
					// make sure the element is visible, even in IE
					// actually showing the wrapped element is handled elsewhere
					label = label.hide().show().wrap("<" + this.settings.wrapper + "/>").parent();
				}
				if ( !this.labelContainer.append(label).length )
					this.settings.errorPlacement
						? this.settings.errorPlacement(label, $(element) )
						: label.insertAfter(element);
			}
			if ( !message && this.settings.success ) {
				label.text("");
				typeof this.settings.success == "string"
					? label.addClass( this.settings.success )
					: this.settings.success( label );
			}
			this.toShow = this.toShow.add(label);
		},

		errorsFor: function(element) {
			var name = this.idOrName(element);
    		return this.errors().filter(function() {
				return $(this).attr('for') == name;
			});
		},

		idOrName: function(element) {
			return this.groups[element.name] || (this.checkable(element) ? element.name : element.id || element.name);
		},

		validationTargetFor: function(element) {
			// if radio/checkbox, validate first element in group instead
			if (this.checkable(element)) {
				element = this.findByName( element.name ).not(this.settings.ignore)[0];
			}
			return element;
		},

		checkable: function( element ) {
			return /radio|checkbox/i.test(element.type);
		},

		findByName: function( name ) {
			// select by name and filter by form for performance over form.find("[name=...]")
			var form = this.currentForm;
			return $(document.getElementsByName(name)).map(function(index, element) {
				return element.form == form && element.name == name && element  || null;
			});
		},

		getLength: function(value, element) {
			switch( element.nodeName.toLowerCase() ) {
			case 'select':
				return $("option:selected", element).length;
			case 'input':
				if( this.checkable( element) )
					return this.findByName(element.name).filter(':checked').length;
			}
			return value.length;
		},

		depend: function(param, element) {
			return this.dependTypes[typeof param]
				? this.dependTypes[typeof param](param, element)
				: true;
		},

		dependTypes: {
			"boolean": function(param, element) {
				return param;
			},
			"string": function(param, element) {
				return !!$(param, element.form).length;
			},
			"function": function(param, element) {
				return param(element);
			}
		},

		optional: function(element) {
			return !$.validator.methods.required.call(this, $.trim(element.value), element) && "dependency-mismatch";
		},

		startRequest: function(element) {
			if (!this.pending[element.name]) {
				this.pendingRequest++;
				this.pending[element.name] = true;
			}
		},

		stopRequest: function(element, valid) {
			this.pendingRequest--;
			// sometimes synchronization fails, make sure pendingRequest is never < 0
			if (this.pendingRequest < 0)
				this.pendingRequest = 0;
			delete this.pending[element.name];
			if ( valid && this.pendingRequest == 0 && this.formSubmitted && this.form() ) {
				$(this.currentForm).submit();
				this.formSubmitted = false;
			} else if (!valid && this.pendingRequest == 0 && this.formSubmitted) {
				$(this.currentForm).triggerHandler("invalid-form", [this]);
				this.formSubmitted = false;
			}
		},

		previousValue: function(element) {
			return $.data(element, "previousValue") || $.data(element, "previousValue", {
				old: null,
				valid: true,
				message: this.defaultMessage( element, "remote" )
			});
		}

	},

	classRuleSettings: {
		required: {required: true},
		email: {email: true},
		url: {url: true},
		date: {date: true},
		dateISO: {dateISO: true},
		dateDE: {dateDE: true},
		number: {number: true},
		numberDE: {numberDE: true},
		digits: {digits: true},
		creditcard: {creditcard: true}
	},

	addClassRules: function(className, rules) {
		className.constructor == String ?
			this.classRuleSettings[className] = rules :
			$.extend(this.classRuleSettings, className);
	},

	classRules: function(element) {
		var rules = {};
		var classes = $(element).attr('class');
		classes && $.each(classes.split(' '), function() {
			if (this in $.validator.classRuleSettings) {
				$.extend(rules, $.validator.classRuleSettings[this]);
			}
		});
		return rules;
	},

	attributeRules: function(element) {
		var rules = {};
		var $element = $(element);

		for (var method in $.validator.methods) {
			var value;
			// If .prop exists (jQuery >= 1.6), use it to get true/false for required
			if (method === 'required' && typeof $.fn.prop === 'function') {
				value = $element.prop(method);
			} else {
				value = $element.attr(method);
			}
			if (value) {
				rules[method] = value;
			} else if ($element[0].getAttribute("type") === method) {
				rules[method] = true;
			}
		}

		// maxlength may be returned as -1, 2147483647 (IE) and 524288 (safari) for text inputs
		if (rules.maxlength && /-1|2147483647|524288/.test(rules.maxlength)) {
			delete rules.maxlength;
		}

		return rules;
	},

	metadataRules: function(element) {
		if (!$.metadata) return {};

		var meta = $.data(element.form, 'validator').settings.meta;
		return meta ?
			$(element).metadata()[meta] :
			$(element).metadata();
	},

	staticRules: function(element) {
		var rules = {};
		var validator = $.data(element.form, 'validator');
		if (validator.settings.rules) {
			rules = $.validator.normalizeRule(validator.settings.rules[element.name]) || {};
		}
		return rules;
	},

	normalizeRules: function(rules, element) {
		// handle dependency check
		$.each(rules, function(prop, val) {
			// ignore rule when param is explicitly false, eg. required:false
			if (val === false) {
				delete rules[prop];
				return;
			}
			if (val.param || val.depends) {
				var keepRule = true;
				switch (typeof val.depends) {
					case "string":
						keepRule = !!$(val.depends, element.form).length;
						break;
					case "function":
						keepRule = val.depends.call(element, element);
						break;
				}
				if (keepRule) {
					rules[prop] = val.param !== undefined ? val.param : true;
				} else {
					delete rules[prop];
				}
			}
		});

		// evaluate parameters
		$.each(rules, function(rule, parameter) {
			rules[rule] = $.isFunction(parameter) ? parameter(element) : parameter;
		});

		// clean number parameters
		$.each(['minlength', 'maxlength', 'min', 'max'], function() {
			if (rules[this]) {
				rules[this] = Number(rules[this]);
			}
		});
		$.each(['rangelength', 'range'], function() {
			if (rules[this]) {
				rules[this] = [Number(rules[this][0]), Number(rules[this][1])];
			}
		});

		if ($.validator.autoCreateRanges) {
			// auto-create ranges
			if (rules.min && rules.max) {
				rules.range = [rules.min, rules.max];
				delete rules.min;
				delete rules.max;
			}
			if (rules.minlength && rules.maxlength) {
				rules.rangelength = [rules.minlength, rules.maxlength];
				delete rules.minlength;
				delete rules.maxlength;
			}
		}

		// To support custom messages in metadata ignore rule methods titled "messages"
		if (rules.messages) {
			delete rules.messages;
		}

		return rules;
	},

	// Converts a simple string to a {string: true} rule, e.g., "required" to {required:true}
	normalizeRule: function(data) {
		if( typeof data == "string" ) {
			var transformed = {};
			$.each(data.split(/\s/), function() {
				transformed[this] = true;
			});
			data = transformed;
		}
		return data;
	},

	// http://docs.jquery.com/Plugins/Validation/Validator/addMethod
	addMethod: function(name, method, message) {
		$.validator.methods[name] = method;
		$.validator.messages[name] = message != undefined ? message : $.validator.messages[name];
		if (method.length < 3) {
			$.validator.addClassRules(name, $.validator.normalizeRule(name));
		}
	},

	methods: {

		// http://docs.jquery.com/Plugins/Validation/Methods/required
		required: function(value, element, param) {
			// check if dependency is met
			if ( !this.depend(param, element) )
				return "dependency-mismatch";
			switch( element.nodeName.toLowerCase() ) {
			case 'select':
				// could be an array for select-multiple or a string, both are fine this way
				var val = $(element).val();
				return val && val.length > 0;
			case 'input':
				if ( this.checkable(element) )
					return this.getLength(value, element) > 0;
			default:
				return $.trim(value).length > 0;
			}
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/remote
		remote: function(value, element, param) {
			if ( this.optional(element) )
				return "dependency-mismatch";

			var previous = this.previousValue(element);
			if (!this.settings.messages[element.name] )
				this.settings.messages[element.name] = {};
			previous.originalMessage = this.settings.messages[element.name].remote;
			this.settings.messages[element.name].remote = previous.message;

			param = typeof param == "string" && {url:param} || param;

			if ( this.pending[element.name] ) {
				return "pending";
			}
			if ( previous.old === value ) {
				return previous.valid;
			}

			previous.old = value;
			var validator = this;
			this.startRequest(element);
			var data = {};
			data[element.name] = value;
			$.ajax($.extend(true, {
				url: param,
				mode: "abort",
				port: "validate" + element.name,
				dataType: "json",
				data: data,
				success: function(response) {
					validator.settings.messages[element.name].remote = previous.originalMessage;
					var valid = response === true;
					if ( valid ) {
						var submitted = validator.formSubmitted;
						validator.prepareElement(element);
						validator.formSubmitted = submitted;
						validator.successList.push(element);
						validator.showErrors();
					} else {
						var errors = {};
						var message = response || validator.defaultMessage( element, "remote" );
						errors[element.name] = previous.message = $.isFunction(message) ? message(value) : message;
						validator.showErrors(errors);
					}
					previous.valid = valid;
					validator.stopRequest(element, valid);
				}
			}, param));
			return "pending";
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/minlength
		minlength: function(value, element, param) {
			return this.optional(element) || this.getLength($.trim(value), element) >= param;
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/maxlength
		maxlength: function(value, element, param) {
			return this.optional(element) || this.getLength($.trim(value), element) <= param;
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/rangelength
		rangelength: function(value, element, param) {
			var length = this.getLength($.trim(value), element);
			return this.optional(element) || ( length >= param[0] && length <= param[1] );
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/min
		min: function( value, element, param ) {
			return this.optional(element) || value >= param;
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/max
		max: function( value, element, param ) {
			return this.optional(element) || value <= param;
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/range
		range: function( value, element, param ) {
			return this.optional(element) || ( value >= param[0] && value <= param[1] );
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/email
		email: function(value, element) {
			// contributed by Scott Gonzalez: http://projects.scottsplayground.com/email_address_validation/
			return this.optional(element) || /^((([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+(\.([a-z]|\d|[!#\$%&'\*\+\-\/=\?\^_`{\|}~]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])+)*)|((\x22)((((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(([\x01-\x08\x0b\x0c\x0e-\x1f\x7f]|\x21|[\x23-\x5b]|[\x5d-\x7e]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(\\([\x01-\x09\x0b\x0c\x0d-\x7f]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]))))*(((\x20|\x09)*(\x0d\x0a))?(\x20|\x09)+)?(\x22)))@((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))$/i.test(value);
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/url
		url: function(value, element) {
			// contributed by Scott Gonzalez: http://projects.scottsplayground.com/iri/
			return this.optional(element) || /^(https?|ftp):\/\/(((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:)*@)?(((\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5]))|((([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|\d|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.)+(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])*([a-z]|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])))\.?)(:\d*)?)(\/((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)+(\/(([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)*)*)?)?(\?((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|[\uE000-\uF8FF]|\/|\?)*)?(\#((([a-z]|\d|-|\.|_|~|[\u00A0-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF])|(%[\da-f]{2})|[!\$&'\(\)\*\+,;=]|:|@)|\/|\?)*)?$/i.test(value);
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/date
		date: function(value, element) {
			return this.optional(element) || !/Invalid|NaN/.test(new Date(value));
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/dateISO
		dateISO: function(value, element) {
			return this.optional(element) || /^\d{4}[\/-]\d{1,2}[\/-]\d{1,2}$/.test(value);
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/number
		number: function(value, element) {
			return this.optional(element) || /^-?(?:\d+|\d{1,3}(?:,\d{3})+)(?:\.\d+)?$/.test(value);
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/digits
		digits: function(value, element) {
			return this.optional(element) || /^\d+$/.test(value);
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/creditcard
		// based on http://en.wikipedia.org/wiki/Luhn
		creditcard: function(value, element) {
			if ( this.optional(element) )
				return "dependency-mismatch";
			// accept only spaces, digits and dashes
			if (/[^0-9 -]+/.test(value))
				return false;
			var nCheck = 0,
				nDigit = 0,
				bEven = false;

			value = value.replace(/\D/g, "");

			for (var n = value.length - 1; n >= 0; n--) {
				var cDigit = value.charAt(n);
				var nDigit = parseInt(cDigit, 10);
				if (bEven) {
					if ((nDigit *= 2) > 9)
						nDigit -= 9;
				}
				nCheck += nDigit;
				bEven = !bEven;
			}

			return (nCheck % 10) == 0;
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/accept
		accept: function(value, element, param) {
			param = typeof param == "string" ? param.replace(/,/g, '|') : "png|jpe?g|gif";
			return this.optional(element) || value.match(new RegExp(".(" + param + ")$", "i"));
		},

		// http://docs.jquery.com/Plugins/Validation/Methods/equalTo
		equalTo: function(value, element, param) {
			// bind to the blur event of the target in order to revalidate whenever the target field is updated
			// TODO find a way to bind the event just once, avoiding the unbind-rebind overhead
			var target = $(param).unbind(".validate-equalTo").bind("blur.validate-equalTo", function() {
				$(element).valid();
			});
			return value == target.val();
		}

	}

});

// deprecated, use $.validator.format instead
$.format = $.validator.format;

})(jQuery);

// ajax mode: abort
// usage: $.ajax({ mode: "abort"[, port: "uniqueport"]});
// if mode:"abort" is used, the previous request on that port (port can be undefined) is aborted via XMLHttpRequest.abort()
;(function($) {
	var pendingRequests = {};
	// Use a prefilter if available (1.5+)
	if ( $.ajaxPrefilter ) {
		$.ajaxPrefilter(function(settings, _, xhr) {
			var port = settings.port;
			if (settings.mode == "abort") {
				if ( pendingRequests[port] ) {
					pendingRequests[port].abort();
				}
				pendingRequests[port] = xhr;
			}
		});
	} else {
		// Proxy ajax
		var ajax = $.ajax;
		$.ajax = function(settings) {
			var mode = ( "mode" in settings ? settings : $.ajaxSettings ).mode,
				port = ( "port" in settings ? settings : $.ajaxSettings ).port;
			if (mode == "abort") {
				if ( pendingRequests[port] ) {
					pendingRequests[port].abort();
				}
				return (pendingRequests[port] = ajax.apply(this, arguments));
			}
			return ajax.apply(this, arguments);
		};
	}
})(jQuery);

// provides cross-browser focusin and focusout events
// IE has native support, in other browsers, use event caputuring (neither bubbles)

// provides delegate(type: String, delegate: Selector, handler: Callback) plugin for easier event delegation
// handler is only called when $(event.target).is(delegate), in the scope of the jquery-object for event.target
;(function($) {
	// only implement if not provided by jQuery core (since 1.4)
	// TODO verify if jQuery 1.4's implementation is compatible with older jQuery special-event APIs
	if (!jQuery.event.special.focusin && !jQuery.event.special.focusout && document.addEventListener) {
		$.each({
			focus: 'focusin',
			blur: 'focusout'
		}, function( original, fix ){
			$.event.special[fix] = {
				setup:function() {
					this.addEventListener( original, handler, true );
				},
				teardown:function() {
					this.removeEventListener( original, handler, true );
				},
				handler: function(e) {
					arguments[0] = $.event.fix(e);
					arguments[0].type = fix;
					return $.event.handle.apply(this, arguments);
				}
			};
			function handler(e) {
				e = $.event.fix(e);
				e.type = fix;
				return $.event.handle.call(this, e);
			}
		});
	};
	$.extend($.fn, {
		validateDelegate: function(delegate, type, handler) {
			return this.bind(type, function(event) {
				var target = $(event.target);
				if (target.is(delegate)) {
					return handler.apply(target, arguments);
				}
			});
		}
	});
})(jQuery);
/*!
	PURE Unobtrusive Rendering Engine for HTML

	Licensed under the MIT licenses.
	More information at: http://www.opensource.org

	Copyright (c) 2012 Michael Cvilic - BeeBole.com

	Thanks to Rog Peppe for the functional JS jump
	revision: 2.72
*/

var $p;
var pure = $p = function(){
	var sel = arguments[0],
		ctxt = false;

	if(typeof sel === 'string'){
		ctxt = arguments[1] || false;
	}else if(sel && !sel[0] && !sel.length){
		sel = [sel];
	}
	return $p.core(sel, ctxt);
};

$p.core = function(sel, ctxt, plugins){
	//get an instance of the plugins
	var templates = [];
	plugins = plugins || getPlugins();

	//search for the template node(s)
	switch(typeof sel){
		case 'string':
			templates = plugins.find(ctxt || document, sel);
			if(templates.length === 0) {
				error('The template "' + sel + '" was not found');
			}
		break;
		case 'undefined':
			error('The root of the template is undefined, check your selector');
		break;
		default:
			templates = sel;
	}

	for(var i = 0, ii = templates.length; i < ii; i++){
		plugins[i] = templates[i];
	}
	plugins.length = ii;

	// set the signature string that will be replaced at render time
	var Sig = '_s' + Math.floor( Math.random() * 1000000 ) + '_',
		// another signature to prepend to attributes and avoid checks: style, height, on[events]...
		attPfx = '_a' + Math.floor( Math.random() * 1000000 ) + '_',
		// rx to parse selectors, e.g. "+tr.foo[class]"
		selRx = /^(\+)?([^\@\+]+)?\@?([^\+]+)?(\+)?$/,
		// set automatically attributes for some tags
		autoAttr = {
			IMG:'src',
			INPUT:'value'
		},
		// check if the argument is an array - thanks salty-horse (Ori Avtalion)
		isArray = Array.isArray ?
			function(o) {
				return Array.isArray(o);
			} :
			function(o) {
				return Object.prototype.toString.call(o) === "[object Array]";
			};

	/* * * * * * * * * * * * * * * * * * * * * * * * * *
		core functions
	 * * * * * * * * * * * * * * * * * * * * * * * * * */


	// error utility
	function error(e){
		if(typeof console !== 'undefined'){
			console.log(e);
			//debugger;
		}
		throw('pure error: ' + e);
	}

	//return a new instance of plugins
	function getPlugins(){
		var plugins = $p.plugins,
			f = function(){};
		f.prototype = plugins;

		// do not overwrite functions if external definition
		f.prototype.compile    = plugins.compile || compile;
		f.prototype.render     = plugins.render || render;
		f.prototype.autoRender = plugins.autoRender || autoRender;
		f.prototype.find       = plugins.find || find;

		// give the compiler and the error handling to the plugin context
		f.prototype._compiler  = compiler;
		f.prototype._error     = error;

		return new f();
	}

	// returns the outer HTML of a node
	function outerHTML(node){
		// if IE, Chrome take the internal method otherwise build one
		return node.outerHTML || (
			function(n){
			var div = document.createElement('div'), h;
			div.appendChild( n.cloneNode(true) );
				h = div.innerHTML;
				div = null;
				return h;
			})(node);
	}

	// returns the string generator function
	function wrapquote(qfn, f){
		return function(ctxt){
			return qfn('' + f.call(ctxt.item || ctxt.context, ctxt));
		};
	}

	// default find using querySelector when available on the browser
	function find(n, sel){
		if(typeof n === 'string'){
			sel = n;
			n = false;
		}
		if(typeof document.querySelectorAll !== 'undefined'){
			return (n||document).querySelectorAll( sel );
		}else{
			return error('You can test PURE standalone with: iPhone, FF3.5+, Safari4+ and IE8+\n\nTo run PURE on your browser, you need a JS library/framework with a CSS selector engine');
		}
	}

	// create a function that concatenates constant string
	// sections (given in parts) and the results of called
	// functions to fill in the gaps between parts (fns).
	// fns[n] fills in the gap between parts[n-1] and parts[n];
	// fns[0] is unused.
	// this is the inner template evaluation loop.
	function concatenator(parts, fns){
		return function(ctxt){
			var strs = [ parts[ 0 ] ],
				n = parts.length,
				fnVal, pVal, attLine, pos;

			for(var i = 1; i < n; i++){
				fnVal = fns[i].call( this, ctxt );
				pVal = parts[i];

				// if the value is empty and attribute, remove it
				if(fnVal === ''){
					attLine = strs[ strs.length - 1 ];
					if( ( pos = attLine.search( /[^\s]+=\"?$/ ) ) > -1){
						strs[ strs.length - 1 ] = attLine.substring( 0, pos );
						pVal = pVal.substr( 1 );
					}
				}

				strs[ strs.length ] = fnVal;
				strs[ strs.length ] = pVal;
			}
			return strs.join('');
		};
	}

	// parse and check the loop directive
	function parseloopspec(p){
		var m = p.match( /^(\w+)\s*<-\s*(\S+)?$/ );
		if(m === null){
			error('bad loop spec: "' + p + '"');
		}
		if(m[1] === 'item'){
			error('"item<-..." is a reserved word for the current running iteration.\n\nPlease choose another name for your loop.');
		}
		if( !m[2] || (m[2] && (/context/i).test(m[2]))){ //undefined or space(IE)
			m[2] = function(ctxt){return ctxt.context;};
		}
		return {name: m[1], sel: m[2]};
	}

	// parse a data selector and return a function that
	// can traverse the data accordingly, given a context.
	function dataselectfn (sel){
		if( typeof(sel) === 'function' ){
			//handle false values in function directive
			return function ( ctxt ){
				var r = sel.call( ctxt.item || ctxt.context || ctxt, ctxt ); 
				return !r && r !== 0 ? '' : r;
			};
		}
		//check for a valid js variable name with hyphen(for properties only), $, _ and :
		var m = sel.match(/^[a-zA-Z\$_\@][\w\$:-]*(\.[\w\$:-]*[^\.])*$/);
		if(m === null){
			var found = false, s = sel, parts = [], pfns = [], i = 0, retStr;
			// check if literal
			if(/\'|\"/.test( s.charAt(0) )){
				if(/\'|\"/.test( s.charAt(s.length-1) )){
					retStr = s.substring(1, s.length-1);
					return function(){ return retStr; };
				}
			}else{
				// check if literal + #{var}
				while((m = s.match(/#\{([^{}]+)\}/)) !== null){
					found = true;
					parts[i++] = s.slice(0, m.index);
					pfns[i] = dataselectfn(m[1]);
					s = s.slice(m.index + m[0].length, s.length);
				}
			}
			if(!found){
				return function(){ return sel; };
			}
			parts[i] = s;
			return concatenator(parts, pfns);
		}
		m = sel.split('.');
		return function(ctxt){
			var data = ctxt.context || ctxt,
				v = ctxt[m[0]],
				i = 0;
			if(v && v.item){
				i += 1;
				if(m[i] === 'pos'){
					//allow pos to be kept by string. Tx to Adam Freidin
					return v.pos;
				}else{
					data = v.item;
				}
			}
			var n = m.length;
			for(; i < n; i++){
				if(!data){break;}
				data = data[m[i]];
			}
			return (!data && data !== 0) ? '':data;
		};
	}

	// wrap in an object the target node/attr and their properties
	function gettarget(dom, sel, isloop){
		var osel, prepend, selector, attr, append, target = [];
		if( typeof sel === 'string' ){
			osel = sel;
			var m = sel.match(selRx);
			if( !m ){
				error( 'bad selector syntax: ' + sel );
			}

			prepend = m[1];
			selector = m[2];
			attr = m[3];
			append = m[4];

			if(selector === '.' || ( !selector && attr ) ){
				target[0] = dom;
			}else{
				target = plugins.find(dom, selector);
			}
			if(!target || target.length === 0){
				return error('The node "' + sel + '" was not found in the template:\n' + outerHTML(dom).replace(/\t/g,'  '));
			}
		}else{
			// autoRender node
			prepend = sel.prepend;
			attr = sel.attr;
			append = sel.append;
			target = [dom];
		}

		if( prepend || append ){
			if( prepend && append ){
				error('append/prepend cannot take place at the same time');
			}else if( isloop ){
				error('no append/prepend/replace modifiers allowed for loop target');
			}else if( append && isloop ){
				error('cannot append with loop (sel: ' + osel + ')');
			}
		}
		var setstr, getstr, quotefn, isStyle, isClass, attName, setfn;
		if(attr){
			isStyle = (/^style$/i).test(attr);
			isClass = (/^class$/i).test(attr);
			attName = isClass ? 'className' : attr;
			setstr = function(node, s) {
				node.setAttribute(attPfx + attr, s);
				if (attName in node && !isStyle) {
					try{node[attName] = '';}catch(e){} //FF4 gives an error sometimes
				}
				if (node.nodeType === 1) {
					node.removeAttribute(attr);
					isClass && node.removeAttribute(attName);
				}
			};
			if (isStyle || isClass) {//IE no quotes special care
				if(isStyle){
					getstr = function(n){ return n.style.cssText; };
				}else{
					getstr = function(n){ return n.className;	};
				}
			}else {
				getstr = function(n){ return n.getAttribute(attr); };
			}
			quotefn = function(s){ return s.replace(/\"/g, '&quot;'); };
			if(prepend){
				setfn = function(node, s){ setstr( node, s + getstr( node )); };
			}else if(append){
				setfn = function(node, s){ setstr( node, getstr( node ) + s); };
			}else{
				setfn = function(node, s){ setstr( node, s ); };
			}
		}else{
			if (isloop) {
				setfn = function(node, s) {
					var pn = node.parentNode;
					if (pn) {
						//replace node with s
						pn.insertBefore(document.createTextNode(s), node.nextSibling);
						pn.removeChild(node);
					}
				};
			} else {
				if (prepend) {
					setfn = function(node, s) { node.insertBefore(document.createTextNode(s), node.firstChild);	};
				} else if (append) {
					setfn = function(node, s) { node.appendChild(document.createTextNode(s));};
				} else {
					setfn = function(node, s) {
						while (node.firstChild) { node.removeChild(node.firstChild); }
						node.appendChild(document.createTextNode(s));
					};
				}
			}
			quotefn = function(s) { return s; };
		}
		return { attr: attr, nodes: target, set: setfn, sel: osel, quotefn: quotefn };
	}

	function setsig(target, n){
		var sig = Sig + n + ':';
		for(var i = 0; i < target.nodes.length; i++){
			// could check for overlapping targets here.
			target.set( target.nodes[i], sig );
		}
	}

	// read de loop data, and pass it to the inner rendering function
	function loopfn(name, dselect, inner, sorter, filter){
		return function(ctxt){
			var a = dselect(ctxt),
				old = ctxt[name],
				temp = { items : a },
				filtered = 0,
				length,
				strs = [],
				buildArg = function(idx, temp, ftr, len){
					//keep the current loop. Tx to Adam Freidin
					var save_pos = ctxt.pos,
						save_item = ctxt.item,
						save_items = ctxt.items;
					ctxt.pos = temp.pos = idx;
					ctxt.item = temp.item = a[ idx ];
					ctxt.items = a;
					//if array, set a length property - filtered items
					typeof len !== 'undefined' &&  (ctxt.length = len);
					//if filter directive
					if(typeof ftr === 'function' && ftr.call(ctxt.item, ctxt) === false){
						filtered++;
						return;
					}
					strs.push( inner.call(ctxt.item, ctxt ) );
					//restore the current loop
					ctxt.pos = save_pos;
					ctxt.item = save_item;
					ctxt.items = save_items;
				};
			ctxt[name] = temp;
			if( isArray(a) ){
				length = a.length || 0;
				// if sort directive
				if(typeof sorter === 'function'){
					a.sort(sorter);
				}
				//loop on array
				for(var i = 0, ii = length; i < ii; i++){
					buildArg(i, temp, filter, length - filtered);
				}
			}else{
				if(a && typeof sorter !== 'undefined'){
					error('sort is only available on arrays, not objects');
				}
				//loop on collections
				for(var prop in a){
					a.hasOwnProperty( prop ) && buildArg(prop, temp, filter);
				}
			}

			typeof old !== 'undefined' ? ctxt[name] = old : delete ctxt[name];
			return strs.join('');
		};
	}
	// generate the template for a loop node
	function loopgen(dom, sel, loop, fns){
		var already = false, ls, sorter, filter, prop;
		for(prop in loop){
			if(loop.hasOwnProperty(prop)){
				if(prop === 'sort'){
					sorter = loop.sort;
					continue;
				}else if(prop === 'filter'){
					filter = loop.filter;
					continue;
				}
				if(already){
					error('cannot have more than one loop on a target');
				}
				ls = prop;
				already = true;
			}
		}
		if(!ls){
			error('Error in the selector: ' + sel + '\nA directive action must be a string, a function or a loop(<-)');
		}
		var dsel = loop[ls];
		// if it's a simple data selector then we default to contents, not replacement.
		if(typeof(dsel) === 'string' || typeof(dsel) === 'function'){
			loop = {};
			loop[ls] = {root: dsel};
			return loopgen(dom, sel, loop, fns);
		}
		var spec = parseloopspec(ls),
			itersel = dataselectfn(spec.sel),
			target = gettarget(dom, sel, true),
			nodes = target.nodes;

		for(i = 0; i < nodes.length; i++){
			var node = nodes[i],
				inner = compiler(node, dsel);
			fns[fns.length] = wrapquote(target.quotefn, loopfn(spec.name, itersel, inner, sorter, filter));
			target.nodes = [node];		// N.B. side effect on target.
			setsig(target, fns.length - 1);
		}
		return target;
	}

	function getAutoNodes(n, data){
		var ns = n.getElementsByTagName('*'),
			an = [],
			openLoops = {a:[],l:{}},
			cspec,
			isNodeValue,
			i, ii, j, jj, ni, cs, cj;
		//for each node found in the template
		for(i = -1, ii = ns.length; i < ii; i++){
			ni = i > -1 ?ns[i]:n;
			if(ni.nodeType === 1 && ni.className !== ''){
				//when a className is found
				cs = ni.className.split(' ');
				// for each className
				for(j = 0, jj=cs.length;j<jj;j++){
					cj = cs[j];
					// check if it is related to a context property
					cspec = checkClass(cj, ni.tagName);
					// if so, store the node, plus the type of data
					if(cspec !== false){
						isNodeValue = (/nodevalue/i).test(cspec.attr);
						if(cspec.sel.indexOf('@') > -1 || isNodeValue){
							ni.className = ni.className.replace('@'+cspec.attr, '');
							if(isNodeValue){
								cspec.attr = false;
							}
						}
						an.push({n:ni, cspec:cspec});
					}
				}
			}
		}

		function checkClass(c, tagName){
			// read the class
			var ca = c.match(selRx),
				attr = ca[3] || autoAttr[tagName],
				cspec = {prepend:!!ca[1], prop:ca[2], attr:attr, append:!!ca[4], sel:c},
				i, ii, loopi, loopil, val;
			// check in existing open loops
			for(i = openLoops.a.length-1; i >= 0; i--){
				loopi = openLoops.a[i];
				loopil = loopi.l[0];
				val = loopil && loopil[cspec.prop];
				if(typeof val !== 'undefined'){
					cspec.prop = loopi.p + '.' + cspec.prop;
					if(openLoops.l[cspec.prop] === true){
						val = val[0];
					}
					break;
				}
			}
			// not found check first level of data
			if(typeof val === 'undefined'){
				val = dataselectfn(cspec.prop)(isArray(data) ? data[0] : data);
				// nothing found return
				if(val === ''){
					return false;
				}
			}
			// set the spec for autoNode
			if(isArray(val)){
				openLoops.a.push( {l:val, p:cspec.prop} );
				openLoops.l[cspec.prop] = true;
				cspec.t = 'loop';
			}else{
				cspec.t = 'str';
			}
			return cspec;
		}

		return an;

	}

	// returns a function that, given a context argument,
	// will render the template defined by dom and directive.
	function compiler(dom, directive, data, ans){
		var fns = [], j, jj, cspec, n, target, nodes, itersel, node, inner, dsel, sels, sel, sl, i, h, parts,  pfns = [], p;
		// autoRendering nodes parsing -> auto-nodes
		ans = ans || data && getAutoNodes(dom, data);
		if(data){
			// for each auto-nodes
			while(ans.length > 0){
				cspec = ans[0].cspec;
				n = ans[0].n;
				ans.splice(0, 1);
				if(cspec.t === 'str'){
					// if the target is a value
					target = gettarget(n, cspec, false);
					setsig(target, fns.length);
					fns[fns.length] = wrapquote(target.quotefn, dataselectfn(cspec.prop));
				}else{
					// if the target is a loop
					itersel = dataselectfn(cspec.sel);
					target = gettarget(n, cspec, true);
					nodes = target.nodes;
					for(j = 0, jj = nodes.length; j < jj; j++){
						node = nodes[j];
						inner = compiler(node, false, data, ans);
						fns[fns.length] = wrapquote(target.quotefn, loopfn(cspec.sel, itersel, inner));
						target.nodes = [node];
						setsig(target, fns.length - 1);
					}
				}
			}
		}
		// read directives
		for(sel in directive){
			if(directive.hasOwnProperty(sel)){
				i = 0;
				dsel = directive[sel];
				sels = sel.split(/\s*,\s*/); //allow selector separation by quotes
				sl = sels.length;
				do{
					if(typeof(dsel) === 'function' || typeof(dsel) === 'string'){
						// set the value for the node/attr
						sel = sels[i];
						target = gettarget(dom, sel, false);
						setsig(target, fns.length);
						fns[fns.length] = wrapquote(target.quotefn, dataselectfn(dsel));
					}else{
						// loop on node
						loopgen(dom, sel, dsel, fns);
					}
				}while(++i < sl);
			}
		}
		// convert node to a string
		h = outerHTML(dom);
			// IE adds an unremovable "selected, value" attribute
			// hard replace while waiting for a better solution
		h = h.replace(/<([^>]+)\s(value\=""|selected)\s?([^>]*)>/ig, "<$1 $3>");

		// remove attribute prefix
		h = h.split(attPfx).join('');

		// slice the html string at "Sig"
		parts = h.split( Sig );
		// for each slice add the return string of
		for(i = 1; i < parts.length; i++){
			p = parts[i];
			// part is of the form "fn-number:..." as placed there by setsig.
			pfns[i] = fns[ parseInt(p, 10) ];
			parts[i] = p.substring( p.indexOf(':') + 1 );
		}
		return concatenator(parts, pfns);
	}
	// compile the template with directive
	// if a context is passed, the autoRendering is triggered automatically
	// return a function waiting the data as argument
	function compile(directive, ctxt, template){
		var rfn = compiler( ( template || this[0] ).cloneNode(true), directive, ctxt);
		return function(context){
			return rfn({context:context});
		};
	}
	//compile with the directive as argument
	// run the template function on the context argument
	// return an HTML string
	// should replace the template and return this
	function render(ctxt, directive){
		var fn = typeof directive === 'function' && directive, i = 0, ii = this.length;
		for(; i < ii; i++){
			this[i] = replaceWith( this[i], (fn || plugins.compile( directive, false, this[i] ))( ctxt, false ));
		}
		context = null;
		return this;
	}

	// compile the template with autoRender
	// run the template function on the context argument
	// return an HTML string
	function autoRender(ctxt, directive){
		var fn = plugins.compile( directive, ctxt, this[0] );
		for(var i = 0, ii = this.length; i < ii; i++){
			this[i] = replaceWith( this[i], fn( ctxt, false));
		}
		context = null;
		return this;
	}

	function replaceWith(elm, html) {
		var ne,
			ep = elm.parentNode,
			depth = 0;
		if(!ep){ //if no parents
			ep = document.createElement('DIV');
			ep.appendChild(elm);
		}
		switch (elm.tagName) {
			case 'TBODY': case 'THEAD': case 'TFOOT':
				html = '<TABLE>' + html + '</TABLE>';
				depth = 1;
			break;
			case 'TR':
				html = '<TABLE><TBODY>' + html + '</TBODY></TABLE>';
				depth = 2;
			break;
			case 'TD': case 'TH':
				html = '<TABLE><TBODY><TR>' + html + '</TR></TBODY></TABLE>';
				depth = 3;
			break;
		}
		tmp = document.createElement('SPAN');
		tmp.style.display = 'none';
		document.body.appendChild(tmp);
		tmp.innerHTML = html;
		ne = tmp.firstChild;
		while (depth--) {
			ne = ne.firstChild;
		}
		ep.insertBefore(ne, elm);
		ep.removeChild(elm);
		document.body.removeChild(tmp);
		elm = ne;

		ne = ep = null;
		return elm;
	}

	return plugins;
};

$p.plugins = {};

$p.libs = {
	dojo:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return dojo.query(sel, n);
			};
		}
	},
	domassistant:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return $(n).cssSelect(sel);
			};
		}
		DOMAssistant.attach({
			publicMethods : [ 'compile', 'render', 'autoRender'],
			compile:function(directive, ctxt){
				return $p([this]).compile(directive, ctxt);
			},
			render:function(ctxt, directive){
				return $( $p([this]).render(ctxt, directive) )[0];
			},
			autoRender:function(ctxt, directive){
				return $( $p([this]).autoRender(ctxt, directive) )[0];
			}
		});
	},
	jquery:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return jQuery(n).find(sel);
			};
		}
		jQuery.fn.extend({
			directives:function(directive){
				this._pure_d = directive; return this;
			},
			compile:function(directive, ctxt){
				return $p(this).compile(this._pure_d || directive, ctxt);
			},
			render:function(ctxt, directive){
				return jQuery( $p( this ).render( ctxt, this._pure_d || directive ) );
			},
			autoRender:function(ctxt, directive){
				return jQuery( $p( this ).autoRender( ctxt, this._pure_d || directive ) );
			}
		});
	},
	mootools:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return $(n).getElements(sel);
			};
		}
		Element.implement({
			compile:function(directive, ctxt){
				return $p(this).compile(directive, ctxt);
			},
			render:function(ctxt, directive){
				return $p([this]).render(ctxt, directive);
			},
			autoRender:function(ctxt, directive){
				return $p([this]).autoRender(ctxt, directive);
			}
		});
	},
	prototype:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				n = n === document ? n.body : n;
				return typeof n === 'string' ? $$(n) : $(n).select(sel);
			};
		}
		Element.addMethods({
			compile:function(element, directive, ctxt){
				return $p([element]).compile(directive, ctxt);
			},
			render:function(element, ctxt, directive){
				return $p([element]).render(ctxt, directive);
			},
			autoRender:function(element, ctxt, directive){
				return $p([element]).autoRender(ctxt, directive);
			}
		});
	},
	sizzle:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return Sizzle(sel, n);
			};
		}
	},
	sly:function(){
		if(typeof document.querySelector === 'undefined'){
			$p.plugins.find = function(n, sel){
				return Sly(sel, n);
			};
		}
	},
	yui:function(){ //Thanks to https://github.com/soljin
		if(typeof document.querySelector === 'undefined'){
			YUI().use("node",function(Y){
				$p.plugins.find = function(n, sel){
					return Y.NodeList.getDOMNodes(Y.one(n).all(sel));
				};
			});
		}
		YUI.add("pure-yui",function(Y){
			Y.Node.prototype.directives = function(directive){
				this._pure_d = directive; return this;
			};
			Y.Node.prototype.compile = function(directive, ctxt){
				return $p([this._node]).compile(this._pure_d || directive, ctxt);
			};
			Y.Node.prototype.render = function(ctxt, directive){
				return Y.one($p([this._node]).render(ctxt, this._pure_d || directive));
			};
			Y.Node.prototype.autoRender = function(ctxt, directive){
				return Y.one($p([this._node]).autoRender(ctxt, this._pure_d || directive));
			};
		},"0.1",{requires:["node"]});
	}
};

// get lib specifics if available
(function(){
	var libkey =
		typeof dojo         !== 'undefined' && 'dojo' ||
		typeof DOMAssistant !== 'undefined' && 'domassistant' ||
		typeof jQuery       !== 'undefined' && 'jquery' ||
		typeof MooTools     !== 'undefined' && 'mootools' ||
		typeof Prototype    !== 'undefined' && 'prototype' ||
		typeof Sizzle       !== 'undefined' && 'sizzle' ||
		typeof Sly          !== 'undefined' && 'sly' ||
		typeof YUI          !== 'undefined' && 'yui';

	libkey && $p.libs[libkey]();

	//for node.js
	if(typeof exports !== 'undefined'){
		exports.$p = $p;
	}
})();var REFERENCE = new function () {

    var that = this;

    that.collectParams = function (dialogName) {
        var dialog = $('#' + dialogName);
        var params = dialog.find('.formParam');
        var result = {};
        $.each(params, function (index, item) {
            if ($(item).attr('type') == 'checkbox') {
                result[$(item).attr('name')] = $(item).attr('checked') == 'checked';
            } else {
                result[$(item).attr('name')] = $(item).val() ? $(item).val() : '';
            }
        });
        return result;
    };

    that.closeEditReferenceDialog = function (dialogName) {
        var dialog = $('#' + dialogName);
        if (dialog && dialog.overlay()){
            dialog.overlay().close();
        }
    };

    that.openEditReferenceDialog = function (dialogName, params) {
        var dialog = $('#' + dialogName);
        dialog.overlay({
            oneInstance: false,
            fixed: false,
            mask: {
                color: '#fff',
                loadSpeed: 0,
                opacity: 0.5,
                zIndex: 100
            },
            closeOnClick: false
        });

        var leftButtons = dialog.find('.leftbuttons');
        var rightButtons = dialog.find('.rightbuttons');

        dialog.find('.dialogMessages').html('');
        leftButtons.children(null).remove();
        rightButtons.children(null).remove();
        $.each(params.buttons, function (index, item) {
            var button = $('<button>');
            button.bind('click', item.action);
            button.html(item.title);
            button.button();
            if (!item.position || item.position == 'right') {
                button.appendTo(rightButtons);
            } else {
                button.appendTo(leftButtons);
            }

        });

        var button = $('<button>', {style: 'margin-left: 5px; margin-right: 5px;'});
        button.bind('click', function () {
            if (params.onClose) {
                params.onClose();
            }
            $('#' + dialogName).overlay().close();
            
            return false;
        });
        button.html(messages['common.close']);
        button.button();
        button.appendTo(rightButtons);

        dialog.overlay().load();

        dialog.css('z-index',(commonHelper.getMaxZIndex() + 1));

    };

    that.fillReferenceList = function (panelName, url, method, params) {
        var panel = $('#' + panelName + 'Panel');

        var selectedPage = params.selectedPage ? params.selectedPage : panel.data('currentPage') ? panel.data('currentPage') : 1;
        var rowsOnPage = params.rowsOnPage ? params.rowsOnPage : 7;
        var fillCallback = params.fillCallback;
        var requestCallback = params.requestCallback;
        var sortName = params.sortName;
        var sortOrder = params.sortOrder;

        var template = panel.find('.' + panelName + 'Template');
        var list = panel.find('#' + panelName);
        commonHelper.callAjaxMethod(url, method, {
                page: selectedPage,
                rows: rowsOnPage,
                sord: sortOrder ? sortOrder : 'asc',
                sidx: sortName ? sortName : 'id',
                filterParams: params.filterParams ? JSON.stringify(params.filterParams) : {}
            },
            function (data) {
                if(requestCallback){
                    requestCallback(data);
                }
                list.children(null).remove();
                if (data && data.rows.length > 0) {
                    var filledList = fillCallback(list, template, data);
                    if (filledList == null){
                        filledList = list;
                    }

                    var generatedRows = filledList.find('.' + panelName + 'Row');
                    generatedRows.filter(':even').addClass('evenRow');
                    generatedRows.filter(':odd').addClass('oddRow');

                    commonHelper.hideEmptyList(panelName);
                    commonHelper.generatePaginator(panelName, data.page, data.total, function (page) {
                        panel.data('currentPage', page);
                        that.fillReferenceList(panelName, url, method, {
                            rowsOnPage: rowsOnPage,
                            fillCallback: fillCallback,
                            selectedPage: page,
                            sortName: sortName,
                            sortOrder: sortOrder,
                            filterParams: params.filterParams
                        });
                    });
                    panel.find('.jPag-control-additional').html(messages['referenceeditor.total'] + ' ' + data.records);

                } else {
                    panel.find('.jPag-control-additional').html(messages['referenceeditor.total'] + ' 0');
                    commonHelper.hidePaginator(panelName);
                    commonHelper.showEmptyList(panelName);
                }

            });

    };

    return this;
};/*
 * Minimal file upload button
 * 
 * @author Paul Warelis <pwarelis@gmail.com>
 * 
 */

!function($){

	var Upload = function (element, options) {
		this.options = $.extend({}, $.fn.Upload.defaults, options);
		this.el = $(element);
		
		var width = this.el.outerWidth();
		var height = this.el.outerHeight();

		var wrapper = $("<div style='position: relative; display: inline-block;'></div>");
		var container = $("<div></div>");
		container.css({
			position: "absolute",
			overflow: "hidden",
			opacity: 0,
			top: 0,
			left: 0
		});
		this.fileInput = $("<input type='file'/>");
		this.fileInput.attr("name", this.options.name);
		// This is the only way to make the button wider
		this.fileInput.css("font-size", "20px");
		
		// Create the file upload input and get its width
		container.append(this.fileInput);
		this.el.wrap(wrapper);
		this.el.before(container);
		var iWidth = container.width();

		container.width(width);
		container.height(height);
		
		this.fileInput.css({
			"margin-left": -(iWidth-width-13)+"px",
			"margin-top": "-3px",
			"height": (height*2)+"px"
		});
		this.listen();
	};

	Upload.prototype = {
		
		listen: function() {
			this.fileInput.change($.proxy(this.onselect, this));
		},
		
		onselect: function(e) {
			this.file = e.currentTarget.files[0];
			if (this.options.onSelect) {
				this.options.onSelect.call(this);
				return;
			}
			this.sendFile();
		},
		
		sendFile: function(data) {
			if (!this.file) return;
			
			var fd = new FormData();
			fd.append(this.options.name, this.file);
			
			if (data) {
				for (var i in data) fd.append(i, data[i]);
			}
			
			this.start = (new Date()).getTime();
			
			var xhr = new XMLHttpRequest();
			xhr.upload.addEventListener("progress", $.proxy(this.update, this), false);
			xhr.addEventListener("load", $.proxy(this.complete, this), false);
			xhr.addEventListener("error", $.proxy(this.failed, this), false);
			xhr.addEventListener("abort", $.proxy(this.cancelled, this), false);
			xhr.open("POST", this.options.url);
			xhr.send(fd);
			this.xhr = xhr;
			
			this.progress = {
				lastBytes: 0,
				total: this.file.size,
				loaded: 0,
				speed: 0
			}

			if (this.options.onUpdate) {
				this.intervalUpdate = $.proxy(this.options.onUpdate, this);
				this.timer = setInterval(this.intervalUpdate, this.options.updateInterval);
			}
		},
		
		getPercentage: function() {
			return Math.round(this.progress.loaded * 100 / this.progress.total);
		},
		
		getThroughput: function() {
			return this.progress.throughput;
		},

		getSpeed: function() {
			return this.progress.speed;
		},

		cancel: function() {
			this.xhr.abort();
		},

		inProgress: function() {
			return !!this.xhr;
		},
		
		update: function(e) {
			if (!e.lengthComputable) return;
			this.progress.total = e.total;
			this.progress.loaded = e.loaded;
			
			this.progress.throughput = Math.round(this.progress.loaded - this.progress.lastBytes);
			this.progress.lastBytes = this.progress.loaded;
			
			var elapsed = (new Date()).getTime() - this.start;
			this.progress.speed = Math.round(1000 * this.progress.loaded / elapsed);
		},
		
		complete: function(e) {
			clearInterval(this.timer);
			this.progress.loaded = this.progress.total;
			this.intervalUpdate();
			if (this.options.onComplete) {
				var data = this.options.parseResponse ? jQuery.parseJSON(this.xhr.responseText) : undefined;
				this.options.onComplete.call(this, data);
			}
			this.xhr = null;
		},
		
		failed: function(e) {
			clearInterval(this.timer);
			if (this.options.onError) {
				this.options.onError.call(this, this.xhr);
			}
			this.xhr = null;
		},
		
		cancelled: function(e) {
			clearInterval(this.timer);
			if (this.options.onCancel) {
				this.options.onCancel.call(this);
			}
			this.xhr = null;
		}
	
	};

	$.fn.Upload = function (option, arg) {
		var $this = $(this),
			data = $this.data('Upload'),
			options = typeof option == 'object' && option;
		if (!data) $this.data('Upload', (data = new Upload(this, options)));
		if (typeof option == 'string') {
			return data[option](arg);
		}
		return data;
	};

	$.fn.Upload.defaults = {
		updateInterval: 500,
		parseResponse: true,
		name: "file"
	}
	
}(window.jQuery);
